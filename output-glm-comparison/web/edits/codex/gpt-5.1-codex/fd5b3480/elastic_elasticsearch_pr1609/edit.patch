diff --git a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java
index ae9eea7..8c18754 100644
--- a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java
+++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java
@@ -208,20 +208,20 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio
             }
         }
 
-        // TODO percolate?
-
         // TODO: external version type, does it make sense here? does not seem like it...
 
         if (operation == null || "index".equals(operation)) {
             IndexRequest indexRequest = Requests.indexRequest(request.index()).type(request.type()).id(request.id()).routing(routing).parent(parent)
                     .source(source, sourceAndContent.v1())
                     .version(getResult.version()).replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel())
-                    .timestamp(timestamp).ttl(ttl);
+                    .timestamp(timestamp).ttl(ttl)
+                    .percolate(request.percolate());
             indexRequest.operationThreaded(false);
             indexAction.execute(indexRequest, new ActionListener<IndexResponse>() {
                 @Override
                 public void onResponse(IndexResponse response) {
                     UpdateResponse update = new UpdateResponse(response.index(), response.type(), response.id(), response.version());
+                    update.matches(response.matches());
                     listener.onResponse(update);
                 }
 
diff --git a/src/main/java/org/elasticsearch/action/update/UpdateRequest.java b/src/main/java/org/elasticsearch/action/update/UpdateRequest.java
index 05e39ce..e1ac6b7 100644
--- a/src/main/java/org/elasticsearch/action/update/UpdateRequest.java
+++ b/src/main/java/org/elasticsearch/action/update/UpdateRequest.java
@@ -51,6 +51,8 @@ public class UpdateRequest extends InstanceShardOperationRequest {
 
     int retryOnConflict = 0;
 
+    private String percolate;
+
     private ReplicationType replicationType = ReplicationType.DEFAULT;
     private WriteConsistencyLevel consistencyLevel = WriteConsistencyLevel.DEFAULT;
 
@@ -239,6 +241,20 @@ public class UpdateRequest extends InstanceShardOperationRequest {
         return this.retryOnConflict;
     }
 
+    /**
+     * Causes the updated doc to be percolated. The parameter is the percolate query
+     * to use to reduce the percolated queries that are going to run against this doc. Can be
+     * set to <tt>*</tt> to indicate that all percolate queries should be run.
+     */
+    public UpdateRequest percolate(String percolate) {
+        this.percolate = percolate;
+        return this;
+    }
+
+    public String percolate() {
+        return this.percolate;
+    }
+
     /**
      * A timeout to wait if the index operation can't be performed immediately. Defaults to <tt>1m</tt>.
      */
@@ -297,6 +313,9 @@ public class UpdateRequest extends InstanceShardOperationRequest {
         }
         scriptParams = in.readMap();
         retryOnConflict = in.readVInt();
+        if (in.readBoolean()) {
+            percolate = in.readUTF();
+        }
     }
 
     @Override
@@ -321,5 +340,11 @@ public class UpdateRequest extends InstanceShardOperationRequest {
         }
         out.writeMap(scriptParams);
         out.writeVInt(retryOnConflict);
+        if (percolate == null) {
+            out.writeBoolean(false);
+        } else {
+            out.writeBoolean(true);
+            out.writeUTF(percolate);
+        }
     }
 }
diff --git a/src/main/java/org/elasticsearch/action/update/UpdateResponse.java b/src/main/java/org/elasticsearch/action/update/UpdateResponse.java
index f4a41dd..3cb6efd 100644
--- a/src/main/java/org/elasticsearch/action/update/UpdateResponse.java
+++ b/src/main/java/org/elasticsearch/action/update/UpdateResponse.java
@@ -19,11 +19,14 @@
 
 package org.elasticsearch.action.update;
 
+import com.google.common.collect.ImmutableList;
 import org.elasticsearch.action.ActionResponse;
 import org.elasticsearch.common.io.stream.StreamInput;
 import org.elasticsearch.common.io.stream.StreamOutput;
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
  */
@@ -37,6 +40,8 @@ public class UpdateResponse implements ActionResponse {
 
     private long version;
 
+    private List<String> matches;
+
     public UpdateResponse() {
 
     }
@@ -104,12 +109,54 @@ public class UpdateResponse implements ActionResponse {
         return version();
     }
 
+    /**
+     * Returns the percolate queries matches. <tt>null</tt> if no percolation was requested.
+     */
+    public List<String> matches() {
+        return this.matches;
+    }
+
+    /**
+     * Returns the percolate queries matches. <tt>null</tt> if no percolation was requested.
+     */
+    public List<String> getMatches() {
+        return this.matches;
+    }
+
+    /**
+     * Internal.
+     */
+    public void matches(List<String> matches) {
+        this.matches = matches;
+    }
+
     @Override
     public void readFrom(StreamInput in) throws IOException {
         index = in.readUTF();
         id = in.readUTF();
         type = in.readUTF();
         version = in.readLong();
+        if (in.readBoolean()) {
+            int size = in.readVInt();
+            if (size == 0) {
+                matches = ImmutableList.of();
+            } else if (size == 1) {
+                matches = ImmutableList.of(in.readUTF());
+            } else if (size == 2) {
+                matches = ImmutableList.of(in.readUTF(), in.readUTF());
+            } else if (size == 3) {
+                matches = ImmutableList.of(in.readUTF(), in.readUTF(), in.readUTF());
+            } else if (size == 4) {
+                matches = ImmutableList.of(in.readUTF(), in.readUTF(), in.readUTF(), in.readUTF());
+            } else if (size == 5) {
+                matches = ImmutableList.of(in.readUTF(), in.readUTF(), in.readUTF(), in.readUTF(), in.readUTF());
+            } else {
+                matches = new ArrayList<String>();
+                for (int i = 0; i < size; i++) {
+                    matches.add(in.readUTF());
+                }
+            }
+        }
     }
 
     @Override
@@ -118,5 +165,14 @@ public class UpdateResponse implements ActionResponse {
         out.writeUTF(id);
         out.writeUTF(type);
         out.writeLong(version);
+        if (matches == null) {
+            out.writeBoolean(false);
+        } else {
+            out.writeBoolean(true);
+            out.writeVInt(matches.size());
+            for (String match : matches) {
+                out.writeUTF(match);
+            }
+        }
     }
 }
diff --git a/src/main/java/org/elasticsearch/client/action/update/UpdateRequestBuilder.java b/src/main/java/org/elasticsearch/client/action/update/UpdateRequestBuilder.java
index dd5c4e3..5118225 100644
--- a/src/main/java/org/elasticsearch/client/action/update/UpdateRequestBuilder.java
+++ b/src/main/java/org/elasticsearch/client/action/update/UpdateRequestBuilder.java
@@ -134,6 +134,11 @@ public class UpdateRequestBuilder extends BaseRequestBuilder<UpdateRequest, Upda
         return this;
     }
 
+    public UpdateRequestBuilder setPercolate(String percolate) {
+        request.percolate(percolate);
+        return this;
+    }
+
     /**
      * Sets the replication type.
      */
diff --git a/src/main/java/org/elasticsearch/rest/action/update/RestUpdateAction.java b/src/main/java/org/elasticsearch/rest/action/update/RestUpdateAction.java
index e6bef60..05ddc23 100644
--- a/src/main/java/org/elasticsearch/rest/action/update/RestUpdateAction.java
+++ b/src/main/java/org/elasticsearch/rest/action/update/RestUpdateAction.java
@@ -75,6 +75,7 @@ public class RestUpdateAction extends BaseRestHandler {
             }
         }
         updateRequest.retryOnConflict(request.paramAsInt("retry_on_conflict", updateRequest.retryOnConflict()));
+        updateRequest.percolate(request.param("percolate"));
 
         // see if we have it in the body
         if (request.hasContent()) {
@@ -92,6 +93,9 @@ public class RestUpdateAction extends BaseRestHandler {
                     if (content.containsKey("params")) {
                         updateRequest.scriptParams((Map<String, Object>) content.get("params"));
                     }
+                    if (content.containsKey("percolate")) {
+                        updateRequest.percolate(content.get("percolate").toString());
+                    }
                 } catch (Exception e) {
                     try {
                         channel.sendResponse(new XContentThrowableRestResponse(request, e));
@@ -114,6 +118,13 @@ public class RestUpdateAction extends BaseRestHandler {
                             .field(Fields._TYPE, response.type())
                             .field(Fields._ID, response.id())
                             .field(Fields._VERSION, response.version());
+                    if (response.matches() != null) {
+                        builder.startArray(Fields.MATCHES);
+                        for (String match : response.matches()) {
+                            builder.value(match);
+                        }
+                        builder.endArray();
+                    }
                     builder.endObject();
                     RestStatus status = OK;
                     if (response.version() == 1) {
@@ -142,5 +153,6 @@ public class RestUpdateAction extends BaseRestHandler {
         static final XContentBuilderString _TYPE = new XContentBuilderString("_type");
         static final XContentBuilderString _ID = new XContentBuilderString("_id");
         static final XContentBuilderString _VERSION = new XContentBuilderString("_version");
+        static final XContentBuilderString MATCHES = new XContentBuilderString("matches");
     }
 }