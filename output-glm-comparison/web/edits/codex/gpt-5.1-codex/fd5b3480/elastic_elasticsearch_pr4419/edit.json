{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4419,
  "base_commit": "4e7ce4ee02a85ca02b8a07a27ae4e82341e2db39",
  "runner": "codex",
  "model": "gpt-5.1-codex",
  "timeout_s": 10800,
  "status": "success",
  "elapsed_ms": 350322,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/indices/IndicesLifecycle.java b/src/main/java/org/elasticsearch/indices/IndicesLifecycle.java\nindex 9c95dd5..072beff 100644\n--- a/src/main/java/org/elasticsearch/indices/IndicesLifecycle.java\n+++ b/src/main/java/org/elasticsearch/indices/IndicesLifecycle.java\n@@ -42,6 +42,14 @@ public interface IndicesLifecycle {\n      */\n     void removeListener(Listener listener);\n \n+    /**\n+     * Notify listeners that a shard routing changed state in the cluster.\n+     *\n+     * @param previousRouting The previous routing state, can be <tt>null</tt> when none existed.\n+     * @param newRouting      The updated routing state.\n+     */\n+    void shardStateChanged(@Nullable ShardRouting previousRouting, ShardRouting newRouting);\n+\n     /**\n      * A listener for index and index shard lifecycle events (create/closed).\n      */\n@@ -58,6 +66,16 @@ public interface IndicesLifecycle {\n \n         }\n \n+        /**\n+         * Called whenever any shard changes state in the cluster.\n+         *\n+         * @param previousRouting previous routing state, can be <tt>null</tt>\n+         * @param newRouting      new routing state\n+         */\n+        public void shardStateChanged(@Nullable ShardRouting previousRouting, ShardRouting newRouting) {\n+\n+        }\n+\n         /**\n          * Called before the index gets created.\n          */\ndiff --git a/src/main/java/org/elasticsearch/indices/InternalIndicesLifecycle.java b/src/main/java/org/elasticsearch/indices/InternalIndicesLifecycle.java\nindex b196f9e..0484695 100644\n--- a/src/main/java/org/elasticsearch/indices/InternalIndicesLifecycle.java\n+++ b/src/main/java/org/elasticsearch/indices/InternalIndicesLifecycle.java\n@@ -61,6 +61,17 @@ public class InternalIndicesLifecycle extends AbstractComponent implements Indic\n         }\n     }\n \n+    @Override\n+    public void shardStateChanged(@Nullable ShardRouting previousRouting, ShardRouting newRouting) {\n+        for (Listener listener : listeners) {\n+            try {\n+                listener.shardStateChanged(previousRouting, newRouting);\n+            } catch (Throwable t) {\n+                logger.warn(\"{} failed to invoke shard state changed callback\", t, newRouting.shardId());\n+            }\n+        }\n+    }\n+\n     public void beforeIndexCreated(Index index) {\n         for (Listener listener : listeners) {\n             try {\ndiff --git a/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\nindex d559b94..000272a 100644\n--- a/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\n+++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\n@@ -27,6 +27,7 @@ import org.elasticsearch.ElasticSearchException;\n import org.elasticsearch.ExceptionsHelper;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n import org.elasticsearch.cluster.ClusterService;\n+import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.ClusterStateListener;\n import org.elasticsearch.cluster.action.index.NodeIndexCreatedAction;\n import org.elasticsearch.cluster.action.index.NodeIndexDeletedAction;\n@@ -60,6 +61,7 @@ import org.elasticsearch.index.shard.IndexShardState;\n import org.elasticsearch.index.shard.ShardId;\n import org.elasticsearch.index.shard.service.IndexShard;\n import org.elasticsearch.index.shard.service.InternalIndexShard;\n+import org.elasticsearch.indices.IndicesLifecycle;\n import org.elasticsearch.indices.IndicesService;\n import org.elasticsearch.indices.recovery.RecoveryFailedException;\n import org.elasticsearch.indices.recovery.RecoveryStatus;\n@@ -187,6 +189,7 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n             applyCleanedIndices(event);\n             applySettings(event);\n             sendIndexLifecycleEvents(event);\n+            sendShardStateEvents(event);\n         }\n     }\n \n@@ -209,6 +212,48 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n         }\n     }\n \n+    private void sendShardStateEvents(final ClusterChangedEvent event) {\n+        if (!event.routingTableChanged()) {\n+            return;\n+        }\n+\n+        final ClusterState previousState = event.previousState();\n+        if (previousState == null) {\n+            return;\n+        }\n+\n+        final RoutingTable previousRoutingTable = previousState.routingTable();\n+        if (previousRoutingTable == null) {\n+            return;\n+        }\n+\n+        final RoutingTable currentRoutingTable = event.state().routingTable();\n+        final IndicesLifecycle indicesLifecycle = indicesService.indicesLifecycle();\n+\n+        for (IndexRoutingTable currentIndexRoutingTable : currentRoutingTable) {\n+            IndexRoutingTable previousIndexRoutingTable = previousRoutingTable.index(currentIndexRoutingTable.index());\n+            if (previousIndexRoutingTable == null) {\n+                continue;\n+            }\n+            for (IndexShardRoutingTable currentShardRoutingTable : currentIndexRoutingTable) {\n+                IndexShardRoutingTable previousShardRoutingTable = previousIndexRoutingTable.shard(currentShardRoutingTable.shardId().id());\n+                if (previousShardRoutingTable == null) {\n+                    continue;\n+                }\n+                List<ShardRouting> currentShards = currentShardRoutingTable.shards();\n+                List<ShardRouting> previousShards = previousShardRoutingTable.shards();\n+                int size = Math.min(previousShards.size(), currentShards.size());\n+                for (int i = 0; i < size; i++) {\n+                    ShardRouting previousShardRouting = previousShards.get(i);\n+                    ShardRouting currentShardRouting = currentShards.get(i);\n+                    if (previousShardRouting.state() != currentShardRouting.state()) {\n+                        indicesLifecycle.shardStateChanged(previousShardRouting, currentShardRouting);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     private void cleanMismatchedIndexUUIDs(final ClusterChangedEvent event) {\n         for (IndexService indexService : indicesService) {\n             IndexMetaData indexMetaData = event.state().metaData().index(indexService.index().name());",
  "logs_path": "codex/gpt-5.1-codex/b8978668/elastic_elasticsearch_pr4419/logs.jsonl",
  "errors": [],
  "edit_run_id": "fd5b3480",
  "test_label": "v1-agent-comparison"
}