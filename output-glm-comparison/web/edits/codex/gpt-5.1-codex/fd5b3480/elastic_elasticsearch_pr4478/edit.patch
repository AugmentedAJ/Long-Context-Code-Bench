diff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java
index 2e67160..3476151 100644
--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java
+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java
@@ -35,6 +35,7 @@ import org.elasticsearch.common.inject.Inject;
 import org.elasticsearch.common.logging.ESLogger;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.node.settings.NodeSettingsService;
+import org.elasticsearch.index.shard.ShardId;
 
 import java.util.*;
 
@@ -597,7 +598,9 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards
                 return false;
             }
             boolean changed = false;
-          
+            final Set<ShardId> replicaLimitReached = new HashSet<ShardId>();
+            final Set<String> throttledNodes = new HashSet<String>();
+
             /*
              * TODO: We could be smarter here and group the shards by index and then
              * use the sorter to save some iterations. 
@@ -621,22 +624,35 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards
             do {
                 Iterator<MutableShardRouting> iterator = unassigned.iterator();
                 while (iterator.hasNext()) {
+                    MutableShardRouting candidate = iterator.next();
+                    if (!candidate.primary() && replicaLimitReached.contains(candidate.shardId())) {
+                        iterator.remove();
+                        ignoredUnassigned.add(candidate);
+                        continue;
+                    }
                     /* we treat every index equally here once chunk a time such that we fill up
                      * nodes with all indices at the same time. Only on shard of a shard a time.
-                	 * Although there might be a primary and a shard of a shard in the set but
-                	 * primaries will be started first.*/
-                    if (currentRound.add(iterator.next())) {
+		 * Although there might be a primary and a shard of a shard in the set but
+		 * primaries will be started first.*/
+                    if (currentRound.add(candidate)) {
                         iterator.remove();
                     }
                 }
                 boolean iterationChanged = false;
                 for (MutableShardRouting shard : currentRound) {
+                    if (!shard.primary() && replicaLimitReached.contains(shard.shardId())) {
+                        ignoredUnassigned.add(shard);
+                        continue;
+                    }
                     assert !shard.assignedToNode();
                     /* find an node with minimal weight we can allocate on*/
                     float minWeight = Float.POSITIVE_INFINITY;
                     ModelNode minNode = null;
                     Decision decision = null;
                     for (ModelNode node : nodes.values()) {
+                        if (throttledNodes.contains(node.getNodeId())) {
+                            continue;
+                        }
                         /*
                          * The shard we add is removed below to simulate the
 	                     * addition for weight calculation we use Decision.ALWAYS to
@@ -698,6 +714,9 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards
                     if (minNode != null) {
                         iterationChanged = true;
                         minNode.addShard(shard, decision);
+                        if (decision != null && decision.type() == Type.THROTTLE) {
+                            throttledNodes.add(minNode.getNodeId());
+                        }
                         if (decision.type() == Type.YES) {
                             if (logger.isTraceEnabled()) {
                                 logger.trace("Assigned shard [{}] to [{}]", shard, minNode.getNodeId());
@@ -713,6 +732,9 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards
                         logger.trace("No Node found to assign shard [{}]", shard);
                     }
                     ignoredUnassigned.add(shard);
+                    if (!shard.primary() && (minNode == null || decision == null || decision.type() != Type.YES)) {
+                        replicaLimitReached.add(shard.shardId());
+                    }
                 }
                 if (!iterationChanged && !unassigned.isEmpty()) {
                     unassigned.copyAll(ignoredUnassigned);