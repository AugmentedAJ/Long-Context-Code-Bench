{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4478,
  "base_commit": "2b6214cff72423fc5c948c7b4c39027c93494400",
  "runner": "codex",
  "model": "gpt-5.1-codex",
  "timeout_s": 10800,
  "status": "success",
  "elapsed_ms": 418853,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java\nindex 2e67160..3476151 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java\n@@ -35,6 +35,7 @@ import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.node.settings.NodeSettingsService;\n+import org.elasticsearch.index.shard.ShardId;\n \n import java.util.*;\n \n@@ -597,7 +598,9 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n                 return false;\n             }\n             boolean changed = false;\n-          \n+            final Set<ShardId> replicaLimitReached = new HashSet<ShardId>();\n+            final Set<String> throttledNodes = new HashSet<String>();\n+\n             /*\n              * TODO: We could be smarter here and group the shards by index and then\n              * use the sorter to save some iterations. \n@@ -621,22 +624,35 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n             do {\n                 Iterator<MutableShardRouting> iterator = unassigned.iterator();\n                 while (iterator.hasNext()) {\n+                    MutableShardRouting candidate = iterator.next();\n+                    if (!candidate.primary() && replicaLimitReached.contains(candidate.shardId())) {\n+                        iterator.remove();\n+                        ignoredUnassigned.add(candidate);\n+                        continue;\n+                    }\n                     /* we treat every index equally here once chunk a time such that we fill up\n                      * nodes with all indices at the same time. Only on shard of a shard a time.\n-                \t * Although there might be a primary and a shard of a shard in the set but\n-                \t * primaries will be started first.*/\n-                    if (currentRound.add(iterator.next())) {\n+\t\t * Although there might be a primary and a shard of a shard in the set but\n+\t\t * primaries will be started first.*/\n+                    if (currentRound.add(candidate)) {\n                         iterator.remove();\n                     }\n                 }\n                 boolean iterationChanged = false;\n                 for (MutableShardRouting shard : currentRound) {\n+                    if (!shard.primary() && replicaLimitReached.contains(shard.shardId())) {\n+                        ignoredUnassigned.add(shard);\n+                        continue;\n+                    }\n                     assert !shard.assignedToNode();\n                     /* find an node with minimal weight we can allocate on*/\n                     float minWeight = Float.POSITIVE_INFINITY;\n                     ModelNode minNode = null;\n                     Decision decision = null;\n                     for (ModelNode node : nodes.values()) {\n+                        if (throttledNodes.contains(node.getNodeId())) {\n+                            continue;\n+                        }\n                         /*\n                          * The shard we add is removed below to simulate the\n \t                     * addition for weight calculation we use Decision.ALWAYS to\n@@ -698,6 +714,9 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n                     if (minNode != null) {\n                         iterationChanged = true;\n                         minNode.addShard(shard, decision);\n+                        if (decision != null && decision.type() == Type.THROTTLE) {\n+                            throttledNodes.add(minNode.getNodeId());\n+                        }\n                         if (decision.type() == Type.YES) {\n                             if (logger.isTraceEnabled()) {\n                                 logger.trace(\"Assigned shard [{}] to [{}]\", shard, minNode.getNodeId());\n@@ -713,6 +732,9 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n                         logger.trace(\"No Node found to assign shard [{}]\", shard);\n                     }\n                     ignoredUnassigned.add(shard);\n+                    if (!shard.primary() && (minNode == null || decision == null || decision.type() != Type.YES)) {\n+                        replicaLimitReached.add(shard.shardId());\n+                    }\n                 }\n                 if (!iterationChanged && !unassigned.isEmpty()) {\n                     unassigned.copyAll(ignoredUnassigned);",
  "logs_path": "codex/gpt-5.1-codex/93548e0a/elastic_elasticsearch_pr4478/logs.jsonl",
  "errors": [],
  "edit_run_id": "fd5b3480",
  "test_label": "v1-agent-comparison"
}