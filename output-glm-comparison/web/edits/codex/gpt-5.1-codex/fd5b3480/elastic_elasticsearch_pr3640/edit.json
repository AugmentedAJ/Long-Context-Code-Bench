{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 3640,
  "base_commit": "4155741f7f486537d4a5f7193d79098d523a6ae8",
  "runner": "codex",
  "model": "gpt-5.1-codex",
  "timeout_s": 10800,
  "status": "success",
  "elapsed_ms": 288642,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\nindex 9764831..c610515 100644\n--- a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\n+++ b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\n@@ -586,52 +586,64 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n         if (node == null) {\n             throw new ConnectTransportException(null, \"can't connect to a null node\");\n         }\n-        globalLock.readLock().lock();\n-        try {\n+        final Object nodeMutex = connectLock(node.id());\n+        synchronized (nodeMutex) {\n             if (!lifecycle.started()) {\n                 throw new ElasticSearchIllegalStateException(\"can't add nodes to a stopped transport\");\n             }\n-            synchronized (connectLock(node.id())) {\n+\n+            globalLock.readLock().lock();\n+            try {\n                 if (!lifecycle.started()) {\n                     throw new ElasticSearchIllegalStateException(\"can't add nodes to a stopped transport\");\n                 }\n-                try {\n-                    NodeChannels nodeChannels = connectedNodes.get(node);\n-                    if (nodeChannels != null) {\n-                        return;\n-                    }\n-\n-                    if (light) {\n-                        nodeChannels = connectToChannelsLight(node);\n-                    } else {\n-                        nodeChannels = new NodeChannels(new Channel[connectionsPerNodeLow], new Channel[connectionsPerNodeMed], new Channel[connectionsPerNodeHigh], new Channel[connectionsPerNodePing]);\n-                        try {\n-                            connectToChannels(nodeChannels, node);\n-                        } catch (Exception e) {\n-                            nodeChannels.close();\n-                            throw e;\n-                        }\n-                    }\n+                NodeChannels existing = connectedNodes.get(node);\n+                if (existing != null) {\n+                    return;\n+                }\n+            } finally {\n+                globalLock.readLock().unlock();\n+            }\n \n-                    NodeChannels existing = connectedNodes.putIfAbsent(node, nodeChannels);\n-                    if (existing != null) {\n-                        // we are already connected to a node, close this ones\n+            NodeChannels nodeChannels;\n+            try {\n+                if (light) {\n+                    nodeChannels = connectToChannelsLight(node);\n+                } else {\n+                    nodeChannels = new NodeChannels(new Channel[connectionsPerNodeLow], new Channel[connectionsPerNodeMed], new Channel[connectionsPerNodeHigh], new Channel[connectionsPerNodePing]);\n+                    try {\n+                        connectToChannels(nodeChannels, node);\n+                    } catch (Exception e) {\n                         nodeChannels.close();\n-                    } else {\n-                        if (logger.isDebugEnabled()) {\n-                            logger.debug(\"connected to node [{}]\", node);\n-                        }\n-                        transportServiceAdapter.raiseNodeConnected(node);\n+                        throw e;\n                     }\n+                }\n+            } catch (ConnectTransportException e) {\n+                throw e;\n+            } catch (Exception e) {\n+                throw new ConnectTransportException(node, \"General node connection failure\", e);\n+            }\n \n-                } catch (ConnectTransportException e) {\n-                    throw e;\n-                } catch (Exception e) {\n-                    throw new ConnectTransportException(node, \"General node connection failure\", e);\n+            globalLock.readLock().lock();\n+            try {\n+                if (!lifecycle.started()) {\n+                    nodeChannels.close();\n+                    throw new ElasticSearchIllegalStateException(\"can't add nodes to a stopped transport\");\n+                }\n+                NodeChannels existing = connectedNodes.putIfAbsent(node, nodeChannels);\n+                if (existing != null) {\n+                    // we are already connected to a node, close this ones\n+                    nodeChannels.close();\n+                } else {\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"connected to node [{}]\", node);\n+                    }\n+                    transportServiceAdapter.raiseNodeConnected(node);\n                 }\n+\n+            } finally {\n+                globalLock.readLock().unlock();\n             }\n-        } finally {\n-            globalLock.readLock().unlock();\n         }\n     }\n \n@@ -750,15 +762,21 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n \n     @Override\n     public void disconnectFromNode(DiscoveryNode node) {\n+        NodeChannels nodeChannels = null;\n         synchronized (connectLock(node.id())) {\n-            NodeChannels nodeChannels = connectedNodes.remove(node);\n-            if (nodeChannels != null) {\n-                try {\n-                    nodeChannels.close();\n-                } finally {\n-                    logger.debug(\"disconnected from [{}]\", node);\n-                    transportServiceAdapter.raiseNodeDisconnected(node);\n-                }\n+            globalLock.readLock().lock();\n+            try {\n+                nodeChannels = connectedNodes.remove(node);\n+            } finally {\n+                globalLock.readLock().unlock();\n+            }\n+        }\n+        if (nodeChannels != null) {\n+            try {\n+                nodeChannels.close();\n+            } finally {\n+                logger.debug(\"disconnected from [{}]\", node);\n+                transportServiceAdapter.raiseNodeDisconnected(node);\n             }\n         }\n     }",
  "logs_path": "codex/gpt-5.1-codex/b8978668/elastic_elasticsearch_pr3640/logs.jsonl",
  "errors": [],
  "edit_run_id": "fd5b3480",
  "test_label": "v1-agent-comparison"
}