{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 1600,
  "base_commit": "ed8a46ce09ccf43adec55af91a72fc9c5dc1ec05",
  "runner": "codex",
  "model": "gpt-5.1-codex",
  "timeout_s": 10800,
  "status": "success",
  "elapsed_ms": 670782,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\nindex 5a296cd..32e4ace 100644\n--- a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\n+++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\n@@ -37,6 +37,7 @@ import org.elasticsearch.cluster.ClusterService;\n import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.block.ClusterBlockException;\n import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.MappingMetaData;\n import org.elasticsearch.cluster.routing.PlainShardIterator;\n import org.elasticsearch.cluster.routing.ShardIterator;\n import org.elasticsearch.cluster.routing.ShardRouting;\n@@ -49,9 +50,12 @@ import org.elasticsearch.index.engine.DocumentMissingException;\n import org.elasticsearch.index.engine.DocumentSourceMissingException;\n import org.elasticsearch.index.engine.VersionConflictEngineException;\n import org.elasticsearch.index.get.GetResult;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.mapper.DocumentMapper;\n import org.elasticsearch.index.mapper.internal.ParentFieldMapper;\n import org.elasticsearch.index.mapper.internal.RoutingFieldMapper;\n import org.elasticsearch.index.mapper.internal.SourceFieldMapper;\n+import org.elasticsearch.index.mapper.internal.TTLFieldMapper;\n import org.elasticsearch.index.mapper.internal.TimestampFieldMapper;\n import org.elasticsearch.index.service.IndexService;\n import org.elasticsearch.index.shard.IllegalIndexShardStateException;\n@@ -63,6 +67,7 @@ import org.elasticsearch.script.ScriptService;\n import org.elasticsearch.threadpool.ThreadPool;\n import org.elasticsearch.transport.TransportService;\n \n+import java.util.Date;\n import java.util.HashMap;\n import java.util.Map;\n \n@@ -151,9 +156,15 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n     protected void shardOperation(final UpdateRequest request, final ActionListener<UpdateResponse> listener, final int retryCount) throws ElasticSearchException {\n         IndexService indexService = indicesService.indexServiceSafe(request.index());\n         IndexShard indexShard = indexService.shardSafe(request.shardId());\n+        DocumentMapper docMapper = indexService.mapperService().documentMapper(request.type());\n+        if (docMapper == null) {\n+            listener.onFailure(new ElasticSearchIllegalArgumentException(\"type [\" + request.type() + \"] missing\"));\n+            return;\n+        }\n+        final TimestampFieldMapper timestampFieldMapper = docMapper.timestampFieldMapper();\n \n         GetResult getResult = indexShard.getService().get(request.type(), request.id(),\n-                new String[]{SourceFieldMapper.NAME, RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TimestampFieldMapper.NAME}, true);\n+                new String[]{SourceFieldMapper.NAME, RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TimestampFieldMapper.NAME, TTLFieldMapper.NAME}, true);\n \n         // no doc, what to do, what to do...\n         if (!getResult.exists()) {\n@@ -171,6 +182,24 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         Map<String, Object> source = sourceAndContent.v2();\n         Map<String, Object> ctx = new HashMap<String, Object>(2);\n         ctx.put(\"_source\", source);\n+        final long nowInMillis = System.currentTimeMillis();\n+        Long timestamp = null;\n+        Long ttlExpiresAt = null;\n+        boolean hasTtl = false;\n+        if (getResult.field(TimestampFieldMapper.NAME) != null) {\n+            timestamp = asLong(getResult.field(TimestampFieldMapper.NAME).value());\n+            if (timestamp != null) {\n+                ctx.put(\"_timestamp\", timestamp);\n+            }\n+        }\n+        if (getResult.field(TTLFieldMapper.NAME) != null) {\n+            Long ttlValue = asLong(getResult.field(TTLFieldMapper.NAME).value());\n+            if (ttlValue != null) {\n+                ctx.put(\"_ttl\", ttlValue);\n+                hasTtl = true;\n+                ttlExpiresAt = nowInMillis + ttlValue;\n+            }\n+        }\n \n         try {\n             ExecutableScript script = scriptService.executable(request.scriptLang, request.script, request.scriptParams);\n@@ -188,7 +217,31 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         // apply script to update the source\n         String routing = getResult.fields().containsKey(RoutingFieldMapper.NAME) ? getResult.field(RoutingFieldMapper.NAME).value().toString() : null;\n         String parent = getResult.fields().containsKey(ParentFieldMapper.NAME) ? getResult.field(ParentFieldMapper.NAME).value().toString() : null;\n-        // TODO ttl/timestamp\n+        if (hasTtl && !ctx.containsKey(\"_ttl\")) {\n+            ttlExpiresAt = null;\n+        }\n+        Long updatedTimestamp = timestamp;\n+        if (ctx.containsKey(\"_timestamp\")) {\n+            Object timestampObj = ctx.get(\"_timestamp\");\n+            if (timestampObj != null) {\n+                updatedTimestamp = parseTimestamp(timestampObj, timestampFieldMapper);\n+            } else {\n+                updatedTimestamp = null;\n+            }\n+        }\n+        Long ttlExpirationTime = ttlExpiresAt;\n+        if (ctx.containsKey(\"_ttl\")) {\n+            Object ttlObj = ctx.get(\"_ttl\");\n+            if (ttlObj != null) {\n+                long ttlValue = parseTtl(ttlObj);\n+                if (ttlValue <= 0) {\n+                    throw new ElasticSearchIllegalArgumentException(\"ttl must be > 0. Received [\" + ttlValue + \"]\");\n+                }\n+                ttlExpirationTime = nowInMillis + ttlValue;\n+            } else {\n+                ttlExpirationTime = null;\n+            }\n+        }\n \n         // TODO percolate?\n \n@@ -198,6 +251,7 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n             IndexRequest indexRequest = Requests.indexRequest(request.index()).type(request.type()).id(request.id()).routing(routing).parent(parent)\n                     .source(source, sourceAndContent.v1())\n                     .version(getResult.version()).replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel());\n+            applyTimestampAndTTL(indexRequest, updatedTimestamp, ttlExpirationTime);\n             indexRequest.operationThreaded(false);\n             indexAction.execute(indexRequest, new ActionListener<IndexResponse>() {\n                 @Override\n@@ -258,4 +312,60 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n             listener.onResponse(new UpdateResponse(getResult.index(), getResult.type(), getResult.id(), getResult.version()));\n         }\n     }\n+\n+    private Long asLong(Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+        if (value instanceof Number) {\n+            return ((Number) value).longValue();\n+        }\n+        return Long.parseLong(value.toString());\n+    }\n+\n+    private Long parseTimestamp(Object timestampObj, TimestampFieldMapper timestampFieldMapper) {\n+        if (timestampObj == null) {\n+            return null;\n+        }\n+        if (timestampObj instanceof Number) {\n+            return ((Number) timestampObj).longValue();\n+        }\n+        if (timestampObj instanceof Date) {\n+            return ((Date) timestampObj).getTime();\n+        }\n+        String timestampAsString = timestampObj.toString();\n+        if (timestampAsString.length() == 0) {\n+            return null;\n+        }\n+        if (timestampFieldMapper != null) {\n+            return Long.parseLong(MappingMetaData.Timestamp.parseStringTimestamp(timestampAsString, timestampFieldMapper.dateTimeFormatter()));\n+        }\n+        return Long.parseLong(MappingMetaData.Timestamp.parseStringTimestamp(timestampAsString, TimestampFieldMapper.Defaults.DATE_TIME_FORMATTER));\n+    }\n+\n+    private long parseTtl(Object ttlObj) {\n+        if (ttlObj instanceof Number) {\n+            return ((Number) ttlObj).longValue();\n+        }\n+        if (ttlObj instanceof TimeValue) {\n+            return ((TimeValue) ttlObj).millis();\n+        }\n+        return TimeValue.parseTimeValue(ttlObj.toString(), null).millis();\n+    }\n+\n+    private void applyTimestampAndTTL(IndexRequest indexRequest, Long timestamp, Long ttlExpiryTime) {\n+        if (timestamp != null) {\n+            indexRequest.timestamp(Long.toString(timestamp));\n+        }\n+        if (ttlExpiryTime != null) {\n+            if (timestamp == null) {\n+                throw new ElasticSearchIllegalArgumentException(\"timestamp is required when specifying ttl in script\");\n+            }\n+            long ttlValue = ttlExpiryTime - timestamp;\n+            if (ttlValue <= 0) {\n+                throw new ElasticSearchIllegalArgumentException(\"ttl must be > 0. Received [\" + ttlValue + \"]\");\n+            }\n+            indexRequest.ttl(ttlValue);\n+        }\n+    }\n }",
  "logs_path": "codex/gpt-5.1-codex/fd5b3480/elastic_elasticsearch_pr1600/logs.jsonl",
  "errors": [],
  "edit_run_id": "fd5b3480",
  "test_label": "v1-agent-comparison"
}