diff --git a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java
index 5a296cd..32e4ace 100644
--- a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java
+++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java
@@ -37,6 +37,7 @@ import org.elasticsearch.cluster.ClusterService;
 import org.elasticsearch.cluster.ClusterState;
 import org.elasticsearch.cluster.block.ClusterBlockException;
 import org.elasticsearch.cluster.block.ClusterBlockLevel;
+import org.elasticsearch.cluster.metadata.MappingMetaData;
 import org.elasticsearch.cluster.routing.PlainShardIterator;
 import org.elasticsearch.cluster.routing.ShardIterator;
 import org.elasticsearch.cluster.routing.ShardRouting;
@@ -49,9 +50,12 @@ import org.elasticsearch.index.engine.DocumentMissingException;
 import org.elasticsearch.index.engine.DocumentSourceMissingException;
 import org.elasticsearch.index.engine.VersionConflictEngineException;
 import org.elasticsearch.index.get.GetResult;
+import org.elasticsearch.common.unit.TimeValue;
+import org.elasticsearch.index.mapper.DocumentMapper;
 import org.elasticsearch.index.mapper.internal.ParentFieldMapper;
 import org.elasticsearch.index.mapper.internal.RoutingFieldMapper;
 import org.elasticsearch.index.mapper.internal.SourceFieldMapper;
+import org.elasticsearch.index.mapper.internal.TTLFieldMapper;
 import org.elasticsearch.index.mapper.internal.TimestampFieldMapper;
 import org.elasticsearch.index.service.IndexService;
 import org.elasticsearch.index.shard.IllegalIndexShardStateException;
@@ -63,6 +67,7 @@ import org.elasticsearch.script.ScriptService;
 import org.elasticsearch.threadpool.ThreadPool;
 import org.elasticsearch.transport.TransportService;
 
+import java.util.Date;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -151,9 +156,15 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio
     protected void shardOperation(final UpdateRequest request, final ActionListener<UpdateResponse> listener, final int retryCount) throws ElasticSearchException {
         IndexService indexService = indicesService.indexServiceSafe(request.index());
         IndexShard indexShard = indexService.shardSafe(request.shardId());
+        DocumentMapper docMapper = indexService.mapperService().documentMapper(request.type());
+        if (docMapper == null) {
+            listener.onFailure(new ElasticSearchIllegalArgumentException("type [" + request.type() + "] missing"));
+            return;
+        }
+        final TimestampFieldMapper timestampFieldMapper = docMapper.timestampFieldMapper();
 
         GetResult getResult = indexShard.getService().get(request.type(), request.id(),
-                new String[]{SourceFieldMapper.NAME, RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TimestampFieldMapper.NAME}, true);
+                new String[]{SourceFieldMapper.NAME, RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TimestampFieldMapper.NAME, TTLFieldMapper.NAME}, true);
 
         // no doc, what to do, what to do...
         if (!getResult.exists()) {
@@ -171,6 +182,24 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio
         Map<String, Object> source = sourceAndContent.v2();
         Map<String, Object> ctx = new HashMap<String, Object>(2);
         ctx.put("_source", source);
+        final long nowInMillis = System.currentTimeMillis();
+        Long timestamp = null;
+        Long ttlExpiresAt = null;
+        boolean hasTtl = false;
+        if (getResult.field(TimestampFieldMapper.NAME) != null) {
+            timestamp = asLong(getResult.field(TimestampFieldMapper.NAME).value());
+            if (timestamp != null) {
+                ctx.put("_timestamp", timestamp);
+            }
+        }
+        if (getResult.field(TTLFieldMapper.NAME) != null) {
+            Long ttlValue = asLong(getResult.field(TTLFieldMapper.NAME).value());
+            if (ttlValue != null) {
+                ctx.put("_ttl", ttlValue);
+                hasTtl = true;
+                ttlExpiresAt = nowInMillis + ttlValue;
+            }
+        }
 
         try {
             ExecutableScript script = scriptService.executable(request.scriptLang, request.script, request.scriptParams);
@@ -188,7 +217,31 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio
         // apply script to update the source
         String routing = getResult.fields().containsKey(RoutingFieldMapper.NAME) ? getResult.field(RoutingFieldMapper.NAME).value().toString() : null;
         String parent = getResult.fields().containsKey(ParentFieldMapper.NAME) ? getResult.field(ParentFieldMapper.NAME).value().toString() : null;
-        // TODO ttl/timestamp
+        if (hasTtl && !ctx.containsKey("_ttl")) {
+            ttlExpiresAt = null;
+        }
+        Long updatedTimestamp = timestamp;
+        if (ctx.containsKey("_timestamp")) {
+            Object timestampObj = ctx.get("_timestamp");
+            if (timestampObj != null) {
+                updatedTimestamp = parseTimestamp(timestampObj, timestampFieldMapper);
+            } else {
+                updatedTimestamp = null;
+            }
+        }
+        Long ttlExpirationTime = ttlExpiresAt;
+        if (ctx.containsKey("_ttl")) {
+            Object ttlObj = ctx.get("_ttl");
+            if (ttlObj != null) {
+                long ttlValue = parseTtl(ttlObj);
+                if (ttlValue <= 0) {
+                    throw new ElasticSearchIllegalArgumentException("ttl must be > 0. Received [" + ttlValue + "]");
+                }
+                ttlExpirationTime = nowInMillis + ttlValue;
+            } else {
+                ttlExpirationTime = null;
+            }
+        }
 
         // TODO percolate?
 
@@ -198,6 +251,7 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio
             IndexRequest indexRequest = Requests.indexRequest(request.index()).type(request.type()).id(request.id()).routing(routing).parent(parent)
                     .source(source, sourceAndContent.v1())
                     .version(getResult.version()).replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel());
+            applyTimestampAndTTL(indexRequest, updatedTimestamp, ttlExpirationTime);
             indexRequest.operationThreaded(false);
             indexAction.execute(indexRequest, new ActionListener<IndexResponse>() {
                 @Override
@@ -258,4 +312,60 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio
             listener.onResponse(new UpdateResponse(getResult.index(), getResult.type(), getResult.id(), getResult.version()));
         }
     }
+
+    private Long asLong(Object value) {
+        if (value == null) {
+            return null;
+        }
+        if (value instanceof Number) {
+            return ((Number) value).longValue();
+        }
+        return Long.parseLong(value.toString());
+    }
+
+    private Long parseTimestamp(Object timestampObj, TimestampFieldMapper timestampFieldMapper) {
+        if (timestampObj == null) {
+            return null;
+        }
+        if (timestampObj instanceof Number) {
+            return ((Number) timestampObj).longValue();
+        }
+        if (timestampObj instanceof Date) {
+            return ((Date) timestampObj).getTime();
+        }
+        String timestampAsString = timestampObj.toString();
+        if (timestampAsString.length() == 0) {
+            return null;
+        }
+        if (timestampFieldMapper != null) {
+            return Long.parseLong(MappingMetaData.Timestamp.parseStringTimestamp(timestampAsString, timestampFieldMapper.dateTimeFormatter()));
+        }
+        return Long.parseLong(MappingMetaData.Timestamp.parseStringTimestamp(timestampAsString, TimestampFieldMapper.Defaults.DATE_TIME_FORMATTER));
+    }
+
+    private long parseTtl(Object ttlObj) {
+        if (ttlObj instanceof Number) {
+            return ((Number) ttlObj).longValue();
+        }
+        if (ttlObj instanceof TimeValue) {
+            return ((TimeValue) ttlObj).millis();
+        }
+        return TimeValue.parseTimeValue(ttlObj.toString(), null).millis();
+    }
+
+    private void applyTimestampAndTTL(IndexRequest indexRequest, Long timestamp, Long ttlExpiryTime) {
+        if (timestamp != null) {
+            indexRequest.timestamp(Long.toString(timestamp));
+        }
+        if (ttlExpiryTime != null) {
+            if (timestamp == null) {
+                throw new ElasticSearchIllegalArgumentException("timestamp is required when specifying ttl in script");
+            }
+            long ttlValue = ttlExpiryTime - timestamp;
+            if (ttlValue <= 0) {
+                throw new ElasticSearchIllegalArgumentException("ttl must be > 0. Received [" + ttlValue + "]");
+            }
+            indexRequest.ttl(ttlValue);
+        }
+    }
 }