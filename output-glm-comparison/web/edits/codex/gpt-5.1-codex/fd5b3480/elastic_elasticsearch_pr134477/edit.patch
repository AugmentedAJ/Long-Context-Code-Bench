diff --git a/server/src/main/java/org/elasticsearch/search/SearchService.java b/server/src/main/java/org/elasticsearch/search/SearchService.java
index 9a101d83..d39580ff 100644
--- a/server/src/main/java/org/elasticsearch/search/SearchService.java
+++ b/server/src/main/java/org/elasticsearch/search/SearchService.java
@@ -156,6 +156,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.BiFunction;
+import java.util.function.BooleanSupplier;
 import java.util.function.Function;
 import java.util.function.LongSupplier;
 import java.util.function.Supplier;
@@ -574,6 +575,17 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv
         keepAliveReaper.cancel();
     }
 
+    static <T> ActionListener<T> wrapListenerForErrorHandling(
+        ActionListener<T> listener,
+        TransportVersion version,
+        String nodeId,
+        ShardId shardId,
+        long taskId,
+        ThreadPool threadPool
+    ) {
+        return wrapListenerForErrorHandling(listener, version, nodeId, shardId, taskId, threadPool, () -> true);
+    }
+
     /**
      * Wraps the listener to ensure errors are logged and to avoid sending
      * StackTraces back to the coordinating node if the `error_trace` header is
@@ -581,13 +593,14 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv
      * the same behavior as before the change, due to older nodes not being able
      * to specify whether they need stack traces.
      *
-     * @param <T>            the type of the response
-     * @param listener       the action listener to be wrapped
-     * @param version        channel version of the request
-     * @param nodeId         id of the current node
-     * @param shardId        id of the shard being searched
-     * @param taskId         id of the task being executed
-     * @param threadPool     with context where to write the new header
+     * @param <T>                    the type of the response
+     * @param listener               the action listener to be wrapped
+     * @param version                channel version of the request
+     * @param nodeId                 id of the current node
+     * @param shardId                id of the shard being searched
+     * @param taskId                 id of the task being executed
+     * @param threadPool             with context where to write the new header
+     * @param shouldWarnOnServerError predicate determining if 500-level errors should be logged as warnings
      * @return the wrapped action listener
      */
     static <T> ActionListener<T> wrapListenerForErrorHandling(
@@ -596,7 +609,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv
         String nodeId,
         ShardId shardId,
         long taskId,
-        ThreadPool threadPool
+        ThreadPool threadPool,
+        BooleanSupplier shouldWarnOnServerError
     ) {
         final boolean header;
         if (version.onOrAfter(ERROR_TRACE_IN_TRANSPORT_HEADER) && threadPool.getThreadContext() != null) {
@@ -612,10 +626,13 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv
                 taskId
             );
             // Keep this logic aligned with that of SUPPRESSED_ERROR_LOGGER in RestResponse
-            if (ExceptionsHelper.status(e).getStatus() < 500 || ExceptionsHelper.isNodeOrShardUnavailableTypeException(e)) {
-                logger.debug(messageSupplier, e);
-            } else {
+            final boolean warnOnServerError = ExceptionsHelper.status(e).getStatus() >= 500
+                && ExceptionsHelper.isNodeOrShardUnavailableTypeException(e) == false
+                && shouldWarnOnServerError.getAsBoolean();
+            if (warnOnServerError) {
                 logger.warn(messageSupplier, e);
+            } else {
+                logger.debug(messageSupplier, e);
             }
 
             if (header == false) {
@@ -636,6 +653,10 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv
         return Boolean.parseBoolean(threadPool.getThreadContext().getHeaderOrDefault("error_trace", "false"));
     }
 
+    private boolean shouldWarnOnSearchFailure() {
+        return lifecycle.stoppedOrClosed() == false;
+    }
+
     public void executeDfsPhase(ShardSearchRequest request, SearchShardTask task, ActionListener<SearchPhaseResult> listener) {
         listener = wrapListenerForErrorHandling(
             listener,
@@ -643,7 +664,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv
             clusterService.localNode().getId(),
             request.shardId(),
             task.getId(),
-            threadPool
+            threadPool,
+            this::shouldWarnOnSearchFailure
         );
         final IndexShard shard = getShard(request);
         rewriteAndFetchShardRequest(shard, request, listener.delegateFailure((l, rewritten) -> {
@@ -705,7 +727,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv
                 clusterService.localNode().getId(),
                 request.shardId(),
                 task.getId(),
-                threadPool
+                threadPool,
+                this::shouldWarnOnSearchFailure
             ).delegateFailure((l, orig) -> {
                 // check if we can shortcut the query phase entirely.
                 if (orig.canReturnNullResponseIfMatchNoDocs()) {
@@ -953,7 +976,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv
             clusterService.localNode().getId(),
             shardSearchRequest.shardId(),
             task.getId(),
-            threadPool
+            threadPool,
+            this::shouldWarnOnSearchFailure
         );
         final Releasable markAsUsed = readerContext.markAsUsed(getKeepAlive(shardSearchRequest));
         runAsync(getExecutor(readerContext.indexShard()), () -> {
@@ -1010,7 +1034,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv
             clusterService.localNode().getId(),
             readerContext.indexShard().shardId(),
             task.getId(),
-            threadPool
+            threadPool,
+            this::shouldWarnOnSearchFailure
         );
         final Releasable markAsUsed;
         try {
@@ -1072,7 +1097,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv
             clusterService.localNode().getId(),
             shardSearchRequest.shardId(),
             task.getId(),
-            threadPool
+            threadPool,
+            this::shouldWarnOnSearchFailure
         );
         final Releasable markAsUsed = readerContext.markAsUsed(getKeepAlive(shardSearchRequest));
         rewriteAndFetchShardRequest(readerContext.indexShard(), shardSearchRequest, listener.delegateFailure((l, rewritten) -> {
diff --git a/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java b/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java
index 29380a05..73f6b3d4 100644
--- a/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java
+++ b/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java
@@ -240,6 +240,54 @@ public class SearchServiceTests extends IndexShardTestCase {
         }
     }
 
+    public void testWrapListenerForErrorHandlingWarnSuppressedWhenStopped() {
+        final String nodeId = "node";
+        final String index = "index";
+        ShardId shardId = new ShardId(index, index, 0);
+        final long taskId = 123L;
+
+        try (var mockLog = MockLog.capture(SearchService.class)) {
+            Configurator.setLevel(SearchService.class, Level.DEBUG);
+            final String exceptionMessage = "test exception message";
+            mockLog.addExpectation(
+                new MockLog.ExceptionSeenEventExpectation(
+                    format(
+                        "\"[%s]%s: failed to execute search request for task [%d]\" and an exception logged",
+                        nodeId,
+                        shardId,
+                        taskId
+                    ),
+                    SearchService.class.getCanonicalName(),
+                    Level.DEBUG,
+                    format("[%s]%s: failed to execute search request for task [%d]", nodeId, shardId, taskId),
+                    IllegalStateException.class,
+                    exceptionMessage
+                )
+            );
+
+            ActionListener<SearchPhaseResult> listener = new ActionListener<>() {
+                @Override
+                public void onResponse(SearchPhaseResult searchPhaseResult) {}
+
+                @Override
+                public void onFailure(Exception e) {
+                    mockLog.assertAllExpectationsMatched();
+                }
+            };
+            IllegalStateException e = new IllegalStateException(exceptionMessage);
+            listener = wrapListenerForErrorHandling(
+                listener,
+                TransportVersion.current(),
+                nodeId,
+                shardId,
+                taskId,
+                threadPool,
+                () -> false
+            );
+            listener.onFailure(e);
+        }
+    }
+
     public void testIsExecutorQueuedBeyondPrewarmingFactor() throws InterruptedException {
         {
             final String threadPoolName = randomFrom(