{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134477,
  "base_commit": "1ccb58a8b2b9b38bad0506c49d455dbfcbea9224",
  "runner": "codex",
  "model": "gpt-5.1-codex",
  "timeout_s": 10800,
  "status": "success",
  "elapsed_ms": 270847,
  "patch_unified": "diff --git a/server/src/main/java/org/elasticsearch/search/SearchService.java b/server/src/main/java/org/elasticsearch/search/SearchService.java\nindex 9a101d83..d39580ff 100644\n--- a/server/src/main/java/org/elasticsearch/search/SearchService.java\n+++ b/server/src/main/java/org/elasticsearch/search/SearchService.java\n@@ -156,6 +156,7 @@ import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.BiFunction;\n+import java.util.function.BooleanSupplier;\n import java.util.function.Function;\n import java.util.function.LongSupplier;\n import java.util.function.Supplier;\n@@ -574,6 +575,17 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n         keepAliveReaper.cancel();\n     }\n \n+    static <T> ActionListener<T> wrapListenerForErrorHandling(\n+        ActionListener<T> listener,\n+        TransportVersion version,\n+        String nodeId,\n+        ShardId shardId,\n+        long taskId,\n+        ThreadPool threadPool\n+    ) {\n+        return wrapListenerForErrorHandling(listener, version, nodeId, shardId, taskId, threadPool, () -> true);\n+    }\n+\n     /**\n      * Wraps the listener to ensure errors are logged and to avoid sending\n      * StackTraces back to the coordinating node if the `error_trace` header is\n@@ -581,13 +593,14 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n      * the same behavior as before the change, due to older nodes not being able\n      * to specify whether they need stack traces.\n      *\n-     * @param <T>            the type of the response\n-     * @param listener       the action listener to be wrapped\n-     * @param version        channel version of the request\n-     * @param nodeId         id of the current node\n-     * @param shardId        id of the shard being searched\n-     * @param taskId         id of the task being executed\n-     * @param threadPool     with context where to write the new header\n+     * @param <T>                    the type of the response\n+     * @param listener               the action listener to be wrapped\n+     * @param version                channel version of the request\n+     * @param nodeId                 id of the current node\n+     * @param shardId                id of the shard being searched\n+     * @param taskId                 id of the task being executed\n+     * @param threadPool             with context where to write the new header\n+     * @param shouldWarnOnServerError predicate determining if 500-level errors should be logged as warnings\n      * @return the wrapped action listener\n      */\n     static <T> ActionListener<T> wrapListenerForErrorHandling(\n@@ -596,7 +609,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n         String nodeId,\n         ShardId shardId,\n         long taskId,\n-        ThreadPool threadPool\n+        ThreadPool threadPool,\n+        BooleanSupplier shouldWarnOnServerError\n     ) {\n         final boolean header;\n         if (version.onOrAfter(ERROR_TRACE_IN_TRANSPORT_HEADER) && threadPool.getThreadContext() != null) {\n@@ -612,10 +626,13 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n                 taskId\n             );\n             // Keep this logic aligned with that of SUPPRESSED_ERROR_LOGGER in RestResponse\n-            if (ExceptionsHelper.status(e).getStatus() < 500 || ExceptionsHelper.isNodeOrShardUnavailableTypeException(e)) {\n-                logger.debug(messageSupplier, e);\n-            } else {\n+            final boolean warnOnServerError = ExceptionsHelper.status(e).getStatus() >= 500\n+                && ExceptionsHelper.isNodeOrShardUnavailableTypeException(e) == false\n+                && shouldWarnOnServerError.getAsBoolean();\n+            if (warnOnServerError) {\n                 logger.warn(messageSupplier, e);\n+            } else {\n+                logger.debug(messageSupplier, e);\n             }\n \n             if (header == false) {\n@@ -636,6 +653,10 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n         return Boolean.parseBoolean(threadPool.getThreadContext().getHeaderOrDefault(\"error_trace\", \"false\"));\n     }\n \n+    private boolean shouldWarnOnSearchFailure() {\n+        return lifecycle.stoppedOrClosed() == false;\n+    }\n+\n     public void executeDfsPhase(ShardSearchRequest request, SearchShardTask task, ActionListener<SearchPhaseResult> listener) {\n         listener = wrapListenerForErrorHandling(\n             listener,\n@@ -643,7 +664,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             clusterService.localNode().getId(),\n             request.shardId(),\n             task.getId(),\n-            threadPool\n+            threadPool,\n+            this::shouldWarnOnSearchFailure\n         );\n         final IndexShard shard = getShard(request);\n         rewriteAndFetchShardRequest(shard, request, listener.delegateFailure((l, rewritten) -> {\n@@ -705,7 +727,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n                 clusterService.localNode().getId(),\n                 request.shardId(),\n                 task.getId(),\n-                threadPool\n+                threadPool,\n+                this::shouldWarnOnSearchFailure\n             ).delegateFailure((l, orig) -> {\n                 // check if we can shortcut the query phase entirely.\n                 if (orig.canReturnNullResponseIfMatchNoDocs()) {\n@@ -953,7 +976,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             clusterService.localNode().getId(),\n             shardSearchRequest.shardId(),\n             task.getId(),\n-            threadPool\n+            threadPool,\n+            this::shouldWarnOnSearchFailure\n         );\n         final Releasable markAsUsed = readerContext.markAsUsed(getKeepAlive(shardSearchRequest));\n         runAsync(getExecutor(readerContext.indexShard()), () -> {\n@@ -1010,7 +1034,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             clusterService.localNode().getId(),\n             readerContext.indexShard().shardId(),\n             task.getId(),\n-            threadPool\n+            threadPool,\n+            this::shouldWarnOnSearchFailure\n         );\n         final Releasable markAsUsed;\n         try {\n@@ -1072,7 +1097,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             clusterService.localNode().getId(),\n             shardSearchRequest.shardId(),\n             task.getId(),\n-            threadPool\n+            threadPool,\n+            this::shouldWarnOnSearchFailure\n         );\n         final Releasable markAsUsed = readerContext.markAsUsed(getKeepAlive(shardSearchRequest));\n         rewriteAndFetchShardRequest(readerContext.indexShard(), shardSearchRequest, listener.delegateFailure((l, rewritten) -> {\ndiff --git a/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java b/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java\nindex 29380a05..73f6b3d4 100644\n--- a/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java\n@@ -240,6 +240,54 @@ public class SearchServiceTests extends IndexShardTestCase {\n         }\n     }\n \n+    public void testWrapListenerForErrorHandlingWarnSuppressedWhenStopped() {\n+        final String nodeId = \"node\";\n+        final String index = \"index\";\n+        ShardId shardId = new ShardId(index, index, 0);\n+        final long taskId = 123L;\n+\n+        try (var mockLog = MockLog.capture(SearchService.class)) {\n+            Configurator.setLevel(SearchService.class, Level.DEBUG);\n+            final String exceptionMessage = \"test exception message\";\n+            mockLog.addExpectation(\n+                new MockLog.ExceptionSeenEventExpectation(\n+                    format(\n+                        \"\\\"[%s]%s: failed to execute search request for task [%d]\\\" and an exception logged\",\n+                        nodeId,\n+                        shardId,\n+                        taskId\n+                    ),\n+                    SearchService.class.getCanonicalName(),\n+                    Level.DEBUG,\n+                    format(\"[%s]%s: failed to execute search request for task [%d]\", nodeId, shardId, taskId),\n+                    IllegalStateException.class,\n+                    exceptionMessage\n+                )\n+            );\n+\n+            ActionListener<SearchPhaseResult> listener = new ActionListener<>() {\n+                @Override\n+                public void onResponse(SearchPhaseResult searchPhaseResult) {}\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    mockLog.assertAllExpectationsMatched();\n+                }\n+            };\n+            IllegalStateException e = new IllegalStateException(exceptionMessage);\n+            listener = wrapListenerForErrorHandling(\n+                listener,\n+                TransportVersion.current(),\n+                nodeId,\n+                shardId,\n+                taskId,\n+                threadPool,\n+                () -> false\n+            );\n+            listener.onFailure(e);\n+        }\n+    }\n+\n     public void testIsExecutorQueuedBeyondPrewarmingFactor() throws InterruptedException {\n         {\n             final String threadPoolName = randomFrom(",
  "logs_path": "codex/gpt-5.1-codex/1c2e04d5/elastic_elasticsearch_pr134477/logs.jsonl",
  "errors": [],
  "edit_run_id": "fd5b3480",
  "test_label": "v1-agent-comparison"
}