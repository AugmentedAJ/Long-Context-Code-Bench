diff --git a/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java b/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java
index c7fd6df4..4699d82b 100644
--- a/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java
+++ b/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java
@@ -70,11 +70,14 @@ import org.elasticsearch.xpack.transform.persistence.TransformIndex;
 import org.elasticsearch.xpack.transform.transforms.pivot.SchemaUtil;
 import org.elasticsearch.xpack.transform.utils.ExceptionRootCauseFinder;
 
+import java.util.ArrayList;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
 import static org.elasticsearch.core.Strings.format;
@@ -154,9 +157,22 @@ class ClientTransformIndexer extends TransformIndexer {
         }
 
         if (getNextCheckpoint().getCheckpoint() != pitCheckpoint) {
-            closePointInTime();
+            closePointInTime(
+                ActionListener.wrap(
+                    ignored -> executeSearchPhase(nextPhase),
+                    e -> {
+                        logger.warn(() -> format("[%s] failed while closing point in time reader", getJobId()), e);
+                        executeSearchPhase(nextPhase);
+                    }
+                )
+            );
+            return;
         }
 
+        executeSearchPhase(nextPhase);
+    }
+
+    private void executeSearchPhase(ActionListener<SearchResponse> nextPhase) {
         injectPointInTimeIfNeeded(
             buildSearchRequest(),
             ActionListener.wrap(searchRequest -> doSearch(searchRequest, nextPhase), nextPhase::onFailure)
@@ -482,34 +498,57 @@ class ClientTransformIndexer extends TransformIndexer {
     }
 
     private void closePointInTime() {
-        for (String name : namedPits.keySet()) {
-            closePointInTime(name);
+        closePointInTime(ActionListener.noop());
+    }
+
+    private void closePointInTime(ActionListener<Void> listener) {
+        final List<String> pitNames = new ArrayList<>(namedPits.keySet());
+        if (pitNames.isEmpty()) {
+            listener.onResponse(null);
+            return;
+        }
+
+        final AtomicInteger remaining = new AtomicInteger(pitNames.size());
+        for (String name : pitNames) {
+            closePointInTime(name, () -> {
+                if (remaining.decrementAndGet() == 0) {
+                    listener.onResponse(null);
+                }
+            });
         }
     }
 
-    private void closePointInTime(String name) {
+    private void closePointInTime(String name, Runnable completion) {
         PointInTimeBuilder pit = namedPits.remove(name);
 
         if (pit == null) {
+            completion.run();
             return;
         }
 
         BytesReference oldPit = pit.getEncodedId();
 
         ClosePointInTimeRequest closePitRequest = new ClosePointInTimeRequest(oldPit);
-        ClientHelper.executeWithHeadersAsync(
-            transformConfig.getHeaders(),
-            ClientHelper.TRANSFORM_ORIGIN,
-            client,
-            TransportClosePointInTimeAction.TYPE,
-            closePitRequest,
-            ActionListener.wrap(response -> {
-                logger.trace("[{}] closed pit search context [{}]", getJobId(), oldPit);
-            }, e -> {
-                // note: closing the pit should never throw, even if the pit is invalid
-                logger.error(() -> "[" + getJobId() + "] Failed to close point in time reader", e);
-            })
-        );
+        try {
+            ClientHelper.executeWithHeadersAsync(
+                transformConfig.getHeaders(),
+                ClientHelper.TRANSFORM_ORIGIN,
+                client,
+                TransportClosePointInTimeAction.TYPE,
+                closePitRequest,
+                ActionListener.wrap(response -> {
+                    logger.trace("[{}] closed pit search context [{}]", getJobId(), oldPit);
+                    completion.run();
+                }, e -> {
+                    // note: closing the pit should never throw, even if the pit is invalid
+                    logger.error(() -> "[" + getJobId() + "] Failed to close point in time reader", e);
+                    completion.run();
+                })
+            );
+        } catch (Exception e) {
+            logger.error(() -> "[" + getJobId() + "] Failed to close point in time reader", e);
+            completion.run();
+        }
     }
 
     private void injectPointInTimeIfNeeded(
diff --git a/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java b/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java
index c1d36c32..bf4b4319 100644
--- a/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java
+++ b/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java
@@ -72,6 +72,7 @@ import org.elasticsearch.xpack.transform.persistence.IndexBasedTransformConfigMa
 import org.elasticsearch.xpack.transform.persistence.SeqNoPrimaryTermAndIndex;
 import org.elasticsearch.xpack.transform.transforms.scheduling.TransformScheduler;
 
+import java.lang.reflect.Field;
 import java.time.Clock;
 import java.time.Instant;
 import java.util.Collections;
@@ -480,6 +481,74 @@ public class ClientTransformIndexerTests extends ESTestCase {
         }
     }
 
+    public void testWaitsForPendingPitCloseBeforeSearchingNextCheckpoint() throws Exception {
+        TransformConfig config = new TransformConfig.Builder(TransformConfigTests.randomTransformConfig()).setSettings(
+            new SettingsConfig.Builder().setUsePit(true).build()
+        ).build();
+
+        try (var threadPool = createThreadPool()) {
+            final var client = new BlockingPitMockClient(threadPool);
+            MockClientTransformIndexer indexer = new MockClientTransformIndexer(
+                mock(ThreadPool.class),
+                mock(ClusterService.class),
+                mock(IndexNameExpressionResolver.class),
+                mock(TransformExtension.class),
+                new TransformServices(
+                    mock(IndexBasedTransformConfigManager.class),
+                    mock(TransformCheckpointService.class),
+                    mock(TransformAuditor.class),
+                    new TransformScheduler(Clock.systemUTC(), mock(ThreadPool.class), Settings.EMPTY, TimeValue.ZERO),
+                    mock(TransformNode.class)
+                ),
+                mock(CheckpointProvider.class),
+                new AtomicReference<>(IndexerState.STOPPED),
+                null,
+                new ParentTaskAssigningClient(client, new TaskId("dummy-node:123456")),
+                mock(TransformIndexerStats.class),
+                config,
+                null,
+                new TransformCheckpoint(
+                    "transform",
+                    Instant.now().toEpochMilli(),
+                    0L,
+                    Collections.emptyMap(),
+                    Instant.now().toEpochMilli()
+                ),
+                new TransformCheckpoint(
+                    "transform",
+                    Instant.now().toEpochMilli(),
+                    2L,
+                    Collections.emptyMap(),
+                    Instant.now().toEpochMilli()
+                ),
+                new SeqNoPrimaryTermAndIndex(1, 1, TransformInternalIndexConstants.LATEST_INDEX_NAME),
+                mock(TransformContext.class),
+                false
+            );
+
+            this.<SearchResponse>assertAsync(listener -> indexer.doNextSearch(0, listener), response -> assertNotNull(response.pointInTimeId()));
+            assertEquals(1L, client.getPitContextCounter());
+
+            setPitCheckpoint(indexer, 0L);
+
+            CountDownLatch listenerLatch = new CountDownLatch(1);
+            AtomicReference<SearchResponse> responseRef = new AtomicReference<>();
+            indexer.doNextSearch(0, ActionListener.wrap(response -> {
+                responseRef.set(response);
+                listenerLatch.countDown();
+            }, e -> fail("unexpected failure: " + e)));
+
+            assertTrue(client.awaitCloseRequest(5, TimeUnit.SECONDS));
+            assertFalse(client.searchInvokedBeforeClose());
+
+            client.allowCloseResponse();
+
+            assertTrue(listenerLatch.await(5, TimeUnit.SECONDS));
+            assertNotNull(responseRef.get());
+            assertFalse(client.searchInvokedBeforeClose());
+        }
+    }
+
     public void testIndexBlocked() {
         var service = serviceWithBlockCheck(true);
         var context = new TransformContext(TransformTaskState.STARTED, "", 0, mock());
@@ -535,6 +604,12 @@ public class ClientTransformIndexerTests extends ESTestCase {
         return resolver;
     }
 
+    private static void setPitCheckpoint(ClientTransformIndexer indexer, long checkpoint) throws Exception {
+        Field field = ClientTransformIndexer.class.getDeclaredField("pitCheckpoint");
+        field.setAccessible(true);
+        field.setLong(indexer, checkpoint);
+    }
+
     private static class MockClientTransformIndexer extends ClientTransformIndexer {
 
         MockClientTransformIndexer(
@@ -674,6 +749,59 @@ public class ClientTransformIndexerTests extends ESTestCase {
         }
     }
 
+    private static class BlockingPitMockClient extends PitMockClient {
+        private final CountDownLatch closeRequestLatch = new CountDownLatch(1);
+        private final CountDownLatch allowCloseResponseLatch = new CountDownLatch(1);
+        private final AtomicBoolean searchBeforeClose = new AtomicBoolean(false);
+        private final AtomicBoolean closeCompleted = new AtomicBoolean(true);
+
+        BlockingPitMockClient(ThreadPool threadPool) {
+            super(threadPool, true);
+        }
+
+        boolean awaitCloseRequest(long timeout, TimeUnit unit) throws InterruptedException {
+            return closeRequestLatch.await(timeout, unit);
+        }
+
+        void allowCloseResponse() {
+            allowCloseResponseLatch.countDown();
+        }
+
+        boolean searchInvokedBeforeClose() {
+            return searchBeforeClose.get();
+        }
+
+        @Override
+        protected <Request extends ActionRequest, Response extends ActionResponse> void doExecute(
+            ActionType<Response> action,
+            Request request,
+            ActionListener<Response> listener
+        ) {
+            if (request instanceof ClosePointInTimeRequest) {
+                closeCompleted.set(false);
+                closeRequestLatch.countDown();
+                try {
+                    if (allowCloseResponseLatch.await(5, TimeUnit.SECONDS) == false) {
+                        throw new AssertionError("timed out waiting to allow close response");
+                    }
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                    throw new AssertionError(e);
+                }
+                super.doExecute(action, request, ActionListener.wrap(response -> {
+                    closeCompleted.set(true);
+                    listener.onResponse(response);
+                }, listener::onFailure));
+                return;
+            } else if (request instanceof SearchRequest) {
+                if (closeCompleted.get() == false) {
+                    searchBeforeClose.set(true);
+                }
+            }
+            super.doExecute(action, request, listener);
+        }
+    }
+
     private <T> void assertAsync(Consumer<ActionListener<T>> function, Consumer<T> furtherTests) throws InterruptedException {
         CountDownLatch latch = new CountDownLatch(1);
         AtomicBoolean listenerCalled = new AtomicBoolean(false);