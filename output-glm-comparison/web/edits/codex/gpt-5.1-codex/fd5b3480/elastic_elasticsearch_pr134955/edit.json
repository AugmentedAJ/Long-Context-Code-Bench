{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134955,
  "base_commit": "8272fc895484bdcf635a3828616e03183cac283d",
  "runner": "codex",
  "model": "gpt-5.1-codex",
  "timeout_s": 10800,
  "status": "success",
  "elapsed_ms": 418481,
  "patch_unified": "diff --git a/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java b/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java\nindex c7fd6df4..4699d82b 100644\n--- a/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java\n+++ b/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java\n@@ -70,11 +70,14 @@ import org.elasticsearch.xpack.transform.persistence.TransformIndex;\n import org.elasticsearch.xpack.transform.transforms.pivot.SchemaUtil;\n import org.elasticsearch.xpack.transform.utils.ExceptionRootCauseFinder;\n \n+import java.util.ArrayList;\n import java.util.LinkedHashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n \n import static org.elasticsearch.core.Strings.format;\n@@ -154,9 +157,22 @@ class ClientTransformIndexer extends TransformIndexer {\n         }\n \n         if (getNextCheckpoint().getCheckpoint() != pitCheckpoint) {\n-            closePointInTime();\n+            closePointInTime(\n+                ActionListener.wrap(\n+                    ignored -> executeSearchPhase(nextPhase),\n+                    e -> {\n+                        logger.warn(() -> format(\"[%s] failed while closing point in time reader\", getJobId()), e);\n+                        executeSearchPhase(nextPhase);\n+                    }\n+                )\n+            );\n+            return;\n         }\n \n+        executeSearchPhase(nextPhase);\n+    }\n+\n+    private void executeSearchPhase(ActionListener<SearchResponse> nextPhase) {\n         injectPointInTimeIfNeeded(\n             buildSearchRequest(),\n             ActionListener.wrap(searchRequest -> doSearch(searchRequest, nextPhase), nextPhase::onFailure)\n@@ -482,34 +498,57 @@ class ClientTransformIndexer extends TransformIndexer {\n     }\n \n     private void closePointInTime() {\n-        for (String name : namedPits.keySet()) {\n-            closePointInTime(name);\n+        closePointInTime(ActionListener.noop());\n+    }\n+\n+    private void closePointInTime(ActionListener<Void> listener) {\n+        final List<String> pitNames = new ArrayList<>(namedPits.keySet());\n+        if (pitNames.isEmpty()) {\n+            listener.onResponse(null);\n+            return;\n+        }\n+\n+        final AtomicInteger remaining = new AtomicInteger(pitNames.size());\n+        for (String name : pitNames) {\n+            closePointInTime(name, () -> {\n+                if (remaining.decrementAndGet() == 0) {\n+                    listener.onResponse(null);\n+                }\n+            });\n         }\n     }\n \n-    private void closePointInTime(String name) {\n+    private void closePointInTime(String name, Runnable completion) {\n         PointInTimeBuilder pit = namedPits.remove(name);\n \n         if (pit == null) {\n+            completion.run();\n             return;\n         }\n \n         BytesReference oldPit = pit.getEncodedId();\n \n         ClosePointInTimeRequest closePitRequest = new ClosePointInTimeRequest(oldPit);\n-        ClientHelper.executeWithHeadersAsync(\n-            transformConfig.getHeaders(),\n-            ClientHelper.TRANSFORM_ORIGIN,\n-            client,\n-            TransportClosePointInTimeAction.TYPE,\n-            closePitRequest,\n-            ActionListener.wrap(response -> {\n-                logger.trace(\"[{}] closed pit search context [{}]\", getJobId(), oldPit);\n-            }, e -> {\n-                // note: closing the pit should never throw, even if the pit is invalid\n-                logger.error(() -> \"[\" + getJobId() + \"] Failed to close point in time reader\", e);\n-            })\n-        );\n+        try {\n+            ClientHelper.executeWithHeadersAsync(\n+                transformConfig.getHeaders(),\n+                ClientHelper.TRANSFORM_ORIGIN,\n+                client,\n+                TransportClosePointInTimeAction.TYPE,\n+                closePitRequest,\n+                ActionListener.wrap(response -> {\n+                    logger.trace(\"[{}] closed pit search context [{}]\", getJobId(), oldPit);\n+                    completion.run();\n+                }, e -> {\n+                    // note: closing the pit should never throw, even if the pit is invalid\n+                    logger.error(() -> \"[\" + getJobId() + \"] Failed to close point in time reader\", e);\n+                    completion.run();\n+                })\n+            );\n+        } catch (Exception e) {\n+            logger.error(() -> \"[\" + getJobId() + \"] Failed to close point in time reader\", e);\n+            completion.run();\n+        }\n     }\n \n     private void injectPointInTimeIfNeeded(\ndiff --git a/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java b/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java\nindex c1d36c32..bf4b4319 100644\n--- a/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java\n+++ b/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java\n@@ -72,6 +72,7 @@ import org.elasticsearch.xpack.transform.persistence.IndexBasedTransformConfigMa\n import org.elasticsearch.xpack.transform.persistence.SeqNoPrimaryTermAndIndex;\n import org.elasticsearch.xpack.transform.transforms.scheduling.TransformScheduler;\n \n+import java.lang.reflect.Field;\n import java.time.Clock;\n import java.time.Instant;\n import java.util.Collections;\n@@ -480,6 +481,74 @@ public class ClientTransformIndexerTests extends ESTestCase {\n         }\n     }\n \n+    public void testWaitsForPendingPitCloseBeforeSearchingNextCheckpoint() throws Exception {\n+        TransformConfig config = new TransformConfig.Builder(TransformConfigTests.randomTransformConfig()).setSettings(\n+            new SettingsConfig.Builder().setUsePit(true).build()\n+        ).build();\n+\n+        try (var threadPool = createThreadPool()) {\n+            final var client = new BlockingPitMockClient(threadPool);\n+            MockClientTransformIndexer indexer = new MockClientTransformIndexer(\n+                mock(ThreadPool.class),\n+                mock(ClusterService.class),\n+                mock(IndexNameExpressionResolver.class),\n+                mock(TransformExtension.class),\n+                new TransformServices(\n+                    mock(IndexBasedTransformConfigManager.class),\n+                    mock(TransformCheckpointService.class),\n+                    mock(TransformAuditor.class),\n+                    new TransformScheduler(Clock.systemUTC(), mock(ThreadPool.class), Settings.EMPTY, TimeValue.ZERO),\n+                    mock(TransformNode.class)\n+                ),\n+                mock(CheckpointProvider.class),\n+                new AtomicReference<>(IndexerState.STOPPED),\n+                null,\n+                new ParentTaskAssigningClient(client, new TaskId(\"dummy-node:123456\")),\n+                mock(TransformIndexerStats.class),\n+                config,\n+                null,\n+                new TransformCheckpoint(\n+                    \"transform\",\n+                    Instant.now().toEpochMilli(),\n+                    0L,\n+                    Collections.emptyMap(),\n+                    Instant.now().toEpochMilli()\n+                ),\n+                new TransformCheckpoint(\n+                    \"transform\",\n+                    Instant.now().toEpochMilli(),\n+                    2L,\n+                    Collections.emptyMap(),\n+                    Instant.now().toEpochMilli()\n+                ),\n+                new SeqNoPrimaryTermAndIndex(1, 1, TransformInternalIndexConstants.LATEST_INDEX_NAME),\n+                mock(TransformContext.class),\n+                false\n+            );\n+\n+            this.<SearchResponse>assertAsync(listener -> indexer.doNextSearch(0, listener), response -> assertNotNull(response.pointInTimeId()));\n+            assertEquals(1L, client.getPitContextCounter());\n+\n+            setPitCheckpoint(indexer, 0L);\n+\n+            CountDownLatch listenerLatch = new CountDownLatch(1);\n+            AtomicReference<SearchResponse> responseRef = new AtomicReference<>();\n+            indexer.doNextSearch(0, ActionListener.wrap(response -> {\n+                responseRef.set(response);\n+                listenerLatch.countDown();\n+            }, e -> fail(\"unexpected failure: \" + e)));\n+\n+            assertTrue(client.awaitCloseRequest(5, TimeUnit.SECONDS));\n+            assertFalse(client.searchInvokedBeforeClose());\n+\n+            client.allowCloseResponse();\n+\n+            assertTrue(listenerLatch.await(5, TimeUnit.SECONDS));\n+            assertNotNull(responseRef.get());\n+            assertFalse(client.searchInvokedBeforeClose());\n+        }\n+    }\n+\n     public void testIndexBlocked() {\n         var service = serviceWithBlockCheck(true);\n         var context = new TransformContext(TransformTaskState.STARTED, \"\", 0, mock());\n@@ -535,6 +604,12 @@ public class ClientTransformIndexerTests extends ESTestCase {\n         return resolver;\n     }\n \n+    private static void setPitCheckpoint(ClientTransformIndexer indexer, long checkpoint) throws Exception {\n+        Field field = ClientTransformIndexer.class.getDeclaredField(\"pitCheckpoint\");\n+        field.setAccessible(true);\n+        field.setLong(indexer, checkpoint);\n+    }\n+\n     private static class MockClientTransformIndexer extends ClientTransformIndexer {\n \n         MockClientTransformIndexer(\n@@ -674,6 +749,59 @@ public class ClientTransformIndexerTests extends ESTestCase {\n         }\n     }\n \n+    private static class BlockingPitMockClient extends PitMockClient {\n+        private final CountDownLatch closeRequestLatch = new CountDownLatch(1);\n+        private final CountDownLatch allowCloseResponseLatch = new CountDownLatch(1);\n+        private final AtomicBoolean searchBeforeClose = new AtomicBoolean(false);\n+        private final AtomicBoolean closeCompleted = new AtomicBoolean(true);\n+\n+        BlockingPitMockClient(ThreadPool threadPool) {\n+            super(threadPool, true);\n+        }\n+\n+        boolean awaitCloseRequest(long timeout, TimeUnit unit) throws InterruptedException {\n+            return closeRequestLatch.await(timeout, unit);\n+        }\n+\n+        void allowCloseResponse() {\n+            allowCloseResponseLatch.countDown();\n+        }\n+\n+        boolean searchInvokedBeforeClose() {\n+            return searchBeforeClose.get();\n+        }\n+\n+        @Override\n+        protected <Request extends ActionRequest, Response extends ActionResponse> void doExecute(\n+            ActionType<Response> action,\n+            Request request,\n+            ActionListener<Response> listener\n+        ) {\n+            if (request instanceof ClosePointInTimeRequest) {\n+                closeCompleted.set(false);\n+                closeRequestLatch.countDown();\n+                try {\n+                    if (allowCloseResponseLatch.await(5, TimeUnit.SECONDS) == false) {\n+                        throw new AssertionError(\"timed out waiting to allow close response\");\n+                    }\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    throw new AssertionError(e);\n+                }\n+                super.doExecute(action, request, ActionListener.wrap(response -> {\n+                    closeCompleted.set(true);\n+                    listener.onResponse(response);\n+                }, listener::onFailure));\n+                return;\n+            } else if (request instanceof SearchRequest) {\n+                if (closeCompleted.get() == false) {\n+                    searchBeforeClose.set(true);\n+                }\n+            }\n+            super.doExecute(action, request, listener);\n+        }\n+    }\n+\n     private <T> void assertAsync(Consumer<ActionListener<T>> function, Consumer<T> furtherTests) throws InterruptedException {\n         CountDownLatch latch = new CountDownLatch(1);\n         AtomicBoolean listenerCalled = new AtomicBoolean(false);",
  "logs_path": "codex/gpt-5.1-codex/1c2e04d5/elastic_elasticsearch_pr134955/logs.jsonl",
  "errors": [],
  "edit_run_id": "fd5b3480",
  "test_label": "v1-agent-comparison"
}