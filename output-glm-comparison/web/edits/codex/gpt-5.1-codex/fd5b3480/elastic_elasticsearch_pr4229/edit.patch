diff --git a/src/main/java/org/elasticsearch/cluster/ClusterModule.java b/src/main/java/org/elasticsearch/cluster/ClusterModule.java
index 491dead..f2b28f7 100644
--- a/src/main/java/org/elasticsearch/cluster/ClusterModule.java
+++ b/src/main/java/org/elasticsearch/cluster/ClusterModule.java
@@ -73,10 +73,9 @@ public class ClusterModule extends AbstractModule implements SpawnModules {
         bind(ShardStateAction.class).asEagerSingleton();
         bind(NodeIndexCreatedAction.class).asEagerSingleton();
         bind(NodeIndexDeletedAction.class).asEagerSingleton();
-        bind(NodeMappingCreatedAction.class).asEagerSingleton();
         bind(NodeMappingRefreshAction.class).asEagerSingleton();
         bind(MappingUpdatedAction.class).asEagerSingleton();
 
         bind(ClusterInfoService.class).to(InternalClusterInfoService.class).asEagerSingleton();
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/elasticsearch/cluster/action/index/NodeMappingCreatedAction.java b/src/main/java/org/elasticsearch/cluster/action/index/NodeMappingCreatedAction.java
deleted file mode 100644
index d39c6e8..0000000
--- a/src/main/java/org/elasticsearch/cluster/action/index/NodeMappingCreatedAction.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * Licensed to ElasticSearch and Shay Banon under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. ElasticSearch licenses this
- * file to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package org.elasticsearch.cluster.action.index;
-
-import org.elasticsearch.ElasticSearchException;
-import org.elasticsearch.cluster.ClusterState;
-import org.elasticsearch.common.component.AbstractComponent;
-import org.elasticsearch.common.inject.Inject;
-import org.elasticsearch.common.io.stream.StreamInput;
-import org.elasticsearch.common.io.stream.StreamOutput;
-import org.elasticsearch.common.settings.Settings;
-import org.elasticsearch.common.unit.TimeValue;
-import org.elasticsearch.threadpool.ThreadPool;
-import org.elasticsearch.transport.*;
-
-import java.io.IOException;
-import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
-
-/**
- *
- */
-public class NodeMappingCreatedAction extends AbstractComponent {
-
-    private final ThreadPool threadPool;
-    private final TransportService transportService;
-    private final List<Listener> listeners = new CopyOnWriteArrayList<Listener>();
-
-    @Inject
-    public NodeMappingCreatedAction(Settings settings, ThreadPool threadPool, TransportService transportService) {
-        super(settings);
-        this.threadPool = threadPool;
-        this.transportService = transportService;
-        transportService.registerHandler(NodeMappingCreatedTransportHandler.ACTION, new NodeMappingCreatedTransportHandler());
-    }
-
-    public void add(final Listener listener, TimeValue timeout) {
-        listeners.add(listener);
-        threadPool.schedule(timeout, ThreadPool.Names.GENERIC, new Runnable() {
-            @Override
-            public void run() {
-                boolean removed = listeners.remove(listener);
-                if (removed) {
-                    listener.onTimeout();
-                }
-            }
-        });
-    }
-
-    public void remove(Listener listener) {
-        listeners.remove(listener);
-    }
-
-    public void nodeMappingCreated(final ClusterState state, final NodeMappingCreatedResponse response) throws ElasticSearchException {
-        logger.debug("Sending mapping created for index {}, type {} (cluster state version: {})", response.index, response.type, response.clusterStateVersion);
-        if (state.nodes().localNodeMaster()) {
-            threadPool.generic().execute(new Runnable() {
-                @Override
-                public void run() {
-                    innerNodeIndexCreated(response);
-                }
-            });
-        } else {
-            transportService.sendRequest(state.nodes().masterNode(),
-                    NodeMappingCreatedTransportHandler.ACTION, response, EmptyTransportResponseHandler.INSTANCE_SAME);
-        }
-    }
-
-    private void innerNodeIndexCreated(NodeMappingCreatedResponse response) {
-        for (Listener listener : listeners) {
-            listener.onNodeMappingCreated(response);
-        }
-    }
-
-
-    public static interface Listener {
-        void onNodeMappingCreated(NodeMappingCreatedResponse response);
-
-        void onTimeout();
-    }
-
-    private class NodeMappingCreatedTransportHandler extends BaseTransportRequestHandler<NodeMappingCreatedResponse> {
-
-        static final String ACTION = "cluster/nodeMappingCreated";
-
-        @Override
-        public NodeMappingCreatedResponse newInstance() {
-            return new NodeMappingCreatedResponse();
-        }
-
-        @Override
-        public void messageReceived(NodeMappingCreatedResponse response, TransportChannel channel) throws Exception {
-            innerNodeIndexCreated(response);
-            channel.sendResponse(TransportResponse.Empty.INSTANCE);
-        }
-
-        @Override
-        public String executor() {
-            return ThreadPool.Names.SAME;
-        }
-    }
-
-    public static class NodeMappingCreatedResponse extends TransportRequest {
-
-        private String index;
-        private String type;
-        private String nodeId;
-        private long clusterStateVersion;
-
-        private NodeMappingCreatedResponse() {
-        }
-
-        public NodeMappingCreatedResponse(String index, String type, String nodeId, long clusterStateVersion) {
-            this.index = index;
-            this.type = type;
-            this.nodeId = nodeId;
-            this.clusterStateVersion = clusterStateVersion;
-        }
-
-        public String index() {
-            return index;
-        }
-
-        public String type() {
-            return type;
-        }
-
-        public String nodeId() {
-            return nodeId;
-        }
-
-        public long clusterStateVersion() {
-            return clusterStateVersion;
-        }
-
-        @Override
-        public void writeTo(StreamOutput out) throws IOException {
-            super.writeTo(out);
-            out.writeString(index);
-            out.writeString(type);
-            out.writeString(nodeId);
-            out.writeVLong(clusterStateVersion);
-        }
-
-        @Override
-        public void readFrom(StreamInput in) throws IOException {
-            super.readFrom(in);
-            index = in.readString();
-            type = in.readString();
-            nodeId = in.readString();
-            clusterStateVersion = in.readVLong();
-        }
-    }
-}
diff --git a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java
index 412fd86..2e64b0c 100644
--- a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java
+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java
@@ -27,9 +27,10 @@ import org.elasticsearch.action.support.master.MasterNodeOperationRequest;
 import org.elasticsearch.cluster.*;
 import org.elasticsearch.cluster.ack.ClusterStateUpdateListener;
 import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;
-import org.elasticsearch.cluster.action.index.NodeMappingCreatedAction;
 import org.elasticsearch.cluster.node.DiscoveryNode;
 import org.elasticsearch.cluster.routing.IndexRoutingTable;
+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;
+import org.elasticsearch.cluster.routing.ShardRouting;
 import org.elasticsearch.common.Nullable;
 import org.elasticsearch.common.Priority;
 import org.elasticsearch.common.component.AbstractComponent;
@@ -38,7 +39,6 @@ import org.elasticsearch.common.inject.Inject;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.common.unit.TimeValue;
 import org.elasticsearch.common.util.concurrent.ConcurrentCollections;
-import org.elasticsearch.common.util.concurrent.CountDown;
 import org.elasticsearch.index.Index;
 import org.elasticsearch.index.mapper.DocumentMapper;
 import org.elasticsearch.index.mapper.MapperService;
@@ -52,6 +52,7 @@ import org.elasticsearch.percolator.PercolatorService;
 
 import java.util.*;
 import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import static com.google.common.collect.Maps.newHashMap;
 import static org.elasticsearch.index.mapper.DocumentMapper.MergeFlags.mergeFlags;
@@ -65,16 +66,13 @@ public class MetaDataMappingService extends AbstractComponent {
 
     private final IndicesService indicesService;
 
-    private final NodeMappingCreatedAction mappingCreatedAction;
-
     private final BlockingQueue<MappingTask> refreshOrUpdateQueue = ConcurrentCollections.newBlockingQueue();
 
     @Inject
-    public MetaDataMappingService(Settings settings, ClusterService clusterService, IndicesService indicesService, NodeMappingCreatedAction mappingCreatedAction) {
+    public MetaDataMappingService(Settings settings, ClusterService clusterService, IndicesService indicesService) {
         super(settings);
         this.clusterService = clusterService;
         this.indicesService = indicesService;
-        this.mappingCreatedAction = mappingCreatedAction;
     }
 
     static class MappingTask {
@@ -364,9 +362,34 @@ public class MetaDataMappingService extends AbstractComponent {
 
     public void putMapping(final PutRequest request, final Listener listener) {
 
-        clusterService.submitStateUpdateTask("put-mapping [" + request.mappingType + "]", Priority.HIGH, new TimeoutClusterStateUpdateTask() {
+        clusterService.submitStateUpdateTask("put-mapping [" + request.mappingType + "]", Priority.HIGH, new AckedClusterStateUpdateTask() {
+
+            private volatile Set<String> nodesToAck = Collections.emptySet();
+            private final AtomicBoolean responseSent = new AtomicBoolean(false);
+
+            @Override
+            public boolean mustAck(DiscoveryNode discoveryNode) {
+                return nodesToAck.contains(discoveryNode.id());
+            }
+
+            @Override
+            public void onAllNodesAcked(@Nullable Throwable t) {
+                if (responseSent.compareAndSet(false, true)) {
+                    listener.onResponse(new Response(true));
+                }
+            }
+
+            @Override
+            public void onAckTimeout() {
+                if (responseSent.compareAndSet(false, true)) {
+                    listener.onResponse(new Response(false));
+                }
+            }
 
-            CountDownListener countDownListener; // used to count ack responses before confirming operation is complete
+            @Override
+            public TimeValue ackTimeout() {
+                return request.timeout;
+            }
 
             @Override
             public TimeValue timeout() {
@@ -375,6 +398,7 @@ public class MetaDataMappingService extends AbstractComponent {
 
             @Override
             public void onFailure(String source, Throwable t) {
+                responseSent.set(true);
                 listener.onFailure(t);
             }
 
@@ -488,8 +512,7 @@ public class MetaDataMappingService extends AbstractComponent {
                     }
 
                     if (mappings.isEmpty()) {
-                        // no changes, return
-                        listener.onResponse(new Response(true));
+                        nodesToAck = Collections.emptySet();
                         return currentState;
                     }
 
@@ -507,22 +530,27 @@ public class MetaDataMappingService extends AbstractComponent {
 
                     ClusterState updatedState = ClusterState.builder(currentState).metaData(builder).build();
 
-                    int counter = 1; // we want to wait on the master node to apply it on its cluster state
-                    // also wait for nodes that actually have the index created on them to apply the mappings internally
+                    Set<String> nodesToAckSet = Sets.newHashSet();
+                    String masterNodeId = updatedState.nodes().masterNodeId();
                     for (String index : request.indices) {
                         IndexRoutingTable indexRoutingTable = updatedState.routingTable().index(index);
-                        if (indexRoutingTable != null) {
-                            counter += indexRoutingTable.numberOfNodesShardsAreAllocatedOn(updatedState.nodes().masterNodeId());
+                        if (indexRoutingTable == null) {
+                            continue;
+                        }
+                        for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {
+                            for (ShardRouting shardRouting : indexShardRoutingTable) {
+                                if (!shardRouting.assignedToNode()) {
+                                    continue;
+                                }
+                                String nodeId = shardRouting.currentNodeId();
+                                if (nodeId.equals(masterNodeId)) {
+                                    continue;
+                                }
+                                nodesToAckSet.add(nodeId);
+                            }
                         }
                     }
-
-                    logger.debug("Expecting {} mapping created responses for other nodes", counter - 1);
-
-                    // TODO: adding one to the version is based on knowledge on how the parent class will increment the version
-                    //       move this to the base class or add another callback before publishing the new cluster state so we
-                    //       capture its version.
-                    countDownListener = new CountDownListener(counter, currentState.version() + 1, listener);
-                    mappingCreatedAction.add(countDownListener, request.timeout);
+                    nodesToAck = nodesToAckSet;
 
                     return updatedState;
                 } finally {
@@ -531,14 +559,6 @@ public class MetaDataMappingService extends AbstractComponent {
                     }
                 }
             }
-
-            @Override
-            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {
-                if (countDownListener != null) {
-                    // the master has applied it on its cluster state
-                    countDownListener.decrementCounter();
-                }
-            }
         });
     }
 
@@ -594,47 +614,4 @@ public class MetaDataMappingService extends AbstractComponent {
         public boolean acknowledged() {
             return acknowledged;
         }
-    }
-
-    private class CountDownListener implements NodeMappingCreatedAction.Listener {
-
-        private final CountDown countDown;
-        private final Listener listener;
-        private final long minClusterStateVersion;
-
-        /**
-         * @param countDown              initial counter value
-         * @param minClusterStateVersion the minimum cluster state version for which accept responses
-         * @param listener               listener to call when counter reaches 0.
-         */
-        public CountDownListener(int countDown, long minClusterStateVersion, Listener listener) {
-            this.countDown = new CountDown(countDown);
-            this.listener = listener;
-            this.minClusterStateVersion = minClusterStateVersion;
-        }
-
-        @Override
-        public void onNodeMappingCreated(NodeMappingCreatedAction.NodeMappingCreatedResponse response) {
-            if (response.clusterStateVersion() < minClusterStateVersion) {
-                return;
-            }
-            decrementCounter();
-
-        }
-
-        public void decrementCounter() {
-            if (countDown.countDown()) {
-                mappingCreatedAction.remove(this);
-                listener.onResponse(new Response(true));
-            }
-        }
-
-        @Override
-        public void onTimeout() {
-            if (countDown.fastForward()) {
-                mappingCreatedAction.remove(this);
-                listener.onResponse(new Response(false));
-            }
-        }
-    }
 }
diff --git a/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java
index c92cb91..dc28fb1 100644
--- a/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java
+++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java
@@ -30,7 +30,6 @@ import org.elasticsearch.cluster.ClusterService;
 import org.elasticsearch.cluster.ClusterStateListener;
 import org.elasticsearch.cluster.action.index.NodeIndexCreatedAction;
 import org.elasticsearch.cluster.action.index.NodeIndexDeletedAction;
-import org.elasticsearch.cluster.action.index.NodeMappingCreatedAction;
 import org.elasticsearch.cluster.action.index.NodeMappingRefreshAction;
 import org.elasticsearch.cluster.action.shard.ShardStateAction;
 import org.elasticsearch.cluster.metadata.AliasMetaData;
@@ -89,7 +88,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic
     private final ShardStateAction shardStateAction;
     private final NodeIndexCreatedAction nodeIndexCreatedAction;
     private final NodeIndexDeletedAction nodeIndexDeletedAction;
-    private final NodeMappingCreatedAction nodeMappingCreatedAction;
     private final NodeMappingRefreshAction nodeMappingRefreshAction;
 
     // a map of mappings type we have seen per index due to cluster state
@@ -119,7 +117,7 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic
                                       ThreadPool threadPool, RecoveryTarget recoveryTarget,
                                       ShardStateAction shardStateAction,
                                       NodeIndexCreatedAction nodeIndexCreatedAction, NodeIndexDeletedAction nodeIndexDeletedAction,
-                                      NodeMappingCreatedAction nodeMappingCreatedAction, NodeMappingRefreshAction nodeMappingRefreshAction) {
+                                      NodeMappingRefreshAction nodeMappingRefreshAction) {
         super(settings);
         this.indicesService = indicesService;
         this.clusterService = clusterService;
@@ -128,7 +126,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic
         this.shardStateAction = shardStateAction;
         this.nodeIndexCreatedAction = nodeIndexCreatedAction;
         this.nodeIndexDeletedAction = nodeIndexDeletedAction;
-        this.nodeMappingCreatedAction = nodeMappingCreatedAction;
         this.nodeMappingRefreshAction = nodeMappingRefreshAction;
     }
 
@@ -410,8 +407,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic
                     logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}", index, mappingType, mappingSource, mapperService.documentMapper(mappingType).mappingSource());
                     requiresRefresh = true;
                 }
-                nodeMappingCreatedAction.nodeMappingCreated(event.state(),
-                        new NodeMappingCreatedAction.NodeMappingCreatedResponse(index, mappingType, event.state().nodes().localNodeId(), event.state().version()));
             } else {
                 DocumentMapper existingMapper = mapperService.documentMapper(mappingType);
                 if (!mappingSource.equals(existingMapper.mappingSource())) {
@@ -426,8 +421,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic
                         // this might happen when upgrading from 0.15 to 0.16
                         logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}", index, mappingType, mappingSource, mapperService.documentMapper(mappingType).mappingSource());
                     }
-                    nodeMappingCreatedAction.nodeMappingCreated(event.state(),
-                            new NodeMappingCreatedAction.NodeMappingCreatedResponse(index, mappingType, event.state().nodes().localNodeId(), event.state().version()));
                 }
             }
         } catch (Throwable e) {