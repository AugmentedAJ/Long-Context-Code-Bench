{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4229,
  "base_commit": "0ec3eaf53d470a309d3976c7f6798f578bd668d5",
  "runner": "codex",
  "model": "gpt-5.1-codex",
  "timeout_s": 10800,
  "status": "success",
  "elapsed_ms": 365266,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/cluster/ClusterModule.java b/src/main/java/org/elasticsearch/cluster/ClusterModule.java\nindex 491dead..f2b28f7 100644\n--- a/src/main/java/org/elasticsearch/cluster/ClusterModule.java\n+++ b/src/main/java/org/elasticsearch/cluster/ClusterModule.java\n@@ -73,10 +73,9 @@ public class ClusterModule extends AbstractModule implements SpawnModules {\n         bind(ShardStateAction.class).asEagerSingleton();\n         bind(NodeIndexCreatedAction.class).asEagerSingleton();\n         bind(NodeIndexDeletedAction.class).asEagerSingleton();\n-        bind(NodeMappingCreatedAction.class).asEagerSingleton();\n         bind(NodeMappingRefreshAction.class).asEagerSingleton();\n         bind(MappingUpdatedAction.class).asEagerSingleton();\n \n         bind(ClusterInfoService.class).to(InternalClusterInfoService.class).asEagerSingleton();\n     }\n-}\n\\ No newline at end of file\n+}\ndiff --git a/src/main/java/org/elasticsearch/cluster/action/index/NodeMappingCreatedAction.java b/src/main/java/org/elasticsearch/cluster/action/index/NodeMappingCreatedAction.java\ndeleted file mode 100644\nindex d39c6e8..0000000\n--- a/src/main/java/org/elasticsearch/cluster/action/index/NodeMappingCreatedAction.java\n+++ /dev/null\n@@ -1,171 +0,0 @@\n-/*\n- * Licensed to ElasticSearch and Shay Banon under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. ElasticSearch licenses this\n- * file to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.cluster.action.index;\n-\n-import org.elasticsearch.ElasticSearchException;\n-import org.elasticsearch.cluster.ClusterState;\n-import org.elasticsearch.common.component.AbstractComponent;\n-import org.elasticsearch.common.inject.Inject;\n-import org.elasticsearch.common.io.stream.StreamInput;\n-import org.elasticsearch.common.io.stream.StreamOutput;\n-import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.common.unit.TimeValue;\n-import org.elasticsearch.threadpool.ThreadPool;\n-import org.elasticsearch.transport.*;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-\n-/**\n- *\n- */\n-public class NodeMappingCreatedAction extends AbstractComponent {\n-\n-    private final ThreadPool threadPool;\n-    private final TransportService transportService;\n-    private final List<Listener> listeners = new CopyOnWriteArrayList<Listener>();\n-\n-    @Inject\n-    public NodeMappingCreatedAction(Settings settings, ThreadPool threadPool, TransportService transportService) {\n-        super(settings);\n-        this.threadPool = threadPool;\n-        this.transportService = transportService;\n-        transportService.registerHandler(NodeMappingCreatedTransportHandler.ACTION, new NodeMappingCreatedTransportHandler());\n-    }\n-\n-    public void add(final Listener listener, TimeValue timeout) {\n-        listeners.add(listener);\n-        threadPool.schedule(timeout, ThreadPool.Names.GENERIC, new Runnable() {\n-            @Override\n-            public void run() {\n-                boolean removed = listeners.remove(listener);\n-                if (removed) {\n-                    listener.onTimeout();\n-                }\n-            }\n-        });\n-    }\n-\n-    public void remove(Listener listener) {\n-        listeners.remove(listener);\n-    }\n-\n-    public void nodeMappingCreated(final ClusterState state, final NodeMappingCreatedResponse response) throws ElasticSearchException {\n-        logger.debug(\"Sending mapping created for index {}, type {} (cluster state version: {})\", response.index, response.type, response.clusterStateVersion);\n-        if (state.nodes().localNodeMaster()) {\n-            threadPool.generic().execute(new Runnable() {\n-                @Override\n-                public void run() {\n-                    innerNodeIndexCreated(response);\n-                }\n-            });\n-        } else {\n-            transportService.sendRequest(state.nodes().masterNode(),\n-                    NodeMappingCreatedTransportHandler.ACTION, response, EmptyTransportResponseHandler.INSTANCE_SAME);\n-        }\n-    }\n-\n-    private void innerNodeIndexCreated(NodeMappingCreatedResponse response) {\n-        for (Listener listener : listeners) {\n-            listener.onNodeMappingCreated(response);\n-        }\n-    }\n-\n-\n-    public static interface Listener {\n-        void onNodeMappingCreated(NodeMappingCreatedResponse response);\n-\n-        void onTimeout();\n-    }\n-\n-    private class NodeMappingCreatedTransportHandler extends BaseTransportRequestHandler<NodeMappingCreatedResponse> {\n-\n-        static final String ACTION = \"cluster/nodeMappingCreated\";\n-\n-        @Override\n-        public NodeMappingCreatedResponse newInstance() {\n-            return new NodeMappingCreatedResponse();\n-        }\n-\n-        @Override\n-        public void messageReceived(NodeMappingCreatedResponse response, TransportChannel channel) throws Exception {\n-            innerNodeIndexCreated(response);\n-            channel.sendResponse(TransportResponse.Empty.INSTANCE);\n-        }\n-\n-        @Override\n-        public String executor() {\n-            return ThreadPool.Names.SAME;\n-        }\n-    }\n-\n-    public static class NodeMappingCreatedResponse extends TransportRequest {\n-\n-        private String index;\n-        private String type;\n-        private String nodeId;\n-        private long clusterStateVersion;\n-\n-        private NodeMappingCreatedResponse() {\n-        }\n-\n-        public NodeMappingCreatedResponse(String index, String type, String nodeId, long clusterStateVersion) {\n-            this.index = index;\n-            this.type = type;\n-            this.nodeId = nodeId;\n-            this.clusterStateVersion = clusterStateVersion;\n-        }\n-\n-        public String index() {\n-            return index;\n-        }\n-\n-        public String type() {\n-            return type;\n-        }\n-\n-        public String nodeId() {\n-            return nodeId;\n-        }\n-\n-        public long clusterStateVersion() {\n-            return clusterStateVersion;\n-        }\n-\n-        @Override\n-        public void writeTo(StreamOutput out) throws IOException {\n-            super.writeTo(out);\n-            out.writeString(index);\n-            out.writeString(type);\n-            out.writeString(nodeId);\n-            out.writeVLong(clusterStateVersion);\n-        }\n-\n-        @Override\n-        public void readFrom(StreamInput in) throws IOException {\n-            super.readFrom(in);\n-            index = in.readString();\n-            type = in.readString();\n-            nodeId = in.readString();\n-            clusterStateVersion = in.readVLong();\n-        }\n-    }\n-}\ndiff --git a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java\nindex 412fd86..2e64b0c 100644\n--- a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java\n+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java\n@@ -27,9 +27,10 @@ import org.elasticsearch.action.support.master.MasterNodeOperationRequest;\n import org.elasticsearch.cluster.*;\n import org.elasticsearch.cluster.ack.ClusterStateUpdateListener;\n import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;\n-import org.elasticsearch.cluster.action.index.NodeMappingCreatedAction;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.common.Nullable;\n import org.elasticsearch.common.Priority;\n import org.elasticsearch.common.component.AbstractComponent;\n@@ -38,7 +39,6 @@ import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n-import org.elasticsearch.common.util.concurrent.CountDown;\n import org.elasticsearch.index.Index;\n import org.elasticsearch.index.mapper.DocumentMapper;\n import org.elasticsearch.index.mapper.MapperService;\n@@ -52,6 +52,7 @@ import org.elasticsearch.percolator.PercolatorService;\n \n import java.util.*;\n import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n import static com.google.common.collect.Maps.newHashMap;\n import static org.elasticsearch.index.mapper.DocumentMapper.MergeFlags.mergeFlags;\n@@ -65,16 +66,13 @@ public class MetaDataMappingService extends AbstractComponent {\n \n     private final IndicesService indicesService;\n \n-    private final NodeMappingCreatedAction mappingCreatedAction;\n-\n     private final BlockingQueue<MappingTask> refreshOrUpdateQueue = ConcurrentCollections.newBlockingQueue();\n \n     @Inject\n-    public MetaDataMappingService(Settings settings, ClusterService clusterService, IndicesService indicesService, NodeMappingCreatedAction mappingCreatedAction) {\n+    public MetaDataMappingService(Settings settings, ClusterService clusterService, IndicesService indicesService) {\n         super(settings);\n         this.clusterService = clusterService;\n         this.indicesService = indicesService;\n-        this.mappingCreatedAction = mappingCreatedAction;\n     }\n \n     static class MappingTask {\n@@ -364,9 +362,34 @@ public class MetaDataMappingService extends AbstractComponent {\n \n     public void putMapping(final PutRequest request, final Listener listener) {\n \n-        clusterService.submitStateUpdateTask(\"put-mapping [\" + request.mappingType + \"]\", Priority.HIGH, new TimeoutClusterStateUpdateTask() {\n+        clusterService.submitStateUpdateTask(\"put-mapping [\" + request.mappingType + \"]\", Priority.HIGH, new AckedClusterStateUpdateTask() {\n+\n+            private volatile Set<String> nodesToAck = Collections.emptySet();\n+            private final AtomicBoolean responseSent = new AtomicBoolean(false);\n+\n+            @Override\n+            public boolean mustAck(DiscoveryNode discoveryNode) {\n+                return nodesToAck.contains(discoveryNode.id());\n+            }\n+\n+            @Override\n+            public void onAllNodesAcked(@Nullable Throwable t) {\n+                if (responseSent.compareAndSet(false, true)) {\n+                    listener.onResponse(new Response(true));\n+                }\n+            }\n+\n+            @Override\n+            public void onAckTimeout() {\n+                if (responseSent.compareAndSet(false, true)) {\n+                    listener.onResponse(new Response(false));\n+                }\n+            }\n \n-            CountDownListener countDownListener; // used to count ack responses before confirming operation is complete\n+            @Override\n+            public TimeValue ackTimeout() {\n+                return request.timeout;\n+            }\n \n             @Override\n             public TimeValue timeout() {\n@@ -375,6 +398,7 @@ public class MetaDataMappingService extends AbstractComponent {\n \n             @Override\n             public void onFailure(String source, Throwable t) {\n+                responseSent.set(true);\n                 listener.onFailure(t);\n             }\n \n@@ -488,8 +512,7 @@ public class MetaDataMappingService extends AbstractComponent {\n                     }\n \n                     if (mappings.isEmpty()) {\n-                        // no changes, return\n-                        listener.onResponse(new Response(true));\n+                        nodesToAck = Collections.emptySet();\n                         return currentState;\n                     }\n \n@@ -507,22 +530,27 @@ public class MetaDataMappingService extends AbstractComponent {\n \n                     ClusterState updatedState = ClusterState.builder(currentState).metaData(builder).build();\n \n-                    int counter = 1; // we want to wait on the master node to apply it on its cluster state\n-                    // also wait for nodes that actually have the index created on them to apply the mappings internally\n+                    Set<String> nodesToAckSet = Sets.newHashSet();\n+                    String masterNodeId = updatedState.nodes().masterNodeId();\n                     for (String index : request.indices) {\n                         IndexRoutingTable indexRoutingTable = updatedState.routingTable().index(index);\n-                        if (indexRoutingTable != null) {\n-                            counter += indexRoutingTable.numberOfNodesShardsAreAllocatedOn(updatedState.nodes().masterNodeId());\n+                        if (indexRoutingTable == null) {\n+                            continue;\n+                        }\n+                        for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {\n+                            for (ShardRouting shardRouting : indexShardRoutingTable) {\n+                                if (!shardRouting.assignedToNode()) {\n+                                    continue;\n+                                }\n+                                String nodeId = shardRouting.currentNodeId();\n+                                if (nodeId.equals(masterNodeId)) {\n+                                    continue;\n+                                }\n+                                nodesToAckSet.add(nodeId);\n+                            }\n                         }\n                     }\n-\n-                    logger.debug(\"Expecting {} mapping created responses for other nodes\", counter - 1);\n-\n-                    // TODO: adding one to the version is based on knowledge on how the parent class will increment the version\n-                    //       move this to the base class or add another callback before publishing the new cluster state so we\n-                    //       capture its version.\n-                    countDownListener = new CountDownListener(counter, currentState.version() + 1, listener);\n-                    mappingCreatedAction.add(countDownListener, request.timeout);\n+                    nodesToAck = nodesToAckSet;\n \n                     return updatedState;\n                 } finally {\n@@ -531,14 +559,6 @@ public class MetaDataMappingService extends AbstractComponent {\n                     }\n                 }\n             }\n-\n-            @Override\n-            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n-                if (countDownListener != null) {\n-                    // the master has applied it on its cluster state\n-                    countDownListener.decrementCounter();\n-                }\n-            }\n         });\n     }\n \n@@ -594,47 +614,4 @@ public class MetaDataMappingService extends AbstractComponent {\n         public boolean acknowledged() {\n             return acknowledged;\n         }\n-    }\n-\n-    private class CountDownListener implements NodeMappingCreatedAction.Listener {\n-\n-        private final CountDown countDown;\n-        private final Listener listener;\n-        private final long minClusterStateVersion;\n-\n-        /**\n-         * @param countDown              initial counter value\n-         * @param minClusterStateVersion the minimum cluster state version for which accept responses\n-         * @param listener               listener to call when counter reaches 0.\n-         */\n-        public CountDownListener(int countDown, long minClusterStateVersion, Listener listener) {\n-            this.countDown = new CountDown(countDown);\n-            this.listener = listener;\n-            this.minClusterStateVersion = minClusterStateVersion;\n-        }\n-\n-        @Override\n-        public void onNodeMappingCreated(NodeMappingCreatedAction.NodeMappingCreatedResponse response) {\n-            if (response.clusterStateVersion() < minClusterStateVersion) {\n-                return;\n-            }\n-            decrementCounter();\n-\n-        }\n-\n-        public void decrementCounter() {\n-            if (countDown.countDown()) {\n-                mappingCreatedAction.remove(this);\n-                listener.onResponse(new Response(true));\n-            }\n-        }\n-\n-        @Override\n-        public void onTimeout() {\n-            if (countDown.fastForward()) {\n-                mappingCreatedAction.remove(this);\n-                listener.onResponse(new Response(false));\n-            }\n-        }\n-    }\n }\ndiff --git a/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\nindex c92cb91..dc28fb1 100644\n--- a/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\n+++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\n@@ -30,7 +30,6 @@ import org.elasticsearch.cluster.ClusterService;\n import org.elasticsearch.cluster.ClusterStateListener;\n import org.elasticsearch.cluster.action.index.NodeIndexCreatedAction;\n import org.elasticsearch.cluster.action.index.NodeIndexDeletedAction;\n-import org.elasticsearch.cluster.action.index.NodeMappingCreatedAction;\n import org.elasticsearch.cluster.action.index.NodeMappingRefreshAction;\n import org.elasticsearch.cluster.action.shard.ShardStateAction;\n import org.elasticsearch.cluster.metadata.AliasMetaData;\n@@ -89,7 +88,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n     private final ShardStateAction shardStateAction;\n     private final NodeIndexCreatedAction nodeIndexCreatedAction;\n     private final NodeIndexDeletedAction nodeIndexDeletedAction;\n-    private final NodeMappingCreatedAction nodeMappingCreatedAction;\n     private final NodeMappingRefreshAction nodeMappingRefreshAction;\n \n     // a map of mappings type we have seen per index due to cluster state\n@@ -119,7 +117,7 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n                                       ThreadPool threadPool, RecoveryTarget recoveryTarget,\n                                       ShardStateAction shardStateAction,\n                                       NodeIndexCreatedAction nodeIndexCreatedAction, NodeIndexDeletedAction nodeIndexDeletedAction,\n-                                      NodeMappingCreatedAction nodeMappingCreatedAction, NodeMappingRefreshAction nodeMappingRefreshAction) {\n+                                      NodeMappingRefreshAction nodeMappingRefreshAction) {\n         super(settings);\n         this.indicesService = indicesService;\n         this.clusterService = clusterService;\n@@ -128,7 +126,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n         this.shardStateAction = shardStateAction;\n         this.nodeIndexCreatedAction = nodeIndexCreatedAction;\n         this.nodeIndexDeletedAction = nodeIndexDeletedAction;\n-        this.nodeMappingCreatedAction = nodeMappingCreatedAction;\n         this.nodeMappingRefreshAction = nodeMappingRefreshAction;\n     }\n \n@@ -410,8 +407,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n                     logger.debug(\"[{}] parsed mapping [{}], and got different sources\\noriginal:\\n{}\\nparsed:\\n{}\", index, mappingType, mappingSource, mapperService.documentMapper(mappingType).mappingSource());\n                     requiresRefresh = true;\n                 }\n-                nodeMappingCreatedAction.nodeMappingCreated(event.state(),\n-                        new NodeMappingCreatedAction.NodeMappingCreatedResponse(index, mappingType, event.state().nodes().localNodeId(), event.state().version()));\n             } else {\n                 DocumentMapper existingMapper = mapperService.documentMapper(mappingType);\n                 if (!mappingSource.equals(existingMapper.mappingSource())) {\n@@ -426,8 +421,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n                         // this might happen when upgrading from 0.15 to 0.16\n                         logger.debug(\"[{}] parsed mapping [{}], and got different sources\\noriginal:\\n{}\\nparsed:\\n{}\", index, mappingType, mappingSource, mapperService.documentMapper(mappingType).mappingSource());\n                     }\n-                    nodeMappingCreatedAction.nodeMappingCreated(event.state(),\n-                            new NodeMappingCreatedAction.NodeMappingCreatedResponse(index, mappingType, event.state().nodes().localNodeId(), event.state().version()));\n                 }\n             }\n         } catch (Throwable e) {",
  "logs_path": "codex/gpt-5.1-codex/bdf2fcfe/elastic_elasticsearch_pr4229/logs.jsonl",
  "errors": [],
  "edit_run_id": "fd5b3480",
  "test_label": "v1-agent-comparison"
}