{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4478,
  "base_commit": "2b6214cff72423fc5c948c7b4c39027c93494400",
  "runner": "auggie",
  "model": "sonnet4.5",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 259857,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java\nindex 2e67160..02c6598 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java\n@@ -632,65 +632,89 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n                 boolean iterationChanged = false;\n                 for (MutableShardRouting shard : currentRound) {\n                     assert !shard.assignedToNode();\n+\n+                    /*\n+                     * Early termination: For replica shards, check if the primary is active.\n+                     * If not, we can skip allocation attempts for this replica in the current round\n+                     * since ReplicaAfterPrimaryActiveAllocationDecider will reject it anyway.\n+                     */\n+                    if (!shard.primary()) {\n+                        MutableShardRouting primary = routingNodes.activePrimary(shard);\n+                        if (primary == null) {\n+                            if (logger.isTraceEnabled()) {\n+                                logger.trace(\"Skipping replica [{}] allocation - no active primary\", shard);\n+                            }\n+                            ignoredUnassigned.add(shard);\n+                            continue;\n+                        }\n+                    }\n+\n                     /* find an node with minimal weight we can allocate on*/\n                     float minWeight = Float.POSITIVE_INFINITY;\n                     ModelNode minNode = null;\n                     Decision decision = null;\n                     for (ModelNode node : nodes.values()) {\n+                        /*\n+                         * Early termination: Skip nodes that already contain this shard.\n+                         * The SameShardAllocationDecider will reject this anyway, so we can\n+                         * avoid the expensive weight calculation and allocation decision checks.\n+                         */\n+                        if (node.containsShard(shard)) {\n+                            continue;\n+                        }\n+\n                         /*\n                          * The shard we add is removed below to simulate the\n \t                     * addition for weight calculation we use Decision.ALWAYS to\n \t                     * not violate the not null condition.\n \t                     */\n-                        if (!node.containsShard(shard)) {\n-                            node.addShard(shard, Decision.ALWAYS);\n-                            float currentWeight = weight.weight(Operation.ALLOCATE, this, node, shard.index());\n-                            /*\n-                             * Remove the shard from the node again this is only a\n+                        node.addShard(shard, Decision.ALWAYS);\n+                        float currentWeight = weight.weight(Operation.ALLOCATE, this, node, shard.index());\n+                        /*\n+                         * Remove the shard from the node again this is only a\n \t                         * simulation\n \t                         */\n-                            Decision removed = node.removeShard(shard);\n-                            assert removed != null;\n-\t                        /*\n-\t                         * Unless the operation is not providing any gains we\n-\t                         * don't check deciders\n-\t                         */\n-                            if (currentWeight <= minWeight) {\n-                                Decision currentDecision = deciders.canAllocate(shard, routingNodes.node(node.getNodeId()), allocation);\n-                                NOUPDATE:\n-                                if (currentDecision.type() == Type.YES || currentDecision.type() == Type.THROTTLE) {\n-                                    if (currentWeight == minWeight) {\n-\t                                    /*  we have an equal weight tie breaking:\n-\t                                     *  1. if one decision is YES prefer it\n-\t                                     *  2. prefer the node that holds the primary for this index with the next id in the ring ie.\n-\t                                     *  for the 3 shards 2 replica case we try to build up:\n-\t                                     *    1 2 0\n-\t                                     *    2 0 1\n-\t                                     *    0 1 2\n-\t                                     *  such that if we need to tie-break we try to prefer the node holding a shard with the minimal id greater\n-\t                                     *  than the id of the shard we need to assign. This works find when new indices are created since \n-\t                                     *  primaries are added first and we only add one shard set a time in this algorithm.\n-\t                                     */\n-                                        if (currentDecision.type() == decision.type()) {\n-                                            final int repId = shard.id();\n-                                            final int nodeHigh = node.highestPrimary(shard.index());\n-                                            final int minNodeHigh = minNode.highestPrimary(shard.index());\n-                                            if ((((nodeHigh > repId && minNodeHigh > repId) || (nodeHigh < repId && minNodeHigh < repId)) && (nodeHigh < minNodeHigh))\n-                                                    || (nodeHigh > minNodeHigh && nodeHigh > repId && minNodeHigh < repId)) {\n-                                                minNode = node;\n-                                                minWeight = currentWeight;\n-                                                decision = currentDecision;\n-                                            } else {\n-                                                break NOUPDATE;\n-                                            }\n-                                        } else if (currentDecision.type() != Type.YES) {\n+                        Decision removed = node.removeShard(shard);\n+                        assert removed != null;\n+\t                    /*\n+\t                     * Unless the operation is not providing any gains we\n+\t                     * don't check deciders\n+\t                     */\n+                        if (currentWeight <= minWeight) {\n+                            Decision currentDecision = deciders.canAllocate(shard, routingNodes.node(node.getNodeId()), allocation);\n+                            NOUPDATE:\n+                            if (currentDecision.type() == Type.YES || currentDecision.type() == Type.THROTTLE) {\n+                                if (currentWeight == minWeight) {\n+\t                                /*  we have an equal weight tie breaking:\n+\t                                 *  1. if one decision is YES prefer it\n+\t                                 *  2. prefer the node that holds the primary for this index with the next id in the ring ie.\n+\t                                 *  for the 3 shards 2 replica case we try to build up:\n+\t                                 *    1 2 0\n+\t                                 *    2 0 1\n+\t                                 *    0 1 2\n+\t                                 *  such that if we need to tie-break we try to prefer the node holding a shard with the minimal id greater\n+\t                                 *  than the id of the shard we need to assign. This works find when new indices are created since\n+\t                                 *  primaries are added first and we only add one shard set a time in this algorithm.\n+\t                                 */\n+                                    if (currentDecision.type() == decision.type()) {\n+                                        final int repId = shard.id();\n+                                        final int nodeHigh = node.highestPrimary(shard.index());\n+                                        final int minNodeHigh = minNode.highestPrimary(shard.index());\n+                                        if ((((nodeHigh > repId && minNodeHigh > repId) || (nodeHigh < repId && minNodeHigh < repId)) && (nodeHigh < minNodeHigh))\n+                                                || (nodeHigh > minNodeHigh && nodeHigh > repId && minNodeHigh < repId)) {\n+                                            minNode = node;\n+                                            minWeight = currentWeight;\n+                                            decision = currentDecision;\n+                                        } else {\n                                             break NOUPDATE;\n                                         }\n+                                    } else if (currentDecision.type() != Type.YES) {\n+                                        break NOUPDATE;\n                                     }\n-                                    minNode = node;\n-                                    minWeight = currentWeight;\n-                                    decision = currentDecision;\n                                 }\n+                                minNode = node;\n+                                minWeight = currentWeight;\n+                                decision = currentDecision;\n                             }\n                         }\n                     }\ndiff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/EvenShardsCountAllocator.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/EvenShardsCountAllocator.java\nindex 6e91ef5..d81289f 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/EvenShardsCountAllocator.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/EvenShardsCountAllocator.java\n@@ -92,6 +92,18 @@ public class EvenShardsCountAllocator extends AbstractComponent implements Shard\n \n         while (unassignedIterator.hasNext()) {\n             MutableShardRouting shard = unassignedIterator.next();\n+\n+            /*\n+             * Early termination: For replica shards, skip allocation if primary is not active.\n+             * ReplicaAfterPrimaryActiveAllocationDecider will reject it anyway.\n+             */\n+            if (!shard.primary()) {\n+                MutableShardRouting primary = routingNodes.activePrimary(shard);\n+                if (primary == null) {\n+                    continue;\n+                }\n+            }\n+\n             // do the allocation, finding the least \"busy\" node\n             for (int i = 0; i < nodes.length; i++) {\n                 RoutingNode node = nodes[lastNode];\n@@ -118,6 +130,18 @@ public class EvenShardsCountAllocator extends AbstractComponent implements Shard\n         // allocate all the unassigned shards above the average per node.\n         for (Iterator<MutableShardRouting> it = routingNodes.unassigned().iterator(); it.hasNext(); ) {\n             MutableShardRouting shard = it.next();\n+\n+            /*\n+             * Early termination: For replica shards, skip allocation if primary is not active.\n+             * ReplicaAfterPrimaryActiveAllocationDecider will reject it anyway.\n+             */\n+            if (!shard.primary()) {\n+                MutableShardRouting primary = routingNodes.activePrimary(shard);\n+                if (primary == null) {\n+                    continue;\n+                }\n+            }\n+\n             // go over the nodes and try and allocate the remaining ones\n             for (RoutingNode routingNode : sortedNodesLeastToHigh(allocation)) {\n                 Decision decision = allocation.deciders().canAllocate(shard, routingNode, allocation);",
  "logs_path": "auggie/sonnet4.5/7ad89f22/elastic_elasticsearch_pr4478/logs.jsonl",
  "errors": [],
  "edit_run_id": "7ad89f22",
  "test_label": "v1-rollouts-1-3-sonnet4.5"
}