{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4229,
  "base_commit": "0ec3eaf53d470a309d3976c7f6798f578bd668d5",
  "runner": "auggie",
  "model": "sonnet4.5",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 402695,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java\nindex 9eb3352..d977183 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java\n@@ -22,22 +22,20 @@ package org.elasticsearch.action.admin.indices.mapping.put;\n import com.carrotsearch.hppc.ObjectOpenHashSet;\n import org.elasticsearch.ElasticSearchGenerationException;\n import org.elasticsearch.ElasticSearchIllegalArgumentException;\n+import org.elasticsearch.Version;\n import org.elasticsearch.action.ActionRequestValidationException;\n-import org.elasticsearch.action.support.master.MasterNodeOperationRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n-import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.common.xcontent.XContentFactory;\n import org.elasticsearch.common.xcontent.XContentType;\n \n import java.io.IOException;\n import java.util.Map;\n-import java.util.concurrent.TimeUnit;\n \n import static org.elasticsearch.action.ValidateActions.addValidationError;\n-import static org.elasticsearch.common.unit.TimeValue.readTimeValue;\n \n /**\n  * Puts mapping definition registered under a specific type into one or more indices. Best created with\n@@ -51,7 +49,7 @@ import static org.elasticsearch.common.unit.TimeValue.readTimeValue;\n  * @see org.elasticsearch.client.IndicesAdminClient#putMapping(PutMappingRequest)\n  * @see PutMappingResponse\n  */\n-public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequest> {\n+public class PutMappingRequest extends AcknowledgedRequest<PutMappingRequest> {\n \n     private static ObjectOpenHashSet<String> RESERVED_FIELDS = ObjectOpenHashSet.from(\n             \"_uid\", \"_id\", \"_type\", \"_source\",  \"_all\", \"_analyzer\", \"_boost\", \"_parent\", \"_routing\", \"_index\",\n@@ -64,8 +62,6 @@ public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequ\n \n     private String source;\n \n-    private TimeValue timeout = new TimeValue(10, TimeUnit.SECONDS);\n-\n     private boolean ignoreConflicts = false;\n \n     PutMappingRequest() {\n@@ -224,30 +220,7 @@ public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequ\n         return this;\n     }\n \n-    /**\n-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to\n-     * <tt>10s</tt>.\n-     */\n-    TimeValue timeout() {\n-        return timeout;\n-    }\n-\n-    /**\n-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to\n-     * <tt>10s</tt>.\n-     */\n-    public PutMappingRequest timeout(TimeValue timeout) {\n-        this.timeout = timeout;\n-        return this;\n-    }\n \n-    /**\n-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to\n-     * <tt>10s</tt>.\n-     */\n-    public PutMappingRequest timeout(String timeout) {\n-        return timeout(TimeValue.parseTimeValue(timeout, null));\n-    }\n \n     /**\n      * If there is already a mapping definition registered against the type, then it will be merged. If there are\n@@ -274,7 +247,7 @@ public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequ\n         indices = in.readStringArray();\n         type = in.readOptionalString();\n         source = in.readString();\n-        timeout = readTimeValue(in);\n+        readTimeout(in, Version.V_0_90_6);\n         ignoreConflicts = in.readBoolean();\n     }\n \n@@ -284,7 +257,7 @@ public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequ\n         out.writeStringArrayNullable(indices);\n         out.writeOptionalString(type);\n         out.writeString(source);\n-        timeout.writeTo(out);\n+        writeTimeout(out, Version.V_0_90_6);\n         out.writeBoolean(ignoreConflicts);\n     }\n }\ndiff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequestBuilder.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequestBuilder.java\nindex e93ca84..592e87c 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequestBuilder.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequestBuilder.java\n@@ -20,10 +20,9 @@\n package org.elasticsearch.action.admin.indices.mapping.put;\n \n import org.elasticsearch.action.ActionListener;\n-import org.elasticsearch.action.support.master.MasterNodeOperationRequestBuilder;\n+import org.elasticsearch.action.support.master.AcknowledgedRequestBuilder;\n import org.elasticsearch.client.IndicesAdminClient;\n import org.elasticsearch.client.internal.InternalIndicesAdminClient;\n-import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n \n import java.util.Map;\n@@ -31,7 +30,7 @@ import java.util.Map;\n /**\n  *\n  */\n-public class PutMappingRequestBuilder extends MasterNodeOperationRequestBuilder<PutMappingRequest, PutMappingResponse, PutMappingRequestBuilder> {\n+public class PutMappingRequestBuilder extends AcknowledgedRequestBuilder<PutMappingRequest, PutMappingResponse, PutMappingRequestBuilder> {\n \n     public PutMappingRequestBuilder(IndicesAdminClient indicesClient) {\n         super((InternalIndicesAdminClient) indicesClient, new PutMappingRequest());\n@@ -83,24 +82,6 @@ public class PutMappingRequestBuilder extends MasterNodeOperationRequestBuilder<\n         return this;\n     }\n \n-    /**\n-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to\n-     * <tt>10s</tt>.\n-     */\n-    public PutMappingRequestBuilder setTimeout(TimeValue timeout) {\n-        request.timeout(timeout);\n-        return this;\n-    }\n-\n-    /**\n-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to\n-     * <tt>10s</tt>.\n-     */\n-    public PutMappingRequestBuilder setTimeout(String timeout) {\n-        request.timeout(timeout);\n-        return this;\n-    }\n-\n     /**\n      * If there is already a mapping definition registered against the type, then it will be merged. If there are\n      * elements that can't be merged are detected, the request will be rejected unless the\ndiff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java\nindex 58edc44..646377b 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java\n@@ -19,7 +19,8 @@\n \n package org.elasticsearch.action.admin.indices.mapping.put;\n \n-import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n \n@@ -28,35 +29,25 @@ import java.io.IOException;\n /**\n  * The response of put mapping operation.\n  */\n-public class PutMappingResponse extends ActionResponse {\n-\n-    private boolean acknowledged;\n+public class PutMappingResponse extends AcknowledgedResponse {\n \n     PutMappingResponse() {\n \n     }\n \n     PutMappingResponse(boolean acknowledged) {\n-        this.acknowledged = acknowledged;\n-    }\n-\n-    /**\n-     * Has the put mapping creation been acknowledged by all current cluster nodes within the\n-     * provided {@link PutMappingRequest#timeout(org.elasticsearch.common.unit.TimeValue)}.\n-     */\n-    public boolean isAcknowledged() {\n-        return acknowledged;\n+        super(acknowledged);\n     }\n \n     @Override\n     public void readFrom(StreamInput in) throws IOException {\n         super.readFrom(in);\n-        acknowledged = in.readBoolean();\n+        readAcknowledged(in, Version.V_0_90_6);\n     }\n \n     @Override\n     public void writeTo(StreamOutput out) throws IOException {\n         super.writeTo(out);\n-        out.writeBoolean(acknowledged);\n+        writeAcknowledged(out, Version.V_0_90_6);\n     }\n }\ndiff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java\nindex e12a4a5..662dc42 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java\n@@ -24,6 +24,8 @@ import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.support.master.TransportMasterNodeOperationAction;\n import org.elasticsearch.cluster.ClusterService;\n import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ack.ClusterStateUpdateListener;\n+import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;\n import org.elasticsearch.cluster.block.ClusterBlockException;\n import org.elasticsearch.cluster.block.ClusterBlockLevel;\n import org.elasticsearch.cluster.metadata.MetaDataMappingService;\n@@ -80,11 +82,18 @@ public class TransportPutMappingAction extends TransportMasterNodeOperationActio\n \n     @Override\n     protected void masterOperation(final PutMappingRequest request, final ClusterState state, final ActionListener<PutMappingResponse> listener) throws ElasticSearchException {\n+        PutMappingClusterStateUpdateRequest updateRequest = new PutMappingClusterStateUpdateRequest()\n+                .indices(request.indices())\n+                .type(request.type())\n+                .source(request.source())\n+                .ignoreConflicts(request.ignoreConflicts())\n+                .ackTimeout(request.timeout())\n+                .masterNodeTimeout(request.masterNodeTimeout());\n \n-        metaDataMappingService.putMapping(new MetaDataMappingService.PutRequest(request.indices(), request.type(), request.source()).ignoreConflicts(request.ignoreConflicts()).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataMappingService.Listener() {\n+        metaDataMappingService.putMapping(updateRequest, new ClusterStateUpdateListener() {\n             @Override\n-            public void onResponse(MetaDataMappingService.Response response) {\n-                listener.onResponse(new PutMappingResponse(response.acknowledged()));\n+            public void onResponse(ClusterStateUpdateResponse response) {\n+                listener.onResponse(new PutMappingResponse(response.isAcknowledged()));\n             }\n \n             @Override\ndiff --git a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java\nindex 412fd86..9cd6d77 100644\n--- a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java\n+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java\n@@ -23,13 +23,11 @@ import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import org.elasticsearch.action.admin.indices.mapping.delete.DeleteMappingClusterStateUpdateRequest;\n-import org.elasticsearch.action.support.master.MasterNodeOperationRequest;\n+import org.elasticsearch.action.admin.indices.mapping.put.PutMappingClusterStateUpdateRequest;\n import org.elasticsearch.cluster.*;\n import org.elasticsearch.cluster.ack.ClusterStateUpdateListener;\n import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;\n-import org.elasticsearch.cluster.action.index.NodeMappingCreatedAction;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n-import org.elasticsearch.cluster.routing.IndexRoutingTable;\n import org.elasticsearch.common.Nullable;\n import org.elasticsearch.common.Priority;\n import org.elasticsearch.common.component.AbstractComponent;\n@@ -37,8 +35,6 @@ import org.elasticsearch.common.compress.CompressedString;\n import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.unit.TimeValue;\n-import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n-import org.elasticsearch.common.util.concurrent.CountDown;\n import org.elasticsearch.index.Index;\n import org.elasticsearch.index.mapper.DocumentMapper;\n import org.elasticsearch.index.mapper.MapperService;\n@@ -65,16 +61,13 @@ public class MetaDataMappingService extends AbstractComponent {\n \n     private final IndicesService indicesService;\n \n-    private final NodeMappingCreatedAction mappingCreatedAction;\n-\n     private final BlockingQueue<MappingTask> refreshOrUpdateQueue = ConcurrentCollections.newBlockingQueue();\n \n     @Inject\n-    public MetaDataMappingService(Settings settings, ClusterService clusterService, IndicesService indicesService, NodeMappingCreatedAction mappingCreatedAction) {\n+    public MetaDataMappingService(Settings settings, ClusterService clusterService, IndicesService indicesService) {\n         super(settings);\n         this.clusterService = clusterService;\n         this.indicesService = indicesService;\n-        this.mappingCreatedAction = mappingCreatedAction;\n     }\n \n     static class MappingTask {\n@@ -362,15 +355,33 @@ public class MetaDataMappingService extends AbstractComponent {\n         });\n     }\n \n-    public void putMapping(final PutRequest request, final Listener listener) {\n+    public void putMapping(final PutMappingClusterStateUpdateRequest request, final ClusterStateUpdateListener listener) {\n+\n+        clusterService.submitStateUpdateTask(\"put-mapping [\" + request.type() + \"]\", Priority.HIGH, new AckedClusterStateUpdateTask() {\n+\n+            @Override\n+            public boolean mustAck(DiscoveryNode discoveryNode) {\n+                return true;\n+            }\n \n-        clusterService.submitStateUpdateTask(\"put-mapping [\" + request.mappingType + \"]\", Priority.HIGH, new TimeoutClusterStateUpdateTask() {\n+            @Override\n+            public void onAllNodesAcked(@Nullable Throwable t) {\n+                listener.onResponse(new ClusterStateUpdateResponse(true));\n+            }\n \n-            CountDownListener countDownListener; // used to count ack responses before confirming operation is complete\n+            @Override\n+            public void onAckTimeout() {\n+                listener.onResponse(new ClusterStateUpdateResponse(false));\n+            }\n+\n+            @Override\n+            public TimeValue ackTimeout() {\n+                return request.ackTimeout();\n+            }\n \n             @Override\n             public TimeValue timeout() {\n-                return request.masterTimeout;\n+                return request.masterNodeTimeout();\n             }\n \n             @Override\n@@ -382,17 +393,17 @@ public class MetaDataMappingService extends AbstractComponent {\n             public ClusterState execute(final ClusterState currentState) throws Exception {\n                 List<String> indicesToClose = Lists.newArrayList();\n                 try {\n-                    if (request.indices.length == 0) {\n+                    if (request.indices().length == 0) {\n                         throw new IndexMissingException(new Index(\"_all\"));\n                     }\n-                    for (String index : request.indices) {\n+                    for (String index : request.indices()) {\n                         if (!currentState.metaData().hasIndex(index)) {\n                             throw new IndexMissingException(new Index(index));\n                         }\n                     }\n \n                     // pre create indices here and add mappings to them so we can merge the mappings here if needed\n-                    for (String index : request.indices) {\n+                    for (String index : request.indices()) {\n                         if (indicesService.hasIndex(index)) {\n                             continue;\n                         }\n@@ -404,29 +415,29 @@ public class MetaDataMappingService extends AbstractComponent {\n                             indexService.mapperService().merge(MapperService.DEFAULT_MAPPING, indexMetaData.mappings().get(MapperService.DEFAULT_MAPPING).source(), false);\n                         }\n                         // only add the current relevant mapping (if exists)\n-                        if (indexMetaData.mappings().containsKey(request.mappingType)) {\n-                            indexService.mapperService().merge(request.mappingType, indexMetaData.mappings().get(request.mappingType).source(), false);\n+                        if (indexMetaData.mappings().containsKey(request.type())) {\n+                            indexService.mapperService().merge(request.type(), indexMetaData.mappings().get(request.type()).source(), false);\n                         }\n                     }\n \n                     Map<String, DocumentMapper> newMappers = newHashMap();\n                     Map<String, DocumentMapper> existingMappers = newHashMap();\n-                    for (String index : request.indices) {\n+                    for (String index : request.indices()) {\n                         IndexService indexService = indicesService.indexService(index);\n                         if (indexService != null) {\n                             // try and parse it (no need to add it here) so we can bail early in case of parsing exception\n                             DocumentMapper newMapper;\n-                            DocumentMapper existingMapper = indexService.mapperService().documentMapper(request.mappingType);\n-                            if (MapperService.DEFAULT_MAPPING.equals(request.mappingType)) {\n+                            DocumentMapper existingMapper = indexService.mapperService().documentMapper(request.type());\n+                            if (MapperService.DEFAULT_MAPPING.equals(request.type())) {\n                                 // _default_ types do not go through merging, but we do test the new settings. Also don't apply the old default\n-                                newMapper = indexService.mapperService().parse(request.mappingType, new CompressedString(request.mappingSource), false);\n+                                newMapper = indexService.mapperService().parse(request.type(), new CompressedString(request.source()), false);\n                             } else {\n-                                newMapper = indexService.mapperService().parse(request.mappingType, new CompressedString(request.mappingSource));\n+                                newMapper = indexService.mapperService().parse(request.type(), new CompressedString(request.source()));\n                                 if (existingMapper != null) {\n                                     // first, simulate\n                                     DocumentMapper.MergeResult mergeResult = existingMapper.merge(newMapper, mergeFlags().simulate(true));\n                                     // if we have conflicts, and we are not supposed to ignore them, throw an exception\n-                                    if (!request.ignoreConflicts && mergeResult.hasConflicts()) {\n+                                    if (!request.ignoreConflicts() && mergeResult.hasConflicts()) {\n                                         throw new MergeMappingException(mergeResult.conflicts());\n                                     }\n                                 }\n@@ -442,7 +453,7 @@ public class MetaDataMappingService extends AbstractComponent {\n                         }\n                     }\n \n-                    String mappingType = request.mappingType;\n+                    String mappingType = request.type();\n                     if (mappingType == null) {\n                         mappingType = newMappers.values().iterator().next().type();\n                     } else if (!mappingType.equals(newMappers.values().iterator().next().type())) {\n@@ -489,12 +500,12 @@ public class MetaDataMappingService extends AbstractComponent {\n \n                     if (mappings.isEmpty()) {\n                         // no changes, return\n-                        listener.onResponse(new Response(true));\n+                        listener.onResponse(new ClusterStateUpdateResponse(true));\n                         return currentState;\n                     }\n \n                     MetaData.Builder builder = MetaData.builder(currentState.metaData());\n-                    for (String indexName : request.indices) {\n+                    for (String indexName : request.indices()) {\n                         IndexMetaData indexMetaData = currentState.metaData().index(indexName);\n                         if (indexMetaData == null) {\n                             throw new IndexMissingException(new Index(indexName));\n@@ -505,26 +516,7 @@ public class MetaDataMappingService extends AbstractComponent {\n                         }\n                     }\n \n-                    ClusterState updatedState = ClusterState.builder(currentState).metaData(builder).build();\n-\n-                    int counter = 1; // we want to wait on the master node to apply it on its cluster state\n-                    // also wait for nodes that actually have the index created on them to apply the mappings internally\n-                    for (String index : request.indices) {\n-                        IndexRoutingTable indexRoutingTable = updatedState.routingTable().index(index);\n-                        if (indexRoutingTable != null) {\n-                            counter += indexRoutingTable.numberOfNodesShardsAreAllocatedOn(updatedState.nodes().masterNodeId());\n-                        }\n-                    }\n-\n-                    logger.debug(\"Expecting {} mapping created responses for other nodes\", counter - 1);\n-\n-                    // TODO: adding one to the version is based on knowledge on how the parent class will increment the version\n-                    //       move this to the base class or add another callback before publishing the new cluster state so we\n-                    //       capture its version.\n-                    countDownListener = new CountDownListener(counter, currentState.version() + 1, listener);\n-                    mappingCreatedAction.add(countDownListener, request.timeout);\n-\n-                    return updatedState;\n+                    return ClusterState.builder(currentState).metaData(builder).build();\n                 } finally {\n                     for (String index : indicesToClose) {\n                         indicesService.removeIndex(index, \"created for mapping processing\");\n@@ -534,10 +526,6 @@ public class MetaDataMappingService extends AbstractComponent {\n \n             @Override\n             public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n-                if (countDownListener != null) {\n-                    // the master has applied it on its cluster state\n-                    countDownListener.decrementCounter();\n-                }\n             }\n         });\n     }\n@@ -549,41 +537,6 @@ public class MetaDataMappingService extends AbstractComponent {\n         void onFailure(Throwable t);\n     }\n \n-    public static class PutRequest {\n-\n-        final String[] indices;\n-\n-        final String mappingType;\n-\n-        final String mappingSource;\n-\n-        boolean ignoreConflicts = false;\n-\n-        TimeValue timeout = TimeValue.timeValueSeconds(10);\n-        TimeValue masterTimeout = MasterNodeOperationRequest.DEFAULT_MASTER_NODE_TIMEOUT;\n-\n-        public PutRequest(String[] indices, String mappingType, String mappingSource) {\n-            this.indices = indices;\n-            this.mappingType = mappingType;\n-            this.mappingSource = mappingSource;\n-        }\n-\n-        public PutRequest ignoreConflicts(boolean ignoreConflicts) {\n-            this.ignoreConflicts = ignoreConflicts;\n-            return this;\n-        }\n-\n-        public PutRequest timeout(TimeValue timeout) {\n-            this.timeout = timeout;\n-            return this;\n-        }\n-\n-        public PutRequest masterTimeout(TimeValue masterTimeout) {\n-            this.masterTimeout = masterTimeout;\n-            return this;\n-        }\n-    }\n-\n     public static class Response {\n         private final boolean acknowledged;\n \n@@ -595,46 +548,4 @@ public class MetaDataMappingService extends AbstractComponent {\n             return acknowledged;\n         }\n     }\n-\n-    private class CountDownListener implements NodeMappingCreatedAction.Listener {\n-\n-        private final CountDown countDown;\n-        private final Listener listener;\n-        private final long minClusterStateVersion;\n-\n-        /**\n-         * @param countDown              initial counter value\n-         * @param minClusterStateVersion the minimum cluster state version for which accept responses\n-         * @param listener               listener to call when counter reaches 0.\n-         */\n-        public CountDownListener(int countDown, long minClusterStateVersion, Listener listener) {\n-            this.countDown = new CountDown(countDown);\n-            this.listener = listener;\n-            this.minClusterStateVersion = minClusterStateVersion;\n-        }\n-\n-        @Override\n-        public void onNodeMappingCreated(NodeMappingCreatedAction.NodeMappingCreatedResponse response) {\n-            if (response.clusterStateVersion() < minClusterStateVersion) {\n-                return;\n-            }\n-            decrementCounter();\n-\n-        }\n-\n-        public void decrementCounter() {\n-            if (countDown.countDown()) {\n-                mappingCreatedAction.remove(this);\n-                listener.onResponse(new Response(true));\n-            }\n-        }\n-\n-        @Override\n-        public void onTimeout() {\n-            if (countDown.fastForward()) {\n-                mappingCreatedAction.remove(this);\n-                listener.onResponse(new Response(false));\n-            }\n-        }\n-    }\n }",
  "logs_path": "auggie/sonnet4.5/7ad89f22/elastic_elasticsearch_pr4229/logs.jsonl",
  "errors": [],
  "edit_run_id": "7ad89f22",
  "test_label": "v1-rollouts-1-3-sonnet4.5"
}