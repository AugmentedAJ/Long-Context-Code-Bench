diff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java
index 9eb3352..d977183 100644
--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java
+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java
@@ -22,22 +22,20 @@ package org.elasticsearch.action.admin.indices.mapping.put;
 import com.carrotsearch.hppc.ObjectOpenHashSet;
 import org.elasticsearch.ElasticSearchGenerationException;
 import org.elasticsearch.ElasticSearchIllegalArgumentException;
+import org.elasticsearch.Version;
 import org.elasticsearch.action.ActionRequestValidationException;
-import org.elasticsearch.action.support.master.MasterNodeOperationRequest;
+import org.elasticsearch.action.support.master.AcknowledgedRequest;
 import org.elasticsearch.common.Strings;
 import org.elasticsearch.common.io.stream.StreamInput;
 import org.elasticsearch.common.io.stream.StreamOutput;
-import org.elasticsearch.common.unit.TimeValue;
 import org.elasticsearch.common.xcontent.XContentBuilder;
 import org.elasticsearch.common.xcontent.XContentFactory;
 import org.elasticsearch.common.xcontent.XContentType;
 
 import java.io.IOException;
 import java.util.Map;
-import java.util.concurrent.TimeUnit;
 
 import static org.elasticsearch.action.ValidateActions.addValidationError;
-import static org.elasticsearch.common.unit.TimeValue.readTimeValue;
 
 /**
  * Puts mapping definition registered under a specific type into one or more indices. Best created with
@@ -51,7 +49,7 @@ import static org.elasticsearch.common.unit.TimeValue.readTimeValue;
  * @see org.elasticsearch.client.IndicesAdminClient#putMapping(PutMappingRequest)
  * @see PutMappingResponse
  */
-public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequest> {
+public class PutMappingRequest extends AcknowledgedRequest<PutMappingRequest> {
 
     private static ObjectOpenHashSet<String> RESERVED_FIELDS = ObjectOpenHashSet.from(
             "_uid", "_id", "_type", "_source",  "_all", "_analyzer", "_boost", "_parent", "_routing", "_index",
@@ -64,8 +62,6 @@ public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequ
 
     private String source;
 
-    private TimeValue timeout = new TimeValue(10, TimeUnit.SECONDS);
-
     private boolean ignoreConflicts = false;
 
     PutMappingRequest() {
@@ -224,30 +220,7 @@ public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequ
         return this;
     }
 
-    /**
-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to
-     * <tt>10s</tt>.
-     */
-    TimeValue timeout() {
-        return timeout;
-    }
-
-    /**
-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to
-     * <tt>10s</tt>.
-     */
-    public PutMappingRequest timeout(TimeValue timeout) {
-        this.timeout = timeout;
-        return this;
-    }
 
-    /**
-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to
-     * <tt>10s</tt>.
-     */
-    public PutMappingRequest timeout(String timeout) {
-        return timeout(TimeValue.parseTimeValue(timeout, null));
-    }
 
     /**
      * If there is already a mapping definition registered against the type, then it will be merged. If there are
@@ -274,7 +247,7 @@ public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequ
         indices = in.readStringArray();
         type = in.readOptionalString();
         source = in.readString();
-        timeout = readTimeValue(in);
+        readTimeout(in, Version.V_0_90_6);
         ignoreConflicts = in.readBoolean();
     }
 
@@ -284,7 +257,7 @@ public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequ
         out.writeStringArrayNullable(indices);
         out.writeOptionalString(type);
         out.writeString(source);
-        timeout.writeTo(out);
+        writeTimeout(out, Version.V_0_90_6);
         out.writeBoolean(ignoreConflicts);
     }
 }
diff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequestBuilder.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequestBuilder.java
index e93ca84..592e87c 100644
--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequestBuilder.java
+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequestBuilder.java
@@ -20,10 +20,9 @@
 package org.elasticsearch.action.admin.indices.mapping.put;
 
 import org.elasticsearch.action.ActionListener;
-import org.elasticsearch.action.support.master.MasterNodeOperationRequestBuilder;
+import org.elasticsearch.action.support.master.AcknowledgedRequestBuilder;
 import org.elasticsearch.client.IndicesAdminClient;
 import org.elasticsearch.client.internal.InternalIndicesAdminClient;
-import org.elasticsearch.common.unit.TimeValue;
 import org.elasticsearch.common.xcontent.XContentBuilder;
 
 import java.util.Map;
@@ -31,7 +30,7 @@ import java.util.Map;
 /**
  *
  */
-public class PutMappingRequestBuilder extends MasterNodeOperationRequestBuilder<PutMappingRequest, PutMappingResponse, PutMappingRequestBuilder> {
+public class PutMappingRequestBuilder extends AcknowledgedRequestBuilder<PutMappingRequest, PutMappingResponse, PutMappingRequestBuilder> {
 
     public PutMappingRequestBuilder(IndicesAdminClient indicesClient) {
         super((InternalIndicesAdminClient) indicesClient, new PutMappingRequest());
@@ -83,24 +82,6 @@ public class PutMappingRequestBuilder extends MasterNodeOperationRequestBuilder<
         return this;
     }
 
-    /**
-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to
-     * <tt>10s</tt>.
-     */
-    public PutMappingRequestBuilder setTimeout(TimeValue timeout) {
-        request.timeout(timeout);
-        return this;
-    }
-
-    /**
-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to
-     * <tt>10s</tt>.
-     */
-    public PutMappingRequestBuilder setTimeout(String timeout) {
-        request.timeout(timeout);
-        return this;
-    }
-
     /**
      * If there is already a mapping definition registered against the type, then it will be merged. If there are
      * elements that can't be merged are detected, the request will be rejected unless the
diff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java
index 58edc44..646377b 100644
--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java
+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java
@@ -19,7 +19,8 @@
 
 package org.elasticsearch.action.admin.indices.mapping.put;
 
-import org.elasticsearch.action.ActionResponse;
+import org.elasticsearch.Version;
+import org.elasticsearch.action.support.master.AcknowledgedResponse;
 import org.elasticsearch.common.io.stream.StreamInput;
 import org.elasticsearch.common.io.stream.StreamOutput;
 
@@ -28,35 +29,25 @@ import java.io.IOException;
 /**
  * The response of put mapping operation.
  */
-public class PutMappingResponse extends ActionResponse {
-
-    private boolean acknowledged;
+public class PutMappingResponse extends AcknowledgedResponse {
 
     PutMappingResponse() {
 
     }
 
     PutMappingResponse(boolean acknowledged) {
-        this.acknowledged = acknowledged;
-    }
-
-    /**
-     * Has the put mapping creation been acknowledged by all current cluster nodes within the
-     * provided {@link PutMappingRequest#timeout(org.elasticsearch.common.unit.TimeValue)}.
-     */
-    public boolean isAcknowledged() {
-        return acknowledged;
+        super(acknowledged);
     }
 
     @Override
     public void readFrom(StreamInput in) throws IOException {
         super.readFrom(in);
-        acknowledged = in.readBoolean();
+        readAcknowledged(in, Version.V_0_90_6);
     }
 
     @Override
     public void writeTo(StreamOutput out) throws IOException {
         super.writeTo(out);
-        out.writeBoolean(acknowledged);
+        writeAcknowledged(out, Version.V_0_90_6);
     }
 }
diff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java
index e12a4a5..662dc42 100644
--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java
+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java
@@ -24,6 +24,8 @@ import org.elasticsearch.action.ActionListener;
 import org.elasticsearch.action.support.master.TransportMasterNodeOperationAction;
 import org.elasticsearch.cluster.ClusterService;
 import org.elasticsearch.cluster.ClusterState;
+import org.elasticsearch.cluster.ack.ClusterStateUpdateListener;
+import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;
 import org.elasticsearch.cluster.block.ClusterBlockException;
 import org.elasticsearch.cluster.block.ClusterBlockLevel;
 import org.elasticsearch.cluster.metadata.MetaDataMappingService;
@@ -80,11 +82,18 @@ public class TransportPutMappingAction extends TransportMasterNodeOperationActio
 
     @Override
     protected void masterOperation(final PutMappingRequest request, final ClusterState state, final ActionListener<PutMappingResponse> listener) throws ElasticSearchException {
+        PutMappingClusterStateUpdateRequest updateRequest = new PutMappingClusterStateUpdateRequest()
+                .indices(request.indices())
+                .type(request.type())
+                .source(request.source())
+                .ignoreConflicts(request.ignoreConflicts())
+                .ackTimeout(request.timeout())
+                .masterNodeTimeout(request.masterNodeTimeout());
 
-        metaDataMappingService.putMapping(new MetaDataMappingService.PutRequest(request.indices(), request.type(), request.source()).ignoreConflicts(request.ignoreConflicts()).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataMappingService.Listener() {
+        metaDataMappingService.putMapping(updateRequest, new ClusterStateUpdateListener() {
             @Override
-            public void onResponse(MetaDataMappingService.Response response) {
-                listener.onResponse(new PutMappingResponse(response.acknowledged()));
+            public void onResponse(ClusterStateUpdateResponse response) {
+                listener.onResponse(new PutMappingResponse(response.isAcknowledged()));
             }
 
             @Override
diff --git a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java
index 412fd86..9cd6d77 100644
--- a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java
+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java
@@ -23,13 +23,11 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import org.elasticsearch.action.admin.indices.mapping.delete.DeleteMappingClusterStateUpdateRequest;
-import org.elasticsearch.action.support.master.MasterNodeOperationRequest;
+import org.elasticsearch.action.admin.indices.mapping.put.PutMappingClusterStateUpdateRequest;
 import org.elasticsearch.cluster.*;
 import org.elasticsearch.cluster.ack.ClusterStateUpdateListener;
 import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;
-import org.elasticsearch.cluster.action.index.NodeMappingCreatedAction;
 import org.elasticsearch.cluster.node.DiscoveryNode;
-import org.elasticsearch.cluster.routing.IndexRoutingTable;
 import org.elasticsearch.common.Nullable;
 import org.elasticsearch.common.Priority;
 import org.elasticsearch.common.component.AbstractComponent;
@@ -37,8 +35,6 @@ import org.elasticsearch.common.compress.CompressedString;
 import org.elasticsearch.common.inject.Inject;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.common.unit.TimeValue;
-import org.elasticsearch.common.util.concurrent.ConcurrentCollections;
-import org.elasticsearch.common.util.concurrent.CountDown;
 import org.elasticsearch.index.Index;
 import org.elasticsearch.index.mapper.DocumentMapper;
 import org.elasticsearch.index.mapper.MapperService;
@@ -65,16 +61,13 @@ public class MetaDataMappingService extends AbstractComponent {
 
     private final IndicesService indicesService;
 
-    private final NodeMappingCreatedAction mappingCreatedAction;
-
     private final BlockingQueue<MappingTask> refreshOrUpdateQueue = ConcurrentCollections.newBlockingQueue();
 
     @Inject
-    public MetaDataMappingService(Settings settings, ClusterService clusterService, IndicesService indicesService, NodeMappingCreatedAction mappingCreatedAction) {
+    public MetaDataMappingService(Settings settings, ClusterService clusterService, IndicesService indicesService) {
         super(settings);
         this.clusterService = clusterService;
         this.indicesService = indicesService;
-        this.mappingCreatedAction = mappingCreatedAction;
     }
 
     static class MappingTask {
@@ -362,15 +355,33 @@ public class MetaDataMappingService extends AbstractComponent {
         });
     }
 
-    public void putMapping(final PutRequest request, final Listener listener) {
+    public void putMapping(final PutMappingClusterStateUpdateRequest request, final ClusterStateUpdateListener listener) {
+
+        clusterService.submitStateUpdateTask("put-mapping [" + request.type() + "]", Priority.HIGH, new AckedClusterStateUpdateTask() {
+
+            @Override
+            public boolean mustAck(DiscoveryNode discoveryNode) {
+                return true;
+            }
 
-        clusterService.submitStateUpdateTask("put-mapping [" + request.mappingType + "]", Priority.HIGH, new TimeoutClusterStateUpdateTask() {
+            @Override
+            public void onAllNodesAcked(@Nullable Throwable t) {
+                listener.onResponse(new ClusterStateUpdateResponse(true));
+            }
 
-            CountDownListener countDownListener; // used to count ack responses before confirming operation is complete
+            @Override
+            public void onAckTimeout() {
+                listener.onResponse(new ClusterStateUpdateResponse(false));
+            }
+
+            @Override
+            public TimeValue ackTimeout() {
+                return request.ackTimeout();
+            }
 
             @Override
             public TimeValue timeout() {
-                return request.masterTimeout;
+                return request.masterNodeTimeout();
             }
 
             @Override
@@ -382,17 +393,17 @@ public class MetaDataMappingService extends AbstractComponent {
             public ClusterState execute(final ClusterState currentState) throws Exception {
                 List<String> indicesToClose = Lists.newArrayList();
                 try {
-                    if (request.indices.length == 0) {
+                    if (request.indices().length == 0) {
                         throw new IndexMissingException(new Index("_all"));
                     }
-                    for (String index : request.indices) {
+                    for (String index : request.indices()) {
                         if (!currentState.metaData().hasIndex(index)) {
                             throw new IndexMissingException(new Index(index));
                         }
                     }
 
                     // pre create indices here and add mappings to them so we can merge the mappings here if needed
-                    for (String index : request.indices) {
+                    for (String index : request.indices()) {
                         if (indicesService.hasIndex(index)) {
                             continue;
                         }
@@ -404,29 +415,29 @@ public class MetaDataMappingService extends AbstractComponent {
                             indexService.mapperService().merge(MapperService.DEFAULT_MAPPING, indexMetaData.mappings().get(MapperService.DEFAULT_MAPPING).source(), false);
                         }
                         // only add the current relevant mapping (if exists)
-                        if (indexMetaData.mappings().containsKey(request.mappingType)) {
-                            indexService.mapperService().merge(request.mappingType, indexMetaData.mappings().get(request.mappingType).source(), false);
+                        if (indexMetaData.mappings().containsKey(request.type())) {
+                            indexService.mapperService().merge(request.type(), indexMetaData.mappings().get(request.type()).source(), false);
                         }
                     }
 
                     Map<String, DocumentMapper> newMappers = newHashMap();
                     Map<String, DocumentMapper> existingMappers = newHashMap();
-                    for (String index : request.indices) {
+                    for (String index : request.indices()) {
                         IndexService indexService = indicesService.indexService(index);
                         if (indexService != null) {
                             // try and parse it (no need to add it here) so we can bail early in case of parsing exception
                             DocumentMapper newMapper;
-                            DocumentMapper existingMapper = indexService.mapperService().documentMapper(request.mappingType);
-                            if (MapperService.DEFAULT_MAPPING.equals(request.mappingType)) {
+                            DocumentMapper existingMapper = indexService.mapperService().documentMapper(request.type());
+                            if (MapperService.DEFAULT_MAPPING.equals(request.type())) {
                                 // _default_ types do not go through merging, but we do test the new settings. Also don't apply the old default
-                                newMapper = indexService.mapperService().parse(request.mappingType, new CompressedString(request.mappingSource), false);
+                                newMapper = indexService.mapperService().parse(request.type(), new CompressedString(request.source()), false);
                             } else {
-                                newMapper = indexService.mapperService().parse(request.mappingType, new CompressedString(request.mappingSource));
+                                newMapper = indexService.mapperService().parse(request.type(), new CompressedString(request.source()));
                                 if (existingMapper != null) {
                                     // first, simulate
                                     DocumentMapper.MergeResult mergeResult = existingMapper.merge(newMapper, mergeFlags().simulate(true));
                                     // if we have conflicts, and we are not supposed to ignore them, throw an exception
-                                    if (!request.ignoreConflicts && mergeResult.hasConflicts()) {
+                                    if (!request.ignoreConflicts() && mergeResult.hasConflicts()) {
                                         throw new MergeMappingException(mergeResult.conflicts());
                                     }
                                 }
@@ -442,7 +453,7 @@ public class MetaDataMappingService extends AbstractComponent {
                         }
                     }
 
-                    String mappingType = request.mappingType;
+                    String mappingType = request.type();
                     if (mappingType == null) {
                         mappingType = newMappers.values().iterator().next().type();
                     } else if (!mappingType.equals(newMappers.values().iterator().next().type())) {
@@ -489,12 +500,12 @@ public class MetaDataMappingService extends AbstractComponent {
 
                     if (mappings.isEmpty()) {
                         // no changes, return
-                        listener.onResponse(new Response(true));
+                        listener.onResponse(new ClusterStateUpdateResponse(true));
                         return currentState;
                     }
 
                     MetaData.Builder builder = MetaData.builder(currentState.metaData());
-                    for (String indexName : request.indices) {
+                    for (String indexName : request.indices()) {
                         IndexMetaData indexMetaData = currentState.metaData().index(indexName);
                         if (indexMetaData == null) {
                             throw new IndexMissingException(new Index(indexName));
@@ -505,26 +516,7 @@ public class MetaDataMappingService extends AbstractComponent {
                         }
                     }
 
-                    ClusterState updatedState = ClusterState.builder(currentState).metaData(builder).build();
-
-                    int counter = 1; // we want to wait on the master node to apply it on its cluster state
-                    // also wait for nodes that actually have the index created on them to apply the mappings internally
-                    for (String index : request.indices) {
-                        IndexRoutingTable indexRoutingTable = updatedState.routingTable().index(index);
-                        if (indexRoutingTable != null) {
-                            counter += indexRoutingTable.numberOfNodesShardsAreAllocatedOn(updatedState.nodes().masterNodeId());
-                        }
-                    }
-
-                    logger.debug("Expecting {} mapping created responses for other nodes", counter - 1);
-
-                    // TODO: adding one to the version is based on knowledge on how the parent class will increment the version
-                    //       move this to the base class or add another callback before publishing the new cluster state so we
-                    //       capture its version.
-                    countDownListener = new CountDownListener(counter, currentState.version() + 1, listener);
-                    mappingCreatedAction.add(countDownListener, request.timeout);
-
-                    return updatedState;
+                    return ClusterState.builder(currentState).metaData(builder).build();
                 } finally {
                     for (String index : indicesToClose) {
                         indicesService.removeIndex(index, "created for mapping processing");
@@ -534,10 +526,6 @@ public class MetaDataMappingService extends AbstractComponent {
 
             @Override
             public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {
-                if (countDownListener != null) {
-                    // the master has applied it on its cluster state
-                    countDownListener.decrementCounter();
-                }
             }
         });
     }
@@ -549,41 +537,6 @@ public class MetaDataMappingService extends AbstractComponent {
         void onFailure(Throwable t);
     }
 
-    public static class PutRequest {
-
-        final String[] indices;
-
-        final String mappingType;
-
-        final String mappingSource;
-
-        boolean ignoreConflicts = false;
-
-        TimeValue timeout = TimeValue.timeValueSeconds(10);
-        TimeValue masterTimeout = MasterNodeOperationRequest.DEFAULT_MASTER_NODE_TIMEOUT;
-
-        public PutRequest(String[] indices, String mappingType, String mappingSource) {
-            this.indices = indices;
-            this.mappingType = mappingType;
-            this.mappingSource = mappingSource;
-        }
-
-        public PutRequest ignoreConflicts(boolean ignoreConflicts) {
-            this.ignoreConflicts = ignoreConflicts;
-            return this;
-        }
-
-        public PutRequest timeout(TimeValue timeout) {
-            this.timeout = timeout;
-            return this;
-        }
-
-        public PutRequest masterTimeout(TimeValue masterTimeout) {
-            this.masterTimeout = masterTimeout;
-            return this;
-        }
-    }
-
     public static class Response {
         private final boolean acknowledged;
 
@@ -595,46 +548,4 @@ public class MetaDataMappingService extends AbstractComponent {
             return acknowledged;
         }
     }
-
-    private class CountDownListener implements NodeMappingCreatedAction.Listener {
-
-        private final CountDown countDown;
-        private final Listener listener;
-        private final long minClusterStateVersion;
-
-        /**
-         * @param countDown              initial counter value
-         * @param minClusterStateVersion the minimum cluster state version for which accept responses
-         * @param listener               listener to call when counter reaches 0.
-         */
-        public CountDownListener(int countDown, long minClusterStateVersion, Listener listener) {
-            this.countDown = new CountDown(countDown);
-            this.listener = listener;
-            this.minClusterStateVersion = minClusterStateVersion;
-        }
-
-        @Override
-        public void onNodeMappingCreated(NodeMappingCreatedAction.NodeMappingCreatedResponse response) {
-            if (response.clusterStateVersion() < minClusterStateVersion) {
-                return;
-            }
-            decrementCounter();
-
-        }
-
-        public void decrementCounter() {
-            if (countDown.countDown()) {
-                mappingCreatedAction.remove(this);
-                listener.onResponse(new Response(true));
-            }
-        }
-
-        @Override
-        public void onTimeout() {
-            if (countDown.fastForward()) {
-                mappingCreatedAction.remove(this);
-                listener.onResponse(new Response(false));
-            }
-        }
-    }
 }