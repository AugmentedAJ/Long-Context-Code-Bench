{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134477,
  "base_commit": "1ccb58a8b2b9b38bad0506c49d455dbfcbea9224",
  "runner": "auggie",
  "model": "sonnet4.5",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 290312,
  "patch_unified": "diff --git a/server/src/main/java/org/elasticsearch/search/SearchService.java b/server/src/main/java/org/elasticsearch/search/SearchService.java\nindex 9a101d83..963b8694 100644\n--- a/server/src/main/java/org/elasticsearch/search/SearchService.java\n+++ b/server/src/main/java/org/elasticsearch/search/SearchService.java\n@@ -588,6 +588,7 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n      * @param shardId        id of the shard being searched\n      * @param taskId         id of the task being executed\n      * @param threadPool     with context where to write the new header\n+     * @param lifecycleState the lifecycle state of the SearchService\n      * @return the wrapped action listener\n      */\n     static <T> ActionListener<T> wrapListenerForErrorHandling(\n@@ -596,7 +597,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n         String nodeId,\n         ShardId shardId,\n         long taskId,\n-        ThreadPool threadPool\n+        ThreadPool threadPool,\n+        Lifecycle.State lifecycleState\n     ) {\n         final boolean header;\n         if (version.onOrAfter(ERROR_TRACE_IN_TRANSPORT_HEADER) && threadPool.getThreadContext() != null) {\n@@ -612,7 +614,12 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n                 taskId\n             );\n             // Keep this logic aligned with that of SUPPRESSED_ERROR_LOGGER in RestResponse\n-            if (ExceptionsHelper.status(e).getStatus() < 500 || ExceptionsHelper.isNodeOrShardUnavailableTypeException(e)) {\n+            // When the service is stopped or closed, don't log 500 errors as warnings to avoid alerts in serverless\n+            final boolean serviceStoppedOrClosed = lifecycleState == Lifecycle.State.STOPPED\n+                || lifecycleState == Lifecycle.State.CLOSED;\n+            if (ExceptionsHelper.status(e).getStatus() < 500\n+                || ExceptionsHelper.isNodeOrShardUnavailableTypeException(e)\n+                || serviceStoppedOrClosed) {\n                 logger.debug(messageSupplier, e);\n             } else {\n                 logger.warn(messageSupplier, e);\n@@ -643,7 +650,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             clusterService.localNode().getId(),\n             request.shardId(),\n             task.getId(),\n-            threadPool\n+            threadPool,\n+            lifecycleState()\n         );\n         final IndexShard shard = getShard(request);\n         rewriteAndFetchShardRequest(shard, request, listener.delegateFailure((l, rewritten) -> {\n@@ -705,7 +713,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n                 clusterService.localNode().getId(),\n                 request.shardId(),\n                 task.getId(),\n-                threadPool\n+                threadPool,\n+                lifecycleState()\n             ).delegateFailure((l, orig) -> {\n                 // check if we can shortcut the query phase entirely.\n                 if (orig.canReturnNullResponseIfMatchNoDocs()) {\n@@ -953,7 +962,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             clusterService.localNode().getId(),\n             shardSearchRequest.shardId(),\n             task.getId(),\n-            threadPool\n+            threadPool,\n+            lifecycleState()\n         );\n         final Releasable markAsUsed = readerContext.markAsUsed(getKeepAlive(shardSearchRequest));\n         runAsync(getExecutor(readerContext.indexShard()), () -> {\n@@ -1010,7 +1020,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             clusterService.localNode().getId(),\n             readerContext.indexShard().shardId(),\n             task.getId(),\n-            threadPool\n+            threadPool,\n+            lifecycleState()\n         );\n         final Releasable markAsUsed;\n         try {\n@@ -1072,7 +1083,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             clusterService.localNode().getId(),\n             shardSearchRequest.shardId(),\n             task.getId(),\n-            threadPool\n+            threadPool,\n+            lifecycleState()\n         );\n         final Releasable markAsUsed = readerContext.markAsUsed(getKeepAlive(shardSearchRequest));\n         rewriteAndFetchShardRequest(readerContext.indexShard(), shardSearchRequest, listener.delegateFailure((l, rewritten) -> {\ndiff --git a/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java b/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java\nindex 29380a05..9935c347 100644\n--- a/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java\n@@ -20,6 +20,7 @@ import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.OriginalIndices;\n import org.elasticsearch.action.search.SearchRequest;\n import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.component.Lifecycle;\n import org.elasticsearch.common.regex.Regex;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.util.BigArrays;\n@@ -160,7 +161,15 @@ public class SearchServiceTests extends IndexShardTestCase {\n         e.fillInStackTrace();\n         assertThat(e.getStackTrace().length, is(not(0)));\n         listener.onFailure(e);\n-        listener = wrapListenerForErrorHandling(listener, TransportVersion.current(), \"node\", shardId, 123L, threadPool);\n+        listener = wrapListenerForErrorHandling(\n+            listener,\n+            TransportVersion.current(),\n+            \"node\",\n+            shardId,\n+            123L,\n+            threadPool,\n+            Lifecycle.State.STARTED\n+        );\n         isWrapped.set(true);\n         listener.onFailure(e);\n     }\n@@ -198,7 +207,15 @@ public class SearchServiceTests extends IndexShardTestCase {\n                 }\n             };\n             IllegalArgumentException e = new IllegalArgumentException(exceptionMessage); // 400-level exception\n-            listener = wrapListenerForErrorHandling(listener, TransportVersion.current(), nodeId, shardId, taskId, threadPool);\n+            listener = wrapListenerForErrorHandling(\n+                listener,\n+                TransportVersion.current(),\n+                nodeId,\n+                shardId,\n+                taskId,\n+                threadPool,\n+                Lifecycle.State.STARTED\n+            );\n             listener.onFailure(e);\n         }\n     }\n@@ -235,7 +252,107 @@ public class SearchServiceTests extends IndexShardTestCase {\n                 }\n             };\n             IllegalStateException e = new IllegalStateException(exceptionMessage); // 500-level exception\n-            listener = wrapListenerForErrorHandling(listener, TransportVersion.current(), nodeId, shardId, taskId, threadPool);\n+            listener = wrapListenerForErrorHandling(\n+                listener,\n+                TransportVersion.current(),\n+                nodeId,\n+                shardId,\n+                taskId,\n+                threadPool,\n+                Lifecycle.State.STARTED\n+            );\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    public void testWrapListenerForErrorHandlingWhenServiceStopped() {\n+        final String nodeId = \"node\";\n+        final String index = \"index\";\n+        ShardId shardId = new ShardId(index, index, 0);\n+        final long taskId = 123L;\n+\n+        try (var mockLog = MockLog.capture(SearchService.class)) {\n+            Configurator.setLevel(SearchService.class, Level.DEBUG);\n+            final String exceptionMessage = \"test exception message\";\n+            mockLog.addExpectation(\n+                new MockLog.ExceptionSeenEventExpectation(\n+                    format(\"\\\"[%s]%s: failed to execute search request for task [%d]\\\" and an exception logged\", nodeId, shardId, taskId),\n+                    SearchService.class.getCanonicalName(),\n+                    Level.DEBUG, // When service is stopped, 500 errors should be logged at DEBUG level, not WARN\n+                    format(\"[%s]%s: failed to execute search request for task [%d]\", nodeId, shardId, taskId),\n+                    IllegalStateException.class,\n+                    exceptionMessage\n+                )\n+            );\n+\n+            // Tests the listener logs at DEBUG level when service is stopped\n+            ActionListener<SearchPhaseResult> listener = new ActionListener<>() {\n+                @Override\n+                public void onResponse(SearchPhaseResult searchPhaseResult) {\n+                    // noop - we only care about failure scenarios\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    mockLog.assertAllExpectationsMatched();\n+                }\n+            };\n+            IllegalStateException e = new IllegalStateException(exceptionMessage); // 500-level exception\n+            listener = wrapListenerForErrorHandling(\n+                listener,\n+                TransportVersion.current(),\n+                nodeId,\n+                shardId,\n+                taskId,\n+                threadPool,\n+                Lifecycle.State.STOPPED\n+            );\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    public void testWrapListenerForErrorHandlingWhenServiceClosed() {\n+        final String nodeId = \"node\";\n+        final String index = \"index\";\n+        ShardId shardId = new ShardId(index, index, 0);\n+        final long taskId = 123L;\n+\n+        try (var mockLog = MockLog.capture(SearchService.class)) {\n+            Configurator.setLevel(SearchService.class, Level.DEBUG);\n+            final String exceptionMessage = \"test exception message\";\n+            mockLog.addExpectation(\n+                new MockLog.ExceptionSeenEventExpectation(\n+                    format(\"\\\"[%s]%s: failed to execute search request for task [%d]\\\" and an exception logged\", nodeId, shardId, taskId),\n+                    SearchService.class.getCanonicalName(),\n+                    Level.DEBUG, // When service is closed, 500 errors should be logged at DEBUG level, not WARN\n+                    format(\"[%s]%s: failed to execute search request for task [%d]\", nodeId, shardId, taskId),\n+                    IllegalStateException.class,\n+                    exceptionMessage\n+                )\n+            );\n+\n+            // Tests the listener logs at DEBUG level when service is closed\n+            ActionListener<SearchPhaseResult> listener = new ActionListener<>() {\n+                @Override\n+                public void onResponse(SearchPhaseResult searchPhaseResult) {\n+                    // noop - we only care about failure scenarios\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    mockLog.assertAllExpectationsMatched();\n+                }\n+            };\n+            IllegalStateException e = new IllegalStateException(exceptionMessage); // 500-level exception\n+            listener = wrapListenerForErrorHandling(\n+                listener,\n+                TransportVersion.current(),\n+                nodeId,\n+                shardId,\n+                taskId,\n+                threadPool,\n+                Lifecycle.State.CLOSED\n+            );\n             listener.onFailure(e);\n         }\n     }",
  "logs_path": "auggie/sonnet4.5/7ad89f22/elastic_elasticsearch_pr134477/logs.jsonl",
  "errors": [],
  "edit_run_id": "7ad89f22",
  "test_label": "v1-rollouts-1-3-sonnet4.5"
}