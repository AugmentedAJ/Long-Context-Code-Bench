diff --git a/x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/rate/TimeSeriesRateAggregator.java b/x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/rate/TimeSeriesRateAggregator.java
index f153a397..8e5b0b24 100644
--- a/x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/rate/TimeSeriesRateAggregator.java
+++ b/x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/rate/TimeSeriesRateAggregator.java
@@ -111,33 +111,34 @@ public final class TimeSeriesRateAggregator extends NumericMetricsAggregator.Sin
         return new LeafBucketCollectorBase(sub, null) {
             @Override
             public void collect(int doc, long bucket) throws IOException {
-                leafValues.advanceExact(doc);   // TODO handle missing values
-                double latestValue = leafValues.doubleValue();
-
-                if (bucket != currentBucket) {
-                    startValues = bigArrays().grow(startValues, bucket + 1);
-                    endValues = bigArrays().grow(endValues, bucket + 1);
-                    startTimes = bigArrays().grow(startTimes, bucket + 1);
-                    endTimes = bigArrays().grow(endTimes, bucket + 1);
-                    resetCompensations = bigArrays().grow(resetCompensations, bucket + 1);
-                    if (currentTsid != aggCtx.getTsidHashOrd()) {
-                        // if we're on a new tsid then we need to calculate the last bucket
-                        calculateLastBucket();
-                        currentTsid = aggCtx.getTsidHashOrd();
+                if (leafValues.advanceExact(doc)) {
+                    double latestValue = leafValues.doubleValue();
+
+                    if (bucket != currentBucket) {
+                        startValues = bigArrays().grow(startValues, bucket + 1);
+                        endValues = bigArrays().grow(endValues, bucket + 1);
+                        startTimes = bigArrays().grow(startTimes, bucket + 1);
+                        endTimes = bigArrays().grow(endTimes, bucket + 1);
+                        resetCompensations = bigArrays().grow(resetCompensations, bucket + 1);
+                        if (currentTsid != aggCtx.getTsidHashOrd()) {
+                            // if we're on a new tsid then we need to calculate the last bucket
+                            calculateLastBucket();
+                            currentTsid = aggCtx.getTsidHashOrd();
+                        } else {
+                            // if we're in a new bucket but in the same tsid then we update the
+                            // timestamp and last value before we calculate the last bucket
+                            currentStartTime = aggCtx.getTimestamp();
+                            currentStartValue = checkForResets(latestValue);
+                            calculateLastBucket();
+                        }
+                        currentBucket = bucket;
+                        currentStartTime = currentEndTime = aggCtx.getTimestamp();
+                        currentStartValue = currentEndValue = latestValue;
+                        resetCompensation = 0;
                     } else {
-                        // if we're in a new bucket but in the same tsid then we update the
-                        // timestamp and last value before we calculate the last bucket
                         currentStartTime = aggCtx.getTimestamp();
                         currentStartValue = checkForResets(latestValue);
-                        calculateLastBucket();
                     }
-                    currentBucket = bucket;
-                    currentStartTime = currentEndTime = aggCtx.getTimestamp();
-                    currentStartValue = currentEndValue = latestValue;
-                    resetCompensation = 0;
-                } else {
-                    currentStartTime = aggCtx.getTimestamp();
-                    currentStartValue = checkForResets(latestValue);
                 }
             }
         };