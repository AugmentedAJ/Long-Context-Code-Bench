{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4422,
  "base_commit": "bb275166f1a1f20f5330691ab854d6dc61c51366",
  "runner": "auggie",
  "model": "sonnet4.5",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 319588,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java\nindex 9814efc..84580a8 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java\n@@ -59,7 +59,7 @@ import static org.elasticsearch.common.unit.TimeValue.readTimeValue;\n  * @see org.elasticsearch.client.Requests#createIndexRequest(String)\n  * @see CreateIndexResponse\n  */\n-public class CreateIndexRequest extends MasterNodeOperationRequest<CreateIndexRequest> {\n+public class CreateIndexRequest extends AcknowledgedRequest<CreateIndexRequest> {\n \n     private String cause = \"\";\n \n@@ -71,8 +71,6 @@ public class CreateIndexRequest extends MasterNodeOperationRequest<CreateIndexRe\n \n     private Map<String, IndexMetaData.Custom> customs = newHashMap();\n \n-    private TimeValue timeout = AcknowledgedRequest.DEFAULT_ACK_TIMEOUT;\n-\n     CreateIndexRequest() {\n     }\n \n@@ -338,38 +336,13 @@ public class CreateIndexRequest extends MasterNodeOperationRequest<CreateIndexRe\n         return this.customs;\n     }\n \n-    /**\n-     * Timeout to wait for the index creation to be acknowledged by current cluster nodes. Defaults\n-     * to <tt>10s</tt>.\n-     */\n-    public TimeValue timeout() {\n-        return timeout;\n-    }\n-\n-    /**\n-     * Timeout to wait for the index creation to be acknowledged by current cluster nodes. Defaults\n-     * to <tt>10s</tt>.\n-     */\n-    public CreateIndexRequest timeout(TimeValue timeout) {\n-        this.timeout = timeout;\n-        return this;\n-    }\n-\n-    /**\n-     * Timeout to wait for the index creation to be acknowledged by current cluster nodes. Defaults\n-     * to <tt>10s</tt>.\n-     */\n-    public CreateIndexRequest timeout(String timeout) {\n-        return timeout(TimeValue.parseTimeValue(timeout, null));\n-    }\n-\n     @Override\n     public void readFrom(StreamInput in) throws IOException {\n         super.readFrom(in);\n         cause = in.readString();\n         index = in.readString();\n         settings = readSettingsFromStream(in);\n-        timeout = readTimeValue(in);\n+        readTimeout(in);\n         int size = in.readVInt();\n         for (int i = 0; i < size; i++) {\n             mappings.put(in.readString(), in.readString());\n@@ -388,7 +361,7 @@ public class CreateIndexRequest extends MasterNodeOperationRequest<CreateIndexRe\n         out.writeString(cause);\n         out.writeString(index);\n         writeSettingsToStream(settings, out);\n-        timeout.writeTo(out);\n+        writeTimeout(out);\n         out.writeVInt(mappings.size());\n         for (Map.Entry<String, String> entry : mappings.entrySet()) {\n             out.writeString(entry.getKey());\ndiff --git a/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexResponse.java b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexResponse.java\nindex 7052861..59fdd23 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexResponse.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexResponse.java\n@@ -19,7 +19,7 @@\n \n package org.elasticsearch.action.admin.indices.create;\n \n-import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n \n@@ -28,34 +28,24 @@ import java.io.IOException;\n /**\n  * A response for a create index action.\n  */\n-public class CreateIndexResponse extends ActionResponse {\n-\n-    private boolean acknowledged;\n+public class CreateIndexResponse extends AcknowledgedResponse {\n \n     CreateIndexResponse() {\n     }\n \n     CreateIndexResponse(boolean acknowledged) {\n-        this.acknowledged = acknowledged;\n-    }\n-\n-    /**\n-     * Has the index creation been acknowledged by all current cluster nodes within the\n-     * provided {@link CreateIndexRequest#timeout(org.elasticsearch.common.unit.TimeValue)}.\n-     */\n-    public boolean isAcknowledged() {\n-        return acknowledged;\n+        super(acknowledged);\n     }\n \n     @Override\n     public void readFrom(StreamInput in) throws IOException {\n         super.readFrom(in);\n-        acknowledged = in.readBoolean();\n+        readAcknowledged(in);\n     }\n \n     @Override\n     public void writeTo(StreamOutput out) throws IOException {\n         super.writeTo(out);\n-        out.writeBoolean(acknowledged);\n+        writeAcknowledged(out);\n     }\n }\ndiff --git a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\nindex a394166..f3feaa0 100644\n--- a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\n+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\n@@ -30,15 +30,16 @@ import org.apache.lucene.util.IOUtils;\n import org.elasticsearch.ElasticSearchException;\n import org.elasticsearch.Version;\n import org.elasticsearch.action.support.master.MasterNodeOperationRequest;\n+import org.elasticsearch.cluster.AckedClusterStateUpdateTask;\n import org.elasticsearch.cluster.ClusterService;\n import org.elasticsearch.cluster.ClusterState;\n-import org.elasticsearch.cluster.TimeoutClusterStateUpdateTask;\n-import org.elasticsearch.cluster.action.index.NodeIndexCreatedAction;\n import org.elasticsearch.cluster.block.ClusterBlock;\n import org.elasticsearch.cluster.block.ClusterBlocks;\n import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.allocation.AllocationService;\n import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.common.Nullable;\n import org.elasticsearch.common.Priority;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.component.AbstractComponent;\n@@ -69,11 +70,9 @@ import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.util.*;\n-import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n import static com.google.common.collect.Maps.newHashMap;\n import static org.elasticsearch.cluster.metadata.IndexMetaData.*;\n@@ -89,21 +88,19 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n     private final ClusterService clusterService;\n     private final IndicesService indicesService;\n     private final AllocationService allocationService;\n-    private final NodeIndexCreatedAction nodeIndexCreatedAction;\n     private final MetaDataService metaDataService;\n     private final Version version;\n     private final String riverIndexName;\n \n     @Inject\n     public MetaDataCreateIndexService(Settings settings, Environment environment, ThreadPool threadPool, ClusterService clusterService, IndicesService indicesService,\n-                                      AllocationService allocationService, NodeIndexCreatedAction nodeIndexCreatedAction, MetaDataService metaDataService, Version version, @RiverIndexName String riverIndexName) {\n+                                      AllocationService allocationService, MetaDataService metaDataService, Version version, @RiverIndexName String riverIndexName) {\n         super(settings);\n         this.environment = environment;\n         this.threadPool = threadPool;\n         this.clusterService = clusterService;\n         this.indicesService = indicesService;\n         this.allocationService = allocationService;\n-        this.nodeIndexCreatedAction = nodeIndexCreatedAction;\n         this.metaDataService = metaDataService;\n         this.version = version;\n         this.riverIndexName = riverIndexName;\n@@ -174,7 +171,12 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n \n     private void createIndex(final Request request, final Listener userListener, Semaphore mdLock) {\n         final CreateIndexListener listener = new CreateIndexListener(mdLock, request, userListener);\n-        clusterService.submitStateUpdateTask(\"create-index [\" + request.index + \"], cause [\" + request.cause + \"]\", Priority.URGENT, new TimeoutClusterStateUpdateTask() {\n+        clusterService.submitStateUpdateTask(\"create-index [\" + request.index + \"], cause [\" + request.cause + \"]\", Priority.URGENT, new AckedClusterStateUpdateTask() {\n+\n+            @Override\n+            public TimeValue ackTimeout() {\n+                return request.timeout;\n+            }\n \n             @Override\n             public TimeValue timeout() {\n@@ -186,6 +188,23 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n                 listener.onFailure(t);\n             }\n \n+            @Override\n+            public boolean mustAck(DiscoveryNode discoveryNode) {\n+                return true;\n+            }\n+\n+            @Override\n+            public void onAllNodesAcked(@Nullable Throwable t) {\n+                listener.onResponse(new Response(true, indexMetaDataRef[0]));\n+            }\n+\n+            @Override\n+            public void onAckTimeout() {\n+                listener.onResponse(new Response(false, indexMetaDataRef[0]));\n+            }\n+\n+            private final IndexMetaData[] indexMetaDataRef = new IndexMetaData[1];\n+\n             @Override\n             public ClusterState execute(ClusterState currentState) throws Exception {\n                 boolean indexCreated = false;\n@@ -360,30 +379,8 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n                         updatedState = ClusterState.builder(updatedState).routingResult(routingResult).build();\n                     }\n \n-                    // we wait for events from all nodes that the index has been added to the metadata\n-                    final AtomicInteger counter = new AtomicInteger(currentState.nodes().size());\n-\n-                    final NodeIndexCreatedAction.Listener nodeIndexCreatedListener = new NodeIndexCreatedAction.Listener() {\n-                        @Override\n-                        public void onNodeIndexCreated(String index, String nodeId) {\n-                            if (index.equals(request.index)) {\n-                                if (counter.decrementAndGet() == 0) {\n-                                    listener.onResponse(new Response(true, indexMetaData));\n-                                    nodeIndexCreatedAction.remove(this);\n-                                }\n-                            }\n-                        }\n-                    };\n-\n-                    nodeIndexCreatedAction.add(nodeIndexCreatedListener);\n-\n-                    listener.future = threadPool.schedule(request.timeout, ThreadPool.Names.SAME, new Runnable() {\n-                        @Override\n-                        public void run() {\n-                            listener.onResponse(new Response(false, indexMetaData));\n-                            nodeIndexCreatedAction.remove(nodeIndexCreatedListener);\n-                        }\n-                    });\n+                    // Store the indexMetaData for use in acknowledgement callbacks\n+                    indexMetaDataRef[0] = indexMetaData;\n \n                     return updatedState;\n                 } finally {\n@@ -406,7 +403,6 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n         private final Semaphore mdLock;\n         private final Request request;\n         private final Listener listener;\n-        volatile ScheduledFuture future;\n \n         private CreateIndexListener(Semaphore mdLock, Request request, Listener listener) {\n             this.mdLock = mdLock;\n@@ -418,9 +414,6 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n         public void onResponse(final Response response) {\n             if (notified.compareAndSet(false, true)) {\n                 mdLock.release();\n-                if (future != null) {\n-                    future.cancel(false);\n-                }\n                 listener.onResponse(response);\n             }\n         }\n@@ -429,9 +422,6 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n         public void onFailure(Throwable t) {\n             if (notified.compareAndSet(false, true)) {\n                 mdLock.release();\n-                if (future != null) {\n-                    future.cancel(false);\n-                }\n                 listener.onFailure(t);\n             }\n         }\ndiff --git a/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\nindex d559b94..14f2805 100644\n--- a/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\n+++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\n@@ -28,7 +28,6 @@ import org.elasticsearch.ExceptionsHelper;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n import org.elasticsearch.cluster.ClusterService;\n import org.elasticsearch.cluster.ClusterStateListener;\n-import org.elasticsearch.cluster.action.index.NodeIndexCreatedAction;\n import org.elasticsearch.cluster.action.index.NodeIndexDeletedAction;\n import org.elasticsearch.cluster.action.index.NodeMappingRefreshAction;\n import org.elasticsearch.cluster.action.shard.ShardStateAction;\n@@ -86,7 +85,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n     private final ThreadPool threadPool;\n     private final RecoveryTarget recoveryTarget;\n     private final ShardStateAction shardStateAction;\n-    private final NodeIndexCreatedAction nodeIndexCreatedAction;\n     private final NodeIndexDeletedAction nodeIndexDeletedAction;\n     private final NodeMappingRefreshAction nodeMappingRefreshAction;\n \n@@ -117,7 +115,7 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n     public IndicesClusterStateService(Settings settings, IndicesService indicesService, ClusterService clusterService,\n                                       ThreadPool threadPool, RecoveryTarget recoveryTarget,\n                                       ShardStateAction shardStateAction,\n-                                      NodeIndexCreatedAction nodeIndexCreatedAction, NodeIndexDeletedAction nodeIndexDeletedAction,\n+                                      NodeIndexDeletedAction nodeIndexDeletedAction,\n                                       NodeMappingRefreshAction nodeMappingRefreshAction) {\n         super(settings);\n         this.indicesService = indicesService;\n@@ -125,7 +123,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n         this.threadPool = threadPool;\n         this.recoveryTarget = recoveryTarget;\n         this.shardStateAction = shardStateAction;\n-        this.nodeIndexCreatedAction = nodeIndexCreatedAction;\n         this.nodeIndexDeletedAction = nodeIndexDeletedAction;\n         this.nodeMappingRefreshAction = nodeMappingRefreshAction;\n \n@@ -193,13 +190,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n     private void sendIndexLifecycleEvents(final ClusterChangedEvent event) {\n         String localNodeId = event.state().nodes().localNodeId();\n         assert localNodeId != null;\n-        for (String index : event.indicesCreated()) {\n-            try {\n-                nodeIndexCreatedAction.nodeIndexCreated(event.state(), index, localNodeId);\n-            } catch (Throwable e) {\n-                logger.debug(\"failed to send to master index {} created event\", e, index);\n-            }\n-        }\n         for (String index : event.indicesDeleted()) {\n             try {\n                 nodeIndexDeletedAction.nodeIndexDeleted(event.state(), index, localNodeId);",
  "logs_path": "auggie/sonnet4.5/7ad89f22/elastic_elasticsearch_pr4422/logs.jsonl",
  "errors": [],
  "edit_run_id": "7ad89f22",
  "test_label": "v1-rollouts-1-3-sonnet4.5"
}