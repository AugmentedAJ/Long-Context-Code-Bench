diff --git a/src/main/java/org/elasticsearch/search/suggest/completion/CompletionTokenStream.java b/src/main/java/org/elasticsearch/search/suggest/completion/CompletionTokenStream.java
index 260bd57..b423fd0 100644
--- a/src/main/java/org/elasticsearch/search/suggest/completion/CompletionTokenStream.java
+++ b/src/main/java/org/elasticsearch/search/suggest/completion/CompletionTokenStream.java
@@ -19,12 +19,15 @@
 package org.elasticsearch.search.suggest.completion;
 
 import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.util.AttributeImpl;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.CharsRef;
 import org.apache.lucene.util.IntsRef;
+import org.apache.lucene.util.UnicodeUtil;
 import org.apache.lucene.util.fst.Util;
 
 import java.io.IOException;
@@ -115,8 +118,9 @@ public final class CompletionTokenStream extends TokenStream {
         public void setBytesRef(BytesRef bytes);
     }
 
-    public static final class ByteTermAttributeImpl extends AttributeImpl implements ByteTermAttribute, TermToBytesRefAttribute {
+    public static final class ByteTermAttributeImpl extends AttributeImpl implements ByteTermAttribute, TermToBytesRefAttribute, CharTermAttribute {
         private BytesRef bytes;
+        private final CharsRef charsRef = new CharsRef();
 
         @Override
         public int fillBytesRef() {
@@ -131,16 +135,95 @@ public final class CompletionTokenStream extends TokenStream {
         @Override
         public void setBytesRef(BytesRef bytes) {
             this.bytes = bytes;
+            // Convert UTF-8 bytes to chars for CharTermAttribute compatibility
+            if (bytes != null) {
+                UnicodeUtil.UTF8toUTF16(bytes, charsRef);
+            } else {
+                charsRef.length = 0;
+            }
         }
 
         @Override
         public void clear() {
+            charsRef.length = 0;
         }
 
         @Override
         public void copyTo(AttributeImpl target) {
             ByteTermAttributeImpl other = (ByteTermAttributeImpl) target;
             other.bytes = bytes;
+            other.charsRef.copyChars(charsRef);
+        }
+
+        // CharTermAttribute implementation
+        @Override
+        public void append(CharSequence csq) {
+            append(csq, 0, csq.length());
+        }
+
+        @Override
+        public void append(CharSequence csq, int start, int end) {
+            int len = end - start;
+            if (len == 0) {
+                return;
+            }
+            resizeBuffer(charsRef.length + len);
+            for (int i = start; i < end; i++) {
+                charsRef.chars[charsRef.length++] = csq.charAt(i);
+            }
+        }
+
+        @Override
+        public void append(char c) {
+            resizeBuffer(charsRef.length + 1);
+            charsRef.chars[charsRef.length++] = c;
+        }
+
+        @Override
+        public void setLength(int length) {
+            if (length > charsRef.chars.length) {
+                throw new IllegalArgumentException("length " + length + " exceeds buffer size " + charsRef.chars.length);
+            }
+            charsRef.length = length;
+        }
+
+        @Override
+        public void setEmpty() {
+            charsRef.length = 0;
+        }
+
+        @Override
+        public char[] buffer() {
+            return charsRef.chars;
+        }
+
+        @Override
+        public char[] resizeBuffer(int newSize) {
+            charsRef.grow(newSize);
+            return charsRef.chars;
+        }
+
+        @Override
+        public int length() {
+            return charsRef.length;
+        }
+
+        @Override
+        public CharSequence subSequence(int start, int end) {
+            return new String(charsRef.chars, start, end - start);
+        }
+
+        @Override
+        public char charAt(int index) {
+            if (index >= charsRef.length) {
+                throw new IndexOutOfBoundsException();
+            }
+            return charsRef.chars[index];
+        }
+
+        @Override
+        public String toString() {
+            return charsRef.toString();
         }
     }
 }
\ No newline at end of file