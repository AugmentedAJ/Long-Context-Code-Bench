{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4496,
  "base_commit": "5a02ec86a8f76c02304b015035c4cffac4474395",
  "runner": "auggie",
  "model": "sonnet4.5",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 220610,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/common/joda/DateMathParser.java b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java\nindex 3e9fec3..8af758a 100644\n--- a/src/main/java/org/elasticsearch/common/joda/DateMathParser.java\n+++ b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java\n@@ -198,7 +198,25 @@ public class DateMathParser {\n \n     private long parseStringValue(String value) {\n         try {\n-            return dateTimeFormatter.parser().parseMillis(value);\n+            // we use 1970-01-01 as the base for partial dates so we can handle searches like 10:12:55 (just time)\n+            // since when we index those, the base is 1970-01-01\n+            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);\n+            int location = dateTimeFormatter.parser().parseInto(dateTime, value, 0);\n+            // if we parsed all the string value, we are good\n+            if (location == value.length()) {\n+                return dateTime.getMillis();\n+            }\n+            // if we did not manage to parse, or the year is really high year which is unreasonable\n+            // see if its a number\n+            if (location <= 0 || dateTime.getYear() > 5000) {\n+                try {\n+                    long time = Long.parseLong(value);\n+                    return timeUnit.toMillis(time);\n+                } catch (NumberFormatException e1) {\n+                    throw new ElasticSearchParseException(\"failed to parse date field [\" + value + \"], tried both date format [\" + dateTimeFormatter.format() + \"], and timestamp number\");\n+                }\n+            }\n+            return dateTime.getMillis();\n         } catch (RuntimeException e) {\n             try {\n                 long time = Long.parseLong(value);\ndiff --git a/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java b/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java\nindex 74e6d9c..a1266d8 100644\n--- a/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java\n+++ b/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java\n@@ -51,6 +51,8 @@ import org.elasticsearch.index.mapper.core.LongFieldMapper.CustomLongNumericFiel\n import org.elasticsearch.index.query.QueryParseContext;\n import org.elasticsearch.index.search.NumericRangeFieldDataFilter;\n import org.elasticsearch.index.similarity.SimilarityProvider;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n \n import java.io.IOException;\n import java.util.List;\n@@ -490,7 +492,25 @@ public class DateFieldMapper extends NumberFieldMapper<Long> {\n \n     private long parseStringValue(String value) {\n         try {\n-            return dateTimeFormatter.parser().parseMillis(value);\n+            // we use 1970-01-01 as the base for partial dates so we can handle values like 10:12:55 (just time)\n+            // since when we index those, the base is 1970-01-01\n+            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);\n+            int location = dateTimeFormatter.parser().parseInto(dateTime, value, 0);\n+            // if we parsed all the string value, we are good\n+            if (location == value.length()) {\n+                return dateTime.getMillis();\n+            }\n+            // if we did not manage to parse, or the year is really high year which is unreasonable\n+            // see if its a number\n+            if (location <= 0 || dateTime.getYear() > 5000) {\n+                try {\n+                    long time = Long.parseLong(value);\n+                    return timeUnit.toMillis(time);\n+                } catch (NumberFormatException e1) {\n+                    throw new MapperParsingException(\"failed to parse date field [\" + value + \"], tried both date format [\" + dateTimeFormatter.format() + \"], and timestamp number with locale [\" + dateTimeFormatter.locale() + \"]\");\n+                }\n+            }\n+            return dateTime.getMillis();\n         } catch (RuntimeException e) {\n             try {\n                 long time = Long.parseLong(value);\ndiff --git a/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java b/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java\nindex 04bce46..fe28842 100644\n--- a/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java\n+++ b/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java\n@@ -25,6 +25,8 @@ import org.elasticsearch.common.joda.Joda;\n import org.elasticsearch.index.mapper.core.DateFieldMapper;\n import org.elasticsearch.index.mapper.ip.IpFieldMapper;\n import org.elasticsearch.search.internal.SearchContext;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n \n import java.util.concurrent.TimeUnit;\n \n@@ -57,7 +59,20 @@ public interface ValueParser {\n \n         @Override\n         public long parseLong(String value, SearchContext searchContext) {\n-            return formatter.parser().parseMillis(value);\n+            // we use 1970-01-01 as the base for partial dates so we can handle values like 10:12:55 (just time)\n+            // since when we index those, the base is 1970-01-01\n+            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);\n+            int location = formatter.parser().parseInto(dateTime, value, 0);\n+            // if we parsed all the string value, we are good\n+            if (location == value.length()) {\n+                return dateTime.getMillis();\n+            }\n+            // if we did not manage to parse, or the year is really high year which is unreasonable\n+            // fall back to parseMillis\n+            if (location <= 0 || dateTime.getYear() > 5000) {\n+                return formatter.parser().parseMillis(value);\n+            }\n+            return dateTime.getMillis();\n         }\n \n         @Override",
  "logs_path": "auggie/sonnet4.5/7ad89f22/elastic_elasticsearch_pr4496/logs.jsonl",
  "errors": [],
  "edit_run_id": "7ad89f22",
  "test_label": "v1-rollouts-1-3-sonnet4.5"
}