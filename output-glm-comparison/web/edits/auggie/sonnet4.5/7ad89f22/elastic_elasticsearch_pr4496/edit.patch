diff --git a/src/main/java/org/elasticsearch/common/joda/DateMathParser.java b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java
index 3e9fec3..8af758a 100644
--- a/src/main/java/org/elasticsearch/common/joda/DateMathParser.java
+++ b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java
@@ -198,7 +198,25 @@ public class DateMathParser {
 
     private long parseStringValue(String value) {
         try {
-            return dateTimeFormatter.parser().parseMillis(value);
+            // we use 1970-01-01 as the base for partial dates so we can handle searches like 10:12:55 (just time)
+            // since when we index those, the base is 1970-01-01
+            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);
+            int location = dateTimeFormatter.parser().parseInto(dateTime, value, 0);
+            // if we parsed all the string value, we are good
+            if (location == value.length()) {
+                return dateTime.getMillis();
+            }
+            // if we did not manage to parse, or the year is really high year which is unreasonable
+            // see if its a number
+            if (location <= 0 || dateTime.getYear() > 5000) {
+                try {
+                    long time = Long.parseLong(value);
+                    return timeUnit.toMillis(time);
+                } catch (NumberFormatException e1) {
+                    throw new ElasticSearchParseException("failed to parse date field [" + value + "], tried both date format [" + dateTimeFormatter.format() + "], and timestamp number");
+                }
+            }
+            return dateTime.getMillis();
         } catch (RuntimeException e) {
             try {
                 long time = Long.parseLong(value);
diff --git a/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java b/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java
index 74e6d9c..a1266d8 100644
--- a/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java
+++ b/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java
@@ -51,6 +51,8 @@ import org.elasticsearch.index.mapper.core.LongFieldMapper.CustomLongNumericFiel
 import org.elasticsearch.index.query.QueryParseContext;
 import org.elasticsearch.index.search.NumericRangeFieldDataFilter;
 import org.elasticsearch.index.similarity.SimilarityProvider;
+import org.joda.time.DateTimeZone;
+import org.joda.time.MutableDateTime;
 
 import java.io.IOException;
 import java.util.List;
@@ -490,7 +492,25 @@ public class DateFieldMapper extends NumberFieldMapper<Long> {
 
     private long parseStringValue(String value) {
         try {
-            return dateTimeFormatter.parser().parseMillis(value);
+            // we use 1970-01-01 as the base for partial dates so we can handle values like 10:12:55 (just time)
+            // since when we index those, the base is 1970-01-01
+            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);
+            int location = dateTimeFormatter.parser().parseInto(dateTime, value, 0);
+            // if we parsed all the string value, we are good
+            if (location == value.length()) {
+                return dateTime.getMillis();
+            }
+            // if we did not manage to parse, or the year is really high year which is unreasonable
+            // see if its a number
+            if (location <= 0 || dateTime.getYear() > 5000) {
+                try {
+                    long time = Long.parseLong(value);
+                    return timeUnit.toMillis(time);
+                } catch (NumberFormatException e1) {
+                    throw new MapperParsingException("failed to parse date field [" + value + "], tried both date format [" + dateTimeFormatter.format() + "], and timestamp number with locale [" + dateTimeFormatter.locale() + "]");
+                }
+            }
+            return dateTime.getMillis();
         } catch (RuntimeException e) {
             try {
                 long time = Long.parseLong(value);
diff --git a/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java b/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java
index 04bce46..fe28842 100644
--- a/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java
+++ b/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java
@@ -25,6 +25,8 @@ import org.elasticsearch.common.joda.Joda;
 import org.elasticsearch.index.mapper.core.DateFieldMapper;
 import org.elasticsearch.index.mapper.ip.IpFieldMapper;
 import org.elasticsearch.search.internal.SearchContext;
+import org.joda.time.DateTimeZone;
+import org.joda.time.MutableDateTime;
 
 import java.util.concurrent.TimeUnit;
 
@@ -57,7 +59,20 @@ public interface ValueParser {
 
         @Override
         public long parseLong(String value, SearchContext searchContext) {
-            return formatter.parser().parseMillis(value);
+            // we use 1970-01-01 as the base for partial dates so we can handle values like 10:12:55 (just time)
+            // since when we index those, the base is 1970-01-01
+            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);
+            int location = formatter.parser().parseInto(dateTime, value, 0);
+            // if we parsed all the string value, we are good
+            if (location == value.length()) {
+                return dateTime.getMillis();
+            }
+            // if we did not manage to parse, or the year is really high year which is unreasonable
+            // fall back to parseMillis
+            if (location <= 0 || dateTime.getYear() > 5000) {
+                return formatter.parser().parseMillis(value);
+            }
+            return dateTime.getMillis();
         }
 
         @Override