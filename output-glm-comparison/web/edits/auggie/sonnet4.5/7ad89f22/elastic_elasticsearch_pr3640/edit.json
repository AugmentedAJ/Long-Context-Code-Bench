{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 3640,
  "base_commit": "4155741f7f486537d4a5f7193d79098d523a6ae8",
  "runner": "auggie",
  "model": "sonnet4.5",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 175673,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\nindex 9764831..a972d06 100644\n--- a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\n+++ b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\n@@ -151,7 +151,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n \n     private volatile BoundTransportAddress boundAddress;\n \n-    private final Object[] connectMutex;\n+    private final ConcurrentMap<String, Object> nodeLocks = newConcurrentMap();\n     // this lock is here to make sure we close this transport and disconnect all the client nodes\n     // connections while no connect operations is going on... (this might help with 100% CPU when stopping the transport?)\n     private final ReadWriteLock globalLock = new ReentrantReadWriteLock();\n@@ -167,11 +167,6 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n             System.setProperty(\"org.jboss.netty.epollBugWorkaround\", \"true\");\n         }\n \n-        this.connectMutex = new Object[500];\n-        for (int i = 0; i < connectMutex.length; i++) {\n-            connectMutex[i] = new Object();\n-        }\n-\n         this.workerCount = componentSettings.getAsInt(\"worker_count\", EsExecutors.boundedNumberOfProcessors() * 2);\n         this.bossCount = componentSettings.getAsInt(\"boss_count\", 1);\n         this.blockingServer = settings.getAsBoolean(\"transport.tcp.blocking_server\", settings.getAsBoolean(TCP_BLOCKING_SERVER, settings.getAsBoolean(TCP_BLOCKING, false)));\n@@ -420,6 +415,8 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n                         clientBootstrap.releaseExternalResources();\n                         clientBootstrap = null;\n                     }\n+\n+                    nodeLocks.clear();\n                 } finally {\n                     globalLock.writeLock().unlock();\n                     latch.countDown();\n@@ -758,6 +755,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n                 } finally {\n                     logger.debug(\"disconnected from [{}]\", node);\n                     transportServiceAdapter.raiseNodeDisconnected(node);\n+                    nodeLocks.remove(node.id());\n                 }\n             }\n         }\n@@ -776,6 +774,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n                 } finally {\n                     logger.debug(\"disconnected from [{}], {}\", node, reason);\n                     transportServiceAdapter.raiseNodeDisconnected(node);\n+                    nodeLocks.remove(node.id());\n                 }\n             }\n         }\n@@ -795,6 +794,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n                     } finally {\n                         logger.debug(\"disconnected from [{}] on channel failure\", failure, node);\n                         transportServiceAdapter.raiseNodeDisconnected(node);\n+                        nodeLocks.remove(node.id());\n                     }\n                 }\n             }\n@@ -810,12 +810,15 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n     }\n \n     private Object connectLock(String nodeId) {\n-        int hash = nodeId.hashCode();\n-        // abs returns Integer.MIN_VALUE, so we need to protect against it...\n-        if (hash == Integer.MIN_VALUE) {\n-            hash = 0;\n+        Object lock = nodeLocks.get(nodeId);\n+        if (lock == null) {\n+            Object newLock = new Object();\n+            lock = nodeLocks.putIfAbsent(nodeId, newLock);\n+            if (lock == null) {\n+                lock = newLock;\n+            }\n         }\n-        return connectMutex[Math.abs(hash) % connectMutex.length];\n+        return lock;\n     }\n \n     private class ChannelCloseListener implements ChannelFutureListener {",
  "logs_path": "auggie/sonnet4.5/7ad89f22/elastic_elasticsearch_pr3640/logs.jsonl",
  "errors": [],
  "edit_run_id": "7ad89f22",
  "test_label": "v1-rollouts-1-3-sonnet4.5"
}