diff --git a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java
index 9764831..a972d06 100644
--- a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java
+++ b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java
@@ -151,7 +151,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
 
     private volatile BoundTransportAddress boundAddress;
 
-    private final Object[] connectMutex;
+    private final ConcurrentMap<String, Object> nodeLocks = newConcurrentMap();
     // this lock is here to make sure we close this transport and disconnect all the client nodes
     // connections while no connect operations is going on... (this might help with 100% CPU when stopping the transport?)
     private final ReadWriteLock globalLock = new ReentrantReadWriteLock();
@@ -167,11 +167,6 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
             System.setProperty("org.jboss.netty.epollBugWorkaround", "true");
         }
 
-        this.connectMutex = new Object[500];
-        for (int i = 0; i < connectMutex.length; i++) {
-            connectMutex[i] = new Object();
-        }
-
         this.workerCount = componentSettings.getAsInt("worker_count", EsExecutors.boundedNumberOfProcessors() * 2);
         this.bossCount = componentSettings.getAsInt("boss_count", 1);
         this.blockingServer = settings.getAsBoolean("transport.tcp.blocking_server", settings.getAsBoolean(TCP_BLOCKING_SERVER, settings.getAsBoolean(TCP_BLOCKING, false)));
@@ -420,6 +415,8 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
                         clientBootstrap.releaseExternalResources();
                         clientBootstrap = null;
                     }
+
+                    nodeLocks.clear();
                 } finally {
                     globalLock.writeLock().unlock();
                     latch.countDown();
@@ -758,6 +755,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
                 } finally {
                     logger.debug("disconnected from [{}]", node);
                     transportServiceAdapter.raiseNodeDisconnected(node);
+                    nodeLocks.remove(node.id());
                 }
             }
         }
@@ -776,6 +774,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
                 } finally {
                     logger.debug("disconnected from [{}], {}", node, reason);
                     transportServiceAdapter.raiseNodeDisconnected(node);
+                    nodeLocks.remove(node.id());
                 }
             }
         }
@@ -795,6 +794,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
                     } finally {
                         logger.debug("disconnected from [{}] on channel failure", failure, node);
                         transportServiceAdapter.raiseNodeDisconnected(node);
+                        nodeLocks.remove(node.id());
                     }
                 }
             }
@@ -810,12 +810,15 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
     }
 
     private Object connectLock(String nodeId) {
-        int hash = nodeId.hashCode();
-        // abs returns Integer.MIN_VALUE, so we need to protect against it...
-        if (hash == Integer.MIN_VALUE) {
-            hash = 0;
+        Object lock = nodeLocks.get(nodeId);
+        if (lock == null) {
+            Object newLock = new Object();
+            lock = nodeLocks.putIfAbsent(nodeId, newLock);
+            if (lock == null) {
+                lock = newLock;
+            }
         }
-        return connectMutex[Math.abs(hash) % connectMutex.length];
+        return lock;
     }
 
     private class ChannelCloseListener implements ChannelFutureListener {