{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134477,
  "base_commit": "1ccb58a8b2b9b38bad0506c49d455dbfcbea9224",
  "runner": "claude-code",
  "model": "claude-sonnet-4-5",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 628424,
  "patch_unified": "diff --git a/server/src/main/java/org/elasticsearch/search/SearchService.java b/server/src/main/java/org/elasticsearch/search/SearchService.java\nindex 9a101d83..82a8a210 100644\n--- a/server/src/main/java/org/elasticsearch/search/SearchService.java\n+++ b/server/src/main/java/org/elasticsearch/search/SearchService.java\n@@ -588,6 +588,7 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n      * @param shardId        id of the shard being searched\n      * @param taskId         id of the task being executed\n      * @param threadPool     with context where to write the new header\n+     * @param lifecycle      lifecycle state of the service to suppress warnings when stopped or closed\n      * @return the wrapped action listener\n      */\n     static <T> ActionListener<T> wrapListenerForErrorHandling(\n@@ -596,7 +597,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n         String nodeId,\n         ShardId shardId,\n         long taskId,\n-        ThreadPool threadPool\n+        ThreadPool threadPool,\n+        Lifecycle lifecycle\n     ) {\n         final boolean header;\n         if (version.onOrAfter(ERROR_TRACE_IN_TRANSPORT_HEADER) && threadPool.getThreadContext() != null) {\n@@ -612,7 +614,10 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n                 taskId\n             );\n             // Keep this logic aligned with that of SUPPRESSED_ERROR_LOGGER in RestResponse\n-            if (ExceptionsHelper.status(e).getStatus() < 500 || ExceptionsHelper.isNodeOrShardUnavailableTypeException(e)) {\n+            // Suppress warnings when the service is stopped or closed to avoid alerting on expected shutdown behavior\n+            if (ExceptionsHelper.status(e).getStatus() < 500\n+                || ExceptionsHelper.isNodeOrShardUnavailableTypeException(e)\n+                || lifecycle.stoppedOrClosed()) {\n                 logger.debug(messageSupplier, e);\n             } else {\n                 logger.warn(messageSupplier, e);\n@@ -643,7 +648,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             clusterService.localNode().getId(),\n             request.shardId(),\n             task.getId(),\n-            threadPool\n+            threadPool,\n+            lifecycle\n         );\n         final IndexShard shard = getShard(request);\n         rewriteAndFetchShardRequest(shard, request, listener.delegateFailure((l, rewritten) -> {\n@@ -705,7 +711,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n                 clusterService.localNode().getId(),\n                 request.shardId(),\n                 task.getId(),\n-                threadPool\n+                threadPool,\n+                lifecycle\n             ).delegateFailure((l, orig) -> {\n                 // check if we can shortcut the query phase entirely.\n                 if (orig.canReturnNullResponseIfMatchNoDocs()) {\n@@ -953,7 +960,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             clusterService.localNode().getId(),\n             shardSearchRequest.shardId(),\n             task.getId(),\n-            threadPool\n+            threadPool,\n+            lifecycle\n         );\n         final Releasable markAsUsed = readerContext.markAsUsed(getKeepAlive(shardSearchRequest));\n         runAsync(getExecutor(readerContext.indexShard()), () -> {\n@@ -1010,7 +1018,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             clusterService.localNode().getId(),\n             readerContext.indexShard().shardId(),\n             task.getId(),\n-            threadPool\n+            threadPool,\n+            lifecycle\n         );\n         final Releasable markAsUsed;\n         try {\n@@ -1072,7 +1081,8 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             clusterService.localNode().getId(),\n             shardSearchRequest.shardId(),\n             task.getId(),\n-            threadPool\n+            threadPool,\n+            lifecycle\n         );\n         final Releasable markAsUsed = readerContext.markAsUsed(getKeepAlive(shardSearchRequest));\n         rewriteAndFetchShardRequest(readerContext.indexShard(), shardSearchRequest, listener.delegateFailure((l, rewritten) -> {\ndiff --git a/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java b/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java\nindex 29380a05..b25eb66f 100644\n--- a/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/SearchServiceTests.java\n@@ -69,6 +69,8 @@ import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.function.BiFunction;\n import java.util.function.Predicate;\n \n+import org.elasticsearch.common.component.Lifecycle;\n+\n import static org.elasticsearch.common.Strings.format;\n import static org.elasticsearch.common.util.concurrent.EsExecutors.DIRECT_EXECUTOR_SERVICE;\n import static org.elasticsearch.search.SearchService.isExecutorQueuedBeyondPrewarmingFactor;\n@@ -160,7 +162,9 @@ public class SearchServiceTests extends IndexShardTestCase {\n         e.fillInStackTrace();\n         assertThat(e.getStackTrace().length, is(not(0)));\n         listener.onFailure(e);\n-        listener = wrapListenerForErrorHandling(listener, TransportVersion.current(), \"node\", shardId, 123L, threadPool);\n+        Lifecycle lifecycle = new Lifecycle();\n+        lifecycle.moveToStarted();\n+        listener = wrapListenerForErrorHandling(listener, TransportVersion.current(), \"node\", shardId, 123L, threadPool, lifecycle);\n         isWrapped.set(true);\n         listener.onFailure(e);\n     }\n@@ -198,7 +202,9 @@ public class SearchServiceTests extends IndexShardTestCase {\n                 }\n             };\n             IllegalArgumentException e = new IllegalArgumentException(exceptionMessage); // 400-level exception\n-            listener = wrapListenerForErrorHandling(listener, TransportVersion.current(), nodeId, shardId, taskId, threadPool);\n+            Lifecycle lifecycle = new Lifecycle();\n+            lifecycle.moveToStarted();\n+            listener = wrapListenerForErrorHandling(listener, TransportVersion.current(), nodeId, shardId, taskId, threadPool, lifecycle);\n             listener.onFailure(e);\n         }\n     }\n@@ -235,7 +241,52 @@ public class SearchServiceTests extends IndexShardTestCase {\n                 }\n             };\n             IllegalStateException e = new IllegalStateException(exceptionMessage); // 500-level exception\n-            listener = wrapListenerForErrorHandling(listener, TransportVersion.current(), nodeId, shardId, taskId, threadPool);\n+            Lifecycle lifecycle = new Lifecycle();\n+            lifecycle.moveToStarted();\n+            listener = wrapListenerForErrorHandling(listener, TransportVersion.current(), nodeId, shardId, taskId, threadPool, lifecycle);\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    public void testWrapListenerForErrorHandlingSuppressWarnWhenStopped() {\n+        final String nodeId = \"node\";\n+        final String index = \"index\";\n+        ShardId shardId = new ShardId(index, index, 0);\n+        final long taskId = 123L;\n+\n+        try (var mockLog = MockLog.capture(SearchService.class)) {\n+            Configurator.setLevel(SearchService.class, Level.DEBUG);\n+            final String exceptionMessage = \"test exception message\";\n+            // We expect DEBUG level, not WARN, even though this is a 500-level exception\n+            // because the service is stopped\n+            mockLog.addExpectation(\n+                new MockLog.ExceptionSeenEventExpectation(\n+                    format(\"\\\"[%s]%s: failed to execute search request for task [%d]\\\" and an exception logged\", nodeId, shardId, taskId),\n+                    SearchService.class.getCanonicalName(),\n+                    Level.DEBUG, // Should be DEBUG when service is stopped, even for 500-level exceptions\n+                    format(\"[%s]%s: failed to execute search request for task [%d]\", nodeId, shardId, taskId),\n+                    IllegalStateException.class,\n+                    exceptionMessage\n+                )\n+            );\n+\n+            // Tests the listener logs at DEBUG level when the service is stopped\n+            ActionListener<SearchPhaseResult> listener = new ActionListener<>() {\n+                @Override\n+                public void onResponse(SearchPhaseResult searchPhaseResult) {\n+                    // noop - we only care about failure scenarios\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    mockLog.assertAllExpectationsMatched();\n+                }\n+            };\n+            IllegalStateException e = new IllegalStateException(exceptionMessage); // 500-level exception\n+            Lifecycle lifecycle = new Lifecycle();\n+            lifecycle.moveToStarted();\n+            lifecycle.moveToStopped(); // Service is stopped\n+            listener = wrapListenerForErrorHandling(listener, TransportVersion.current(), nodeId, shardId, taskId, threadPool, lifecycle);\n             listener.onFailure(e);\n         }\n     }",
  "logs_path": "claude-code/claude-sonnet-4-5/8d6f99fc/elastic_elasticsearch_pr134477/logs.jsonl",
  "errors": [],
  "edit_run_id": "8d6f99fc",
  "test_label": "v1-rollouts-1-3-sonnet4.5"
}