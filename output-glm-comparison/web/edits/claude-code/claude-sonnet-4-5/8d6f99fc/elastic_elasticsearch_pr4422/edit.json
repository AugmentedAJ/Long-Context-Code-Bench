{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4422,
  "base_commit": "bb275166f1a1f20f5330691ab854d6dc61c51366",
  "runner": "claude-code",
  "model": "claude-sonnet-4-5",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 264817,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexResponse.java b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexResponse.java\nindex 7052861..59fdd23 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexResponse.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexResponse.java\n@@ -19,7 +19,7 @@\n \n package org.elasticsearch.action.admin.indices.create;\n \n-import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n \n@@ -28,34 +28,24 @@ import java.io.IOException;\n /**\n  * A response for a create index action.\n  */\n-public class CreateIndexResponse extends ActionResponse {\n-\n-    private boolean acknowledged;\n+public class CreateIndexResponse extends AcknowledgedResponse {\n \n     CreateIndexResponse() {\n     }\n \n     CreateIndexResponse(boolean acknowledged) {\n-        this.acknowledged = acknowledged;\n-    }\n-\n-    /**\n-     * Has the index creation been acknowledged by all current cluster nodes within the\n-     * provided {@link CreateIndexRequest#timeout(org.elasticsearch.common.unit.TimeValue)}.\n-     */\n-    public boolean isAcknowledged() {\n-        return acknowledged;\n+        super(acknowledged);\n     }\n \n     @Override\n     public void readFrom(StreamInput in) throws IOException {\n         super.readFrom(in);\n-        acknowledged = in.readBoolean();\n+        readAcknowledged(in);\n     }\n \n     @Override\n     public void writeTo(StreamOutput out) throws IOException {\n         super.writeTo(out);\n-        out.writeBoolean(acknowledged);\n+        writeAcknowledged(out);\n     }\n }\ndiff --git a/src/main/java/org/elasticsearch/cluster/ClusterModule.java b/src/main/java/org/elasticsearch/cluster/ClusterModule.java\nindex 5edfa23..ae123dd 100644\n--- a/src/main/java/org/elasticsearch/cluster/ClusterModule.java\n+++ b/src/main/java/org/elasticsearch/cluster/ClusterModule.java\n@@ -71,7 +71,6 @@ public class ClusterModule extends AbstractModule implements SpawnModules {\n         bind(RoutingService.class).asEagerSingleton();\n \n         bind(ShardStateAction.class).asEagerSingleton();\n-        bind(NodeIndexCreatedAction.class).asEagerSingleton();\n         bind(NodeIndexDeletedAction.class).asEagerSingleton();\n         bind(NodeMappingRefreshAction.class).asEagerSingleton();\n         bind(MappingUpdatedAction.class).asEagerSingleton();\ndiff --git a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\nindex a394166..573d789 100644\n--- a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\n+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\n@@ -33,7 +33,6 @@ import org.elasticsearch.action.support.master.MasterNodeOperationRequest;\n import org.elasticsearch.cluster.ClusterService;\n import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.TimeoutClusterStateUpdateTask;\n-import org.elasticsearch.cluster.action.index.NodeIndexCreatedAction;\n import org.elasticsearch.cluster.block.ClusterBlock;\n import org.elasticsearch.cluster.block.ClusterBlocks;\n import org.elasticsearch.cluster.routing.RoutingTable;\n@@ -69,11 +68,9 @@ import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.util.*;\n-import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n import static com.google.common.collect.Maps.newHashMap;\n import static org.elasticsearch.cluster.metadata.IndexMetaData.*;\n@@ -89,21 +86,19 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n     private final ClusterService clusterService;\n     private final IndicesService indicesService;\n     private final AllocationService allocationService;\n-    private final NodeIndexCreatedAction nodeIndexCreatedAction;\n     private final MetaDataService metaDataService;\n     private final Version version;\n     private final String riverIndexName;\n \n     @Inject\n     public MetaDataCreateIndexService(Settings settings, Environment environment, ThreadPool threadPool, ClusterService clusterService, IndicesService indicesService,\n-                                      AllocationService allocationService, NodeIndexCreatedAction nodeIndexCreatedAction, MetaDataService metaDataService, Version version, @RiverIndexName String riverIndexName) {\n+                                      AllocationService allocationService, MetaDataService metaDataService, Version version, @RiverIndexName String riverIndexName) {\n         super(settings);\n         this.environment = environment;\n         this.threadPool = threadPool;\n         this.clusterService = clusterService;\n         this.indicesService = indicesService;\n         this.allocationService = allocationService;\n-        this.nodeIndexCreatedAction = nodeIndexCreatedAction;\n         this.metaDataService = metaDataService;\n         this.version = version;\n         this.riverIndexName = riverIndexName;\n@@ -360,31 +355,6 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n                         updatedState = ClusterState.builder(updatedState).routingResult(routingResult).build();\n                     }\n \n-                    // we wait for events from all nodes that the index has been added to the metadata\n-                    final AtomicInteger counter = new AtomicInteger(currentState.nodes().size());\n-\n-                    final NodeIndexCreatedAction.Listener nodeIndexCreatedListener = new NodeIndexCreatedAction.Listener() {\n-                        @Override\n-                        public void onNodeIndexCreated(String index, String nodeId) {\n-                            if (index.equals(request.index)) {\n-                                if (counter.decrementAndGet() == 0) {\n-                                    listener.onResponse(new Response(true, indexMetaData));\n-                                    nodeIndexCreatedAction.remove(this);\n-                                }\n-                            }\n-                        }\n-                    };\n-\n-                    nodeIndexCreatedAction.add(nodeIndexCreatedListener);\n-\n-                    listener.future = threadPool.schedule(request.timeout, ThreadPool.Names.SAME, new Runnable() {\n-                        @Override\n-                        public void run() {\n-                            listener.onResponse(new Response(false, indexMetaData));\n-                            nodeIndexCreatedAction.remove(nodeIndexCreatedListener);\n-                        }\n-                    });\n-\n                     return updatedState;\n                 } finally {\n                     if (indexCreated) {\n@@ -396,6 +366,7 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n \n             @Override\n             public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n+                listener.onResponse(new Response(true, indexMetaData));\n             }\n         });\n     }\n@@ -406,7 +377,6 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n         private final Semaphore mdLock;\n         private final Request request;\n         private final Listener listener;\n-        volatile ScheduledFuture future;\n \n         private CreateIndexListener(Semaphore mdLock, Request request, Listener listener) {\n             this.mdLock = mdLock;\n@@ -418,9 +388,6 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n         public void onResponse(final Response response) {\n             if (notified.compareAndSet(false, true)) {\n                 mdLock.release();\n-                if (future != null) {\n-                    future.cancel(false);\n-                }\n                 listener.onResponse(response);\n             }\n         }\n@@ -429,9 +396,6 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n         public void onFailure(Throwable t) {\n             if (notified.compareAndSet(false, true)) {\n                 mdLock.release();\n-                if (future != null) {\n-                    future.cancel(false);\n-                }\n                 listener.onFailure(t);\n             }\n         }\ndiff --git a/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\nindex d559b94..14f2805 100644\n--- a/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\n+++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\n@@ -28,7 +28,6 @@ import org.elasticsearch.ExceptionsHelper;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n import org.elasticsearch.cluster.ClusterService;\n import org.elasticsearch.cluster.ClusterStateListener;\n-import org.elasticsearch.cluster.action.index.NodeIndexCreatedAction;\n import org.elasticsearch.cluster.action.index.NodeIndexDeletedAction;\n import org.elasticsearch.cluster.action.index.NodeMappingRefreshAction;\n import org.elasticsearch.cluster.action.shard.ShardStateAction;\n@@ -86,7 +85,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n     private final ThreadPool threadPool;\n     private final RecoveryTarget recoveryTarget;\n     private final ShardStateAction shardStateAction;\n-    private final NodeIndexCreatedAction nodeIndexCreatedAction;\n     private final NodeIndexDeletedAction nodeIndexDeletedAction;\n     private final NodeMappingRefreshAction nodeMappingRefreshAction;\n \n@@ -117,7 +115,7 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n     public IndicesClusterStateService(Settings settings, IndicesService indicesService, ClusterService clusterService,\n                                       ThreadPool threadPool, RecoveryTarget recoveryTarget,\n                                       ShardStateAction shardStateAction,\n-                                      NodeIndexCreatedAction nodeIndexCreatedAction, NodeIndexDeletedAction nodeIndexDeletedAction,\n+                                      NodeIndexDeletedAction nodeIndexDeletedAction,\n                                       NodeMappingRefreshAction nodeMappingRefreshAction) {\n         super(settings);\n         this.indicesService = indicesService;\n@@ -125,7 +123,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n         this.threadPool = threadPool;\n         this.recoveryTarget = recoveryTarget;\n         this.shardStateAction = shardStateAction;\n-        this.nodeIndexCreatedAction = nodeIndexCreatedAction;\n         this.nodeIndexDeletedAction = nodeIndexDeletedAction;\n         this.nodeMappingRefreshAction = nodeMappingRefreshAction;\n \n@@ -193,13 +190,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n     private void sendIndexLifecycleEvents(final ClusterChangedEvent event) {\n         String localNodeId = event.state().nodes().localNodeId();\n         assert localNodeId != null;\n-        for (String index : event.indicesCreated()) {\n-            try {\n-                nodeIndexCreatedAction.nodeIndexCreated(event.state(), index, localNodeId);\n-            } catch (Throwable e) {\n-                logger.debug(\"failed to send to master index {} created event\", e, index);\n-            }\n-        }\n         for (String index : event.indicesDeleted()) {\n             try {\n                 nodeIndexDeletedAction.nodeIndexDeleted(event.state(), index, localNodeId);\ndiff --git a/src/main/java/org/elasticsearch/rest/action/admin/indices/create/RestCreateIndexAction.java b/src/main/java/org/elasticsearch/rest/action/admin/indices/create/RestCreateIndexAction.java\nindex 90cb970..5f97bf4 100644\n--- a/src/main/java/org/elasticsearch/rest/action/admin/indices/create/RestCreateIndexAction.java\n+++ b/src/main/java/org/elasticsearch/rest/action/admin/indices/create/RestCreateIndexAction.java\n@@ -19,20 +19,15 @@\n \n package org.elasticsearch.rest.action.admin.indices.create;\n \n-import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;\n import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.rest.*;\n-import org.elasticsearch.rest.action.support.RestXContentBuilder;\n \n import java.io.IOException;\n \n-import static org.elasticsearch.rest.RestStatus.OK;\n-\n /**\n  *\n  */\n@@ -66,29 +61,6 @@ public class RestCreateIndexAction extends BaseRestHandler {\n         createIndexRequest.timeout(request.paramAsTime(\"timeout\", createIndexRequest.timeout()));\n         createIndexRequest.masterNodeTimeout(request.paramAsTime(\"master_timeout\", createIndexRequest.masterNodeTimeout()));\n \n-        client.admin().indices().create(createIndexRequest, new ActionListener<CreateIndexResponse>() {\n-            @Override\n-            public void onResponse(CreateIndexResponse response) {\n-                try {\n-                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n-                    builder.startObject()\n-                            .field(\"ok\", true)\n-                            .field(\"acknowledged\", response.isAcknowledged())\n-                            .endObject();\n-                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n-                } catch (Throwable e) {\n-                    onFailure(e);\n-                }\n-            }\n-\n-            @Override\n-            public void onFailure(Throwable e) {\n-                try {\n-                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n-                } catch (IOException e1) {\n-                    logger.error(\"Failed to send failure response\", e1);\n-                }\n-            }\n-        });\n+        client.admin().indices().create(createIndexRequest, new AcknowledgedRestResponseActionListener<CreateIndexResponse>(request, channel, logger));\n     }\n }",
  "logs_path": "claude-code/claude-sonnet-4-5/8d6f99fc/elastic_elasticsearch_pr4422/logs.jsonl",
  "errors": [],
  "edit_run_id": "8d6f99fc",
  "test_label": "v1-rollouts-1-3-sonnet4.5"
}