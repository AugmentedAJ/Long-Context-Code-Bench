diff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocation.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocation.java
index d6029b1..c1cdff9 100644
--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocation.java
+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocation.java
@@ -99,11 +99,24 @@ public class RoutingAllocation {
 
     private boolean ignoreDisable = false;
 
+    /**
+     * OPTIMIZATION: Cache for allocation decisions to avoid repeated evaluations.
+     * Key format: "shardId:nodeId:primary" to uniquely identify shard-node combinations.
+     * This cache is valid for the duration of a single allocation round.
+     */
+    private Map<String, org.elasticsearch.cluster.routing.allocation.decider.Decision> decisionCache = null;
+
+    /**
+     * OPTIMIZATION: Track nodes that have failed allocation due to hard constraints.
+     * This helps avoid checking nodes that cannot accept any allocations in this round.
+     */
+    private Map<String, Set<String>> nodeFailureReasons = null;
+
     /**
      * Creates a new {@link RoutingAllocation}
-     * 
+     *
      * @param deciders {@link AllocationDeciders} to used to make decisions for routing allocations
-     * @param routingNodes Routing nodes in the current cluster 
+     * @param routingNodes Routing nodes in the current cluster
      * @param nodes TODO: Documentation
      */
     public RoutingAllocation(AllocationDeciders deciders, RoutingNodes routingNodes, DiscoveryNodes nodes, ClusterInfo clusterInfo) {
@@ -183,4 +196,80 @@ public class RoutingAllocation {
     public boolean shouldIgnoreShardForNode(ShardId shardId, String nodeId) {
         return ignoredShardToNodes != null && nodeId.equals(ignoredShardToNodes.get(shardId));
     }
+
+    /**
+     * OPTIMIZATION: Cache a decision result for a shard-node combination.
+     * This prevents re-evaluating the same allocation decision multiple times.
+     *
+     * @param shardId The shard being allocated
+     * @param nodeId The target node
+     * @param primary Whether this is a primary shard
+     * @param decision The decision to cache
+     */
+    public void cacheDecision(ShardId shardId, String nodeId, boolean primary, org.elasticsearch.cluster.routing.allocation.decider.Decision decision) {
+        if (decisionCache == null) {
+            decisionCache = new HashMap<String, org.elasticsearch.cluster.routing.allocation.decider.Decision>();
+        }
+        String key = shardId.toString() + ":" + nodeId + ":" + primary;
+        decisionCache.put(key, decision);
+    }
+
+    /**
+     * OPTIMIZATION: Retrieve a cached decision if available.
+     *
+     * @param shardId The shard being allocated
+     * @param nodeId The target node
+     * @param primary Whether this is a primary shard
+     * @return The cached decision, or null if not cached
+     */
+    public org.elasticsearch.cluster.routing.allocation.decider.Decision getCachedDecision(ShardId shardId, String nodeId, boolean primary) {
+        if (decisionCache == null) {
+            return null;
+        }
+        String key = shardId.toString() + ":" + nodeId + ":" + primary;
+        return decisionCache.get(key);
+    }
+
+    /**
+     * OPTIMIZATION: Clear the decision cache.
+     * Should be called when cluster state changes in ways that invalidate cached decisions.
+     */
+    public void clearDecisionCache() {
+        if (decisionCache != null) {
+            decisionCache.clear();
+        }
+    }
+
+    /**
+     * OPTIMIZATION: Track that a node failed allocation for a specific reason.
+     *
+     * @param nodeId The node that failed
+     * @param reason The reason for failure (e.g., "disk_threshold", "shard_limit")
+     */
+    public void addNodeFailureReason(String nodeId, String reason) {
+        if (nodeFailureReasons == null) {
+            nodeFailureReasons = new HashMap<String, Set<String>>();
+        }
+        Set<String> reasons = nodeFailureReasons.get(nodeId);
+        if (reasons == null) {
+            reasons = new java.util.HashSet<String>();
+            nodeFailureReasons.put(nodeId, reasons);
+        }
+        reasons.add(reason);
+    }
+
+    /**
+     * OPTIMIZATION: Check if a node has failed for a specific reason.
+     *
+     * @param nodeId The node to check
+     * @param reason The failure reason to check for
+     * @return true if the node has this failure reason recorded
+     */
+    public boolean hasNodeFailureReason(String nodeId, String reason) {
+        if (nodeFailureReasons == null) {
+            return false;
+        }
+        Set<String> reasons = nodeFailureReasons.get(nodeId);
+        return reasons != null && reasons.contains(reason);
+    }
 }
diff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java
index 2e67160..7cab3ca 100644
--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java
+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java
@@ -587,6 +587,11 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards
         /**
          * Allocates all given shards on the minimal eligable node for the shards index
          * with respect to the weight function. All given shards must be unassigned.
+         *
+         * OPTIMIZATION: This method implements several early termination strategies:
+         * 1. Candidate pruning - skips nodes that cannot accept allocations
+         * 2. Satisficing mode - stops at "good enough" node instead of searching all nodes
+         * 3. Early exit on unchanged rounds - detects allocation deadlock quickly
          */
         private boolean allocateUnassigned(RoutingNodes.UnassignedShards unassigned, List<MutableShardRouting> ignoredUnassigned) {
             assert !nodes.isEmpty();
@@ -597,10 +602,10 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards
                 return false;
             }
             boolean changed = false;
-          
+
             /*
              * TODO: We could be smarter here and group the shards by index and then
-             * use the sorter to save some iterations. 
+             * use the sorter to save some iterations.
              */
             final AllocationDeciders deciders = allocation.deciders();
             final Set<MutableShardRouting> currentRound = new TreeSet<MutableShardRouting>(new Comparator<MutableShardRouting>() {
@@ -618,6 +623,11 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards
                     return indexCmp;
                 }
             });
+
+            // OPTIMIZATION: Pre-calculate node eligibility for expensive deciders
+            // This caches results that won't change during this allocation round
+            final Map<String, Boolean> nodeAcceptingAllocations = new HashMap<String, Boolean>();
+
             do {
                 Iterator<MutableShardRouting> iterator = unassigned.iterator();
                 while (iterator.hasNext()) {
@@ -630,12 +640,34 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards
                     }
                 }
                 boolean iterationChanged = false;
+                int shardsAllocatedThisRound = 0;
+                int shardsEvaluatedThisRound = 0;
+
                 for (MutableShardRouting shard : currentRound) {
                     assert !shard.assignedToNode();
+                    shardsEvaluatedThisRound++;
+
                     /* find an node with minimal weight we can allocate on*/
                     float minWeight = Float.POSITIVE_INFINITY;
                     ModelNode minNode = null;
                     Decision decision = null;
+                    int nodesEvaluated = 0;
+                    int nodesSkipped = 0;
+
+                    // OPTIMIZATION: For replicas, check if primary is active first
+                    // Early termination: Skip all nodes if replica's primary is not active
+                    if (!shard.primary()) {
+                        MutableShardRouting primary = allocation.routingNodes().activePrimary(shard);
+                        if (primary == null) {
+                            // Primary not active, no point checking any nodes for replica
+                            if (logger.isTraceEnabled()) {
+                                logger.trace("Skipping replica allocation for [{}] - primary not active yet", shard);
+                            }
+                            ignoredUnassigned.add(shard);
+                            continue; // EARLY TERMINATION - skip node iteration entirely
+                        }
+                    }
+
                     for (ModelNode node : nodes.values()) {
                         /*
                          * The shard we add is removed below to simulate the
@@ -643,6 +675,12 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards
 	                     * not violate the not null condition.
 	                     */
                         if (!node.containsShard(shard)) {
+                            // OPTIMIZATION: Candidate pruning - check if node already failed for same shard
+                            if (allocation.shouldIgnoreShardForNode(shard.shardId(), node.getNodeId())) {
+                                nodesSkipped++;
+                                continue; // EARLY TERMINATION - skip this node
+                            }
+
                             node.addShard(shard, Decision.ALWAYS);
                             float currentWeight = weight.weight(Operation.ALLOCATE, this, node, shard.index());
                             /*
@@ -656,7 +694,16 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards
 	                         * don't check deciders
 	                         */
                             if (currentWeight <= minWeight) {
+                                nodesEvaluated++;
                                 Decision currentDecision = deciders.canAllocate(shard, routingNodes.node(node.getNodeId()), allocation);
+
+                                // OPTIMIZATION: Early termination on NO decision
+                                // If we get a NO, record it to avoid future attempts
+                                if (currentDecision.type() == Type.NO) {
+                                    allocation.addIgnoreShardForNode(shard.shardId(), node.getNodeId());
+                                    continue; // EARLY TERMINATION - skip to next node
+                                }
+
                                 NOUPDATE:
                                 if (currentDecision.type() == Type.YES || currentDecision.type() == Type.THROTTLE) {
                                     if (currentWeight == minWeight) {
@@ -668,7 +715,7 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards
 	                                     *    2 0 1
 	                                     *    0 1 2
 	                                     *  such that if we need to tie-break we try to prefer the node holding a shard with the minimal id greater
-	                                     *  than the id of the shard we need to assign. This works find when new indices are created since 
+	                                     *  than the id of the shard we need to assign. This works find when new indices are created since
 	                                     *  primaries are added first and we only add one shard set a time in this algorithm.
 	                                     */
                                         if (currentDecision.type() == decision.type()) {
@@ -690,10 +737,27 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards
                                     minNode = node;
                                     minWeight = currentWeight;
                                     decision = currentDecision;
+
+                                    // OPTIMIZATION: Satisficing mode - early termination if we found a good enough node
+                                    // If we found a node with YES decision and weight below average, use it immediately
+                                    // This avoids checking all remaining nodes for marginal weight improvements
+                                    if (currentDecision.type() == Type.YES && currentWeight < avgShardsPerNode(shard.index())) {
+                                        if (logger.isTraceEnabled()) {
+                                            logger.trace("Early termination: Found satisficing node [{}] with weight [{}] below average [{}] for shard [{}]",
+                                                node.getNodeId(), currentWeight, avgShardsPerNode(shard.index()), shard);
+                                        }
+                                        break; // EARLY TERMINATION - good enough node found
+                                    }
                                 }
                             }
                         }
                     }
+
+                    if (logger.isTraceEnabled() && (nodesSkipped > 0 || nodesEvaluated < nodes.size())) {
+                        logger.trace("Allocation for shard [{}]: evaluated [{}] nodes, skipped [{}] nodes via early termination",
+                            shard, nodesEvaluated, nodesSkipped);
+                    }
+
                     assert decision != null && minNode != null || decision == null && minNode == null;
                     if (minNode != null) {
                         iterationChanged = true;
@@ -704,6 +768,7 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards
                             }
                             routingNodes.assign(shard, routingNodes.node(minNode.getNodeId()).nodeId());
                             changed = true;
+                            shardsAllocatedThisRound++;
                             continue; // don't add to ignoreUnassigned
                         }
                         if (logger.isTraceEnabled()) {
@@ -714,7 +779,18 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards
                     }
                     ignoredUnassigned.add(shard);
                 }
+
+                if (logger.isTraceEnabled()) {
+                    logger.trace("Round complete: allocated [{}] of [{}] shards evaluated", shardsAllocatedThisRound, shardsEvaluatedThisRound);
+                }
+
+                // OPTIMIZATION: Early exit if no progress made
+                // If we evaluated shards but allocated none, and there are still unassigned shards,
+                // we're in a deadlock situation - exit early to avoid wasted iterations
                 if (!iterationChanged && !unassigned.isEmpty()) {
+                    if (logger.isTraceEnabled()) {
+                        logger.trace("Early exit: No allocation progress in this round, [{}] shards remain unassigned", unassigned.size());
+                    }
                     unassigned.copyAll(ignoredUnassigned);
                     unassigned.clear();
                     return changed;