diff --git a/src/main/java/org/elasticsearch/search/highlight/FastVectorHighlighter.java b/src/main/java/org/elasticsearch/search/highlight/FastVectorHighlighter.java
index 7763753..496678b 100644
--- a/src/main/java/org/elasticsearch/search/highlight/FastVectorHighlighter.java
+++ b/src/main/java/org/elasticsearch/search/highlight/FastVectorHighlighter.java
@@ -121,7 +121,15 @@ public class FastVectorHighlighter implements Highlighter {
                     // fragment builders are used explicitly
                     cache.fvh = new org.apache.lucene.search.vectorhighlight.FastVectorHighlighter();
                 }
-                CustomFieldQuery.highlightFilters.set(field.highlightFilter());
+                cache.mappers.put(mapper, entry);
+            }
+
+            // Set up the FieldQuery - use custom highlight query if provided, otherwise use cached query
+            CustomFieldQuery.highlightFilters.set(field.highlightFilter());
+            if (field.highlightQuery() != null) {
+                // If a custom highlight query is provided, create a new FieldQuery instead of using cached one
+                fieldQuery = new CustomFieldQuery(field.highlightQuery(), hitContext.topLevelReader(), true, field.requireFieldMatch());
+            } else {
                 if (field.requireFieldMatch()) {
                     if (cache.fieldMatchFieldQuery == null) {
                         // we use top level reader to rewrite the query against all readers, with use caching it across hits (and across readers...)
@@ -135,7 +143,6 @@ public class FastVectorHighlighter implements Highlighter {
                     }
                     fieldQuery = cache.noFieldMatchFieldQuery;
                 }
-                cache.mappers.put(mapper, entry);
             }
 
             String[] fragments;
diff --git a/src/main/java/org/elasticsearch/search/highlight/HighlightBuilder.java b/src/main/java/org/elasticsearch/search/highlight/HighlightBuilder.java
index 4e0ccc6..ad7b975 100644
--- a/src/main/java/org/elasticsearch/search/highlight/HighlightBuilder.java
+++ b/src/main/java/org/elasticsearch/search/highlight/HighlightBuilder.java
@@ -21,6 +21,7 @@ package org.elasticsearch.search.highlight;
 
 import org.elasticsearch.common.xcontent.ToXContent;
 import org.elasticsearch.common.xcontent.XContentBuilder;
+import org.elasticsearch.index.query.QueryBuilder;
 
 import java.io.IOException;
 import java.util.List;
@@ -282,6 +283,10 @@ public class HighlightBuilder implements ToXContent {
                 if (field.options != null && field.options.size() > 0) {
                     builder.field("options", field.options);
                 }
+                if (field.highlightQuery != null) {
+                    builder.field("highlight_query");
+                    field.highlightQuery.toXContent(builder, params);
+                }
 
                 builder.endObject();
             }
@@ -307,6 +312,7 @@ public class HighlightBuilder implements ToXContent {
         String highlighterType;
         String fragmenter;
         Map<String, Object> options;
+        QueryBuilder highlightQuery;
 
         public Field(String name) {
             this.name = name;
@@ -408,5 +414,14 @@ public class HighlightBuilder implements ToXContent {
             this.options = options;
             return this;
         }
+
+        /**
+         * Sets a query to be used for highlighting instead of the search query.
+         * This is useful when you want to highlight different terms than those used in the search.
+         */
+        public Field highlightQuery(QueryBuilder highlightQuery) {
+            this.highlightQuery = highlightQuery;
+            return this;
+        }
     }
 }
diff --git a/src/main/java/org/elasticsearch/search/highlight/HighlighterParseElement.java b/src/main/java/org/elasticsearch/search/highlight/HighlighterParseElement.java
index edceffc..31f5a68 100644
--- a/src/main/java/org/elasticsearch/search/highlight/HighlighterParseElement.java
+++ b/src/main/java/org/elasticsearch/search/highlight/HighlighterParseElement.java
@@ -20,6 +20,7 @@
 package org.elasticsearch.search.highlight;
 
 import com.google.common.collect.Lists;
+import org.apache.lucene.search.Query;
 import org.apache.lucene.search.vectorhighlight.SimpleBoundaryScanner;
 import org.elasticsearch.common.xcontent.XContentParser;
 import org.elasticsearch.search.SearchParseElement;
@@ -185,8 +186,13 @@ public class HighlighterParseElement implements SearchParseElement {
                                     } else if ("fragmenter".equals(fieldName)) {
                                         field.fragmenter(parser.text());
                                     }
-                                } else if (fieldName.equals("options")) {
-                                    field.options(parser.map());
+                                } else if (token == XContentParser.Token.START_OBJECT) {
+                                    if ("highlight_query".equals(fieldName) || "highlightQuery".equals(fieldName)) {
+                                        Query highlightQuery = context.queryParserService().parse(parser).query();
+                                        field.highlightQuery(highlightQuery);
+                                    } else if ("options".equals(fieldName)) {
+                                        field.options(parser.map());
+                                    }
                                 }
                             }
                             fields.add(field);
diff --git a/src/main/java/org/elasticsearch/search/highlight/PlainHighlighter.java b/src/main/java/org/elasticsearch/search/highlight/PlainHighlighter.java
index ff1d0f8..d4eae3b 100644
--- a/src/main/java/org/elasticsearch/search/highlight/PlainHighlighter.java
+++ b/src/main/java/org/elasticsearch/search/highlight/PlainHighlighter.java
@@ -62,17 +62,24 @@ public class PlainHighlighter implements Highlighter {
 
         Encoder encoder = field.encoder().equals("html") ? Encoders.HTML : Encoders.DEFAULT;
 
-        if (!hitContext.cache().containsKey(CACHE_KEY)) {
-            Map<FieldMapper<?>, org.apache.lucene.search.highlight.Highlighter> mappers = Maps.newHashMap();
-            hitContext.cache().put(CACHE_KEY, mappers);
+        org.apache.lucene.search.highlight.Highlighter entry;
+        // Don't use cache if a custom highlight query is provided, since the query is part of the highlighter state
+        if (field.highlightQuery() == null) {
+            if (!hitContext.cache().containsKey(CACHE_KEY)) {
+                Map<FieldMapper<?>, org.apache.lucene.search.highlight.Highlighter> mappers = Maps.newHashMap();
+                hitContext.cache().put(CACHE_KEY, mappers);
+            }
+            Map<FieldMapper<?>, org.apache.lucene.search.highlight.Highlighter> cache = (Map<FieldMapper<?>, org.apache.lucene.search.highlight.Highlighter>) hitContext.cache().get(CACHE_KEY);
+            entry = cache.get(mapper);
+        } else {
+            entry = null;
         }
-        Map<FieldMapper<?>, org.apache.lucene.search.highlight.Highlighter> cache = (Map<FieldMapper<?>, org.apache.lucene.search.highlight.Highlighter>) hitContext.cache().get(CACHE_KEY);
 
-        org.apache.lucene.search.highlight.Highlighter entry = cache.get(mapper);
         if (entry == null) {
             // Don't use the context.query() since it might be rewritten, and we need to pass the non rewritten queries to
             // let the highlighter handle MultiTerm ones
-            Query query = context.parsedQuery().query();
+            // Use custom highlight query if provided, otherwise use the search query
+            Query query = field.highlightQuery() != null ? field.highlightQuery() : context.parsedQuery().query();
             QueryScorer queryScorer = new CustomQueryScorer(query, field.requireFieldMatch() ? mapper.names().indexName() : null);
             queryScorer.setExpandMultiTermQuery(true);
             Fragmenter fragmenter;
@@ -94,7 +101,11 @@ public class PlainHighlighter implements Highlighter {
             // always highlight across all data
             entry.setMaxDocCharsToAnalyze(Integer.MAX_VALUE);
 
-            cache.put(mapper, entry);
+            // Only cache if not using a custom highlight query
+            if (field.highlightQuery() == null) {
+                Map<FieldMapper<?>, org.apache.lucene.search.highlight.Highlighter> cache = (Map<FieldMapper<?>, org.apache.lucene.search.highlight.Highlighter>) hitContext.cache().get(CACHE_KEY);
+                cache.put(mapper, entry);
+            }
         }
 
         List<Object> textsToHighlight;
diff --git a/src/main/java/org/elasticsearch/search/highlight/SearchContextHighlight.java b/src/main/java/org/elasticsearch/search/highlight/SearchContextHighlight.java
index 04e71d2..c88f198 100644
--- a/src/main/java/org/elasticsearch/search/highlight/SearchContextHighlight.java
+++ b/src/main/java/org/elasticsearch/search/highlight/SearchContextHighlight.java
@@ -19,6 +19,8 @@
 
 package org.elasticsearch.search.highlight;
 
+import org.apache.lucene.search.Query;
+
 import java.util.List;
 import java.util.Map;
 
@@ -68,6 +70,8 @@ public class SearchContextHighlight {
 
         private Map<String, Object> options;
 
+        private Query highlightQuery;
+
         public Field(String field) {
             this.field = field;
         }
@@ -187,5 +191,13 @@ public class SearchContextHighlight {
         public void options(Map<String, Object> options) {
             this.options = options;
         }
+
+        public Query highlightQuery() {
+            return highlightQuery;
+        }
+
+        public void highlightQuery(Query highlightQuery) {
+            this.highlightQuery = highlightQuery;
+        }
     }
 }