diff --git a/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java b/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java
index 89f4ab7..3ddd02e 100644
--- a/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java
+++ b/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java
@@ -19,8 +19,11 @@
 
 package org.elasticsearch.test.integration.ttl;
 
+import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;
 import org.elasticsearch.action.get.GetResponse;
 import org.elasticsearch.client.Client;
+import org.elasticsearch.cluster.routing.IndexRoutingTable;
+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.common.xcontent.XContentFactory;
 import org.elasticsearch.test.integration.AbstractNodesTests;
@@ -119,4 +122,262 @@ public class SimpleTTLTests extends AbstractNodesTests {
         getResponse = client.prepareGet("test", "type1", "1").setFields("_ttl").setRealtime(false).execute().actionGet();
         assertThat(getResponse.exists(), equalTo(false));
     }
+
+    @Test
+    public void testTTLWithRouting() throws Exception {
+        client.admin().indices().prepareDelete().execute().actionGet();
+
+        client.admin().indices().prepareCreate("test")
+                .setSettings(settingsBuilder()
+                        .put("index.number_of_shards", 5)
+                        .put("index.number_of_replicas", 1))
+                .addMapping("type1", XContentFactory.jsonBuilder()
+                        .startObject()
+                        .startObject("type1")
+                        .startObject("_timestamp").field("enabled", true).field("store", "yes").endObject()
+                        .startObject("_ttl").field("enabled", true).field("store", "yes").endObject()
+                        .endObject()
+                        .endObject())
+                .execute().actionGet();
+        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();
+
+        long providedTTLValue = 3000;
+        logger.info("--> indexing with routing [0]");
+        client.prepareIndex("test", "type1", "1").setRouting("0").setSource("field1", "value1").setTTL(providedTTLValue).setRefresh(true).execute().actionGet();
+        logger.info("--> indexing with routing [1]");
+        client.prepareIndex("test", "type1", "2").setRouting("1").setSource("field1", "value2").setTTL(providedTTLValue).setRefresh(true).execute().actionGet();
+        logger.info("--> indexing with routing [2]");
+        client.prepareIndex("test", "type1", "3").setRouting("2").setSource("field1", "value3").setTTL(providedTTLValue).setRefresh(true).execute().actionGet();
+
+        long now = System.currentTimeMillis();
+
+        // verify documents exist with correct routing
+        logger.info("--> verifying documents exist with routing");
+        GetResponse getResponse = client.prepareGet("test", "type1", "1").setRouting("0").setFields("_ttl").execute().actionGet();
+        assertThat(getResponse.exists(), equalTo(true));
+        getResponse = client.prepareGet("test", "type1", "2").setRouting("1").setFields("_ttl").execute().actionGet();
+        assertThat(getResponse.exists(), equalTo(true));
+        getResponse = client.prepareGet("test", "type1", "3").setRouting("2").setFields("_ttl").execute().actionGet();
+        assertThat(getResponse.exists(), equalTo(true));
+
+        // verify documents don't exist without routing (unless they happen to hash to the same shard)
+        logger.info("--> verifying documents may not be found without routing");
+        getResponse = client.prepareGet("test", "type1", "1").setFields("_ttl").execute().actionGet();
+        // Note: document might be found without routing if ID "1" hashes to same shard as routing "0"
+        // but most likely will not be found
+
+        logger.info("--> waiting for expiration and purge");
+        // wait for expiration
+        long shouldBeExpiredDate = now + providedTTLValue + purgeInterval + 2000;
+        long now1 = System.currentTimeMillis();
+        if (shouldBeExpiredDate - now1 > 0) {
+            Thread.sleep(shouldBeExpiredDate - now1);
+        }
+
+        // verify all documents are deleted from all shards
+        logger.info("--> verifying all routed documents are purged");
+        getResponse = client.prepareGet("test", "type1", "1").setRouting("0").setFields("_ttl").execute().actionGet();
+        assertThat(getResponse.exists(), equalTo(false));
+        getResponse = client.prepareGet("test", "type1", "2").setRouting("1").setFields("_ttl").execute().actionGet();
+        assertThat(getResponse.exists(), equalTo(false));
+        getResponse = client.prepareGet("test", "type1", "3").setRouting("2").setFields("_ttl").execute().actionGet();
+        assertThat(getResponse.exists(), equalTo(false));
+    }
+
+    @Test
+    public void testTTLWithRequiredRouting() throws Exception {
+        client.admin().indices().prepareDelete().execute().actionGet();
+
+        client.admin().indices().prepareCreate("test")
+                .setSettings(settingsBuilder()
+                        .put("index.number_of_shards", 5)
+                        .put("index.number_of_replicas", 1))
+                .addMapping("type1", XContentFactory.jsonBuilder()
+                        .startObject()
+                        .startObject("type1")
+                        .startObject("_timestamp").field("enabled", true).field("store", "yes").endObject()
+                        .startObject("_ttl").field("enabled", true).field("store", "yes").endObject()
+                        .startObject("_routing").field("required", true).endObject()
+                        .endObject()
+                        .endObject())
+                .execute().actionGet();
+        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();
+
+        long providedTTLValue = 3000;
+        logger.info("--> indexing documents with required routing");
+        client.prepareIndex("test", "type1", "1").setRouting("routing_value_1").setSource("field1", "value1").setTTL(providedTTLValue).setRefresh(true).execute().actionGet();
+        client.prepareIndex("test", "type1", "2").setRouting("routing_value_2").setSource("field1", "value2").setTTL(providedTTLValue).setRefresh(true).execute().actionGet();
+
+        long now = System.currentTimeMillis();
+
+        // verify documents exist with routing
+        logger.info("--> verifying documents exist with correct routing");
+        GetResponse getResponse = client.prepareGet("test", "type1", "1").setRouting("routing_value_1").setFields("_ttl").execute().actionGet();
+        assertThat(getResponse.exists(), equalTo(true));
+        long ttl = ((Number) getResponse.field("_ttl").value()).longValue();
+        assertThat(ttl, greaterThan(0L));
+        assertThat(ttl, lessThanOrEqualTo(providedTTLValue));
+
+        getResponse = client.prepareGet("test", "type1", "2").setRouting("routing_value_2").setFields("_ttl").execute().actionGet();
+        assertThat(getResponse.exists(), equalTo(true));
+        ttl = ((Number) getResponse.field("_ttl").value()).longValue();
+        assertThat(ttl, greaterThan(0L));
+        assertThat(ttl, lessThanOrEqualTo(providedTTLValue));
+
+        logger.info("--> waiting for expiration and purge");
+        // wait for expiration
+        long shouldBeExpiredDate = now + providedTTLValue + purgeInterval + 2000;
+        long now1 = System.currentTimeMillis();
+        if (shouldBeExpiredDate - now1 > 0) {
+            Thread.sleep(shouldBeExpiredDate - now1);
+        }
+
+        // verify documents are deleted even with required routing
+        logger.info("--> verifying documents with required routing are purged");
+        getResponse = client.prepareGet("test", "type1", "1").setRouting("routing_value_1").setFields("_ttl").execute().actionGet();
+        assertThat(getResponse.exists(), equalTo(false));
+        getResponse = client.prepareGet("test", "type1", "2").setRouting("routing_value_2").setFields("_ttl").execute().actionGet();
+        assertThat(getResponse.exists(), equalTo(false));
+    }
+
+    @Test
+    public void testTTLWithPathBasedRouting() throws Exception {
+        client.admin().indices().prepareDelete().execute().actionGet();
+
+        client.admin().indices().prepareCreate("test")
+                .setSettings(settingsBuilder()
+                        .put("index.number_of_shards", 5)
+                        .put("index.number_of_replicas", 1))
+                .addMapping("type1", XContentFactory.jsonBuilder()
+                        .startObject()
+                        .startObject("type1")
+                        .startObject("_timestamp").field("enabled", true).field("store", "yes").endObject()
+                        .startObject("_ttl").field("enabled", true).field("store", "yes").endObject()
+                        .startObject("_routing").field("required", true).field("path", "routing_field").endObject()
+                        .endObject()
+                        .endObject())
+                .execute().actionGet();
+        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();
+
+        long providedTTLValue = 3000;
+        logger.info("--> indexing documents with path-based routing");
+        client.prepareIndex("test", "type1", "1")
+                .setSource("field1", "value1", "routing_field", "route_a")
+                .setTTL(providedTTLValue)
+                .setRefresh(true)
+                .execute().actionGet();
+        client.prepareIndex("test", "type1", "2")
+                .setSource("field1", "value2", "routing_field", "route_b")
+                .setTTL(providedTTLValue)
+                .setRefresh(true)
+                .execute().actionGet();
+
+        long now = System.currentTimeMillis();
+
+        // verify documents exist with path-based routing
+        logger.info("--> verifying documents exist with path-based routing");
+        GetResponse getResponse = client.prepareGet("test", "type1", "1").setRouting("route_a").setFields("_ttl").execute().actionGet();
+        assertThat(getResponse.exists(), equalTo(true));
+        long ttl = ((Number) getResponse.field("_ttl").value()).longValue();
+        assertThat(ttl, greaterThan(0L));
+        assertThat(ttl, lessThanOrEqualTo(providedTTLValue));
+
+        getResponse = client.prepareGet("test", "type1", "2").setRouting("route_b").setFields("_ttl").execute().actionGet();
+        assertThat(getResponse.exists(), equalTo(true));
+        ttl = ((Number) getResponse.field("_ttl").value()).longValue();
+        assertThat(ttl, greaterThan(0L));
+        assertThat(ttl, lessThanOrEqualTo(providedTTLValue));
+
+        logger.info("--> waiting for expiration and purge");
+        // wait for expiration
+        long shouldBeExpiredDate = now + providedTTLValue + purgeInterval + 2000;
+        long now1 = System.currentTimeMillis();
+        if (shouldBeExpiredDate - now1 > 0) {
+            Thread.sleep(shouldBeExpiredDate - now1);
+        }
+
+        // verify documents are deleted with path-based routing
+        logger.info("--> verifying documents with path-based routing are purged");
+        getResponse = client.prepareGet("test", "type1", "1").setRouting("route_a").setFields("_ttl").execute().actionGet();
+        assertThat(getResponse.exists(), equalTo(false));
+        getResponse = client.prepareGet("test", "type1", "2").setRouting("route_b").setFields("_ttl").execute().actionGet();
+        assertThat(getResponse.exists(), equalTo(false));
+    }
+
+    @Test
+    public void testTTLWithMultipleShards() throws Exception {
+        client.admin().indices().prepareDelete().execute().actionGet();
+
+        client.admin().indices().prepareCreate("test")
+                .setSettings(settingsBuilder()
+                        .put("index.number_of_shards", 5)
+                        .put("index.number_of_replicas", 1))
+                .addMapping("type1", XContentFactory.jsonBuilder()
+                        .startObject()
+                        .startObject("type1")
+                        .startObject("_timestamp").field("enabled", true).field("store", "yes").endObject()
+                        .startObject("_ttl").field("enabled", true).field("store", "yes").endObject()
+                        .endObject()
+                        .endObject())
+                .execute().actionGet();
+        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();
+
+        long providedTTLValue = 3000;
+        logger.info("--> indexing multiple documents to ensure distribution across shards");
+
+        // Index enough documents to ensure they're distributed across multiple shards
+        for (int i = 0; i < 25; i++) {
+            client.prepareIndex("test", "type1", String.valueOf(i))
+                    .setSource("field1", "value" + i)
+                    .setTTL(providedTTLValue)
+                    .execute().actionGet();
+        }
+        client.admin().indices().prepareRefresh().execute().actionGet();
+
+        long now = System.currentTimeMillis();
+
+        // Verify documents are distributed across shards
+        logger.info("--> verifying documents are distributed across shards");
+        ClusterStateResponse clusterState = client.admin().cluster().prepareState().execute().actionGet();
+        IndexRoutingTable indexRouting = clusterState.state().routingTable().index("test");
+        int shardsWithDocs = 0;
+        for (IndexShardRoutingTable shardRouting : indexRouting) {
+            // Check if this shard has any documents by attempting a search
+            long count = client.prepareCount("test")
+                    .setPreference("_shards:" + shardRouting.shardId().id())
+                    .execute().actionGet().count();
+            if (count > 0) {
+                shardsWithDocs++;
+                logger.info("--> shard [{}] has [{}] documents", shardRouting.shardId().id(), count);
+            }
+        }
+        assertThat("Documents should be distributed across multiple shards", shardsWithDocs, greaterThan(1));
+
+        // Verify all documents exist
+        logger.info("--> verifying all documents exist");
+        for (int i = 0; i < 25; i++) {
+            GetResponse getResponse = client.prepareGet("test", "type1", String.valueOf(i)).execute().actionGet();
+            assertThat("Document " + i + " should exist", getResponse.exists(), equalTo(true));
+        }
+
+        logger.info("--> waiting for expiration and purge across all shards");
+        // wait for expiration
+        long shouldBeExpiredDate = now + providedTTLValue + purgeInterval + 2000;
+        long now1 = System.currentTimeMillis();
+        if (shouldBeExpiredDate - now1 > 0) {
+            Thread.sleep(shouldBeExpiredDate - now1);
+        }
+
+        // verify all documents are deleted from all shards
+        logger.info("--> verifying all documents are purged from all shards");
+        for (int i = 0; i < 25; i++) {
+            GetResponse getResponse = client.prepareGet("test", "type1", String.valueOf(i)).execute().actionGet();
+            assertThat("Document " + i + " should be purged", getResponse.exists(), equalTo(false));
+        }
+
+        // Verify all shards have been purged
+        logger.info("--> verifying all shards have been purged");
+        long totalCount = client.prepareCount("test").execute().actionGet().count();
+        assertThat("All documents should be purged from all shards", totalCount, equalTo(0L));
+    }
 }