{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4496,
  "base_commit": "5a02ec86a8f76c02304b015035c4cffac4474395",
  "runner": "claude-code",
  "model": "claude-sonnet-4-5",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 220678,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/common/joda/DateMathParser.java b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java\nindex 3e9fec3..12176ce 100644\n--- a/src/main/java/org/elasticsearch/common/joda/DateMathParser.java\n+++ b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java\n@@ -198,7 +198,20 @@ public class DateMathParser {\n \n     private long parseStringValue(String value) {\n         try {\n-            return dateTimeFormatter.parser().parseMillis(value);\n+            // Use 1970-01-01 as the base for partial dates to be consistent with parseRoundCeilStringValue\n+            // This ensures partial dates without year default to 1970 instead of 2000\n+            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);\n+            int location = dateTimeFormatter.parser().parseInto(dateTime, value, 0);\n+            // if we parsed the entire string value, we are good\n+            if (location == value.length()) {\n+                return dateTime.getMillis();\n+            }\n+            // if we did not manage to parse, or the year is unreasonably high, try parsing as a number\n+            if (location <= 0 || dateTime.getYear() > 5000) {\n+                long time = Long.parseLong(value);\n+                return timeUnit.toMillis(time);\n+            }\n+            return dateTime.getMillis();\n         } catch (RuntimeException e) {\n             try {\n                 long time = Long.parseLong(value);\ndiff --git a/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java b/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java\nindex 74e6d9c..269aafa 100644\n--- a/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java\n+++ b/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java\n@@ -51,6 +51,8 @@ import org.elasticsearch.index.mapper.core.LongFieldMapper.CustomLongNumericFiel\n import org.elasticsearch.index.query.QueryParseContext;\n import org.elasticsearch.index.search.NumericRangeFieldDataFilter;\n import org.elasticsearch.index.similarity.SimilarityProvider;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n \n import java.io.IOException;\n import java.util.List;\n@@ -490,7 +492,20 @@ public class DateFieldMapper extends NumberFieldMapper<Long> {\n \n     private long parseStringValue(String value) {\n         try {\n-            return dateTimeFormatter.parser().parseMillis(value);\n+            // Use 1970-01-01 as the base for partial dates to ensure consistency\n+            // This ensures partial dates without year default to 1970 instead of 2000\n+            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);\n+            int location = dateTimeFormatter.parser().parseInto(dateTime, value, 0);\n+            // if we parsed the entire string value, we are good\n+            if (location == value.length()) {\n+                return dateTime.getMillis();\n+            }\n+            // if we did not manage to parse, or the year is unreasonably high, try parsing as a number\n+            if (location <= 0 || dateTime.getYear() > 5000) {\n+                long time = Long.parseLong(value);\n+                return timeUnit.toMillis(time);\n+            }\n+            return dateTime.getMillis();\n         } catch (RuntimeException e) {\n             try {\n                 long time = Long.parseLong(value);",
  "logs_path": "claude-code/claude-sonnet-4-5/8d6f99fc/elastic_elasticsearch_pr4496/logs.jsonl",
  "errors": [],
  "edit_run_id": "8d6f99fc",
  "test_label": "v1-rollouts-1-3-sonnet4.5"
}