diff --git a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/release/SetCompatibleVersionsTask.java b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/release/SetCompatibleVersionsTask.java
index f2fa39ce..afbe130a 100644
--- a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/release/SetCompatibleVersionsTask.java
+++ b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/release/SetCompatibleVersionsTask.java
@@ -9,22 +9,13 @@
 
 package org.elasticsearch.gradle.internal.release;
 
-import com.github.javaparser.StaticJavaParser;
-import com.github.javaparser.ast.CompilationUnit;
-import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
-import com.github.javaparser.ast.expr.NameExpr;
-import com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter;
-
 import org.elasticsearch.gradle.Version;
 import org.gradle.api.tasks.TaskAction;
 import org.gradle.api.tasks.options.Option;
 import org.gradle.initialization.layout.BuildLayout;
 
-import java.io.IOException;
-import java.nio.file.Path;
 import java.util.List;
 import java.util.Map;
-import java.util.Optional;
 
 import javax.inject.Inject;
 
@@ -54,48 +45,7 @@ public class SetCompatibleVersionsTask extends AbstractVersionsTask {
     }
 
     @TaskAction
-    public void executeTask() throws IOException {
-        if (versionIds.isEmpty()) {
-            throw new IllegalArgumentException("No version ids specified");
-        }
-
-        if (releaseVersion.getMajor() < thisVersion.getMajor()) {
-            // don't need to update CCS version - this is for a different major
-            return;
-        }
-
-        Integer transportVersion = versionIds.get(TRANSPORT_VERSION_TYPE);
-        if (transportVersion == null) {
-            throw new IllegalArgumentException("TransportVersion id not specified");
-        }
-        Path versionJava = rootDir.resolve(TRANSPORT_VERSIONS_FILE_PATH);
-        CompilationUnit file = LexicalPreservingPrinter.setup(StaticJavaParser.parse(versionJava));
-
-        Optional<CompilationUnit> modifiedFile;
-
-        modifiedFile = setMinimumCcsTransportVersion(file, transportVersion);
-
-        if (modifiedFile.isPresent()) {
-            writeOutNewContents(versionJava, modifiedFile.get());
-        }
-    }
-
-    static Optional<CompilationUnit> setMinimumCcsTransportVersion(CompilationUnit unit, int transportVersion) {
-        ClassOrInterfaceDeclaration transportVersions = unit.getClassByName("TransportVersions").get();
-
-        String tvConstantName = transportVersions.getFields().stream().filter(f -> {
-            var i = findSingleIntegerExpr(f);
-            return i.isPresent() && i.getAsInt() == transportVersion;
-        })
-            .map(f -> f.getVariable(0).getNameAsString())
-            .findFirst()
-            .orElseThrow(() -> new IllegalStateException("Could not find constant for id " + transportVersion));
-
-        transportVersions.getFieldByName("MINIMUM_CCS_VERSION")
-            .orElseThrow(() -> new IllegalStateException("Could not find MINIMUM_CCS_VERSION constant"))
-            .getVariable(0)
-            .setInitializer(new NameExpr(tvConstantName));
-
-        return Optional.of(unit);
+    public void executeTask() {
+        // No-op: This task will be removed with the new transport version system
     }
 }