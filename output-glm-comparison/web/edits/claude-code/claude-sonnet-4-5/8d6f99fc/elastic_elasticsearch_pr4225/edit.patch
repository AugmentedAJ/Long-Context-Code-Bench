diff --git a/src/main/java/org/elasticsearch/common/geo/GeoDistance.java b/src/main/java/org/elasticsearch/common/geo/GeoDistance.java
index 0ded558..755a4e5 100644
--- a/src/main/java/org/elasticsearch/common/geo/GeoDistance.java
+++ b/src/main/java/org/elasticsearch/common/geo/GeoDistance.java
@@ -19,6 +19,7 @@
 
 package org.elasticsearch.common.geo;
 
+import org.apache.lucene.util.SloppyMath;
 import org.elasticsearch.ElasticSearchIllegalArgumentException;
 import org.elasticsearch.common.unit.DistanceUnit;
 
@@ -75,18 +76,15 @@ public enum GeoDistance {
     ARC() {
         @Override
         public double calculate(double sourceLatitude, double sourceLongitude, double targetLatitude, double targetLongitude, DistanceUnit unit) {
-            double longitudeDifference = targetLongitude - sourceLongitude;
-            double a = Math.toRadians(90D - sourceLatitude);
-            double c = Math.toRadians(90D - targetLatitude);
-            double factor = (Math.cos(a) * Math.cos(c)) + (Math.sin(a) * Math.sin(c) * Math.cos(Math.toRadians(longitudeDifference)));
-
-            if (factor < -1D) {
-                return Math.PI * unit.getEarthRadius();
-            } else if (factor >= 1D) {
-                return 0;
-            } else {
-                return Math.acos(factor) * unit.getEarthRadius();
-            }
+            // SloppyMath.haversinMeters expects coordinates in radians and returns distance in meters
+            double distanceInMeters = SloppyMath.haversinMeters(
+                Math.toRadians(sourceLatitude),
+                Math.toRadians(sourceLongitude),
+                Math.toRadians(targetLatitude),
+                Math.toRadians(targetLongitude)
+            );
+            // Convert from meters to the requested unit
+            return DistanceUnit.METERS.convert(distanceInMeters, unit);
         }
 
         @Override
@@ -293,34 +291,30 @@ public enum GeoDistance {
 
         private final double sourceLatitude;
         private final double sourceLongitude;
-        private final double earthRadius;
+        private final DistanceUnit unit;
 
-        private final double a;
-        private final double sinA;
-        private final double cosA;
+        private final double sourceLatRad;
+        private final double sourceLonRad;
 
         public ArcFixedSourceDistance(double sourceLatitude, double sourceLongitude, DistanceUnit unit) {
             this.sourceLatitude = sourceLatitude;
             this.sourceLongitude = sourceLongitude;
-            this.earthRadius = unit.getEarthRadius();
-            this.a = Math.toRadians(90D - sourceLatitude);
-            this.sinA = Math.sin(a);
-            this.cosA = Math.cos(a);
+            this.unit = unit;
+            this.sourceLatRad = Math.toRadians(sourceLatitude);
+            this.sourceLonRad = Math.toRadians(sourceLongitude);
         }
 
         @Override
         public double calculate(double targetLatitude, double targetLongitude) {
-            double longitudeDifference = targetLongitude - sourceLongitude;
-            double c = Math.toRadians(90D - targetLatitude);
-            double factor = (cosA * Math.cos(c)) + (sinA * Math.sin(c) * Math.cos(Math.toRadians(longitudeDifference)));
-
-            if (factor < -1D) {
-                return Math.PI * earthRadius;
-            } else if (factor >= 1D) {
-                return 0;
-            } else {
-                return Math.acos(factor) * earthRadius;
-            }
+            // SloppyMath.haversinMeters expects coordinates in radians and returns distance in meters
+            double distanceInMeters = SloppyMath.haversinMeters(
+                sourceLatRad,
+                sourceLonRad,
+                Math.toRadians(targetLatitude),
+                Math.toRadians(targetLongitude)
+            );
+            // Convert from meters to the requested unit
+            return DistanceUnit.METERS.convert(distanceInMeters, unit);
         }
     }
 }