diff --git a/server/src/main/java/org/elasticsearch/TransportVersion.java b/server/src/main/java/org/elasticsearch/TransportVersion.java
index f130f7d6..b7e32505 100644
--- a/server/src/main/java/org/elasticsearch/TransportVersion.java
+++ b/server/src/main/java/org/elasticsearch/TransportVersion.java
@@ -239,11 +239,110 @@ public record TransportVersion(String name, int id, TransportVersion nextPatchVe
     public static TransportVersion fromName(String name) {
         TransportVersion known = VersionsHolder.ALL_VERSIONS_BY_NAME.get(name);
         if (known == null) {
-            throw new IllegalStateException("unknown transport version [" + name + "]");
+            String suggestions = findSimilarVersionNames(name, 3);
+            String message = "unknown transport version [" + name + "]";
+            if (suggestions.isEmpty() == false) {
+                message += ". Did you mean: " + suggestions + "?";
+            }
+            throw new IllegalStateException(message);
         }
         return known;
     }
 
+    /**
+     * Finds similar version names to the given input using Levenshtein distance.
+     * Returns up to {@code maxSuggestions} similar names, sorted by similarity.
+     *
+     * @param input the input version name to compare against
+     * @param maxSuggestions the maximum number of suggestions to return
+     * @return a comma-separated string of similar version names, or empty string if none found
+     */
+    private static String findSimilarVersionNames(String input, int maxSuggestions) {
+        if (input == null || input.isEmpty()) {
+            return "";
+        }
+
+        record Suggestion(String name, int distance) implements Comparable<Suggestion> {
+            @Override
+            public int compareTo(Suggestion other) {
+                int distanceCompare = Integer.compare(this.distance, other.distance);
+                if (distanceCompare != 0) {
+                    return distanceCompare;
+                }
+                return this.name.compareTo(other.name);
+            }
+        }
+
+        var suggestions = new java.util.TreeSet<Suggestion>();
+        int maxDistance = Math.max(3, input.length() / 2); // Allow up to half the string length or 3 characters difference
+
+        for (String availableName : VersionsHolder.ALL_VERSIONS_BY_NAME.keySet()) {
+            int distance = levenshteinDistance(input.toLowerCase(), availableName.toLowerCase());
+            if (distance <= maxDistance) {
+                suggestions.add(new Suggestion(availableName, distance));
+            }
+        }
+
+        return suggestions.stream().limit(maxSuggestions).map(Suggestion::name).collect(java.util.stream.Collectors.joining(", "));
+    }
+
+    /**
+     * Calculates the Levenshtein distance between two strings.
+     * This measures the minimum number of single-character edits (insertions, deletions, or substitutions)
+     * required to change one string into the other.
+     *
+     * @param s1 the first string
+     * @param s2 the second string
+     * @return the Levenshtein distance between the two strings
+     */
+    private static int levenshteinDistance(String s1, String s2) {
+        int len1 = s1.length();
+        int len2 = s2.length();
+
+        // Optimization: if the strings are identical, return 0
+        if (s1.equals(s2)) {
+            return 0;
+        }
+
+        // Optimization: if one string is empty, return the length of the other
+        if (len1 == 0) {
+            return len2;
+        }
+        if (len2 == 0) {
+            return len1;
+        }
+
+        // Create a matrix to store distances
+        int[] previousRow = new int[len2 + 1];
+        int[] currentRow = new int[len2 + 1];
+
+        // Initialize the first row
+        for (int j = 0; j <= len2; j++) {
+            previousRow[j] = j;
+        }
+
+        // Calculate distances
+        for (int i = 1; i <= len1; i++) {
+            currentRow[0] = i;
+
+            for (int j = 1; j <= len2; j++) {
+                int substitutionCost = s1.charAt(i - 1) == s2.charAt(j - 1) ? 0 : 1;
+
+                currentRow[j] = Math.min(
+                    Math.min(currentRow[j - 1] + 1, previousRow[j] + 1), // insertion or deletion
+                    previousRow[j - 1] + substitutionCost                 // substitution
+                );
+            }
+
+            // Swap rows
+            int[] temp = previousRow;
+            previousRow = currentRow;
+            currentRow = temp;
+        }
+
+        return previousRow[len2];
+    }
+
     public static void writeVersion(TransportVersion version, StreamOutput out) throws IOException {
         out.writeVInt(version.id);
     }
diff --git a/server/src/test/java/org/elasticsearch/TransportVersionTests.java b/server/src/test/java/org/elasticsearch/TransportVersionTests.java
index e51ca0c5..ba18aa6d 100644
--- a/server/src/test/java/org/elasticsearch/TransportVersionTests.java
+++ b/server/src/test/java/org/elasticsearch/TransportVersionTests.java
@@ -391,4 +391,49 @@ public class TransportVersionTests extends ESTestCase {
         );
         assertThat(new TransportVersion(null, 1000000, null).supports(test3), is(true));
     }
+
+    public void testFromNameWithUnknownVersionSuggestsSimilar() {
+        // First, we need to ensure there are some named versions available for testing
+        // We'll test with actual named versions if they exist, or create a test scenario
+
+        // Test with a completely unknown name that should provide suggestions
+        IllegalStateException exception = expectThrows(IllegalStateException.class, () -> TransportVersion.fromName("unknown_version"));
+        assertThat(exception.getMessage(), containsString("unknown transport version [unknown_version]"));
+
+        // If there are named versions in the system, the error might contain suggestions
+        // This is a basic test that the error message format is correct
+    }
+
+    public void testFromNameWithTypoSuggestsSimilar() {
+        // Create a test with synthetic data to verify suggestion logic
+        // This test checks that if named versions exist and we have a typo, we get suggestions
+
+        // Test with null - should not crash and should return empty suggestions
+        IllegalStateException exception = expectThrows(IllegalStateException.class, () -> TransportVersion.fromName(""));
+        assertThat(exception.getMessage(), containsString("unknown transport version []"));
+
+        // The actual suggestion logic is tested indirectly through the fromName method
+        // If named versions are available in the system, typos should trigger suggestions
+    }
+
+    public void testFromNameWithExactMatch() {
+        // This test verifies that exact matches still work correctly
+        // We can only test this if named versions are actually registered
+
+        // First check if there are any named versions available
+        if (TransportVersion.getAllVersions().stream().anyMatch(tv -> tv.name() != null)) {
+            // There are named versions, so let's try to find one
+            TransportVersion namedVersion = TransportVersion.getAllVersions()
+                .stream()
+                .filter(tv -> tv.name() != null)
+                .findFirst()
+                .orElse(null);
+
+            if (namedVersion != null) {
+                // Test that we can retrieve it by name
+                TransportVersion retrieved = TransportVersion.fromName(namedVersion.name());
+                assertThat(retrieved, is(namedVersion));
+            }
+        }
+    }
 }