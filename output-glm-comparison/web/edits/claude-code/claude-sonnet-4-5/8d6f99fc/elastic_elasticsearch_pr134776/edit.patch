diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/Authentication.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/Authentication.java
index ac543c4f..6d1831a7 100644
--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/Authentication.java
+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/Authentication.java
@@ -551,6 +551,46 @@ public final class Authentication implements ToXContentObject {
         return effectiveSubject.getType() == Subject.Type.CROSS_CLUSTER_ACCESS;
     }
 
+    /**
+     * Checks if this authentication has a request-scoped token.
+     * Request-scoped tokens limit the authentication to specific operations or resources.
+     *
+     * @return true if the authentication is scoped to a specific request or operation
+     */
+    public boolean isRequestScoped() {
+        final Object requestScoped = getAuthenticatingSubject().getMetadata().get(AuthenticationField.REQUEST_SCOPED_TOKEN_KEY);
+        return requestScoped instanceof Boolean && (Boolean) requestScoped;
+    }
+
+    /**
+     * Gets the request scope associated with this authentication, if any.
+     * The scope defines what operations or resources this authentication is limited to.
+     *
+     * @return the request scope string, or null if not request-scoped
+     */
+    @Nullable
+    public String getRequestScope() {
+        if (isRequestScoped()) {
+            final Object scope = getAuthenticatingSubject().getMetadata().get(AuthenticationField.REQUEST_SCOPED_TOKEN_SCOPE_KEY);
+            return scope instanceof String ? (String) scope : null;
+        }
+        return null;
+    }
+
+    /**
+     * Checks if this authentication's request scope matches the given scope.
+     *
+     * @param expectedScope the scope to check against
+     * @return true if the authentication has the specified scope
+     */
+    public boolean hasRequestScope(String expectedScope) {
+        if (expectedScope == null || expectedScope.isEmpty()) {
+            return false;
+        }
+        final String actualScope = getRequestScope();
+        return expectedScope.equals(actualScope);
+    }
+
     /**
      * Whether the authentication can run-as another user
      */
@@ -1354,12 +1394,9 @@ public final class Authentication implements ToXContentObject {
 
     public static Authentication newServiceAccountAuthentication(User serviceAccountUser, String nodeName, Map<String, Object> metadata) {
         // TODO make the service account user a separate class/interface
-        final Authentication.RealmRef authenticatedBy = newServiceAccountRealmRef(nodeName);
-        Authentication authentication = new Authentication(
-            new Subject(serviceAccountUser, authenticatedBy, TransportVersion.current(), metadata),
-            AuthenticationType.TOKEN
-        );
-        return authentication;
+        // Create an AuthenticationResult wrapping the service account user
+        final AuthenticationResult<User> authResult = AuthenticationResult.success(serviceAccountUser, metadata);
+        return newUnifiedAuthentication(authResult, nodeName, AuthenticationType.TOKEN, Subject.Type.SERVICE_ACCOUNT);
     }
 
     public static Authentication newRealmAuthentication(User user, RealmRef realmRef) {
@@ -1389,25 +1426,77 @@ public final class Authentication implements ToXContentObject {
     }
 
     public static Authentication newCloudApiKeyAuthentication(AuthenticationResult<User> authResult, String nodeName) {
-        assert authResult.isAuthenticated() : "cloud API Key authn result must be successful";
-        final User apiKeyUser = authResult.getValue();
-        final Authentication.RealmRef authenticatedBy = newCloudApiKeyRealmRef(nodeName);
-        return new Authentication(
-            new Subject(apiKeyUser, authenticatedBy, TransportVersion.current(), authResult.getMetadata()),
-            AuthenticationType.API_KEY
-        );
+        return newUnifiedAuthentication(authResult, nodeName, AuthenticationType.API_KEY, Subject.Type.CLOUD_API_KEY);
     }
 
     public static Authentication newApiKeyAuthentication(AuthenticationResult<User> authResult, String nodeName) {
-        assert authResult.isAuthenticated() : "API Key authn result must be successful";
-        final User apiKeyUser = authResult.getValue();
-        assert apiKeyUser.roles().length == 0 : "The user associated to an API key authentication must have no role";
-        final Authentication.RealmRef authenticatedBy = newApiKeyRealmRef(nodeName);
-        Authentication authentication = new Authentication(
-            new Subject(apiKeyUser, authenticatedBy, TransportVersion.current(), authResult.getMetadata()),
-            AuthenticationType.API_KEY
+        return newUnifiedAuthentication(authResult, nodeName, AuthenticationType.API_KEY, Subject.Type.API_KEY);
+    }
+
+    /**
+     * Unified authentication creation method that supports both User and API Key authentication types
+     * with request-scoped tokens. This method consolidates the logic for creating authentications
+     * and allows for flexible scoping of tokens at request time.
+     *
+     * @param authResult The authentication result containing the user and metadata
+     * @param nodeName The name of the node creating the authentication
+     * @param authType The authentication type (REALM, API_KEY, TOKEN)
+     * @param subjectType The subject type (USER, API_KEY, CLOUD_API_KEY, etc.)
+     * @param requestScope Optional scope to limit the authentication to specific operations
+     * @return A new Authentication object with the specified configuration
+     */
+    public static Authentication newUnifiedAuthentication(
+        AuthenticationResult<User> authResult,
+        String nodeName,
+        AuthenticationType authType,
+        Subject.Type subjectType,
+        @Nullable String requestScope
+    ) {
+        assert authResult.isAuthenticated() : "Authentication result must be successful";
+
+        final User user = authResult.getValue();
+        final Map<String, Object> metadata = new HashMap<>(authResult.getMetadata());
+
+        // Add request scope to metadata if provided
+        if (requestScope != null && !requestScope.isEmpty()) {
+            metadata.put(AuthenticationField.REQUEST_SCOPED_TOKEN_KEY, true);
+            metadata.put(AuthenticationField.REQUEST_SCOPED_TOKEN_SCOPE_KEY, requestScope);
+        }
+
+        // Determine the appropriate realm reference based on subject type
+        final Authentication.RealmRef realmRef = switch (subjectType) {
+            case API_KEY -> {
+                assert user.roles().length == 0 : "The user associated to an API key authentication must have no role";
+                yield newApiKeyRealmRef(nodeName);
+            }
+            case CLOUD_API_KEY -> newCloudApiKeyRealmRef(nodeName);
+            case SERVICE_ACCOUNT -> newServiceAccountRealmRef(nodeName);
+            case CROSS_CLUSTER_ACCESS -> newCrossClusterAccessRealmRef(nodeName);
+            case USER -> {
+                // For user authentication, we need a proper realm reference from the authResult
+                // This should be provided by the caller in the metadata or through other means
+                throw new IllegalArgumentException(
+                    "User authentication requires a RealmRef. Use newRealmAuthentication() instead."
+                );
+            }
+        };
+
+        return new Authentication(
+            new Subject(user, realmRef, TransportVersion.current(), metadata),
+            authType
         );
-        return authentication;
+    }
+
+    /**
+     * Overloaded version of newUnifiedAuthentication without request scope.
+     */
+    public static Authentication newUnifiedAuthentication(
+        AuthenticationResult<User> authResult,
+        String nodeName,
+        AuthenticationType authType,
+        Subject.Type subjectType
+    ) {
+        return newUnifiedAuthentication(authResult, nodeName, authType, subjectType, null);
     }
 
     public Authentication toCrossClusterAccess(CrossClusterAccessSubjectInfo crossClusterAccessSubjectInfo) {
diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/AuthenticationField.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/AuthenticationField.java
index bbf2690b..a182eb0f 100644
--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/AuthenticationField.java
+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/AuthenticationField.java
@@ -43,5 +43,9 @@ public final class AuthenticationField {
     public static final String CROSS_CLUSTER_ACCESS_AUTHENTICATION_KEY = "_security_cross_cluster_access_authentication";
     public static final String CROSS_CLUSTER_ACCESS_ROLE_DESCRIPTORS_KEY = "_security_cross_cluster_access_role_descriptors";
 
+    // Request-scoped token fields
+    public static final String REQUEST_SCOPED_TOKEN_KEY = "_security_request_scoped_token";
+    public static final String REQUEST_SCOPED_TOKEN_SCOPE_KEY = "_security_request_scoped_token_scope";
+
     private AuthenticationField() {}
 }