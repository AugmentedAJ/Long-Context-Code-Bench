{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134776,
  "base_commit": "2ea81d0548b2a25633ffe948cd9304a2c0c59563",
  "runner": "claude-code",
  "model": "claude-sonnet-4-5",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 312694,
  "patch_unified": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/Authentication.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/Authentication.java\nindex ac543c4f..6d1831a7 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/Authentication.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/Authentication.java\n@@ -551,6 +551,46 @@ public final class Authentication implements ToXContentObject {\n         return effectiveSubject.getType() == Subject.Type.CROSS_CLUSTER_ACCESS;\n     }\n \n+    /**\n+     * Checks if this authentication has a request-scoped token.\n+     * Request-scoped tokens limit the authentication to specific operations or resources.\n+     *\n+     * @return true if the authentication is scoped to a specific request or operation\n+     */\n+    public boolean isRequestScoped() {\n+        final Object requestScoped = getAuthenticatingSubject().getMetadata().get(AuthenticationField.REQUEST_SCOPED_TOKEN_KEY);\n+        return requestScoped instanceof Boolean && (Boolean) requestScoped;\n+    }\n+\n+    /**\n+     * Gets the request scope associated with this authentication, if any.\n+     * The scope defines what operations or resources this authentication is limited to.\n+     *\n+     * @return the request scope string, or null if not request-scoped\n+     */\n+    @Nullable\n+    public String getRequestScope() {\n+        if (isRequestScoped()) {\n+            final Object scope = getAuthenticatingSubject().getMetadata().get(AuthenticationField.REQUEST_SCOPED_TOKEN_SCOPE_KEY);\n+            return scope instanceof String ? (String) scope : null;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks if this authentication's request scope matches the given scope.\n+     *\n+     * @param expectedScope the scope to check against\n+     * @return true if the authentication has the specified scope\n+     */\n+    public boolean hasRequestScope(String expectedScope) {\n+        if (expectedScope == null || expectedScope.isEmpty()) {\n+            return false;\n+        }\n+        final String actualScope = getRequestScope();\n+        return expectedScope.equals(actualScope);\n+    }\n+\n     /**\n      * Whether the authentication can run-as another user\n      */\n@@ -1354,12 +1394,9 @@ public final class Authentication implements ToXContentObject {\n \n     public static Authentication newServiceAccountAuthentication(User serviceAccountUser, String nodeName, Map<String, Object> metadata) {\n         // TODO make the service account user a separate class/interface\n-        final Authentication.RealmRef authenticatedBy = newServiceAccountRealmRef(nodeName);\n-        Authentication authentication = new Authentication(\n-            new Subject(serviceAccountUser, authenticatedBy, TransportVersion.current(), metadata),\n-            AuthenticationType.TOKEN\n-        );\n-        return authentication;\n+        // Create an AuthenticationResult wrapping the service account user\n+        final AuthenticationResult<User> authResult = AuthenticationResult.success(serviceAccountUser, metadata);\n+        return newUnifiedAuthentication(authResult, nodeName, AuthenticationType.TOKEN, Subject.Type.SERVICE_ACCOUNT);\n     }\n \n     public static Authentication newRealmAuthentication(User user, RealmRef realmRef) {\n@@ -1389,25 +1426,77 @@ public final class Authentication implements ToXContentObject {\n     }\n \n     public static Authentication newCloudApiKeyAuthentication(AuthenticationResult<User> authResult, String nodeName) {\n-        assert authResult.isAuthenticated() : \"cloud API Key authn result must be successful\";\n-        final User apiKeyUser = authResult.getValue();\n-        final Authentication.RealmRef authenticatedBy = newCloudApiKeyRealmRef(nodeName);\n-        return new Authentication(\n-            new Subject(apiKeyUser, authenticatedBy, TransportVersion.current(), authResult.getMetadata()),\n-            AuthenticationType.API_KEY\n-        );\n+        return newUnifiedAuthentication(authResult, nodeName, AuthenticationType.API_KEY, Subject.Type.CLOUD_API_KEY);\n     }\n \n     public static Authentication newApiKeyAuthentication(AuthenticationResult<User> authResult, String nodeName) {\n-        assert authResult.isAuthenticated() : \"API Key authn result must be successful\";\n-        final User apiKeyUser = authResult.getValue();\n-        assert apiKeyUser.roles().length == 0 : \"The user associated to an API key authentication must have no role\";\n-        final Authentication.RealmRef authenticatedBy = newApiKeyRealmRef(nodeName);\n-        Authentication authentication = new Authentication(\n-            new Subject(apiKeyUser, authenticatedBy, TransportVersion.current(), authResult.getMetadata()),\n-            AuthenticationType.API_KEY\n+        return newUnifiedAuthentication(authResult, nodeName, AuthenticationType.API_KEY, Subject.Type.API_KEY);\n+    }\n+\n+    /**\n+     * Unified authentication creation method that supports both User and API Key authentication types\n+     * with request-scoped tokens. This method consolidates the logic for creating authentications\n+     * and allows for flexible scoping of tokens at request time.\n+     *\n+     * @param authResult The authentication result containing the user and metadata\n+     * @param nodeName The name of the node creating the authentication\n+     * @param authType The authentication type (REALM, API_KEY, TOKEN)\n+     * @param subjectType The subject type (USER, API_KEY, CLOUD_API_KEY, etc.)\n+     * @param requestScope Optional scope to limit the authentication to specific operations\n+     * @return A new Authentication object with the specified configuration\n+     */\n+    public static Authentication newUnifiedAuthentication(\n+        AuthenticationResult<User> authResult,\n+        String nodeName,\n+        AuthenticationType authType,\n+        Subject.Type subjectType,\n+        @Nullable String requestScope\n+    ) {\n+        assert authResult.isAuthenticated() : \"Authentication result must be successful\";\n+\n+        final User user = authResult.getValue();\n+        final Map<String, Object> metadata = new HashMap<>(authResult.getMetadata());\n+\n+        // Add request scope to metadata if provided\n+        if (requestScope != null && !requestScope.isEmpty()) {\n+            metadata.put(AuthenticationField.REQUEST_SCOPED_TOKEN_KEY, true);\n+            metadata.put(AuthenticationField.REQUEST_SCOPED_TOKEN_SCOPE_KEY, requestScope);\n+        }\n+\n+        // Determine the appropriate realm reference based on subject type\n+        final Authentication.RealmRef realmRef = switch (subjectType) {\n+            case API_KEY -> {\n+                assert user.roles().length == 0 : \"The user associated to an API key authentication must have no role\";\n+                yield newApiKeyRealmRef(nodeName);\n+            }\n+            case CLOUD_API_KEY -> newCloudApiKeyRealmRef(nodeName);\n+            case SERVICE_ACCOUNT -> newServiceAccountRealmRef(nodeName);\n+            case CROSS_CLUSTER_ACCESS -> newCrossClusterAccessRealmRef(nodeName);\n+            case USER -> {\n+                // For user authentication, we need a proper realm reference from the authResult\n+                // This should be provided by the caller in the metadata or through other means\n+                throw new IllegalArgumentException(\n+                    \"User authentication requires a RealmRef. Use newRealmAuthentication() instead.\"\n+                );\n+            }\n+        };\n+\n+        return new Authentication(\n+            new Subject(user, realmRef, TransportVersion.current(), metadata),\n+            authType\n         );\n-        return authentication;\n+    }\n+\n+    /**\n+     * Overloaded version of newUnifiedAuthentication without request scope.\n+     */\n+    public static Authentication newUnifiedAuthentication(\n+        AuthenticationResult<User> authResult,\n+        String nodeName,\n+        AuthenticationType authType,\n+        Subject.Type subjectType\n+    ) {\n+        return newUnifiedAuthentication(authResult, nodeName, authType, subjectType, null);\n     }\n \n     public Authentication toCrossClusterAccess(CrossClusterAccessSubjectInfo crossClusterAccessSubjectInfo) {\ndiff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/AuthenticationField.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/AuthenticationField.java\nindex bbf2690b..a182eb0f 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/AuthenticationField.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/AuthenticationField.java\n@@ -43,5 +43,9 @@ public final class AuthenticationField {\n     public static final String CROSS_CLUSTER_ACCESS_AUTHENTICATION_KEY = \"_security_cross_cluster_access_authentication\";\n     public static final String CROSS_CLUSTER_ACCESS_ROLE_DESCRIPTORS_KEY = \"_security_cross_cluster_access_role_descriptors\";\n \n+    // Request-scoped token fields\n+    public static final String REQUEST_SCOPED_TOKEN_KEY = \"_security_request_scoped_token\";\n+    public static final String REQUEST_SCOPED_TOKEN_SCOPE_KEY = \"_security_request_scoped_token_scope\";\n+\n     private AuthenticationField() {}\n }",
  "logs_path": "claude-code/claude-sonnet-4-5/8d6f99fc/elastic_elasticsearch_pr134776/logs.jsonl",
  "errors": [],
  "edit_run_id": "8d6f99fc",
  "test_label": "v1-rollouts-1-3-sonnet4.5"
}