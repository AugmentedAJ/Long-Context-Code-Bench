diff --git a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java
index 9764831..3e1180d 100644
--- a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java
+++ b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java
@@ -143,6 +143,9 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
 
     // node id to actual channel
     final ConcurrentMap<DiscoveryNode, NodeChannels> connectedNodes = newConcurrentMap();
+    
+    // node id to per-node lock for connect/disconnect operations
+    final ConcurrentMap<String, Object> nodeLocks = newConcurrentMap();
 
 
     private volatile Channel serverChannel;
@@ -150,8 +153,6 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
     private volatile TransportServiceAdapter transportServiceAdapter;
 
     private volatile BoundTransportAddress boundAddress;
-
-    private final Object[] connectMutex;
     // this lock is here to make sure we close this transport and disconnect all the client nodes
     // connections while no connect operations is going on... (this might help with 100% CPU when stopping the transport?)
     private final ReadWriteLock globalLock = new ReentrantReadWriteLock();
@@ -167,11 +168,6 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
             System.setProperty("org.jboss.netty.epollBugWorkaround", "true");
         }
 
-        this.connectMutex = new Object[500];
-        for (int i = 0; i < connectMutex.length; i++) {
-            connectMutex[i] = new Object();
-        }
-
         this.workerCount = componentSettings.getAsInt("worker_count", EsExecutors.boundedNumberOfProcessors() * 2);
         this.bossCount = componentSettings.getAsInt("boss_count", 1);
         this.blockingServer = settings.getAsBoolean("transport.tcp.blocking_server", settings.getAsBoolean(TCP_BLOCKING_SERVER, settings.getAsBoolean(TCP_BLOCKING, false)));
@@ -420,6 +416,9 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
                         clientBootstrap.releaseExternalResources();
                         clientBootstrap = null;
                     }
+                    
+                    // Clean up all node locks to prevent memory leaks
+                    nodeLocks.clear();
                 } finally {
                     globalLock.writeLock().unlock();
                     latch.countDown();
@@ -758,6 +757,8 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
                 } finally {
                     logger.debug("disconnected from [{}]", node);
                     transportServiceAdapter.raiseNodeDisconnected(node);
+                    // Clean up the node-specific lock to prevent memory leaks
+                    nodeLocks.remove(node.id());
                 }
             }
         }
@@ -776,6 +777,8 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
                 } finally {
                     logger.debug("disconnected from [{}], {}", node, reason);
                     transportServiceAdapter.raiseNodeDisconnected(node);
+                    // Clean up the node-specific lock to prevent memory leaks
+                    nodeLocks.remove(node.id());
                 }
             }
         }
@@ -795,6 +798,8 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
                     } finally {
                         logger.debug("disconnected from [{}] on channel failure", failure, node);
                         transportServiceAdapter.raiseNodeDisconnected(node);
+                        // Clean up the node-specific lock to prevent memory leaks
+                        nodeLocks.remove(node.id());
                     }
                 }
             }
@@ -810,12 +815,17 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
     }
 
     private Object connectLock(String nodeId) {
-        int hash = nodeId.hashCode();
-        // abs returns Integer.MIN_VALUE, so we need to protect against it...
-        if (hash == Integer.MIN_VALUE) {
-            hash = 0;
+        // Use putIfAbsent to atomically get or create a lock for this specific node ID
+        // This ensures each node has its own lock, preventing hash collision deadlocks
+        Object lock = nodeLocks.get(nodeId);
+        if (lock == null) {
+            lock = new Object();
+            Object existingLock = nodeLocks.putIfAbsent(nodeId, lock);
+            if (existingLock != null) {
+                lock = existingLock;
+            }
         }
-        return connectMutex[Math.abs(hash) % connectMutex.length];
+        return lock;
     }
 
     private class ChannelCloseListener implements ChannelFutureListener {