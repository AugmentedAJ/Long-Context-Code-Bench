{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 3640,
  "base_commit": "4155741f7f486537d4a5f7193d79098d523a6ae8",
  "runner": "factory",
  "model": "mcp:glm-4.6",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 309811,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\nindex 9764831..3e1180d 100644\n--- a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\n+++ b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\n@@ -143,6 +143,9 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n \n     // node id to actual channel\n     final ConcurrentMap<DiscoveryNode, NodeChannels> connectedNodes = newConcurrentMap();\n+    \n+    // node id to per-node lock for connect/disconnect operations\n+    final ConcurrentMap<String, Object> nodeLocks = newConcurrentMap();\n \n \n     private volatile Channel serverChannel;\n@@ -150,8 +153,6 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n     private volatile TransportServiceAdapter transportServiceAdapter;\n \n     private volatile BoundTransportAddress boundAddress;\n-\n-    private final Object[] connectMutex;\n     // this lock is here to make sure we close this transport and disconnect all the client nodes\n     // connections while no connect operations is going on... (this might help with 100% CPU when stopping the transport?)\n     private final ReadWriteLock globalLock = new ReentrantReadWriteLock();\n@@ -167,11 +168,6 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n             System.setProperty(\"org.jboss.netty.epollBugWorkaround\", \"true\");\n         }\n \n-        this.connectMutex = new Object[500];\n-        for (int i = 0; i < connectMutex.length; i++) {\n-            connectMutex[i] = new Object();\n-        }\n-\n         this.workerCount = componentSettings.getAsInt(\"worker_count\", EsExecutors.boundedNumberOfProcessors() * 2);\n         this.bossCount = componentSettings.getAsInt(\"boss_count\", 1);\n         this.blockingServer = settings.getAsBoolean(\"transport.tcp.blocking_server\", settings.getAsBoolean(TCP_BLOCKING_SERVER, settings.getAsBoolean(TCP_BLOCKING, false)));\n@@ -420,6 +416,9 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n                         clientBootstrap.releaseExternalResources();\n                         clientBootstrap = null;\n                     }\n+                    \n+                    // Clean up all node locks to prevent memory leaks\n+                    nodeLocks.clear();\n                 } finally {\n                     globalLock.writeLock().unlock();\n                     latch.countDown();\n@@ -758,6 +757,8 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n                 } finally {\n                     logger.debug(\"disconnected from [{}]\", node);\n                     transportServiceAdapter.raiseNodeDisconnected(node);\n+                    // Clean up the node-specific lock to prevent memory leaks\n+                    nodeLocks.remove(node.id());\n                 }\n             }\n         }\n@@ -776,6 +777,8 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n                 } finally {\n                     logger.debug(\"disconnected from [{}], {}\", node, reason);\n                     transportServiceAdapter.raiseNodeDisconnected(node);\n+                    // Clean up the node-specific lock to prevent memory leaks\n+                    nodeLocks.remove(node.id());\n                 }\n             }\n         }\n@@ -795,6 +798,8 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n                     } finally {\n                         logger.debug(\"disconnected from [{}] on channel failure\", failure, node);\n                         transportServiceAdapter.raiseNodeDisconnected(node);\n+                        // Clean up the node-specific lock to prevent memory leaks\n+                        nodeLocks.remove(node.id());\n                     }\n                 }\n             }\n@@ -810,12 +815,17 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n     }\n \n     private Object connectLock(String nodeId) {\n-        int hash = nodeId.hashCode();\n-        // abs returns Integer.MIN_VALUE, so we need to protect against it...\n-        if (hash == Integer.MIN_VALUE) {\n-            hash = 0;\n+        // Use putIfAbsent to atomically get or create a lock for this specific node ID\n+        // This ensures each node has its own lock, preventing hash collision deadlocks\n+        Object lock = nodeLocks.get(nodeId);\n+        if (lock == null) {\n+            lock = new Object();\n+            Object existingLock = nodeLocks.putIfAbsent(nodeId, lock);\n+            if (existingLock != null) {\n+                lock = existingLock;\n+            }\n         }\n-        return connectMutex[Math.abs(hash) % connectMutex.length];\n+        return lock;\n     }\n \n     private class ChannelCloseListener implements ChannelFutureListener {",
  "logs_path": "factory/mcp:glm-4.6/6bf04592/elastic_elasticsearch_pr3640/logs.jsonl",
  "errors": [],
  "edit_run_id": "6bf04592",
  "test_label": "v1-mcp"
}