diff --git a/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java b/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java
index c7fd6df4..f0b2e73c 100644
--- a/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java
+++ b/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java
@@ -74,7 +74,10 @@ import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
 import static org.elasticsearch.core.Strings.format;
@@ -94,6 +97,8 @@ class ClientTransformIndexer extends TransformIndexer {
     private final ConcurrentHashMap<String, PointInTimeBuilder> namedPits = new ConcurrentHashMap<>();
     private volatile long pitCheckpoint;
     private volatile boolean disablePit = false;
+    private final AtomicInteger pendingPitCloses = new AtomicInteger(0);
+    private volatile CountDownLatch pitCloseLatch;
 
     ClientTransformIndexer(
         ThreadPool threadPool,
@@ -155,6 +160,7 @@ class ClientTransformIndexer extends TransformIndexer {
 
         if (getNextCheckpoint().getCheckpoint() != pitCheckpoint) {
             closePointInTime();
+            waitForPitCloseOperations();
         }
 
         injectPointInTimeIfNeeded(
@@ -436,6 +442,7 @@ class ClientTransformIndexer extends TransformIndexer {
     @Override
     protected void afterFinishOrFailure() {
         closePointInTime();
+        waitForPitCloseOperations();
         super.afterFinishOrFailure();
     }
 
@@ -478,10 +485,19 @@ class ClientTransformIndexer extends TransformIndexer {
     @Override
     protected void onStop() {
         closePointInTime();
+        waitForPitCloseOperations();
         super.onStop();
     }
 
     private void closePointInTime() {
+        if (namedPits.isEmpty()) {
+            return;
+        }
+        
+        // Initialize latch to wait for all PIT close operations
+        pitCloseLatch = new CountDownLatch(namedPits.size());
+        pendingPitCloses.set(namedPits.size());
+        
         for (String name : namedPits.keySet()) {
             closePointInTime(name);
         }
@@ -491,6 +507,13 @@ class ClientTransformIndexer extends TransformIndexer {
         PointInTimeBuilder pit = namedPits.remove(name);
 
         if (pit == null) {
+            // Count down if latch exists
+            if (pitCloseLatch != null) {
+                pitCloseLatch.countDown();
+                if (pendingPitCloses.decrementAndGet() == 0) {
+                    pitCloseLatch = null;
+                }
+            }
             return;
         }
 
@@ -505,13 +528,45 @@ class ClientTransformIndexer extends TransformIndexer {
             closePitRequest,
             ActionListener.wrap(response -> {
                 logger.trace("[{}] closed pit search context [{}]", getJobId(), oldPit);
+                // Count down the latch when PIT close completes
+                if (pitCloseLatch != null) {
+                    pitCloseLatch.countDown();
+                    if (pendingPitCloses.decrementAndGet() == 0) {
+                        pitCloseLatch = null;
+                    }
+                }
             }, e -> {
                 // note: closing the pit should never throw, even if the pit is invalid
                 logger.error(() -> "[" + getJobId() + "] Failed to close point in time reader", e);
+                // Count down the latch even on failure
+                if (pitCloseLatch != null) {
+                    pitCloseLatch.countDown();
+                    if (pendingPitCloses.decrementAndGet() == 0) {
+                        pitCloseLatch = null;
+                    }
+                }
             })
         );
     }
 
+    private void waitForPitCloseOperations() {
+        CountDownLatch latch = pitCloseLatch;
+        if (latch != null) {
+            try {
+                // Wait up to 30 seconds for all PIT close operations to complete
+                boolean completed = latch.await(30, TimeUnit.SECONDS);
+                if (completed) {
+                    logger.debug("[{}] All PIT close operations completed before checkpoint", getJobId());
+                } else {
+                    logger.warn("[{}] Timed out waiting for PIT close operations to complete before checkpoint", getJobId());
+                }
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+                logger.warn("[{}] Interrupted while waiting for PIT close operations to complete", getJobId());
+            }
+        }
+    }
+
     private void injectPointInTimeIfNeeded(
         Tuple<String, SearchRequest> namedSearchRequest,
         ActionListener<Tuple<String, SearchRequest>> listener
diff --git a/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java b/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java
index c1d36c32..6b2bc069 100644
--- a/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java
+++ b/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java
@@ -48,6 +48,13 @@ import org.elasticsearch.tasks.TaskId;
 import org.elasticsearch.test.ESTestCase;
 import org.elasticsearch.test.client.NoOpClient;
 import org.elasticsearch.threadpool.ThreadPool;
+
+import java.util.Collections;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 import org.elasticsearch.transport.ActionNotFoundTransportException;
 import org.elasticsearch.xpack.core.indexing.IndexerState;
 import org.elasticsearch.xpack.core.transform.TransformMetadata;
@@ -733,4 +740,118 @@ public class ClientTransformIndexerTests extends ESTestCase {
             false
         );
     }
+
+    public void testPitCloseOperationsAreSynchronized() throws Exception {
+        try (var threadPool = createThreadPool()) {
+            // Create a mock client that tracks PIT close operations
+            final var client = new PitMockClient(threadPool, true) {
+                private final AtomicInteger closeCallCount = new AtomicInteger(0);
+                private final CountDownLatch closeLatch = new CountDownLatch(3); // Expect 3 PIT close operations
+                
+                @Override
+                protected <Request extends ActionRequest, Response extends ActionResponse> void doExecute(
+                    ActionType<Response> action,
+                    Request request,
+                    ActionListener<Response> listener
+                ) {
+                    if (request instanceof OpenPointInTimeRequest) {
+                        super.doExecute(action, request, listener);
+                        return;
+                    } else if (request instanceof ClosePointInTimeRequest) {
+                        // Simulate some delay in PIT close operations
+                        closeCallCount.incrementAndGet();
+                        threadPool.executor(ThreadPool.Names.GENERIC).execute(() -> {
+                            try {
+                                Thread.sleep(100); // Simulate work
+                                super.doExecute(action, request, listener);
+                                closeLatch.countDown();
+                            } catch (InterruptedException e) {
+                                Thread.currentThread().interrupt();
+                                listener.onFailure(e);
+                            }
+                        });
+                        return;
+                    }
+                    super.doExecute(action, request, listener);
+                }
+                
+                public CountDownLatch getCloseLatch() {
+                    return closeLatch;
+                }
+            };
+            
+            // Create indexer with initial PIT contexts
+            MockClientTransformIndexer indexer = new MockClientTransformIndexer(
+                mock(ThreadPool.class),
+                mock(ClusterService.class),
+                mock(IndexNameExpressionResolver.class),
+                mock(TransformExtension.class),
+                new TransformServices(
+                    mock(IndexBasedTransformConfigManager.class),
+                    mock(TransformCheckpointService.class),
+                    mock(TransformAuditor.class),
+                    new TransformScheduler(Clock.systemUTC(), mock(ThreadPool.class), Settings.EMPTY, TimeValue.ZERO),
+                    mock(TransformNode.class)
+                ),
+                mock(CheckpointProvider.class),
+                new AtomicReference<>(IndexerState.STARTED),
+                null,
+                new ParentTaskAssigningClient(client, new TaskId("dummy-node:123456")),
+                mock(TransformIndexerStats.class),
+                TransformConfigTests.randomTransformConfig(),
+                null,
+                new TransformCheckpoint(
+                    "transform",
+                    Instant.now().toEpochMilli(),
+                    0L,
+                    Collections.emptyMap(),
+                    Instant.now().toEpochMilli()
+                ),
+                new TransformCheckpoint(
+                    "transform",
+                    Instant.now().toEpochMilli(),
+                    2L,
+                    Collections.emptyMap(),
+                    Instant.now().toEpochMilli()
+                ),
+                new SeqNoPrimaryTermAndIndex(1, 1, TransformInternalIndexConstants.LATEST_INDEX_NAME),
+                mock(TransformContext.class),
+                false
+            );
+            
+            // Execute search requests to create PIT contexts
+            indexer.doNextSearch(0, ActionListener.wrap(response -> {}, e -> fail("Unexpected exception: " + e)));
+            indexer.doNextSearch(0, ActionListener.wrap(response -> {}, e -> fail("Unexpected exception: " + e)));
+            indexer.doNextSearch(0, ActionListener.wrap(response -> {}, e -> fail("Unexpected exception: " + e)));
+            
+            // Verify PIT contexts are created
+            assertEquals(3L, client.getPitContextCounter());
+            
+            // Change checkpoint to trigger PIT closing
+            // Note: We need to use reflection to set the private field since there's no setter
+            java.lang.reflect.Field nextCheckpointField = TransformIndexer.class.getDeclaredField("nextCheckpoint");
+            nextCheckpointField.setAccessible(true);
+            nextCheckpointField.set(indexer, new TransformCheckpoint(
+                "transform",
+                Instant.now().toEpochMilli(),
+                3L,
+                Collections.emptyMap(),
+                Instant.now().toEpochMilli()
+            ));
+            
+            // Execute next search which should close PITs and wait for them to complete
+            long startTime = System.nanoTime();
+            indexer.doNextSearch(0, ActionListener.wrap(response -> {
+                long duration = System.nanoTime() - startTime;
+                // Should wait for PIT close operations (at least 100ms due to our delay)
+                assertTrue("Should have waited for PIT close operations", duration > TimeUnit.MILLISECONDS.toNanos(50));
+            }, e -> fail("Unexpected exception: " + e)));
+            
+            // Wait for all PIT close operations to complete
+            assertTrue("PIT close operations should complete", client.getCloseLatch().await(5, TimeUnit.SECONDS));
+            
+            // Verify PIT contexts are closed
+            assertEquals(0L, client.getPitContextCounter());
+        }
+    }
 }