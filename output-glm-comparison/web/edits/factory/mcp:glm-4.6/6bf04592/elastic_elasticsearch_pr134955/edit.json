{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134955,
  "base_commit": "8272fc895484bdcf635a3828616e03183cac283d",
  "runner": "factory",
  "model": "mcp:glm-4.6",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 673789,
  "patch_unified": "diff --git a/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java b/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java\nindex c7fd6df4..f0b2e73c 100644\n--- a/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java\n+++ b/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java\n@@ -74,7 +74,10 @@ import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n \n import static org.elasticsearch.core.Strings.format;\n@@ -94,6 +97,8 @@ class ClientTransformIndexer extends TransformIndexer {\n     private final ConcurrentHashMap<String, PointInTimeBuilder> namedPits = new ConcurrentHashMap<>();\n     private volatile long pitCheckpoint;\n     private volatile boolean disablePit = false;\n+    private final AtomicInteger pendingPitCloses = new AtomicInteger(0);\n+    private volatile CountDownLatch pitCloseLatch;\n \n     ClientTransformIndexer(\n         ThreadPool threadPool,\n@@ -155,6 +160,7 @@ class ClientTransformIndexer extends TransformIndexer {\n \n         if (getNextCheckpoint().getCheckpoint() != pitCheckpoint) {\n             closePointInTime();\n+            waitForPitCloseOperations();\n         }\n \n         injectPointInTimeIfNeeded(\n@@ -436,6 +442,7 @@ class ClientTransformIndexer extends TransformIndexer {\n     @Override\n     protected void afterFinishOrFailure() {\n         closePointInTime();\n+        waitForPitCloseOperations();\n         super.afterFinishOrFailure();\n     }\n \n@@ -478,10 +485,19 @@ class ClientTransformIndexer extends TransformIndexer {\n     @Override\n     protected void onStop() {\n         closePointInTime();\n+        waitForPitCloseOperations();\n         super.onStop();\n     }\n \n     private void closePointInTime() {\n+        if (namedPits.isEmpty()) {\n+            return;\n+        }\n+        \n+        // Initialize latch to wait for all PIT close operations\n+        pitCloseLatch = new CountDownLatch(namedPits.size());\n+        pendingPitCloses.set(namedPits.size());\n+        \n         for (String name : namedPits.keySet()) {\n             closePointInTime(name);\n         }\n@@ -491,6 +507,13 @@ class ClientTransformIndexer extends TransformIndexer {\n         PointInTimeBuilder pit = namedPits.remove(name);\n \n         if (pit == null) {\n+            // Count down if latch exists\n+            if (pitCloseLatch != null) {\n+                pitCloseLatch.countDown();\n+                if (pendingPitCloses.decrementAndGet() == 0) {\n+                    pitCloseLatch = null;\n+                }\n+            }\n             return;\n         }\n \n@@ -505,13 +528,45 @@ class ClientTransformIndexer extends TransformIndexer {\n             closePitRequest,\n             ActionListener.wrap(response -> {\n                 logger.trace(\"[{}] closed pit search context [{}]\", getJobId(), oldPit);\n+                // Count down the latch when PIT close completes\n+                if (pitCloseLatch != null) {\n+                    pitCloseLatch.countDown();\n+                    if (pendingPitCloses.decrementAndGet() == 0) {\n+                        pitCloseLatch = null;\n+                    }\n+                }\n             }, e -> {\n                 // note: closing the pit should never throw, even if the pit is invalid\n                 logger.error(() -> \"[\" + getJobId() + \"] Failed to close point in time reader\", e);\n+                // Count down the latch even on failure\n+                if (pitCloseLatch != null) {\n+                    pitCloseLatch.countDown();\n+                    if (pendingPitCloses.decrementAndGet() == 0) {\n+                        pitCloseLatch = null;\n+                    }\n+                }\n             })\n         );\n     }\n \n+    private void waitForPitCloseOperations() {\n+        CountDownLatch latch = pitCloseLatch;\n+        if (latch != null) {\n+            try {\n+                // Wait up to 30 seconds for all PIT close operations to complete\n+                boolean completed = latch.await(30, TimeUnit.SECONDS);\n+                if (completed) {\n+                    logger.debug(\"[{}] All PIT close operations completed before checkpoint\", getJobId());\n+                } else {\n+                    logger.warn(\"[{}] Timed out waiting for PIT close operations to complete before checkpoint\", getJobId());\n+                }\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                logger.warn(\"[{}] Interrupted while waiting for PIT close operations to complete\", getJobId());\n+            }\n+        }\n+    }\n+\n     private void injectPointInTimeIfNeeded(\n         Tuple<String, SearchRequest> namedSearchRequest,\n         ActionListener<Tuple<String, SearchRequest>> listener\ndiff --git a/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java b/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java\nindex c1d36c32..6b2bc069 100644\n--- a/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java\n+++ b/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java\n@@ -48,6 +48,13 @@ import org.elasticsearch.tasks.TaskId;\n import org.elasticsearch.test.ESTestCase;\n import org.elasticsearch.test.client.NoOpClient;\n import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n import org.elasticsearch.transport.ActionNotFoundTransportException;\n import org.elasticsearch.xpack.core.indexing.IndexerState;\n import org.elasticsearch.xpack.core.transform.TransformMetadata;\n@@ -733,4 +740,118 @@ public class ClientTransformIndexerTests extends ESTestCase {\n             false\n         );\n     }\n+\n+    public void testPitCloseOperationsAreSynchronized() throws Exception {\n+        try (var threadPool = createThreadPool()) {\n+            // Create a mock client that tracks PIT close operations\n+            final var client = new PitMockClient(threadPool, true) {\n+                private final AtomicInteger closeCallCount = new AtomicInteger(0);\n+                private final CountDownLatch closeLatch = new CountDownLatch(3); // Expect 3 PIT close operations\n+                \n+                @Override\n+                protected <Request extends ActionRequest, Response extends ActionResponse> void doExecute(\n+                    ActionType<Response> action,\n+                    Request request,\n+                    ActionListener<Response> listener\n+                ) {\n+                    if (request instanceof OpenPointInTimeRequest) {\n+                        super.doExecute(action, request, listener);\n+                        return;\n+                    } else if (request instanceof ClosePointInTimeRequest) {\n+                        // Simulate some delay in PIT close operations\n+                        closeCallCount.incrementAndGet();\n+                        threadPool.executor(ThreadPool.Names.GENERIC).execute(() -> {\n+                            try {\n+                                Thread.sleep(100); // Simulate work\n+                                super.doExecute(action, request, listener);\n+                                closeLatch.countDown();\n+                            } catch (InterruptedException e) {\n+                                Thread.currentThread().interrupt();\n+                                listener.onFailure(e);\n+                            }\n+                        });\n+                        return;\n+                    }\n+                    super.doExecute(action, request, listener);\n+                }\n+                \n+                public CountDownLatch getCloseLatch() {\n+                    return closeLatch;\n+                }\n+            };\n+            \n+            // Create indexer with initial PIT contexts\n+            MockClientTransformIndexer indexer = new MockClientTransformIndexer(\n+                mock(ThreadPool.class),\n+                mock(ClusterService.class),\n+                mock(IndexNameExpressionResolver.class),\n+                mock(TransformExtension.class),\n+                new TransformServices(\n+                    mock(IndexBasedTransformConfigManager.class),\n+                    mock(TransformCheckpointService.class),\n+                    mock(TransformAuditor.class),\n+                    new TransformScheduler(Clock.systemUTC(), mock(ThreadPool.class), Settings.EMPTY, TimeValue.ZERO),\n+                    mock(TransformNode.class)\n+                ),\n+                mock(CheckpointProvider.class),\n+                new AtomicReference<>(IndexerState.STARTED),\n+                null,\n+                new ParentTaskAssigningClient(client, new TaskId(\"dummy-node:123456\")),\n+                mock(TransformIndexerStats.class),\n+                TransformConfigTests.randomTransformConfig(),\n+                null,\n+                new TransformCheckpoint(\n+                    \"transform\",\n+                    Instant.now().toEpochMilli(),\n+                    0L,\n+                    Collections.emptyMap(),\n+                    Instant.now().toEpochMilli()\n+                ),\n+                new TransformCheckpoint(\n+                    \"transform\",\n+                    Instant.now().toEpochMilli(),\n+                    2L,\n+                    Collections.emptyMap(),\n+                    Instant.now().toEpochMilli()\n+                ),\n+                new SeqNoPrimaryTermAndIndex(1, 1, TransformInternalIndexConstants.LATEST_INDEX_NAME),\n+                mock(TransformContext.class),\n+                false\n+            );\n+            \n+            // Execute search requests to create PIT contexts\n+            indexer.doNextSearch(0, ActionListener.wrap(response -> {}, e -> fail(\"Unexpected exception: \" + e)));\n+            indexer.doNextSearch(0, ActionListener.wrap(response -> {}, e -> fail(\"Unexpected exception: \" + e)));\n+            indexer.doNextSearch(0, ActionListener.wrap(response -> {}, e -> fail(\"Unexpected exception: \" + e)));\n+            \n+            // Verify PIT contexts are created\n+            assertEquals(3L, client.getPitContextCounter());\n+            \n+            // Change checkpoint to trigger PIT closing\n+            // Note: We need to use reflection to set the private field since there's no setter\n+            java.lang.reflect.Field nextCheckpointField = TransformIndexer.class.getDeclaredField(\"nextCheckpoint\");\n+            nextCheckpointField.setAccessible(true);\n+            nextCheckpointField.set(indexer, new TransformCheckpoint(\n+                \"transform\",\n+                Instant.now().toEpochMilli(),\n+                3L,\n+                Collections.emptyMap(),\n+                Instant.now().toEpochMilli()\n+            ));\n+            \n+            // Execute next search which should close PITs and wait for them to complete\n+            long startTime = System.nanoTime();\n+            indexer.doNextSearch(0, ActionListener.wrap(response -> {\n+                long duration = System.nanoTime() - startTime;\n+                // Should wait for PIT close operations (at least 100ms due to our delay)\n+                assertTrue(\"Should have waited for PIT close operations\", duration > TimeUnit.MILLISECONDS.toNanos(50));\n+            }, e -> fail(\"Unexpected exception: \" + e)));\n+            \n+            // Wait for all PIT close operations to complete\n+            assertTrue(\"PIT close operations should complete\", client.getCloseLatch().await(5, TimeUnit.SECONDS));\n+            \n+            // Verify PIT contexts are closed\n+            assertEquals(0L, client.getPitContextCounter());\n+        }\n+    }\n }",
  "logs_path": "factory/mcp:glm-4.6/6bf04592/elastic_elasticsearch_pr134955/logs.jsonl",
  "errors": [],
  "edit_run_id": "6bf04592",
  "test_label": "v1-mcp"
}