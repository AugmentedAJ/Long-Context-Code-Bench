{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4253,
  "base_commit": "9f5d01ca4cc06bf7affdb5a656dc838c383e0c4c",
  "runner": "factory",
  "model": "mcp:glm-4.6",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 1251728,
  "patch_unified": "diff --git a/src/main/java/org/apache/lucene/search/suggest/analyzing/XAnalyzingSuggester.java b/src/main/java/org/apache/lucene/search/suggest/analyzing/XAnalyzingSuggester.java\nindex f107d17..7b2188d 100644\n--- a/src/main/java/org/apache/lucene/search/suggest/analyzing/XAnalyzingSuggester.java\n+++ b/src/main/java/org/apache/lucene/search/suggest/analyzing/XAnalyzingSuggester.java\n@@ -18,10 +18,13 @@\n  */\n package org.apache.lucene.search.suggest.analyzing;\n \n+import static org.apache.lucene.util.automaton.Operations.DEFAULT_DETERMINIZE_WORK_LIMIT;\n+\n import com.carrotsearch.hppc.ObjectIntOpenHashMap;\n import org.apache.lucene.analysis.Analyzer;\n import org.apache.lucene.analysis.TokenStream;\n import org.apache.lucene.analysis.TokenStreamToAutomaton;\n+import org.apache.lucene.codecs.CodecUtil;\n import org.apache.lucene.search.suggest.InputIterator;\n import org.apache.lucene.search.suggest.Lookup;\n import org.apache.lucene.search.suggest.Sort;\n@@ -123,6 +126,9 @@ public class XAnalyzingSuggester extends Lookup {\n    */\n   private final boolean preserveSep;\n \n+  private final Directory tempDir;\n+  private final String tempFileNamePrefix;\n+\n   /** Include this flag in the options parameter to {@link\n    *  #XAnalyzingSuggester(Analyzer,Analyzer,int,int,int,FST,boolean,int)} to always\n    *  return the exact match first, regardless of score.  This\n@@ -165,22 +171,82 @@ public class XAnalyzingSuggester extends Lookup {\n   /** Whether position holes should appear in the automaton. */\n   private boolean preservePositionIncrements;\n \n+  /** Number of entries the lookup was built with */\n+  private volatile long count = 0;\n+\n   /**\n-   * Calls {@link #XAnalyzingSuggester(Analyzer,Analyzer,int,int,int,FST,boolean,int)\n+   * Calls {@link #XAnalyzingSuggester(Directory,String,Analyzer,Analyzer,int,int,int,boolean)}\n    * AnalyzingSuggester(analyzer, analyzer, EXACT_FIRST |\n-   * PRESERVE_SEP, 256, -1)}\n+   * PRESERVE_SEP, 256, -1, true)}\n    */\n-  public XAnalyzingSuggester(Analyzer analyzer) {\n-    this(analyzer, analyzer, EXACT_FIRST | PRESERVE_SEP, 256, -1, null, false, 0);\n+  public XAnalyzingSuggester(Directory tempDir, String tempFileNamePrefix, Analyzer analyzer) {\n+    this(tempDir, tempFileNamePrefix, analyzer, analyzer, EXACT_FIRST | PRESERVE_SEP, 256, -1, true);\n   }\n \n   /**\n-   * Calls {@link #XAnalyzingSuggester(Analyzer,Analyzer,int,int,int,FST,boolean,int)\n+   * Calls {@link #XAnalyzingSuggester(Directory,String,Analyzer,Analyzer,int,int,int,boolean)}\n    * AnalyzingSuggester(indexAnalyzer, queryAnalyzer, EXACT_FIRST |\n-   * PRESERVE_SEP, 256, -1)}\n+   * PRESERVE_SEP, 256, -1, true)}\n+   */\n+  public XAnalyzingSuggester(Directory tempDir, String tempFileNamePrefix, Analyzer indexAnalyzer, Analyzer queryAnalyzer) {\n+    this(tempDir, tempFileNamePrefix, indexAnalyzer, queryAnalyzer, EXACT_FIRST | PRESERVE_SEP, 256, -1, true);\n+  }\n+\n+  /**\n+   * Creates a new suggester.\n+   * \n+   * @param tempDir Temporary directory for sorting\n+   * @param tempFileNamePrefix Prefix for temp files\n+   * @param indexAnalyzer Analyzer that will be used for\n+   *   analyzing suggestions while building the index.\n+   * @param queryAnalyzer Analyzer that will be used for\n+   *   analyzing query text during lookup\n+   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n+   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n+   *   surface forms to keep for a single analyzed form.\n+   *   When there are too many surface forms we discard the\n+   *   lowest weighted ones.\n+   * @param maxGraphExpansions Maximum number of graph paths\n+   *   to expand from the analyzed form.  Set this to -1 for\n+   *   no limit.\n+   * @param preservePositionIncrements Whether position holes should appear in automaton\n    */\n-  public XAnalyzingSuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer) {\n-    this(indexAnalyzer, queryAnalyzer, EXACT_FIRST | PRESERVE_SEP, 256, -1, null, false, 0);\n+  public XAnalyzingSuggester(\n+      Directory tempDir,\n+      String tempFileNamePrefix,\n+      Analyzer indexAnalyzer, \n+      Analyzer queryAnalyzer, \n+      int options, \n+      int maxSurfaceFormsPerAnalyzedForm, \n+      int maxGraphExpansions,\n+      boolean preservePositionIncrements) { \n+      this.indexAnalyzer = indexAnalyzer;\n+      this.queryAnalyzer = queryAnalyzer;\n+      this.fst = null;\n+      this.hasPayloads = false;\n+      if ((options & ~(EXACT_FIRST | PRESERVE_SEP)) != 0) {\n+        throw new IllegalArgumentException(\"options should only contain EXACT_FIRST and PRESERVE_SEP; got \" + options);\n+      }\n+      this.exactFirst = (options & EXACT_FIRST) != 0;\n+      this.preserveSep = (options & PRESERVE_SEP) != 0;\n+\n+      // NOTE: this is just an implementation limitation; if\n+      // somehow this is a problem we could fix it by using\n+      // more than one byte to disambiguate ... but 256 seems\n+      // like it should be way more then enough.\n+      if (maxSurfaceFormsPerAnalyzedForm <= 0 || maxSurfaceFormsPerAnalyzedForm > 256) {\n+        throw new IllegalArgumentException(\"maxSurfaceFormsPerAnalyzedForm must be > 0 and < 256 (got: \" + maxSurfaceFormsPerAnalyzedForm + \")\");\n+      }\n+      this.maxSurfaceFormsPerAnalyzedForm = maxSurfaceFormsPerAnalyzedForm;\n+\n+      if (maxGraphExpansions < 1 && maxGraphExpansions != -1) {\n+        throw new IllegalArgumentException(\"maxGraphExpansions must -1 (no limit) or > 0 (got: \" + maxGraphExpansions + \")\");\n+      }\n+      this.maxGraphExpansions = maxGraphExpansions;\n+      this.maxAnalyzedPathsForOneInput = 0;\n+      this.preservePositionIncrements = preservePositionIncrements;\n+      this.tempDir = tempDir;\n+      this.tempFileNamePrefix = tempFileNamePrefix;\n   }\n \n   /**\n@@ -236,41 +302,41 @@ public class XAnalyzingSuggester extends Lookup {\n   }\n \n     /** Returns byte size of the underlying FST. */\n-  public long sizeInBytes() {\n-    return fst == null ? 0 : fst.sizeInBytes();\n+  @Override\n+  public long ramBytesUsed() {\n+    return fst == null ? 0 : fst.ramBytesUsed();\n   }\n \n-  private static void copyDestTransitions(State from, State to, List<Transition> transitions) {\n-    if (to.isAccept()) {\n-      from.setAccept(true);\n-    }\n-    for(Transition t : to.getTransitions()) {\n-      transitions.add(t);\n-    }\n-  }\n+  \n \n   // Replaces SEP with epsilon or remaps them if\n   // we were asked to preserve them:\n-  private static void replaceSep(Automaton a, boolean preserveSep) {\n+  private Automaton replaceSep(Automaton a) {\n \n-    State[] states = a.getNumberedStates();\n+    int numStates = a.getNumStates();\n+    Automaton.Builder result = new Automaton.Builder(numStates, a.getNumTransitions());\n+    // Copy all states over\n+    result.copyStates(a);\n \n     // Go in reverse topo sort so we know we only have to\n     // make one pass:\n-    for(int stateNumber=states.length-1;stateNumber >=0;stateNumber--) {\n-      final State state = states[stateNumber];\n-      List<Transition> newTransitions = new ArrayList<Transition>();\n-      for(Transition t : state.getTransitions()) {\n-        assert t.getMin() == t.getMax();\n-        if (t.getMin() == TokenStreamToAutomaton.POS_SEP) {\n+    Transition t = new Transition();\n+    int[] topoSortStates = Operations.topoSortStates(a);\n+    for (int i = 0; i < topoSortStates.length; i++) {\n+      int state = topoSortStates[topoSortStates.length - 1 - i];\n+      int count = a.initTransition(state, t);\n+      for (int j = 0; j < count; j++) {\n+        a.getNextTransition(t);\n+        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n+          assert t.max == TokenStreamToAutomaton.POS_SEP;\n           if (preserveSep) {\n             // Remap to SEP_LABEL:\n-            newTransitions.add(new Transition(SEP_LABEL, t.getDest()));\n+            result.addTransition(state, t.dest, SEP_LABEL);\n           } else {\n-            copyDestTransitions(state, t.getDest(), newTransitions);\n-            a.setDeterministic(false);\n+            result.addEpsilon(state, t.dest);\n           }\n-        } else if (t.getMin() == TokenStreamToAutomaton.HOLE) {\n+        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n+          assert t.max == TokenStreamToAutomaton.HOLE;\n \n           // Just remove the hole: there will then be two\n           // SEP tokens next to each other, which will only\n@@ -279,14 +345,14 @@ public class XAnalyzingSuggester extends Lookup {\n           // that's somehow a problem we can always map HOLE\n           // to a dedicated byte (and escape it in the\n           // input).\n-          copyDestTransitions(state, t.getDest(), newTransitions);\n-          a.setDeterministic(false);\n+          result.addEpsilon(state, t.dest);\n         } else {\n-          newTransitions.add(t);\n+          result.addTransition(state, t.dest, t.min, t.max);\n         }\n       }\n-      state.setTransitions(newTransitions.toArray(new Transition[newTransitions.size()]));\n     }\n+\n+    return result.finish();\n   }\n \n   /** Just escapes the 0xff byte (which we still for SEP). */\n@@ -318,7 +384,12 @@ public class XAnalyzingSuggester extends Lookup {\n     }\n   }\n \n-  public TokenStreamToAutomaton getTokenStreamToAutomaton() {\n+  /** Used by subclass to change lookup automaton, if necessary. */\n+  protected Automaton convertAutomaton(Automaton a) {\n+    return a;\n+  }\n+\n+  TokenStreamToAutomaton getTokenStreamToAutomaton() {\n     final TokenStreamToAutomaton tsta;\n     if (preserveSep) {\n       tsta = new EscapingTokenStreamToAutomaton();\n@@ -328,6 +399,7 @@ public class XAnalyzingSuggester extends Lookup {\n       tsta = new TokenStreamToAutomaton();\n     }\n     tsta.setPreservePositionIncrements(preservePositionIncrements);\n+    tsta.setFinalOffsetGapAsHole(true);\n     return tsta;\n   }\n   \n@@ -391,39 +463,48 @@ public class XAnalyzingSuggester extends Lookup {\n \n   @Override\n   public void build(InputIterator iterator) throws IOException {\n-    String prefix = getClass().getSimpleName();\n-    File directory = Sort.defaultTempDir();\n-    File tempInput = File.createTempFile(prefix, \".input\", directory);\n-    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n+    if (iterator.hasContexts()) {\n+      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n+    }\n \n     hasPayloads = iterator.hasPayloads();\n \n-    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n-    Sort.ByteSequencesReader reader = null;\n-    BytesRef scratch = new BytesRef();\n+    OfflineSorter sorter =\n+        new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));\n+\n+    IndexOutput tempInput =\n+        tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n+\n+    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n+    OfflineSorter.ByteSequencesReader reader = null;\n+    BytesRefBuilder scratch = new BytesRefBuilder();\n \n     TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n \n-    boolean success = false;\n-    byte buffer[] = new byte[8];\n+    String tempSortedFileName = null;\n+\n+    long newCount = 0;\n+    byte[] buffer = new byte[8];\n     try {\n       ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n-      BytesRef surfaceForm;\n \n-      while ((surfaceForm = iterator.next()) != null) {\n-        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n-        \n-        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n+      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null; ) {\n+        LimitedFiniteStringsIterator finiteStrings =\n+            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n \n-        for (IntsRef path : paths) {\n+        for (IntsRef string; (string = finiteStrings.next()) != null; newCount++) {\n+          Util.toBytesRef(string, scratch);\n \n-          Util.toBytesRef(path, scratch);\n-          \n           // length of the analyzed text (FST input)\n-          if (scratch.length > Short.MAX_VALUE-2) {\n-            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n+          if (scratch.length() > Short.MAX_VALUE - 2) {\n+            throw new IllegalArgumentException(\n+                \"cannot handle analyzed forms > \"\n+                    + (Short.MAX_VALUE - 2)\n+                    + \" in length (got \"\n+                    + scratch.length()\n+                    + \")\");\n           }\n-          short analyzedLength = (short) scratch.length;\n+          short analyzedLength = (short) scratch.length();\n \n           // compute the required length:\n           // analyzed sequence + weight (4) + surface + analyzedLength (short)\n@@ -432,8 +513,13 @@ public class XAnalyzingSuggester extends Lookup {\n           BytesRef payload;\n \n           if (hasPayloads) {\n-            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n-              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n+            if (surfaceForm.length > (Short.MAX_VALUE - 2)) {\n+              throw new IllegalArgumentException(\n+                  \"cannot handle surface form > \"\n+                      + (Short.MAX_VALUE - 2)\n+                      + \" in length (got \"\n+                      + surfaceForm.length\n+                      + \")\");\n             }\n             payload = iterator.payload();\n             // payload + surfaceLength (short)\n@@ -441,21 +527,22 @@ public class XAnalyzingSuggester extends Lookup {\n           } else {\n             payload = null;\n           }\n-          \n-          buffer = ArrayUtil.grow(buffer, requiredLength);\n-          \n+\n+          buffer = ArrayUtil.growNoCopy(buffer, requiredLength);\n+\n           output.reset(buffer);\n \n           output.writeShort(analyzedLength);\n \n-          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n+          output.writeBytes(scratch.bytes(), 0, scratch.length());\n \n           output.writeInt(encodeWeight(iterator.weight()));\n \n           if (hasPayloads) {\n-            for(int i=0;i<surfaceForm.length;i++) {\n+            for (int i = 0; i < surfaceForm.length; i++) {\n               if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n-                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n+                throw new IllegalArgumentException(\n+                    \"surface form cannot contain unit separator character U+001F; this character is reserved\");\n               }\n             }\n             output.writeShort((short) surfaceForm.length);\n@@ -465,61 +552,72 @@ public class XAnalyzingSuggester extends Lookup {\n             output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n           }\n \n-          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n-\n+          assert output.getPosition() == requiredLength\n+              : output.getPosition() + \" vs \" + requiredLength;\n           writer.write(buffer, 0, output.getPosition());\n         }\n+\n+        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n       }\n+      CodecUtil.writeFooter(tempInput);\n       writer.close();\n \n       // Sort all input/output pairs (required by FST.Builder):\n-      new Sort(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n+      tempSortedFileName = sorter.sort(tempInput.getName());\n \n       // Free disk space:\n-      tempInput.delete();\n+      tempDir.deleteFile(tempInput.getName());\n \n-      reader = new Sort.ByteSequencesReader(tempSorted);\n-     \n-      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n-      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n+      reader =\n+          new OfflineSorter.ByteSequencesReader(\n+              tempDir.openChecksumInput(tempSortedFileName), tempSortedFileName);\n+\n+      PairOutputs<Long, BytesRef> outputs =\n+          new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n+      FSTCompiler<Pair<Long, BytesRef>> fstCompiler =\n+          new FSTCompiler.Builder<>(FST.INPUT_TYPE.BYTE1, outputs).build();\n \n       // Build FST:\n-      BytesRef previousAnalyzed = null;\n-      BytesRef analyzed = new BytesRef();\n+      BytesRefBuilder previousAnalyzed = null;\n+      BytesRefBuilder analyzed = new BytesRefBuilder();\n       BytesRef surface = new BytesRef();\n-      IntsRef scratchInts = new IntsRef();\n+      IntsRefBuilder scratchInts = new IntsRefBuilder();\n       ByteArrayDataInput input = new ByteArrayDataInput();\n \n       // Used to remove duplicate surface forms (but we\n       // still index the hightest-weight one).  We clear\n       // this when we see a new analyzed form, so it cannot\n       // grow unbounded (at most 256 entries):\n-      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n+      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n \n       int dedup = 0;\n-      while (reader.read(scratch)) {\n-        input.reset(scratch.bytes, scratch.offset, scratch.length);\n+      while (true) {\n+        BytesRef bytes = reader.next();\n+        if (bytes == null) {\n+          break;\n+        }\n+        input.reset(bytes.bytes, bytes.offset, bytes.length);\n         short analyzedLength = input.readShort();\n-        analyzed.grow(analyzedLength+2);\n-        input.readBytes(analyzed.bytes, 0, analyzedLength);\n-        analyzed.length = analyzedLength;\n+        analyzed.growNoCopy(analyzedLength + 2);\n+        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n+        analyzed.setLength(analyzedLength);\n \n         long cost = input.readInt();\n \n-        surface.bytes = scratch.bytes;\n+        surface.bytes = bytes.bytes;\n         if (hasPayloads) {\n           surface.length = input.readShort();\n           surface.offset = input.getPosition();\n         } else {\n           surface.offset = input.getPosition();\n-          surface.length = scratch.length - surface.offset;\n+          surface.length = bytes.length - surface.offset;\n         }\n-        \n+\n         if (previousAnalyzed == null) {\n-          previousAnalyzed = new BytesRef();\n-          previousAnalyzed.copyBytes(analyzed);\n+          previousAnalyzed = new BytesRefBuilder();\n+          previousAnalyzed.copyBytes(analyzed.get());\n           seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n-        } else if (analyzed.equals(previousAnalyzed)) {\n+        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n           dedup++;\n           if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n             // More than maxSurfaceFormsPerAnalyzedForm\n@@ -545,78 +643,65 @@ public class XAnalyzingSuggester extends Lookup {\n \n         // NOTE: must be byte 0 so we sort before whatever\n         // is next\n-        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n-        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n-        analyzed.length += 2;\n+        analyzed.append((byte) 0);\n+        analyzed.append((byte) dedup);\n \n-        Util.toIntsRef(analyzed, scratchInts);\n-        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n+        Util.toIntsRef(analyzed.get(), scratchInts);\n+        // System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" +\n+        // surface.utf8ToString());\n         if (!hasPayloads) {\n-          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n+          fstCompiler.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n         } else {\n           int payloadOffset = input.getPosition() + surface.length;\n-          int payloadLength = scratch.length - payloadOffset;\n+          int payloadLength = bytes.length - payloadOffset;\n           BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n           System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n           br.bytes[surface.length] = PAYLOAD_SEP;\n-          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n+          System.arraycopy(bytes.bytes, payloadOffset, br.bytes, surface.length + 1, payloadLength);\n           br.length = br.bytes.length;\n-          builder.add(scratchInts, outputs.newPair(cost, br));\n+          fstCompiler.add(scratchInts.get(), outputs.newPair(cost, br));\n         }\n       }\n-      fst = builder.finish();\n+      fst = FST.fromFSTReader(fstCompiler.compile(), fstCompiler.getFSTReader());\n+      count = newCount;\n \n-      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n-      \n-      success = true;\n+      // Util.dotToFile(fst, \"/tmp/suggest.dot\");\n     } finally {\n-      if (success) {\n-        IOUtils.close(reader, writer);\n-      } else {\n-        IOUtils.closeWhileHandlingException(reader, writer);\n-      }\n-      \n-      tempInput.delete();\n-      tempSorted.delete();\n+      IOUtils.closeWhileHandlingException(reader, writer);\n+      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n     }\n   }\n \n   @Override\n-  public boolean store(OutputStream output) throws IOException {\n-    DataOutput dataOut = new OutputStreamDataOutput(output);\n-    try {\n-      if (fst == null) {\n-        return false;\n-      }\n-\n-      fst.save(dataOut);\n-      dataOut.writeVInt(maxAnalyzedPathsForOneInput);\n-      dataOut.writeByte((byte) (hasPayloads ? 1 : 0));\n-    } finally {\n-      IOUtils.close(output);\n+  public boolean store(DataOutput output) throws IOException {\n+    output.writeVLong(count);\n+    if (fst == null) {\n+      return false;\n     }\n+\n+    fst.save(output, output);\n+    output.writeVInt(maxAnalyzedPathsForOneInput);\n+    output.writeByte((byte) (hasPayloads ? 1 : 0));\n     return true;\n   }\n \n   @Override\n-  public boolean load(InputStream input) throws IOException {\n-    DataInput dataIn = new InputStreamDataInput(input);\n-    try {\n-      this.fst = new FST<Pair<Long,BytesRef>>(dataIn, new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton()));\n-      maxAnalyzedPathsForOneInput = dataIn.readVInt();\n-      hasPayloads = dataIn.readByte() == 1;\n-    } finally {\n-      IOUtils.close(input);\n-    }\n+  public boolean load(DataInput input) throws IOException {\n+    count = input.readVLong();\n+    PairOutputs<Long, BytesRef> outputs =\n+        new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n+    this.fst = new FST<>(FST.readMetadata(input, outputs), input);\n+    maxAnalyzedPathsForOneInput = input.readVInt();\n+    hasPayloads = input.readByte() == 1;\n     return true;\n   }\n \n-  private LookupResult getLookupResult(Long output1, BytesRef output2, CharsRef spare) {\n+  private LookupResult getLookupResult(Long output1, BytesRef output2, CharsRefBuilder spare) {\n     LookupResult result;\n     if (hasPayloads) {\n       int sepIndex = -1;\n-      for(int i=0;i<output2.length;i++) {\n-        if (output2.bytes[output2.offset+i] == PAYLOAD_SEP) {\n+      for (int i = 0; i < output2.length; i++) {\n+        if (output2.bytes[output2.offset + i] == PAYLOAD_SEP) {\n           sepIndex = i;\n           break;\n         }\n@@ -624,14 +709,14 @@ public class XAnalyzingSuggester extends Lookup {\n       assert sepIndex != -1;\n       spare.grow(sepIndex);\n       final int payloadLen = output2.length - sepIndex - 1;\n-      UnicodeUtil.UTF8toUTF16(output2.bytes, output2.offset, sepIndex, spare);\n+      spare.copyUTF8Bytes(output2.bytes, output2.offset, sepIndex);\n       BytesRef payload = new BytesRef(payloadLen);\n-      System.arraycopy(output2.bytes, sepIndex+1, payload.bytes, 0, payloadLen);\n+      System.arraycopy(output2.bytes, sepIndex + 1, payload.bytes, 0, payloadLen);\n       payload.length = payloadLen;\n       result = new LookupResult(spare.toString(), decodeWeight(output1), payload);\n     } else {\n       spare.grow(output2.length);\n-      UnicodeUtil.UTF8toUTF16(output2, spare);\n+      spare.copyUTF8Bytes(output2);\n       result = new LookupResult(spare.toString(), decodeWeight(output1));\n     }\n \n@@ -656,45 +741,59 @@ public class XAnalyzingSuggester extends Lookup {\n   }\n \n   @Override\n-  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n+  public List<LookupResult> lookup(\n+      final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n     assert num > 0;\n \n     if (onlyMorePopular) {\n       throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n     }\n+    if (contexts != null) {\n+      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n+    }\n     if (fst == null) {\n       return Collections.emptyList();\n     }\n \n-    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n+    // System.out.println(\"lookup key=\" + key + \" num=\" + num);\n+    for (int i = 0; i < key.length(); i++) {\n+      if (key.charAt(i) == 0x1E) {\n+        throw new IllegalArgumentException(\n+            \"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n+      }\n+      if (key.charAt(i) == 0x1F) {\n+        throw new IllegalArgumentException(\n+            \"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n+      }\n+    }\n     final BytesRef utf8Key = new BytesRef(key);\n     try {\n-\n       Automaton lookupAutomaton = toLookupAutomaton(key);\n \n-      final CharsRef spare = new CharsRef();\n+      final CharsRefBuilder spare = new CharsRefBuilder();\n+\n+      // System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n \n-      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n-    \n       // Intersect automaton w/ suggest wFST and get all\n       // prefix starting nodes & their outputs:\n-      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n+      // final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n \n-      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n+      // System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n \n       BytesReader bytesReader = fst.getBytesReader();\n \n-      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n+      FST.Arc<Pair<Long, BytesRef>> scratchArc = new FST.Arc<>();\n \n-      final List<LookupResult> results = new ArrayList<LookupResult>();\n+      final List<LookupResult> results = new ArrayList<>();\n \n-      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n+      List<FSTUtil.Path<Pair<Long, BytesRef>>> prefixPaths =\n+          FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n \n       if (exactFirst) {\n \n         int count = 0;\n-        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n-          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n+        for (FSTUtil.Path<Pair<Long, BytesRef>> path : prefixPaths) {\n+          if (fst.findTargetArc(END_BYTE, path.fstNode(), scratchArc, bytesReader) != null) {\n             // This node has END_BYTE arc leaving, meaning it's an\n             // \"exact\" match:\n             count++;\n@@ -703,23 +802,33 @@ public class XAnalyzingSuggester extends Lookup {\n \n         // Searcher just to find the single exact only\n         // match, if present:\n-        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n-        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n+        Util.TopNSearcher<Pair<Long, BytesRef>> searcher;\n+        searcher =\n+            new Util.TopNSearcher<>(\n+                fst,\n+                count * maxSurfaceFormsPerAnalyzedForm,\n+                count * maxSurfaceFormsPerAnalyzedForm,\n+                weightComparator);\n \n         // NOTE: we could almost get away with only using\n         // the first start node.  The only catch is if\n         // maxSurfaceFormsPerAnalyzedForm had kicked in and\n         // pruned our exact match from one of these nodes\n         // ...:\n-        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n-          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n+        for (FSTUtil.Path<Pair<Long, BytesRef>> path : prefixPaths) {\n+          if (fst.findTargetArc(END_BYTE, path.fstNode(), scratchArc, bytesReader) != null) {\n             // This node has END_BYTE arc leaving, meaning it's an\n             // \"exact\" match:\n-            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n+            searcher.addStartPaths(\n+                scratchArc,\n+                fst.outputs.add(path.output(), scratchArc.output()),\n+                false,\n+                path.input());\n           }\n         }\n \n-        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n+        TopResults<Pair<Long, BytesRef>> completions = searcher.search();\n+        assert completions.isComplete;\n \n         // NOTE: this is rather inefficient: we enumerate\n         // every matching \"exactly the same analyzed form\"\n@@ -733,10 +842,10 @@ public class XAnalyzingSuggester extends Lookup {\n         // seach: it's bounded by how many prefix start\n         // nodes we have and the\n         // maxSurfaceFormsPerAnalyzedForm:\n-        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n-          BytesRef output2 = completion.output.output2;\n+        for (Util.Result<Pair<Long, BytesRef>> completion : completions) {\n+          BytesRef output2 = completion.output().output2;\n           if (sameSurfaceForm(utf8Key, output2)) {\n-            results.add(getLookupResult(completion.output.output1, output2, spare));\n+            results.add(getLookupResult(completion.output().output1, output2, spare));\n             break;\n           }\n         }\n@@ -747,57 +856,58 @@ public class XAnalyzingSuggester extends Lookup {\n         }\n       }\n \n-      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n-      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n-                                                            num - results.size(),\n-                                                            num * maxAnalyzedPathsForOneInput,\n-                                                            weightComparator) {\n-        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n+      Util.TopNSearcher<Pair<Long, BytesRef>> searcher;\n+      searcher =\n+          new Util.TopNSearcher<>(\n+              fst, num - results.size(), num * maxAnalyzedPathsForOneInput, weightComparator) {\n+            private final Set<BytesRef> seen = new HashSet<>();\n \n-        @Override\n-        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n+            @Override\n+            protected boolean acceptResult(IntsRef input, Pair<Long, BytesRef> output) {\n \n-          // Dedup: when the input analyzes to a graph we\n-          // can get duplicate surface forms:\n-          if (seen.contains(output.output2)) {\n-            return false;\n-          }\n-          seen.add(output.output2);\n-          \n-          if (!exactFirst) {\n-            return true;\n-          } else {\n-            // In exactFirst mode, don't accept any paths\n-            // matching the surface form since that will\n-            // create duplicate results:\n-            if (sameSurfaceForm(utf8Key, output.output2)) {\n-              // We found exact match, which means we should\n-              // have already found it in the first search:\n-              assert results.size() == 1;\n-              return false;\n-            } else {\n-              return true;\n+              // Dedup: when the input analyzes to a graph we\n+              // can get duplicate surface forms:\n+              if (seen.contains(output.output2)) {\n+                return false;\n+              }\n+              seen.add(output.output2);\n+\n+              if (!exactFirst) {\n+                return true;\n+              } else {\n+                // In exactFirst mode, don't accept any paths\n+                // matching the surface form since that will\n+                // create duplicate results:\n+                if (sameSurfaceForm(utf8Key, output.output2)) {\n+                  // We found exact match, which means we should\n+                  // have already found it in the first search:\n+                  assert results.size() == 1;\n+                  return false;\n+                } else {\n+                  return true;\n+                }\n+              }\n             }\n-          }\n-        }\n-      };\n+          };\n \n       prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n-      \n-      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n-        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n+\n+      for (FSTUtil.Path<Pair<Long, BytesRef>> path : prefixPaths) {\n+        searcher.addStartPaths(path.fstNode(), path.output(), true, path.input());\n       }\n \n-      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n+      TopResults<Pair<Long, BytesRef>> completions = searcher.search();\n+      assert completions.isComplete;\n \n-      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n+      for (Util.Result<Pair<Long, BytesRef>> completion : completions) {\n \n-        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n+        LookupResult result =\n+            getLookupResult(completion.output().output1, completion.output().output2, spare);\n \n         // TODO: for fuzzy case would be nice to return\n         // how many edits were required\n \n-        //System.out.println(\"    result=\" + result);\n+        // System.out.println(\"    result=\" + result);\n         results.add(result);\n \n         if (results.size() == num) {\n@@ -821,54 +931,7 @@ public class XAnalyzingSuggester extends Lookup {\n     return prefixPaths;\n   }\n   \n-  final Set<IntsRef> toFiniteStrings(final BytesRef surfaceForm, final TokenStreamToAutomaton ts2a) throws IOException {\n-      // Analyze surface form:\n-    TokenStream ts = indexAnalyzer.tokenStream(\"\", surfaceForm.utf8ToString());\n-    return toFiniteStrings(ts2a, ts);\n-  }\n   \n-  public final Set<IntsRef> toFiniteStrings(final TokenStreamToAutomaton ts2a, TokenStream ts) throws IOException {\n-      // Analyze surface form:\n-\n-      // Create corresponding automaton: labels are bytes\n-      // from each analyzed token, with byte 0 used as\n-      // separator between tokens:\n-      Automaton automaton = ts2a.toAutomaton(ts);\n-      ts.close();\n-\n-      replaceSep(automaton, preserveSep);\n-\n-      assert SpecialOperations.isFinite(automaton);\n-\n-      // Get all paths from the automaton (there can be\n-      // more than one path, eg if the analyzer created a\n-      // graph using SynFilter or WDF):\n-\n-      // TODO: we could walk & add simultaneously, so we\n-      // don't have to alloc [possibly biggish]\n-      // intermediate HashSet in RAM:\n-      return SpecialOperations.getFiniteStrings(automaton, maxGraphExpansions);\n-  }\n-\n-  final Automaton toLookupAutomaton(final CharSequence key) throws IOException {\n-    // Turn tokenstream into automaton:\n-    TokenStream ts = queryAnalyzer.tokenStream(\"\", key.toString());\n-    Automaton automaton = (getTokenStreamToAutomaton()).toAutomaton(ts);\n-    ts.close();\n-\n-    // TODO: we could use the end offset to \"guess\"\n-    // whether the final token was a partial token; this\n-    // would only be a heuristic ... but maybe an OK one.\n-    // This way we could eg differentiate \"net\" from \"net \",\n-    // which we can't today...\n-\n-    replaceSep(automaton, preserveSep);\n-\n-    // TODO: we can optimize this somewhat by determinizing\n-    // while we convert\n-    BasicOperations.determinize(automaton);\n-    return automaton;\n-  }\n   \n   \n \n@@ -876,6 +939,11 @@ public class XAnalyzingSuggester extends Lookup {\n    * Returns the weight associated with an input string,\n    * or null if it does not exist.\n    */\n+  @Override\n+  public long getCount() {\n+    return count;\n+  }\n+\n   public Object get(CharSequence key) {\n     throw new UnsupportedOperationException();\n   }\n@@ -899,6 +967,42 @@ public class XAnalyzingSuggester extends Lookup {\n       return left.output1.compareTo(right.output1);\n     }\n   };\n+\n+  final Automaton toAutomaton(final BytesRef surfaceForm, final TokenStreamToAutomaton ts2a)\n+      throws IOException {\n+    // Analyze surface form:\n+    Automaton automaton;\n+    try (TokenStream ts = indexAnalyzer.tokenStream(\"\", surfaceForm.utf8ToString())) {\n+\n+      // Create corresponding automaton: labels are bytes\n+      // from each analyzed token, with byte 0 used as\n+      // separator between tokens:\n+      automaton = ts2a.toAutomaton(ts);\n+    }\n+\n+    automaton = replaceSep(automaton);\n+\n+    // Get all paths from the automaton (there can be\n+    // more than one path, eg if the analyzer created a\n+    // graph using SynFilter or WDF):\n+    return automaton;\n+  }\n+\n+  final Automaton toLookupAutomaton(final CharSequence key) throws IOException {\n+    // TODO: is there a Reader from a CharSequence?\n+    // Turn tokenstream into automaton:\n+    Automaton automaton = null;\n+    try (TokenStream ts = queryAnalyzer.tokenStream(\"\", key.toString())) {\n+      automaton = getTokenStreamToAutomaton().toAutomaton(ts);\n+    }\n+\n+    automaton = replaceSep(automaton);\n+\n+    // TODO: we can optimize this somewhat by determinizing\n+    // while we convert\n+    automaton = Operations.determinize(automaton, DEFAULT_DETERMINIZE_WORK_LIMIT);\n+    return automaton;\n+  }\n   \n   \n     public static class XBuilder {",
  "logs_path": "factory/mcp:glm-4.6/6bf04592/elastic_elasticsearch_pr4253/logs.jsonl",
  "errors": [],
  "edit_run_id": "6bf04592",
  "test_label": "v1-mcp"
}