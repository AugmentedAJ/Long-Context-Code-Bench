diff --git a/src/main/java/org/apache/lucene/search/suggest/analyzing/XAnalyzingSuggester.java b/src/main/java/org/apache/lucene/search/suggest/analyzing/XAnalyzingSuggester.java
index f107d17..7b2188d 100644
--- a/src/main/java/org/apache/lucene/search/suggest/analyzing/XAnalyzingSuggester.java
+++ b/src/main/java/org/apache/lucene/search/suggest/analyzing/XAnalyzingSuggester.java
@@ -18,10 +18,13 @@
  */
 package org.apache.lucene.search.suggest.analyzing;
 
+import static org.apache.lucene.util.automaton.Operations.DEFAULT_DETERMINIZE_WORK_LIMIT;
+
 import com.carrotsearch.hppc.ObjectIntOpenHashMap;
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.TokenStreamToAutomaton;
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.search.suggest.InputIterator;
 import org.apache.lucene.search.suggest.Lookup;
 import org.apache.lucene.search.suggest.Sort;
@@ -123,6 +126,9 @@ public class XAnalyzingSuggester extends Lookup {
    */
   private final boolean preserveSep;
 
+  private final Directory tempDir;
+  private final String tempFileNamePrefix;
+
   /** Include this flag in the options parameter to {@link
    *  #XAnalyzingSuggester(Analyzer,Analyzer,int,int,int,FST,boolean,int)} to always
    *  return the exact match first, regardless of score.  This
@@ -165,22 +171,82 @@ public class XAnalyzingSuggester extends Lookup {
   /** Whether position holes should appear in the automaton. */
   private boolean preservePositionIncrements;
 
+  /** Number of entries the lookup was built with */
+  private volatile long count = 0;
+
   /**
-   * Calls {@link #XAnalyzingSuggester(Analyzer,Analyzer,int,int,int,FST,boolean,int)
+   * Calls {@link #XAnalyzingSuggester(Directory,String,Analyzer,Analyzer,int,int,int,boolean)}
    * AnalyzingSuggester(analyzer, analyzer, EXACT_FIRST |
-   * PRESERVE_SEP, 256, -1)}
+   * PRESERVE_SEP, 256, -1, true)}
    */
-  public XAnalyzingSuggester(Analyzer analyzer) {
-    this(analyzer, analyzer, EXACT_FIRST | PRESERVE_SEP, 256, -1, null, false, 0);
+  public XAnalyzingSuggester(Directory tempDir, String tempFileNamePrefix, Analyzer analyzer) {
+    this(tempDir, tempFileNamePrefix, analyzer, analyzer, EXACT_FIRST | PRESERVE_SEP, 256, -1, true);
   }
 
   /**
-   * Calls {@link #XAnalyzingSuggester(Analyzer,Analyzer,int,int,int,FST,boolean,int)
+   * Calls {@link #XAnalyzingSuggester(Directory,String,Analyzer,Analyzer,int,int,int,boolean)}
    * AnalyzingSuggester(indexAnalyzer, queryAnalyzer, EXACT_FIRST |
-   * PRESERVE_SEP, 256, -1)}
+   * PRESERVE_SEP, 256, -1, true)}
+   */
+  public XAnalyzingSuggester(Directory tempDir, String tempFileNamePrefix, Analyzer indexAnalyzer, Analyzer queryAnalyzer) {
+    this(tempDir, tempFileNamePrefix, indexAnalyzer, queryAnalyzer, EXACT_FIRST | PRESERVE_SEP, 256, -1, true);
+  }
+
+  /**
+   * Creates a new suggester.
+   * 
+   * @param tempDir Temporary directory for sorting
+   * @param tempFileNamePrefix Prefix for temp files
+   * @param indexAnalyzer Analyzer that will be used for
+   *   analyzing suggestions while building the index.
+   * @param queryAnalyzer Analyzer that will be used for
+   *   analyzing query text during lookup
+   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}
+   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of
+   *   surface forms to keep for a single analyzed form.
+   *   When there are too many surface forms we discard the
+   *   lowest weighted ones.
+   * @param maxGraphExpansions Maximum number of graph paths
+   *   to expand from the analyzed form.  Set this to -1 for
+   *   no limit.
+   * @param preservePositionIncrements Whether position holes should appear in automaton
    */
-  public XAnalyzingSuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer) {
-    this(indexAnalyzer, queryAnalyzer, EXACT_FIRST | PRESERVE_SEP, 256, -1, null, false, 0);
+  public XAnalyzingSuggester(
+      Directory tempDir,
+      String tempFileNamePrefix,
+      Analyzer indexAnalyzer, 
+      Analyzer queryAnalyzer, 
+      int options, 
+      int maxSurfaceFormsPerAnalyzedForm, 
+      int maxGraphExpansions,
+      boolean preservePositionIncrements) { 
+      this.indexAnalyzer = indexAnalyzer;
+      this.queryAnalyzer = queryAnalyzer;
+      this.fst = null;
+      this.hasPayloads = false;
+      if ((options & ~(EXACT_FIRST | PRESERVE_SEP)) != 0) {
+        throw new IllegalArgumentException("options should only contain EXACT_FIRST and PRESERVE_SEP; got " + options);
+      }
+      this.exactFirst = (options & EXACT_FIRST) != 0;
+      this.preserveSep = (options & PRESERVE_SEP) != 0;
+
+      // NOTE: this is just an implementation limitation; if
+      // somehow this is a problem we could fix it by using
+      // more than one byte to disambiguate ... but 256 seems
+      // like it should be way more then enough.
+      if (maxSurfaceFormsPerAnalyzedForm <= 0 || maxSurfaceFormsPerAnalyzedForm > 256) {
+        throw new IllegalArgumentException("maxSurfaceFormsPerAnalyzedForm must be > 0 and < 256 (got: " + maxSurfaceFormsPerAnalyzedForm + ")");
+      }
+      this.maxSurfaceFormsPerAnalyzedForm = maxSurfaceFormsPerAnalyzedForm;
+
+      if (maxGraphExpansions < 1 && maxGraphExpansions != -1) {
+        throw new IllegalArgumentException("maxGraphExpansions must -1 (no limit) or > 0 (got: " + maxGraphExpansions + ")");
+      }
+      this.maxGraphExpansions = maxGraphExpansions;
+      this.maxAnalyzedPathsForOneInput = 0;
+      this.preservePositionIncrements = preservePositionIncrements;
+      this.tempDir = tempDir;
+      this.tempFileNamePrefix = tempFileNamePrefix;
   }
 
   /**
@@ -236,41 +302,41 @@ public class XAnalyzingSuggester extends Lookup {
   }
 
     /** Returns byte size of the underlying FST. */
-  public long sizeInBytes() {
-    return fst == null ? 0 : fst.sizeInBytes();
+  @Override
+  public long ramBytesUsed() {
+    return fst == null ? 0 : fst.ramBytesUsed();
   }
 
-  private static void copyDestTransitions(State from, State to, List<Transition> transitions) {
-    if (to.isAccept()) {
-      from.setAccept(true);
-    }
-    for(Transition t : to.getTransitions()) {
-      transitions.add(t);
-    }
-  }
+  
 
   // Replaces SEP with epsilon or remaps them if
   // we were asked to preserve them:
-  private static void replaceSep(Automaton a, boolean preserveSep) {
+  private Automaton replaceSep(Automaton a) {
 
-    State[] states = a.getNumberedStates();
+    int numStates = a.getNumStates();
+    Automaton.Builder result = new Automaton.Builder(numStates, a.getNumTransitions());
+    // Copy all states over
+    result.copyStates(a);
 
     // Go in reverse topo sort so we know we only have to
     // make one pass:
-    for(int stateNumber=states.length-1;stateNumber >=0;stateNumber--) {
-      final State state = states[stateNumber];
-      List<Transition> newTransitions = new ArrayList<Transition>();
-      for(Transition t : state.getTransitions()) {
-        assert t.getMin() == t.getMax();
-        if (t.getMin() == TokenStreamToAutomaton.POS_SEP) {
+    Transition t = new Transition();
+    int[] topoSortStates = Operations.topoSortStates(a);
+    for (int i = 0; i < topoSortStates.length; i++) {
+      int state = topoSortStates[topoSortStates.length - 1 - i];
+      int count = a.initTransition(state, t);
+      for (int j = 0; j < count; j++) {
+        a.getNextTransition(t);
+        if (t.min == TokenStreamToAutomaton.POS_SEP) {
+          assert t.max == TokenStreamToAutomaton.POS_SEP;
           if (preserveSep) {
             // Remap to SEP_LABEL:
-            newTransitions.add(new Transition(SEP_LABEL, t.getDest()));
+            result.addTransition(state, t.dest, SEP_LABEL);
           } else {
-            copyDestTransitions(state, t.getDest(), newTransitions);
-            a.setDeterministic(false);
+            result.addEpsilon(state, t.dest);
           }
-        } else if (t.getMin() == TokenStreamToAutomaton.HOLE) {
+        } else if (t.min == TokenStreamToAutomaton.HOLE) {
+          assert t.max == TokenStreamToAutomaton.HOLE;
 
           // Just remove the hole: there will then be two
           // SEP tokens next to each other, which will only
@@ -279,14 +345,14 @@ public class XAnalyzingSuggester extends Lookup {
           // that's somehow a problem we can always map HOLE
           // to a dedicated byte (and escape it in the
           // input).
-          copyDestTransitions(state, t.getDest(), newTransitions);
-          a.setDeterministic(false);
+          result.addEpsilon(state, t.dest);
         } else {
-          newTransitions.add(t);
+          result.addTransition(state, t.dest, t.min, t.max);
         }
       }
-      state.setTransitions(newTransitions.toArray(new Transition[newTransitions.size()]));
     }
+
+    return result.finish();
   }
 
   /** Just escapes the 0xff byte (which we still for SEP). */
@@ -318,7 +384,12 @@ public class XAnalyzingSuggester extends Lookup {
     }
   }
 
-  public TokenStreamToAutomaton getTokenStreamToAutomaton() {
+  /** Used by subclass to change lookup automaton, if necessary. */
+  protected Automaton convertAutomaton(Automaton a) {
+    return a;
+  }
+
+  TokenStreamToAutomaton getTokenStreamToAutomaton() {
     final TokenStreamToAutomaton tsta;
     if (preserveSep) {
       tsta = new EscapingTokenStreamToAutomaton();
@@ -328,6 +399,7 @@ public class XAnalyzingSuggester extends Lookup {
       tsta = new TokenStreamToAutomaton();
     }
     tsta.setPreservePositionIncrements(preservePositionIncrements);
+    tsta.setFinalOffsetGapAsHole(true);
     return tsta;
   }
   
@@ -391,39 +463,48 @@ public class XAnalyzingSuggester extends Lookup {
 
   @Override
   public void build(InputIterator iterator) throws IOException {
-    String prefix = getClass().getSimpleName();
-    File directory = Sort.defaultTempDir();
-    File tempInput = File.createTempFile(prefix, ".input", directory);
-    File tempSorted = File.createTempFile(prefix, ".sorted", directory);
+    if (iterator.hasContexts()) {
+      throw new IllegalArgumentException("this suggester doesn't support contexts");
+    }
 
     hasPayloads = iterator.hasPayloads();
 
-    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);
-    Sort.ByteSequencesReader reader = null;
-    BytesRef scratch = new BytesRef();
+    OfflineSorter sorter =
+        new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));
+
+    IndexOutput tempInput =
+        tempDir.createTempOutput(tempFileNamePrefix, "input", IOContext.DEFAULT);
+
+    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);
+    OfflineSorter.ByteSequencesReader reader = null;
+    BytesRefBuilder scratch = new BytesRefBuilder();
 
     TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();
 
-    boolean success = false;
-    byte buffer[] = new byte[8];
+    String tempSortedFileName = null;
+
+    long newCount = 0;
+    byte[] buffer = new byte[8];
     try {
       ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);
-      BytesRef surfaceForm;
 
-      while ((surfaceForm = iterator.next()) != null) {
-        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);
-        
-        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());
+      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null; ) {
+        LimitedFiniteStringsIterator finiteStrings =
+            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);
 
-        for (IntsRef path : paths) {
+        for (IntsRef string; (string = finiteStrings.next()) != null; newCount++) {
+          Util.toBytesRef(string, scratch);
 
-          Util.toBytesRef(path, scratch);
-          
           // length of the analyzed text (FST input)
-          if (scratch.length > Short.MAX_VALUE-2) {
-            throw new IllegalArgumentException("cannot handle analyzed forms > " + (Short.MAX_VALUE-2) + " in length (got " + scratch.length + ")");
+          if (scratch.length() > Short.MAX_VALUE - 2) {
+            throw new IllegalArgumentException(
+                "cannot handle analyzed forms > "
+                    + (Short.MAX_VALUE - 2)
+                    + " in length (got "
+                    + scratch.length()
+                    + ")");
           }
-          short analyzedLength = (short) scratch.length;
+          short analyzedLength = (short) scratch.length();
 
           // compute the required length:
           // analyzed sequence + weight (4) + surface + analyzedLength (short)
@@ -432,8 +513,13 @@ public class XAnalyzingSuggester extends Lookup {
           BytesRef payload;
 
           if (hasPayloads) {
-            if (surfaceForm.length > (Short.MAX_VALUE-2)) {
-              throw new IllegalArgumentException("cannot handle surface form > " + (Short.MAX_VALUE-2) + " in length (got " + surfaceForm.length + ")");
+            if (surfaceForm.length > (Short.MAX_VALUE - 2)) {
+              throw new IllegalArgumentException(
+                  "cannot handle surface form > "
+                      + (Short.MAX_VALUE - 2)
+                      + " in length (got "
+                      + surfaceForm.length
+                      + ")");
             }
             payload = iterator.payload();
             // payload + surfaceLength (short)
@@ -441,21 +527,22 @@ public class XAnalyzingSuggester extends Lookup {
           } else {
             payload = null;
           }
-          
-          buffer = ArrayUtil.grow(buffer, requiredLength);
-          
+
+          buffer = ArrayUtil.growNoCopy(buffer, requiredLength);
+
           output.reset(buffer);
 
           output.writeShort(analyzedLength);
 
-          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);
+          output.writeBytes(scratch.bytes(), 0, scratch.length());
 
           output.writeInt(encodeWeight(iterator.weight()));
 
           if (hasPayloads) {
-            for(int i=0;i<surfaceForm.length;i++) {
+            for (int i = 0; i < surfaceForm.length; i++) {
               if (surfaceForm.bytes[i] == PAYLOAD_SEP) {
-                throw new IllegalArgumentException("surface form cannot contain unit separator character U+001F; this character is reserved");
+                throw new IllegalArgumentException(
+                    "surface form cannot contain unit separator character U+001F; this character is reserved");
               }
             }
             output.writeShort((short) surfaceForm.length);
@@ -465,61 +552,72 @@ public class XAnalyzingSuggester extends Lookup {
             output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);
           }
 
-          assert output.getPosition() == requiredLength: output.getPosition() + " vs " + requiredLength;
-
+          assert output.getPosition() == requiredLength
+              : output.getPosition() + " vs " + requiredLength;
           writer.write(buffer, 0, output.getPosition());
         }
+
+        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());
       }
+      CodecUtil.writeFooter(tempInput);
       writer.close();
 
       // Sort all input/output pairs (required by FST.Builder):
-      new Sort(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);
+      tempSortedFileName = sorter.sort(tempInput.getName());
 
       // Free disk space:
-      tempInput.delete();
+      tempDir.deleteFile(tempInput.getName());
 
-      reader = new Sort.ByteSequencesReader(tempSorted);
-     
-      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());
-      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);
+      reader =
+          new OfflineSorter.ByteSequencesReader(
+              tempDir.openChecksumInput(tempSortedFileName), tempSortedFileName);
+
+      PairOutputs<Long, BytesRef> outputs =
+          new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());
+      FSTCompiler<Pair<Long, BytesRef>> fstCompiler =
+          new FSTCompiler.Builder<>(FST.INPUT_TYPE.BYTE1, outputs).build();
 
       // Build FST:
-      BytesRef previousAnalyzed = null;
-      BytesRef analyzed = new BytesRef();
+      BytesRefBuilder previousAnalyzed = null;
+      BytesRefBuilder analyzed = new BytesRefBuilder();
       BytesRef surface = new BytesRef();
-      IntsRef scratchInts = new IntsRef();
+      IntsRefBuilder scratchInts = new IntsRefBuilder();
       ByteArrayDataInput input = new ByteArrayDataInput();
 
       // Used to remove duplicate surface forms (but we
       // still index the hightest-weight one).  We clear
       // this when we see a new analyzed form, so it cannot
       // grow unbounded (at most 256 entries):
-      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();
+      Set<BytesRef> seenSurfaceForms = new HashSet<>();
 
       int dedup = 0;
-      while (reader.read(scratch)) {
-        input.reset(scratch.bytes, scratch.offset, scratch.length);
+      while (true) {
+        BytesRef bytes = reader.next();
+        if (bytes == null) {
+          break;
+        }
+        input.reset(bytes.bytes, bytes.offset, bytes.length);
         short analyzedLength = input.readShort();
-        analyzed.grow(analyzedLength+2);
-        input.readBytes(analyzed.bytes, 0, analyzedLength);
-        analyzed.length = analyzedLength;
+        analyzed.growNoCopy(analyzedLength + 2);
+        input.readBytes(analyzed.bytes(), 0, analyzedLength);
+        analyzed.setLength(analyzedLength);
 
         long cost = input.readInt();
 
-        surface.bytes = scratch.bytes;
+        surface.bytes = bytes.bytes;
         if (hasPayloads) {
           surface.length = input.readShort();
           surface.offset = input.getPosition();
         } else {
           surface.offset = input.getPosition();
-          surface.length = scratch.length - surface.offset;
+          surface.length = bytes.length - surface.offset;
         }
-        
+
         if (previousAnalyzed == null) {
-          previousAnalyzed = new BytesRef();
-          previousAnalyzed.copyBytes(analyzed);
+          previousAnalyzed = new BytesRefBuilder();
+          previousAnalyzed.copyBytes(analyzed.get());
           seenSurfaceForms.add(BytesRef.deepCopyOf(surface));
-        } else if (analyzed.equals(previousAnalyzed)) {
+        } else if (analyzed.get().equals(previousAnalyzed.get())) {
           dedup++;
           if (dedup >= maxSurfaceFormsPerAnalyzedForm) {
             // More than maxSurfaceFormsPerAnalyzedForm
@@ -545,78 +643,65 @@ public class XAnalyzingSuggester extends Lookup {
 
         // NOTE: must be byte 0 so we sort before whatever
         // is next
-        analyzed.bytes[analyzed.offset+analyzed.length] = 0;
-        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;
-        analyzed.length += 2;
+        analyzed.append((byte) 0);
+        analyzed.append((byte) dedup);
 
-        Util.toIntsRef(analyzed, scratchInts);
-        //System.out.println("ADD: " + scratchInts + " -> " + cost + ": " + surface.utf8ToString());
+        Util.toIntsRef(analyzed.get(), scratchInts);
+        // System.out.println("ADD: " + scratchInts + " -> " + cost + ": " +
+        // surface.utf8ToString());
         if (!hasPayloads) {
-          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));
+          fstCompiler.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));
         } else {
           int payloadOffset = input.getPosition() + surface.length;
-          int payloadLength = scratch.length - payloadOffset;
+          int payloadLength = bytes.length - payloadOffset;
           BytesRef br = new BytesRef(surface.length + 1 + payloadLength);
           System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);
           br.bytes[surface.length] = PAYLOAD_SEP;
-          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);
+          System.arraycopy(bytes.bytes, payloadOffset, br.bytes, surface.length + 1, payloadLength);
           br.length = br.bytes.length;
-          builder.add(scratchInts, outputs.newPair(cost, br));
+          fstCompiler.add(scratchInts.get(), outputs.newPair(cost, br));
         }
       }
-      fst = builder.finish();
+      fst = FST.fromFSTReader(fstCompiler.compile(), fstCompiler.getFSTReader());
+      count = newCount;
 
-      //Util.dotToFile(fst, "/tmp/suggest.dot");
-      
-      success = true;
+      // Util.dotToFile(fst, "/tmp/suggest.dot");
     } finally {
-      if (success) {
-        IOUtils.close(reader, writer);
-      } else {
-        IOUtils.closeWhileHandlingException(reader, writer);
-      }
-      
-      tempInput.delete();
-      tempSorted.delete();
+      IOUtils.closeWhileHandlingException(reader, writer);
+      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);
     }
   }
 
   @Override
-  public boolean store(OutputStream output) throws IOException {
-    DataOutput dataOut = new OutputStreamDataOutput(output);
-    try {
-      if (fst == null) {
-        return false;
-      }
-
-      fst.save(dataOut);
-      dataOut.writeVInt(maxAnalyzedPathsForOneInput);
-      dataOut.writeByte((byte) (hasPayloads ? 1 : 0));
-    } finally {
-      IOUtils.close(output);
+  public boolean store(DataOutput output) throws IOException {
+    output.writeVLong(count);
+    if (fst == null) {
+      return false;
     }
+
+    fst.save(output, output);
+    output.writeVInt(maxAnalyzedPathsForOneInput);
+    output.writeByte((byte) (hasPayloads ? 1 : 0));
     return true;
   }
 
   @Override
-  public boolean load(InputStream input) throws IOException {
-    DataInput dataIn = new InputStreamDataInput(input);
-    try {
-      this.fst = new FST<Pair<Long,BytesRef>>(dataIn, new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton()));
-      maxAnalyzedPathsForOneInput = dataIn.readVInt();
-      hasPayloads = dataIn.readByte() == 1;
-    } finally {
-      IOUtils.close(input);
-    }
+  public boolean load(DataInput input) throws IOException {
+    count = input.readVLong();
+    PairOutputs<Long, BytesRef> outputs =
+        new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());
+    this.fst = new FST<>(FST.readMetadata(input, outputs), input);
+    maxAnalyzedPathsForOneInput = input.readVInt();
+    hasPayloads = input.readByte() == 1;
     return true;
   }
 
-  private LookupResult getLookupResult(Long output1, BytesRef output2, CharsRef spare) {
+  private LookupResult getLookupResult(Long output1, BytesRef output2, CharsRefBuilder spare) {
     LookupResult result;
     if (hasPayloads) {
       int sepIndex = -1;
-      for(int i=0;i<output2.length;i++) {
-        if (output2.bytes[output2.offset+i] == PAYLOAD_SEP) {
+      for (int i = 0; i < output2.length; i++) {
+        if (output2.bytes[output2.offset + i] == PAYLOAD_SEP) {
           sepIndex = i;
           break;
         }
@@ -624,14 +709,14 @@ public class XAnalyzingSuggester extends Lookup {
       assert sepIndex != -1;
       spare.grow(sepIndex);
       final int payloadLen = output2.length - sepIndex - 1;
-      UnicodeUtil.UTF8toUTF16(output2.bytes, output2.offset, sepIndex, spare);
+      spare.copyUTF8Bytes(output2.bytes, output2.offset, sepIndex);
       BytesRef payload = new BytesRef(payloadLen);
-      System.arraycopy(output2.bytes, sepIndex+1, payload.bytes, 0, payloadLen);
+      System.arraycopy(output2.bytes, sepIndex + 1, payload.bytes, 0, payloadLen);
       payload.length = payloadLen;
       result = new LookupResult(spare.toString(), decodeWeight(output1), payload);
     } else {
       spare.grow(output2.length);
-      UnicodeUtil.UTF8toUTF16(output2, spare);
+      spare.copyUTF8Bytes(output2);
       result = new LookupResult(spare.toString(), decodeWeight(output1));
     }
 
@@ -656,45 +741,59 @@ public class XAnalyzingSuggester extends Lookup {
   }
 
   @Override
-  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {
+  public List<LookupResult> lookup(
+      final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {
     assert num > 0;
 
     if (onlyMorePopular) {
       throw new IllegalArgumentException("this suggester only works with onlyMorePopular=false");
     }
+    if (contexts != null) {
+      throw new IllegalArgumentException("this suggester doesn't support contexts");
+    }
     if (fst == null) {
       return Collections.emptyList();
     }
 
-    //System.out.println("lookup key=" + key + " num=" + num);
+    // System.out.println("lookup key=" + key + " num=" + num);
+    for (int i = 0; i < key.length(); i++) {
+      if (key.charAt(i) == 0x1E) {
+        throw new IllegalArgumentException(
+            "lookup key cannot contain HOLE character U+001E; this character is reserved");
+      }
+      if (key.charAt(i) == 0x1F) {
+        throw new IllegalArgumentException(
+            "lookup key cannot contain unit separator character U+001F; this character is reserved");
+      }
+    }
     final BytesRef utf8Key = new BytesRef(key);
     try {
-
       Automaton lookupAutomaton = toLookupAutomaton(key);
 
-      final CharsRef spare = new CharsRef();
+      final CharsRefBuilder spare = new CharsRefBuilder();
+
+      // System.out.println("  now intersect exactFirst=" + exactFirst);
 
-      //System.out.println("  now intersect exactFirst=" + exactFirst);
-    
       // Intersect automaton w/ suggest wFST and get all
       // prefix starting nodes & their outputs:
-      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);
+      // final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);
 
-      //System.out.println("  prefixPaths: " + prefixPaths.size());
+      // System.out.println("  prefixPaths: " + prefixPaths.size());
 
       BytesReader bytesReader = fst.getBytesReader();
 
-      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();
+      FST.Arc<Pair<Long, BytesRef>> scratchArc = new FST.Arc<>();
 
-      final List<LookupResult> results = new ArrayList<LookupResult>();
+      final List<LookupResult> results = new ArrayList<>();
 
-      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);
+      List<FSTUtil.Path<Pair<Long, BytesRef>>> prefixPaths =
+          FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);
 
       if (exactFirst) {
 
         int count = 0;
-        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {
-          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {
+        for (FSTUtil.Path<Pair<Long, BytesRef>> path : prefixPaths) {
+          if (fst.findTargetArc(END_BYTE, path.fstNode(), scratchArc, bytesReader) != null) {
             // This node has END_BYTE arc leaving, meaning it's an
             // "exact" match:
             count++;
@@ -703,23 +802,33 @@ public class XAnalyzingSuggester extends Lookup {
 
         // Searcher just to find the single exact only
         // match, if present:
-        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;
-        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);
+        Util.TopNSearcher<Pair<Long, BytesRef>> searcher;
+        searcher =
+            new Util.TopNSearcher<>(
+                fst,
+                count * maxSurfaceFormsPerAnalyzedForm,
+                count * maxSurfaceFormsPerAnalyzedForm,
+                weightComparator);
 
         // NOTE: we could almost get away with only using
         // the first start node.  The only catch is if
         // maxSurfaceFormsPerAnalyzedForm had kicked in and
         // pruned our exact match from one of these nodes
         // ...:
-        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {
-          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {
+        for (FSTUtil.Path<Pair<Long, BytesRef>> path : prefixPaths) {
+          if (fst.findTargetArc(END_BYTE, path.fstNode(), scratchArc, bytesReader) != null) {
             // This node has END_BYTE arc leaving, meaning it's an
             // "exact" match:
-            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);
+            searcher.addStartPaths(
+                scratchArc,
+                fst.outputs.add(path.output(), scratchArc.output()),
+                false,
+                path.input());
           }
         }
 
-        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();
+        TopResults<Pair<Long, BytesRef>> completions = searcher.search();
+        assert completions.isComplete;
 
         // NOTE: this is rather inefficient: we enumerate
         // every matching "exactly the same analyzed form"
@@ -733,10 +842,10 @@ public class XAnalyzingSuggester extends Lookup {
         // seach: it's bounded by how many prefix start
         // nodes we have and the
         // maxSurfaceFormsPerAnalyzedForm:
-        for(MinResult<Pair<Long,BytesRef>> completion : completions) {
-          BytesRef output2 = completion.output.output2;
+        for (Util.Result<Pair<Long, BytesRef>> completion : completions) {
+          BytesRef output2 = completion.output().output2;
           if (sameSurfaceForm(utf8Key, output2)) {
-            results.add(getLookupResult(completion.output.output1, output2, spare));
+            results.add(getLookupResult(completion.output().output1, output2, spare));
             break;
           }
         }
@@ -747,57 +856,58 @@ public class XAnalyzingSuggester extends Lookup {
         }
       }
 
-      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;
-      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,
-                                                            num - results.size(),
-                                                            num * maxAnalyzedPathsForOneInput,
-                                                            weightComparator) {
-        private final Set<BytesRef> seen = new HashSet<BytesRef>();
+      Util.TopNSearcher<Pair<Long, BytesRef>> searcher;
+      searcher =
+          new Util.TopNSearcher<>(
+              fst, num - results.size(), num * maxAnalyzedPathsForOneInput, weightComparator) {
+            private final Set<BytesRef> seen = new HashSet<>();
 
-        @Override
-        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {
+            @Override
+            protected boolean acceptResult(IntsRef input, Pair<Long, BytesRef> output) {
 
-          // Dedup: when the input analyzes to a graph we
-          // can get duplicate surface forms:
-          if (seen.contains(output.output2)) {
-            return false;
-          }
-          seen.add(output.output2);
-          
-          if (!exactFirst) {
-            return true;
-          } else {
-            // In exactFirst mode, don't accept any paths
-            // matching the surface form since that will
-            // create duplicate results:
-            if (sameSurfaceForm(utf8Key, output.output2)) {
-              // We found exact match, which means we should
-              // have already found it in the first search:
-              assert results.size() == 1;
-              return false;
-            } else {
-              return true;
+              // Dedup: when the input analyzes to a graph we
+              // can get duplicate surface forms:
+              if (seen.contains(output.output2)) {
+                return false;
+              }
+              seen.add(output.output2);
+
+              if (!exactFirst) {
+                return true;
+              } else {
+                // In exactFirst mode, don't accept any paths
+                // matching the surface form since that will
+                // create duplicate results:
+                if (sameSurfaceForm(utf8Key, output.output2)) {
+                  // We found exact match, which means we should
+                  // have already found it in the first search:
+                  assert results.size() == 1;
+                  return false;
+                } else {
+                  return true;
+                }
+              }
             }
-          }
-        }
-      };
+          };
 
       prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);
-      
-      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {
-        searcher.addStartPaths(path.fstNode, path.output, true, path.input);
+
+      for (FSTUtil.Path<Pair<Long, BytesRef>> path : prefixPaths) {
+        searcher.addStartPaths(path.fstNode(), path.output(), true, path.input());
       }
 
-      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();
+      TopResults<Pair<Long, BytesRef>> completions = searcher.search();
+      assert completions.isComplete;
 
-      for(MinResult<Pair<Long,BytesRef>> completion : completions) {
+      for (Util.Result<Pair<Long, BytesRef>> completion : completions) {
 
-        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);
+        LookupResult result =
+            getLookupResult(completion.output().output1, completion.output().output2, spare);
 
         // TODO: for fuzzy case would be nice to return
         // how many edits were required
 
-        //System.out.println("    result=" + result);
+        // System.out.println("    result=" + result);
         results.add(result);
 
         if (results.size() == num) {
@@ -821,54 +931,7 @@ public class XAnalyzingSuggester extends Lookup {
     return prefixPaths;
   }
   
-  final Set<IntsRef> toFiniteStrings(final BytesRef surfaceForm, final TokenStreamToAutomaton ts2a) throws IOException {
-      // Analyze surface form:
-    TokenStream ts = indexAnalyzer.tokenStream("", surfaceForm.utf8ToString());
-    return toFiniteStrings(ts2a, ts);
-  }
   
-  public final Set<IntsRef> toFiniteStrings(final TokenStreamToAutomaton ts2a, TokenStream ts) throws IOException {
-      // Analyze surface form:
-
-      // Create corresponding automaton: labels are bytes
-      // from each analyzed token, with byte 0 used as
-      // separator between tokens:
-      Automaton automaton = ts2a.toAutomaton(ts);
-      ts.close();
-
-      replaceSep(automaton, preserveSep);
-
-      assert SpecialOperations.isFinite(automaton);
-
-      // Get all paths from the automaton (there can be
-      // more than one path, eg if the analyzer created a
-      // graph using SynFilter or WDF):
-
-      // TODO: we could walk & add simultaneously, so we
-      // don't have to alloc [possibly biggish]
-      // intermediate HashSet in RAM:
-      return SpecialOperations.getFiniteStrings(automaton, maxGraphExpansions);
-  }
-
-  final Automaton toLookupAutomaton(final CharSequence key) throws IOException {
-    // Turn tokenstream into automaton:
-    TokenStream ts = queryAnalyzer.tokenStream("", key.toString());
-    Automaton automaton = (getTokenStreamToAutomaton()).toAutomaton(ts);
-    ts.close();
-
-    // TODO: we could use the end offset to "guess"
-    // whether the final token was a partial token; this
-    // would only be a heuristic ... but maybe an OK one.
-    // This way we could eg differentiate "net" from "net ",
-    // which we can't today...
-
-    replaceSep(automaton, preserveSep);
-
-    // TODO: we can optimize this somewhat by determinizing
-    // while we convert
-    BasicOperations.determinize(automaton);
-    return automaton;
-  }
   
   
 
@@ -876,6 +939,11 @@ public class XAnalyzingSuggester extends Lookup {
    * Returns the weight associated with an input string,
    * or null if it does not exist.
    */
+  @Override
+  public long getCount() {
+    return count;
+  }
+
   public Object get(CharSequence key) {
     throw new UnsupportedOperationException();
   }
@@ -899,6 +967,42 @@ public class XAnalyzingSuggester extends Lookup {
       return left.output1.compareTo(right.output1);
     }
   };
+
+  final Automaton toAutomaton(final BytesRef surfaceForm, final TokenStreamToAutomaton ts2a)
+      throws IOException {
+    // Analyze surface form:
+    Automaton automaton;
+    try (TokenStream ts = indexAnalyzer.tokenStream("", surfaceForm.utf8ToString())) {
+
+      // Create corresponding automaton: labels are bytes
+      // from each analyzed token, with byte 0 used as
+      // separator between tokens:
+      automaton = ts2a.toAutomaton(ts);
+    }
+
+    automaton = replaceSep(automaton);
+
+    // Get all paths from the automaton (there can be
+    // more than one path, eg if the analyzer created a
+    // graph using SynFilter or WDF):
+    return automaton;
+  }
+
+  final Automaton toLookupAutomaton(final CharSequence key) throws IOException {
+    // TODO: is there a Reader from a CharSequence?
+    // Turn tokenstream into automaton:
+    Automaton automaton = null;
+    try (TokenStream ts = queryAnalyzer.tokenStream("", key.toString())) {
+      automaton = getTokenStreamToAutomaton().toAutomaton(ts);
+    }
+
+    automaton = replaceSep(automaton);
+
+    // TODO: we can optimize this somewhat by determinizing
+    // while we convert
+    automaton = Operations.determinize(automaton, DEFAULT_DETERMINIZE_WORK_LIMIT);
+    return automaton;
+  }
   
   
     public static class XBuilder {