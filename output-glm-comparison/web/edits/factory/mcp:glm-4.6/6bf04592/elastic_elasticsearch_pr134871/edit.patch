diff --git a/server/src/main/java/org/elasticsearch/common/unit/SizeUnit.java b/server/src/main/java/org/elasticsearch/common/unit/SizeUnit.java
deleted file mode 100644
index b4b33540..00000000
--- a/server/src/main/java/org/elasticsearch/common/unit/SizeUnit.java
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
- * or more contributor license agreements. Licensed under the "Elastic License
- * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
- * Public License v 1"; you may not use this file except in compliance with, at
- * your election, the "Elastic License 2.0", the "GNU Affero General Public
- * License v3.0 only", or the "Server Side Public License, v 1".
- */
-
-package org.elasticsearch.common.unit;
-
-public enum SizeUnit {
-    SINGLE {
-        @Override
-        public long toSingles(long size) {
-            return size;
-        }
-
-        @Override
-        public long toKilo(long size) {
-            return size / (C1 / C0);
-        }
-
-        @Override
-        public long toMega(long size) {
-            return size / (C2 / C0);
-        }
-
-        @Override
-        public long toGiga(long size) {
-            return size / (C3 / C0);
-        }
-
-        @Override
-        public long toTera(long size) {
-            return size / (C4 / C0);
-        }
-
-        @Override
-        public long toPeta(long size) {
-            return size / (C5 / C0);
-        }
-    },
-    KILO {
-        @Override
-        public long toSingles(long size) {
-            return x(size, C1 / C0, MAX / (C1 / C0));
-        }
-
-        @Override
-        public long toKilo(long size) {
-            return size;
-        }
-
-        @Override
-        public long toMega(long size) {
-            return size / (C2 / C1);
-        }
-
-        @Override
-        public long toGiga(long size) {
-            return size / (C3 / C1);
-        }
-
-        @Override
-        public long toTera(long size) {
-            return size / (C4 / C1);
-        }
-
-        @Override
-        public long toPeta(long size) {
-            return size / (C5 / C1);
-        }
-    },
-    MEGA {
-        @Override
-        public long toSingles(long size) {
-            return x(size, C2 / C0, MAX / (C2 / C0));
-        }
-
-        @Override
-        public long toKilo(long size) {
-            return x(size, C2 / C1, MAX / (C2 / C1));
-        }
-
-        @Override
-        public long toMega(long size) {
-            return size;
-        }
-
-        @Override
-        public long toGiga(long size) {
-            return size / (C3 / C2);
-        }
-
-        @Override
-        public long toTera(long size) {
-            return size / (C4 / C2);
-        }
-
-        @Override
-        public long toPeta(long size) {
-            return size / (C5 / C2);
-        }
-    },
-    GIGA {
-        @Override
-        public long toSingles(long size) {
-            return x(size, C3 / C0, MAX / (C3 / C0));
-        }
-
-        @Override
-        public long toKilo(long size) {
-            return x(size, C3 / C1, MAX / (C3 / C1));
-        }
-
-        @Override
-        public long toMega(long size) {
-            return x(size, C3 / C2, MAX / (C3 / C2));
-        }
-
-        @Override
-        public long toGiga(long size) {
-            return size;
-        }
-
-        @Override
-        public long toTera(long size) {
-            return size / (C4 / C3);
-        }
-
-        @Override
-        public long toPeta(long size) {
-            return size / (C5 / C3);
-        }
-    },
-    TERA {
-        @Override
-        public long toSingles(long size) {
-            return x(size, C4 / C0, MAX / (C4 / C0));
-        }
-
-        @Override
-        public long toKilo(long size) {
-            return x(size, C4 / C1, MAX / (C4 / C1));
-        }
-
-        @Override
-        public long toMega(long size) {
-            return x(size, C4 / C2, MAX / (C4 / C2));
-        }
-
-        @Override
-        public long toGiga(long size) {
-            return x(size, C4 / C3, MAX / (C4 / C3));
-        }
-
-        @Override
-        public long toTera(long size) {
-            return size;
-        }
-
-        @Override
-        public long toPeta(long size) {
-            return size / (C5 / C0);
-        }
-    },
-    PETA {
-        @Override
-        public long toSingles(long size) {
-            return x(size, C5 / C0, MAX / (C5 / C0));
-        }
-
-        @Override
-        public long toKilo(long size) {
-            return x(size, C5 / C1, MAX / (C5 / C1));
-        }
-
-        @Override
-        public long toMega(long size) {
-            return x(size, C5 / C2, MAX / (C5 / C2));
-        }
-
-        @Override
-        public long toGiga(long size) {
-            return x(size, C5 / C3, MAX / (C5 / C3));
-        }
-
-        @Override
-        public long toTera(long size) {
-            return x(size, C5 / C4, MAX / (C5 / C4));
-        }
-
-        @Override
-        public long toPeta(long size) {
-            return size;
-        }
-    };
-
-    static final long C0 = 1L;
-    static final long C1 = C0 * 1000L;
-    static final long C2 = C1 * 1000L;
-    static final long C3 = C2 * 1000L;
-    static final long C4 = C3 * 1000L;
-    static final long C5 = C4 * 1000L;
-
-    static final long MAX = Long.MAX_VALUE;
-
-    /**
-     * Scale d by m, checking for overflow.
-     * This has a short name to make above code more readable.
-     */
-    static long x(long d, long m, long over) {
-        if (d > over) return Long.MAX_VALUE;
-        if (d < -over) return Long.MIN_VALUE;
-        return d * m;
-    }
-
-    public abstract long toSingles(long size);
-
-    public abstract long toKilo(long size);
-
-    public abstract long toMega(long size);
-
-    public abstract long toGiga(long size);
-
-    public abstract long toTera(long size);
-
-    public abstract long toPeta(long size);
-}
diff --git a/server/src/main/java/org/elasticsearch/common/unit/SizeValue.java b/server/src/main/java/org/elasticsearch/common/unit/SizeValue.java
deleted file mode 100644
index 9fa57e3b..00000000
--- a/server/src/main/java/org/elasticsearch/common/unit/SizeValue.java
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
- * or more contributor license agreements. Licensed under the "Elastic License
- * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
- * Public License v 1"; you may not use this file except in compliance with, at
- * your election, the "Elastic License 2.0", the "GNU Affero General Public
- * License v3.0 only", or the "Server Side Public License, v 1".
- */
-
-package org.elasticsearch.common.unit;
-
-import org.elasticsearch.ElasticsearchParseException;
-import org.elasticsearch.common.Strings;
-import org.elasticsearch.common.io.stream.StreamInput;
-import org.elasticsearch.common.io.stream.StreamOutput;
-import org.elasticsearch.common.io.stream.Writeable;
-
-import java.io.IOException;
-
-public class SizeValue implements Writeable, Comparable<SizeValue> {
-
-    private final long size;
-    private final SizeUnit sizeUnit;
-
-    public SizeValue(long singles) {
-        this(singles, SizeUnit.SINGLE);
-    }
-
-    public SizeValue(long size, SizeUnit sizeUnit) {
-        if (size < 0) {
-            throw new IllegalArgumentException("size in SizeValue may not be negative");
-        }
-        this.size = size;
-        this.sizeUnit = sizeUnit;
-    }
-
-    public SizeValue(StreamInput in) throws IOException {
-        size = in.readVLong();
-        sizeUnit = SizeUnit.SINGLE;
-    }
-
-    @Override
-    public void writeTo(StreamOutput out) throws IOException {
-        out.writeVLong(singles());
-    }
-
-    public long singles() {
-        return sizeUnit.toSingles(size);
-    }
-
-    public long kilo() {
-        return sizeUnit.toKilo(size);
-    }
-
-    public long mega() {
-        return sizeUnit.toMega(size);
-    }
-
-    public long giga() {
-        return sizeUnit.toGiga(size);
-    }
-
-    public long tera() {
-        return sizeUnit.toTera(size);
-    }
-
-    public long peta() {
-        return sizeUnit.toPeta(size);
-    }
-
-    public double kiloFrac() {
-        return ((double) singles()) / SizeUnit.C1;
-    }
-
-    public double megaFrac() {
-        return ((double) singles()) / SizeUnit.C2;
-    }
-
-    public double gigaFrac() {
-        return ((double) singles()) / SizeUnit.C3;
-    }
-
-    public double teraFrac() {
-        return ((double) singles()) / SizeUnit.C4;
-    }
-
-    public double petaFrac() {
-        return ((double) singles()) / SizeUnit.C5;
-    }
-
-    @Override
-    public String toString() {
-        long singles = singles();
-        double value = singles;
-        String suffix = "";
-        if (singles >= SizeUnit.C5) {
-            value = petaFrac();
-            suffix = "p";
-        } else if (singles >= SizeUnit.C4) {
-            value = teraFrac();
-            suffix = "t";
-        } else if (singles >= SizeUnit.C3) {
-            value = gigaFrac();
-            suffix = "g";
-        } else if (singles >= SizeUnit.C2) {
-            value = megaFrac();
-            suffix = "m";
-        } else if (singles >= SizeUnit.C1) {
-            value = kiloFrac();
-            suffix = "k";
-        }
-
-        return Strings.format1Decimals(value, suffix);
-    }
-
-    public static SizeValue parseSizeValue(String sValue) throws ElasticsearchParseException {
-        return parseSizeValue(sValue, null);
-    }
-
-    public static SizeValue parseSizeValue(String sValue, SizeValue defaultValue) throws ElasticsearchParseException {
-        if (sValue == null) {
-            return defaultValue;
-        }
-        long singles;
-        try {
-            if (sValue.endsWith("k") || sValue.endsWith("K")) {
-                singles = (long) (Double.parseDouble(sValue.substring(0, sValue.length() - 1)) * SizeUnit.C1);
-            } else if (sValue.endsWith("m") || sValue.endsWith("M")) {
-                singles = (long) (Double.parseDouble(sValue.substring(0, sValue.length() - 1)) * SizeUnit.C2);
-            } else if (sValue.endsWith("g") || sValue.endsWith("G")) {
-                singles = (long) (Double.parseDouble(sValue.substring(0, sValue.length() - 1)) * SizeUnit.C3);
-            } else if (sValue.endsWith("t") || sValue.endsWith("T")) {
-                singles = (long) (Double.parseDouble(sValue.substring(0, sValue.length() - 1)) * SizeUnit.C4);
-            } else if (sValue.endsWith("p") || sValue.endsWith("P")) {
-                singles = (long) (Double.parseDouble(sValue.substring(0, sValue.length() - 1)) * SizeUnit.C5);
-            } else {
-                singles = Long.parseLong(sValue);
-            }
-        } catch (NumberFormatException e) {
-            throw new ElasticsearchParseException("failed to parse [{}]", e, sValue);
-        }
-        return new SizeValue(singles, SizeUnit.SINGLE);
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-
-        return compareTo((SizeValue) o) == 0;
-    }
-
-    @Override
-    public int hashCode() {
-        return Double.hashCode(((double) size) * sizeUnit.toSingles(1));
-    }
-
-    @Override
-    public int compareTo(SizeValue other) {
-        double thisValue = ((double) size) * sizeUnit.toSingles(1);
-        double otherValue = ((double) other.size) * other.sizeUnit.toSingles(1);
-        return Double.compare(thisValue, otherValue);
-    }
-}
diff --git a/server/src/main/java/org/elasticsearch/rest/action/cat/RestTable.java b/server/src/main/java/org/elasticsearch/rest/action/cat/RestTable.java
index 68716a86..d953e808 100644
--- a/server/src/main/java/org/elasticsearch/rest/action/cat/RestTable.java
+++ b/server/src/main/java/org/elasticsearch/rest/action/cat/RestTable.java
@@ -14,7 +14,7 @@ import org.elasticsearch.common.Table;
 import org.elasticsearch.common.collect.Iterators;
 import org.elasticsearch.common.regex.Regex;
 import org.elasticsearch.common.unit.ByteSizeValue;
-import org.elasticsearch.common.unit.SizeValue;
+
 import org.elasticsearch.common.util.set.Sets;
 import org.elasticsearch.core.Booleans;
 import org.elasticsearch.core.TimeValue;
@@ -370,20 +370,20 @@ public class RestTable {
                 return v.toString();
             }
         }
-        if (value instanceof SizeValue v) {
+        if (value instanceof Long v) {
             String resolution = request.param("size");
             if ("".equals(resolution)) {
-                return Long.toString(v.singles());
+                return v.toString();
             } else if ("k".equals(resolution)) {
-                return Long.toString(v.kilo());
+                return Long.toString(v / 1000);
             } else if ("m".equals(resolution)) {
-                return Long.toString(v.mega());
+                return Long.toString(v / 1000 / 1000);
             } else if ("g".equals(resolution)) {
-                return Long.toString(v.giga());
+                return Long.toString(v / 1000 / 1000 / 1000);
             } else if ("t".equals(resolution)) {
-                return Long.toString(v.tera());
+                return Long.toString(v / 1000 / 1000 / 1000 / 1000);
             } else if ("p".equals(resolution)) {
-                return Long.toString(v.peta());
+                return Long.toString(v / 1000 / 1000 / 1000 / 1000 / 1000);
             } else {
                 return v.toString();
             }
diff --git a/server/src/main/java/org/elasticsearch/rest/action/cat/RestThreadPoolAction.java b/server/src/main/java/org/elasticsearch/rest/action/cat/RestThreadPoolAction.java
index 5cde4e70..a0193450 100644
--- a/server/src/main/java/org/elasticsearch/rest/action/cat/RestThreadPoolAction.java
+++ b/server/src/main/java/org/elasticsearch/rest/action/cat/RestThreadPoolAction.java
@@ -208,7 +208,7 @@ public class RestThreadPoolAction extends AbstractCatAction {
 
                 if (poolInfo != null) {
                     if (poolInfo.getQueueSize() != null) {
-                        maxQueueSize = poolInfo.getQueueSize().singles();
+                        maxQueueSize = poolInfo.getQueueSize();
                     }
                     if (poolInfo.getKeepAlive() != null) {
                         keepAlive = poolInfo.getKeepAlive();
diff --git a/server/src/main/java/org/elasticsearch/threadpool/FixedExecutorBuilder.java b/server/src/main/java/org/elasticsearch/threadpool/FixedExecutorBuilder.java
index 9c723f24..1e61da0b 100644
--- a/server/src/main/java/org/elasticsearch/threadpool/FixedExecutorBuilder.java
+++ b/server/src/main/java/org/elasticsearch/threadpool/FixedExecutorBuilder.java
@@ -11,7 +11,7 @@ package org.elasticsearch.threadpool;
 
 import org.elasticsearch.common.settings.Setting;
 import org.elasticsearch.common.settings.Settings;
-import org.elasticsearch.common.unit.SizeValue;
+
 import org.elasticsearch.common.util.concurrent.EsExecutors;
 import org.elasticsearch.common.util.concurrent.EsExecutors.TaskTrackingConfig;
 import org.elasticsearch.common.util.concurrent.ThreadContext;
@@ -160,7 +160,7 @@ public final class FixedExecutorBuilder extends ExecutorBuilder<FixedExecutorBui
             size,
             size,
             null,
-            queueSize < 0 ? null : new SizeValue(queueSize)
+            queueSize < 0 ? null : (long) queueSize
         );
         return new ThreadPool.ExecutorHolder(executor, info);
     }
diff --git a/server/src/main/java/org/elasticsearch/threadpool/ThreadPool.java b/server/src/main/java/org/elasticsearch/threadpool/ThreadPool.java
index 2a8c42c9..6e63e1e5 100644
--- a/server/src/main/java/org/elasticsearch/threadpool/ThreadPool.java
+++ b/server/src/main/java/org/elasticsearch/threadpool/ThreadPool.java
@@ -19,7 +19,7 @@ import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.common.time.TimeProvider;
 import org.elasticsearch.common.unit.ByteSizeUnit;
 import org.elasticsearch.common.unit.ByteSizeValue;
-import org.elasticsearch.common.unit.SizeValue;
+
 import org.elasticsearch.common.util.concurrent.EsExecutors;
 import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;
 import org.elasticsearch.common.util.concurrent.EsRejectedExecutionHandler;
@@ -934,7 +934,7 @@ public class ThreadPool implements ReportingService<ThreadPoolInfo>, Scheduler,
         private final int min;
         private final int max;
         private final TimeValue keepAlive;
-        private final SizeValue queueSize;
+        private final Long queueSize;
 
         public Info(String name, ThreadPoolType type) {
             this(name, type, -1);
@@ -944,7 +944,7 @@ public class ThreadPool implements ReportingService<ThreadPoolInfo>, Scheduler,
             this(name, type, size, size, null, null);
         }
 
-        public Info(String name, ThreadPoolType type, int min, int max, @Nullable TimeValue keepAlive, @Nullable SizeValue queueSize) {
+        public Info(String name, ThreadPoolType type, int min, int max, @Nullable TimeValue keepAlive, @Nullable Long queueSize) {
             this.name = name;
             this.type = type;
             this.min = min;
@@ -959,7 +959,7 @@ public class ThreadPool implements ReportingService<ThreadPoolInfo>, Scheduler,
             min = in.readInt();
             max = in.readInt();
             keepAlive = in.readOptionalTimeValue();
-            queueSize = in.readOptionalWriteable(SizeValue::new);
+            queueSize = in.readOptionalLong();
         }
 
         @Override
@@ -969,7 +969,7 @@ public class ThreadPool implements ReportingService<ThreadPoolInfo>, Scheduler,
             out.writeInt(min);
             out.writeInt(max);
             out.writeOptionalTimeValue(keepAlive);
-            out.writeOptionalWriteable(queueSize);
+            out.writeOptionalLong(queueSize);
         }
 
         public String getName() {
@@ -994,7 +994,7 @@ public class ThreadPool implements ReportingService<ThreadPoolInfo>, Scheduler,
         }
 
         @Nullable
-        public SizeValue getQueueSize() {
+        public Long getQueueSize() {
             return this.queueSize;
         }
 
@@ -1018,7 +1018,7 @@ public class ThreadPool implements ReportingService<ThreadPoolInfo>, Scheduler,
             if (queueSize == null) {
                 builder.field("queue_size", -1);
             } else {
-                builder.field("queue_size", queueSize.singles());
+                builder.field("queue_size", queueSize);
             }
             builder.endObject();
             return builder;
diff --git a/server/src/test/java/org/elasticsearch/common/unit/SizeValueTests.java b/server/src/test/java/org/elasticsearch/common/unit/SizeValueTests.java
deleted file mode 100644
index 91f3c45a..00000000
--- a/server/src/test/java/org/elasticsearch/common/unit/SizeValueTests.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
- * or more contributor license agreements. Licensed under the "Elastic License
- * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
- * Public License v 1"; you may not use this file except in compliance with, at
- * your election, the "Elastic License 2.0", the "GNU Affero General Public
- * License v3.0 only", or the "Server Side Public License, v 1".
- */
-package org.elasticsearch.common.unit;
-
-import org.elasticsearch.test.ESTestCase;
-
-import static org.hamcrest.Matchers.containsString;
-import static org.hamcrest.Matchers.is;
-
-public class SizeValueTests extends ESTestCase {
-    public void testThatConversionWorks() {
-        SizeValue sizeValue = new SizeValue(1000);
-        assertThat(sizeValue.kilo(), is(1L));
-        assertThat(sizeValue.toString(), is("1k"));
-
-        sizeValue = new SizeValue(1000, SizeUnit.KILO);
-        assertThat(sizeValue.singles(), is(1000000L));
-        assertThat(sizeValue.toString(), is("1m"));
-
-        sizeValue = new SizeValue(1000, SizeUnit.MEGA);
-        assertThat(sizeValue.singles(), is(1000000000L));
-        assertThat(sizeValue.toString(), is("1g"));
-
-        sizeValue = new SizeValue(1000, SizeUnit.GIGA);
-        assertThat(sizeValue.singles(), is(1000000000000L));
-        assertThat(sizeValue.toString(), is("1t"));
-
-        sizeValue = new SizeValue(1000, SizeUnit.TERA);
-        assertThat(sizeValue.singles(), is(1000000000000000L));
-        assertThat(sizeValue.toString(), is("1p"));
-
-        sizeValue = new SizeValue(1000, SizeUnit.PETA);
-        assertThat(sizeValue.singles(), is(1000000000000000000L));
-        assertThat(sizeValue.toString(), is("1000p"));
-    }
-
-    public void testThatParsingWorks() {
-        assertThat(SizeValue.parseSizeValue("1k").toString(), is(new SizeValue(1000).toString()));
-        assertThat(SizeValue.parseSizeValue("1p").toString(), is(new SizeValue(1, SizeUnit.PETA).toString()));
-        assertThat(SizeValue.parseSizeValue("1G").toString(), is(new SizeValue(1, SizeUnit.GIGA).toString()));
-    }
-
-    public void testThatNegativeValuesThrowException() {
-        try {
-            new SizeValue(-1);
-            fail("Expected IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
-            assertThat(e.getMessage(), containsString("may not be negative"));
-        }
-    }
-
-    public void testCompareEquality() {
-        long randomValue = randomNonNegativeLong();
-        SizeUnit randomUnit = randomFrom(SizeUnit.values());
-        SizeValue firstValue = new SizeValue(randomValue, randomUnit);
-        SizeValue secondValue = new SizeValue(randomValue, randomUnit);
-        assertEquals(0, firstValue.compareTo(secondValue));
-    }
-
-    public void testCompareValue() {
-        long firstRandom = randomNonNegativeLong();
-        long secondRandom = randomValueOtherThan(firstRandom, ESTestCase::randomNonNegativeLong);
-        SizeUnit unit = randomFrom(SizeUnit.values());
-        SizeValue firstSizeValue = new SizeValue(firstRandom, unit);
-        SizeValue secondSizeValue = new SizeValue(secondRandom, unit);
-        assertEquals(firstRandom > secondRandom, firstSizeValue.compareTo(secondSizeValue) > 0);
-        assertEquals(secondRandom > firstRandom, secondSizeValue.compareTo(firstSizeValue) > 0);
-    }
-
-    public void testCompareUnits() {
-        long number = randomNonNegativeLong();
-        SizeUnit randomUnit = randomValueOtherThan(SizeUnit.PETA, () -> randomFrom(SizeUnit.values()));
-        SizeValue firstValue = new SizeValue(number, randomUnit);
-        SizeValue secondValue = new SizeValue(number, SizeUnit.PETA);
-        assertTrue(firstValue.compareTo(secondValue) < 0);
-        assertTrue(secondValue.compareTo(firstValue) > 0);
-    }
-
-    public void testConversionHashCode() {
-        SizeValue firstValue = new SizeValue(randomIntBetween(0, Integer.MAX_VALUE), SizeUnit.GIGA);
-        SizeValue secondValue = new SizeValue(firstValue.singles(), SizeUnit.SINGLE);
-        assertEquals(firstValue.hashCode(), secondValue.hashCode());
-    }
-}
diff --git a/server/src/test/java/org/elasticsearch/threadpool/ThreadPoolSerializationTests.java b/server/src/test/java/org/elasticsearch/threadpool/ThreadPoolSerializationTests.java
index 29af0902..5c76776c 100644
--- a/server/src/test/java/org/elasticsearch/threadpool/ThreadPoolSerializationTests.java
+++ b/server/src/test/java/org/elasticsearch/threadpool/ThreadPoolSerializationTests.java
@@ -13,7 +13,7 @@ import org.elasticsearch.common.bytes.BytesReference;
 import org.elasticsearch.common.io.stream.BytesStreamOutput;
 import org.elasticsearch.common.io.stream.StreamInput;
 import org.elasticsearch.common.settings.Settings;
-import org.elasticsearch.common.unit.SizeValue;
+
 import org.elasticsearch.common.xcontent.XContentHelper;
 import org.elasticsearch.core.TimeValue;
 import org.elasticsearch.telemetry.metric.MeterRegistry;
@@ -47,7 +47,7 @@ public class ThreadPoolSerializationTests extends ESTestCase {
             1,
             10,
             TimeValue.timeValueMillis(3000),
-            SizeValue.parseSizeValue("10k")
+            10000L
         );
         output.setTransportVersion(TransportVersion.current());
         info.writeTo(output);
@@ -55,7 +55,7 @@ public class ThreadPoolSerializationTests extends ESTestCase {
         StreamInput input = output.bytes().streamInput();
         ThreadPool.Info newInfo = new ThreadPool.Info(input);
 
-        assertThat(newInfo.getQueueSize().singles(), is(10000L));
+        assertThat(newInfo.getQueueSize(), is(10000L));
     }
 
     public void testThatNegativeQueueSizesCanBeSerialized() throws Exception {
@@ -99,7 +99,7 @@ public class ThreadPoolSerializationTests extends ESTestCase {
             1,
             10,
             TimeValue.timeValueMillis(3000),
-            SizeValue.parseSizeValue("1k")
+            1000L
         );
         XContentBuilder builder = jsonBuilder();
         builder.startObject();
diff --git a/server/src/test/java/org/elasticsearch/threadpool/UpdateThreadPoolSettingsTests.java b/server/src/test/java/org/elasticsearch/threadpool/UpdateThreadPoolSettingsTests.java
index 873a7fca..b31f799f 100644
--- a/server/src/test/java/org/elasticsearch/threadpool/UpdateThreadPoolSettingsTests.java
+++ b/server/src/test/java/org/elasticsearch/threadpool/UpdateThreadPoolSettingsTests.java
@@ -146,7 +146,7 @@ public class UpdateThreadPoolSettingsTests extends ESThreadPoolTestCase {
                 .put("node.name", "testShutdownNowInterrupts")
                 .build();
             threadPool = new ThreadPool(nodeSettings, MeterRegistry.NOOP, new DefaultBuiltInExecutorBuilders());
-            assertEquals(info(threadPool, threadPoolName).getQueueSize().singles(), 1000L);
+assertEquals((long)info(threadPool, threadPoolName).getQueueSize(), 1000L);
 
             final CountDownLatch shutDownLatch = new CountDownLatch(1);
             final CountDownLatch latch = new CountDownLatch(1);
@@ -209,7 +209,7 @@ public class UpdateThreadPoolSettingsTests extends ESThreadPoolTestCase {
                     assertEquals(info.getThreadPoolType(), ThreadPool.ThreadPoolType.FIXED);
                     assertThat(info.getMin(), equalTo(1));
                     assertThat(info.getMax(), equalTo(1));
-                    assertThat(info.getQueueSize().singles(), equalTo(1L));
+                    assertThat(info.getQueueSize(), equalTo(1L));
                 } else {
                     for (Field field : Names.class.getFields()) {
                         if (info.getName().equalsIgnoreCase(field.getName())) {