diff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plugin/ComputeService.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plugin/ComputeService.java
index dddb41e9..a1aed65b 100644
--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plugin/ComputeService.java
+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plugin/ComputeService.java
@@ -329,28 +329,34 @@ public class ComputeService {
                 listener.onFailure(new IllegalStateException(error));
                 return;
             }
-            var computeContext = new ComputeContext(
-                newChildSession(sessionId),
-                profileDescription(profileQualifier, "single"),
-                LOCAL_CLUSTER,
-                flags,
-                List.of(),
-                configuration,
-                foldContext,
-                null,
-                exchangeSinkSupplier
-            );
-            updateShardCountForCoordinatorOnlyQuery(execInfo);
-            try (
-                var computeListener = new ComputeListener(
-                    transportService.getThreadPool(),
-                    cancelQueryOnFailure,
-                    listener.map(completionInfo -> {
-                        updateExecutionInfoAfterCoordinatorOnlyQuery(execInfo);
-                        return new Result(physicalPlan.output(), collectedPages, completionInfo, execInfo);
-                    })
-                )
-            ) {
+        /*
+         * Grab the output attributes here, so we can pass them to
+         * the listener without holding on to a reference to the
+         * entire plan.
+         */
+        List<Attribute> outputAttributes = physicalPlan.output();
+        var computeContext = new ComputeContext(
+            newChildSession(sessionId),
+            profileDescription(profileQualifier, "single"),
+            LOCAL_CLUSTER,
+            flags,
+            List.of(),
+            configuration,
+            foldContext,
+            null,
+            exchangeSinkSupplier
+        );
+        updateShardCountForCoordinatorOnlyQuery(execInfo);
+        try (
+            var computeListener = new ComputeListener(
+                transportService.getThreadPool(),
+                cancelQueryOnFailure,
+                listener.map(completionInfo -> {
+                    updateExecutionInfoAfterCoordinatorOnlyQuery(execInfo);
+                    return new Result(outputAttributes, collectedPages, completionInfo, execInfo);
+                })
+            )
+        ) {
                 runCompute(rootTask, computeContext, coordinatorPlan, computeListener.acquireCompute());
                 return;
             }