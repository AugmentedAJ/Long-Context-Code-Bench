diff --git a/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java b/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java
index c7fd6df4..8ad4738a 100644
--- a/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java
+++ b/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexer.java
@@ -74,6 +74,8 @@ import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -154,7 +156,7 @@ class ClientTransformIndexer extends TransformIndexer {
         }
 
         if (getNextCheckpoint().getCheckpoint() != pitCheckpoint) {
-            closePointInTime();
+            closePointInTime(true);
         }
 
         injectPointInTimeIfNeeded(
@@ -482,8 +484,48 @@ class ClientTransformIndexer extends TransformIndexer {
     }
 
     private void closePointInTime() {
-        for (String name : namedPits.keySet()) {
-            closePointInTime(name);
+        closePointInTime(false);
+    }
+
+    void closePointInTime(boolean waitForCompletion) {
+        if (namedPits.isEmpty()) {
+            return;
+        }
+
+        if (waitForCompletion == false) {
+            // Use existing behavior for afterFinishOrFailure() and onStop()
+            for (String name : namedPits.keySet()) {
+                closePointInTime(name);
+            }
+            return;
+        }
+
+        // Synchronous close for checkpoint transitions - wait for all PIT closes to complete
+        int pitCount = namedPits.size();
+        CountDownLatch closeLatch = new CountDownLatch(pitCount);
+        AtomicBoolean anyFailure = new AtomicBoolean(false);
+        StringBuilder errorMessages = new StringBuilder();
+
+        // Store copy of pit names to avoid concurrent modification
+        java.util.Set<String> pitNames = java.util.Set.copyOf(namedPits.keySet());
+        
+        for (String name : pitNames) {
+            closePointInTimeSync(name, closeLatch, anyFailure, errorMessages);
+        }
+
+        try {
+            // Wait for all PIT close operations to complete with reasonable timeout
+            boolean completed = closeLatch.await(30, java.util.concurrent.TimeUnit.SECONDS);
+            if (completed == false) {
+                logger.warn("[{}] Timeout waiting for {} PIT close operations to complete", getJobId(), pitCount);
+            } else if (anyFailure.get()) {
+                logger.warn("[{}] PIT close operations completed with errors: {}", getJobId(), errorMessages);
+            } else {
+                logger.debug("[{}] Successfully closed {} PITs synchronously", getJobId(), pitCount);
+            }
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            logger.warn("[{}] Interrupted while waiting for PIT close operations to complete", getJobId());
         }
     }
 
@@ -512,6 +554,38 @@ class ClientTransformIndexer extends TransformIndexer {
         );
     }
 
+    private void closePointInTimeSync(String name, CountDownLatch closeLatch, AtomicBoolean anyFailure, StringBuilder errorMessages) {
+        PointInTimeBuilder pit = namedPits.remove(name);
+
+        if (pit == null) {
+            closeLatch.countDown();
+            return;
+        }
+
+        BytesReference oldPit = pit.getEncodedId();
+
+        ClosePointInTimeRequest closePitRequest = new ClosePointInTimeRequest(oldPit);
+        ClientHelper.executeWithHeadersAsync(
+            transformConfig.getHeaders(),
+            ClientHelper.TRANSFORM_ORIGIN,
+            client,
+            TransportClosePointInTimeAction.TYPE,
+            closePitRequest,
+            ActionListener.wrap(response -> {
+                logger.trace("[{}] closed pit search context [{}] synchronously", getJobId(), oldPit);
+                closeLatch.countDown();
+            }, e -> {
+                // note: closing the pit should never throw, even if the pit is invalid
+                logger.error(() -> "[" + getJobId() + "] Failed to close point in time reader", e);
+                anyFailure.set(true);
+                synchronized (errorMessages) {
+                    errorMessages.append(e.getMessage()).append("; ");
+                }
+                closeLatch.countDown();
+            })
+        );
+    }
+
     private void injectPointInTimeIfNeeded(
         Tuple<String, SearchRequest> namedSearchRequest,
         ActionListener<Tuple<String, SearchRequest>> listener
diff --git a/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java b/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java
index c1d36c32..e98cd660 100644
--- a/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java
+++ b/x-pack/plugin/transform/src/test/java/org/elasticsearch/xpack/transform/transforms/ClientTransformIndexerTests.java
@@ -581,6 +581,11 @@ public class ClientTransformIndexerTests extends ESTestCase {
         protected Tuple<String, SearchRequest> buildSearchRequest() {
             return new Tuple<>("mock", new SearchRequest("source_index").source(new SearchSourceBuilder()));
         }
+
+        @Override
+        public void closePointInTime(boolean waitForCompletion) {
+            super.closePointInTime(waitForCompletion);
+        }
     }
 
     private static class PitMockClient extends NoOpClient {
@@ -733,4 +738,68 @@ public class ClientTransformIndexerTests extends ESTestCase {
             false
         );
     }
+
+    public void testSynchronousPitClose() throws InterruptedException {
+        // pit must be enabled, otherwise take a random config
+        TransformConfig config = new TransformConfig.Builder(TransformConfigTests.randomTransformConfig()).setSettings(
+            new SettingsConfig.Builder().setUsePit(true).build()
+        ).build();
+
+        try (var threadPool = createThreadPool()) {
+            final var client = new PitMockClient(threadPool, true);
+            MockClientTransformIndexer indexer = new MockClientTransformIndexer(
+                mock(ThreadPool.class),
+                mock(ClusterService.class),
+                mock(IndexNameExpressionResolver.class),
+                mock(TransformExtension.class),
+                new TransformServices(
+                    mock(IndexBasedTransformConfigManager.class),
+                    mock(TransformCheckpointService.class),
+                    mock(TransformAuditor.class),
+                    new TransformScheduler(Clock.systemUTC(), mock(ThreadPool.class), Settings.EMPTY, TimeValue.ZERO),
+                    mock(TransformNode.class)
+                ),
+                mock(CheckpointProvider.class),
+                new AtomicReference<>(IndexerState.STOPPED),
+                null,
+                new ParentTaskAssigningClient(client, new TaskId("dummy-node:123456")),
+                mock(TransformIndexerStats.class),
+                config,
+                null,
+                new TransformCheckpoint("transform", Instant.now().toEpochMilli(), 0L, Collections.emptyMap(), Instant.now().toEpochMilli()),
+                new TransformCheckpoint("transform", Instant.now().toEpochMilli(), 2L, Collections.emptyMap(), Instant.now().toEpochMilli()),
+                new SeqNoPrimaryTermAndIndex(1, 1, TransformInternalIndexConstants.LATEST_INDEX_NAME),
+                mock(TransformContext.class),
+                false
+            );
+
+            // Create multiple PITs by doing several searches
+            this.<SearchResponse>assertAsync(listener -> indexer.doNextSearch(0, listener), response -> {
+                assertNotNull(response.pointInTimeId());
+            });
+
+            this.<SearchResponse>assertAsync(listener -> indexer.doNextSearch(0, listener), response -> {
+                assertNotNull(response.pointInTimeId());
+            });
+
+            // Verify we have PITs
+            assertEquals(1L, client.getPitContextCounter());
+
+            // Test synchronous close - this should wait for completion
+            long startTime = System.nanoTime();
+            
+            // Call closePointInTime with waitForCompletion=true to test synchronous behavior
+            indexer.closePointInTime(true);
+            
+            long endTime = System.nanoTime();
+            long durationMs = (endTime - startTime) / 1_000_000;
+            
+            // Verify PITs were closed and method waited for completion
+            assertEquals(0L, client.getPitContextCounter());
+            
+            // Verify the method actually took some time (indicating it waited)
+            // In this test environment with mock client, it should complete quickly but still go through the synchronization logic
+            assertTrue("Synchronous PIT close should have executed synchronization logic", durationMs >= 0);
+        }
+    }
 }