{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4496,
  "base_commit": "5a02ec86a8f76c02304b015035c4cffac4474395",
  "runner": "factory",
  "model": "glm-4.6",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 206605,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/common/joda/DateMathParser.java b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java\nindex 3e9fec3..04dd08d 100644\n--- a/src/main/java/org/elasticsearch/common/joda/DateMathParser.java\n+++ b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java\n@@ -198,6 +198,15 @@ public class DateMathParser {\n \n     private long parseStringValue(String value) {\n         try {\n+            // We use parseInto with a 1970 base date to ensure consistent handling of partial dates\n+            // This prevents Joda from defaulting to year 2000 for partial dates\n+            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);\n+            int location = dateTimeFormatter.parser().parseInto(dateTime, value, 0);\n+            // if we parsed all the string value, we are good\n+            if (location == value.length()) {\n+                return dateTime.getMillis();\n+            }\n+            // If parseInto didn't consume the entire string or failed, fall back to parseMillis\n             return dateTimeFormatter.parser().parseMillis(value);\n         } catch (RuntimeException e) {\n             try {\n@@ -222,8 +231,8 @@ public class DateMathParser {\n                 return dateTime.getMillis();\n             }\n             // if we did not manage to parse, or the year is really high year which is unreasonable\n-            // see if its a number\n-            if (location <= 0 || dateTime.getYear() > 5000) {\n+            // or if Joda defaulted to year 2000 for partial dates, see if its a number\n+            if (location <= 0 || dateTime.getYear() > 5000 || (dateTime.getYear() == 2000 && location < value.length())) {\n                 try {\n                     long time = Long.parseLong(value);\n                     return timeUnit.toMillis(time);\ndiff --git a/src/main/java/org/elasticsearch/index/analysis/NumericDateTokenizer.java b/src/main/java/org/elasticsearch/index/analysis/NumericDateTokenizer.java\nindex 3816829..323a0d9 100644\n--- a/src/main/java/org/elasticsearch/index/analysis/NumericDateTokenizer.java\n+++ b/src/main/java/org/elasticsearch/index/analysis/NumericDateTokenizer.java\n@@ -20,6 +20,8 @@\n package org.elasticsearch.index.analysis;\n \n import org.apache.lucene.analysis.NumericTokenStream;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n import org.joda.time.format.DateTimeFormatter;\n \n import java.io.IOException;\n@@ -36,6 +38,17 @@ public class NumericDateTokenizer extends NumericTokenizer {\n \n     @Override\n     protected void setValue(NumericTokenStream tokenStream, String value) {\n+        // Use parseInto with 1970 base to ensure consistent behavior for partial dates\n+        try {\n+            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);\n+            int location = ((DateTimeFormatter) extra).parseInto(dateTime, value, 0);\n+            if (location == value.length()) {\n+                tokenStream.setLongValue(dateTime.getMillis());\n+                return;\n+            }\n+        } catch (Exception e) {\n+            // Fall back to parseMillis if parseInto fails\n+        }\n         tokenStream.setLongValue(((DateTimeFormatter) extra).parseMillis(value));\n     }\n }\n\\ No newline at end of file\ndiff --git a/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java b/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java\nindex 74e6d9c..a6bda0a 100644\n--- a/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java\n+++ b/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java\n@@ -51,6 +51,8 @@ import org.elasticsearch.index.mapper.core.LongFieldMapper.CustomLongNumericFiel\n import org.elasticsearch.index.query.QueryParseContext;\n import org.elasticsearch.index.search.NumericRangeFieldDataFilter;\n import org.elasticsearch.index.similarity.SimilarityProvider;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n \n import java.io.IOException;\n import java.util.List;\n@@ -490,6 +492,15 @@ public class DateFieldMapper extends NumberFieldMapper<Long> {\n \n     private long parseStringValue(String value) {\n         try {\n+            // We use parseInto with a 1970 base date to ensure consistent handling of partial dates\n+            // This prevents Joda from defaulting to year 2000 for partial dates\n+            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);\n+            int location = dateTimeFormatter.parser().parseInto(dateTime, value, 0);\n+            // if we parsed all the string value, we are good\n+            if (location == value.length()) {\n+                return dateTime.getMillis();\n+            }\n+            // If parseInto didn't consume the entire string or failed, fall back to parseMillis\n             return dateTimeFormatter.parser().parseMillis(value);\n         } catch (RuntimeException e) {\n             try {\ndiff --git a/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java b/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java\nindex 04bce46..e9e68ae 100644\n--- a/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java\n+++ b/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java\n@@ -25,6 +25,8 @@ import org.elasticsearch.common.joda.Joda;\n import org.elasticsearch.index.mapper.core.DateFieldMapper;\n import org.elasticsearch.index.mapper.ip.IpFieldMapper;\n import org.elasticsearch.search.internal.SearchContext;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n \n import java.util.concurrent.TimeUnit;\n \n@@ -57,6 +59,16 @@ public interface ValueParser {\n \n         @Override\n         public long parseLong(String value, SearchContext searchContext) {\n+            try {\n+                // Use parseInto with 1970 base to ensure consistent behavior for partial dates\n+                MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);\n+                int location = formatter.parser().parseInto(dateTime, value, 0);\n+                if (location == value.length()) {\n+                    return dateTime.getMillis();\n+                }\n+            } catch (Exception e) {\n+                // Fall back to parseMillis if parseInto fails\n+            }\n             return formatter.parser().parseMillis(value);\n         }\n ",
  "logs_path": "factory/glm-4.6/24634b85/elastic_elasticsearch_pr4496/logs.jsonl",
  "errors": [],
  "edit_run_id": "24634b85",
  "test_label": null
}