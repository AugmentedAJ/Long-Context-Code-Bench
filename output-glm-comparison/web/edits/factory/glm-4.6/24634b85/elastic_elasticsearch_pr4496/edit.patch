diff --git a/src/main/java/org/elasticsearch/common/joda/DateMathParser.java b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java
index 3e9fec3..04dd08d 100644
--- a/src/main/java/org/elasticsearch/common/joda/DateMathParser.java
+++ b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java
@@ -198,6 +198,15 @@ public class DateMathParser {
 
     private long parseStringValue(String value) {
         try {
+            // We use parseInto with a 1970 base date to ensure consistent handling of partial dates
+            // This prevents Joda from defaulting to year 2000 for partial dates
+            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);
+            int location = dateTimeFormatter.parser().parseInto(dateTime, value, 0);
+            // if we parsed all the string value, we are good
+            if (location == value.length()) {
+                return dateTime.getMillis();
+            }
+            // If parseInto didn't consume the entire string or failed, fall back to parseMillis
             return dateTimeFormatter.parser().parseMillis(value);
         } catch (RuntimeException e) {
             try {
@@ -222,8 +231,8 @@ public class DateMathParser {
                 return dateTime.getMillis();
             }
             // if we did not manage to parse, or the year is really high year which is unreasonable
-            // see if its a number
-            if (location <= 0 || dateTime.getYear() > 5000) {
+            // or if Joda defaulted to year 2000 for partial dates, see if its a number
+            if (location <= 0 || dateTime.getYear() > 5000 || (dateTime.getYear() == 2000 && location < value.length())) {
                 try {
                     long time = Long.parseLong(value);
                     return timeUnit.toMillis(time);
diff --git a/src/main/java/org/elasticsearch/index/analysis/NumericDateTokenizer.java b/src/main/java/org/elasticsearch/index/analysis/NumericDateTokenizer.java
index 3816829..323a0d9 100644
--- a/src/main/java/org/elasticsearch/index/analysis/NumericDateTokenizer.java
+++ b/src/main/java/org/elasticsearch/index/analysis/NumericDateTokenizer.java
@@ -20,6 +20,8 @@
 package org.elasticsearch.index.analysis;
 
 import org.apache.lucene.analysis.NumericTokenStream;
+import org.joda.time.DateTimeZone;
+import org.joda.time.MutableDateTime;
 import org.joda.time.format.DateTimeFormatter;
 
 import java.io.IOException;
@@ -36,6 +38,17 @@ public class NumericDateTokenizer extends NumericTokenizer {
 
     @Override
     protected void setValue(NumericTokenStream tokenStream, String value) {
+        // Use parseInto with 1970 base to ensure consistent behavior for partial dates
+        try {
+            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);
+            int location = ((DateTimeFormatter) extra).parseInto(dateTime, value, 0);
+            if (location == value.length()) {
+                tokenStream.setLongValue(dateTime.getMillis());
+                return;
+            }
+        } catch (Exception e) {
+            // Fall back to parseMillis if parseInto fails
+        }
         tokenStream.setLongValue(((DateTimeFormatter) extra).parseMillis(value));
     }
 }
\ No newline at end of file
diff --git a/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java b/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java
index 74e6d9c..a6bda0a 100644
--- a/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java
+++ b/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java
@@ -51,6 +51,8 @@ import org.elasticsearch.index.mapper.core.LongFieldMapper.CustomLongNumericFiel
 import org.elasticsearch.index.query.QueryParseContext;
 import org.elasticsearch.index.search.NumericRangeFieldDataFilter;
 import org.elasticsearch.index.similarity.SimilarityProvider;
+import org.joda.time.DateTimeZone;
+import org.joda.time.MutableDateTime;
 
 import java.io.IOException;
 import java.util.List;
@@ -490,6 +492,15 @@ public class DateFieldMapper extends NumberFieldMapper<Long> {
 
     private long parseStringValue(String value) {
         try {
+            // We use parseInto with a 1970 base date to ensure consistent handling of partial dates
+            // This prevents Joda from defaulting to year 2000 for partial dates
+            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);
+            int location = dateTimeFormatter.parser().parseInto(dateTime, value, 0);
+            // if we parsed all the string value, we are good
+            if (location == value.length()) {
+                return dateTime.getMillis();
+            }
+            // If parseInto didn't consume the entire string or failed, fall back to parseMillis
             return dateTimeFormatter.parser().parseMillis(value);
         } catch (RuntimeException e) {
             try {
diff --git a/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java b/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java
index 04bce46..e9e68ae 100644
--- a/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java
+++ b/src/main/java/org/elasticsearch/search/aggregations/support/numeric/ValueParser.java
@@ -25,6 +25,8 @@ import org.elasticsearch.common.joda.Joda;
 import org.elasticsearch.index.mapper.core.DateFieldMapper;
 import org.elasticsearch.index.mapper.ip.IpFieldMapper;
 import org.elasticsearch.search.internal.SearchContext;
+import org.joda.time.DateTimeZone;
+import org.joda.time.MutableDateTime;
 
 import java.util.concurrent.TimeUnit;
 
@@ -57,6 +59,16 @@ public interface ValueParser {
 
         @Override
         public long parseLong(String value, SearchContext searchContext) {
+            try {
+                // Use parseInto with 1970 base to ensure consistent behavior for partial dates
+                MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);
+                int location = formatter.parser().parseInto(dateTime, value, 0);
+                if (location == value.length()) {
+                    return dateTime.getMillis();
+                }
+            } catch (Exception e) {
+                // Fall back to parseMillis if parseInto fails
+            }
             return formatter.parser().parseMillis(value);
         }
 