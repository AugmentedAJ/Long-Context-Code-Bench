{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134776,
  "base_commit": "2ea81d0548b2a25633ffe948cd9304a2c0c59563",
  "runner": "factory",
  "model": "glm-4.6",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 306345,
  "patch_unified": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/Authentication.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/Authentication.java\nindex ac543c4f..f637123f 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/Authentication.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/Authentication.java\n@@ -1363,51 +1363,24 @@ public final class Authentication implements ToXContentObject {\n     }\n \n     public static Authentication newRealmAuthentication(User user, RealmRef realmRef) {\n-        // TODO make the type system ensure that this is not a run-as user\n-        Authentication authentication = new Authentication(\n-            new Subject(user, realmRef, TransportVersion.current(), Map.of()),\n-            AuthenticationType.REALM\n-        );\n-        assert false == authentication.isServiceAccount();\n-        assert false == authentication.isApiKey();\n-        assert false == authentication.isCrossClusterAccess();\n-        assert false == authentication.isAuthenticatedInternally();\n-        assert false == authentication.isAuthenticatedAnonymously();\n-        return authentication;\n+        // Create an AuthenticationResult wrapper to use the unified method\n+        AuthenticationResult<User> authResult = AuthenticationResult.success(user);\n+        return newUnifiedAuthentication(Subject.Type.USER, authResult, null, AuthenticationType.REALM, realmRef);\n     }\n \n     public static Authentication newCloudAccessTokenAuthentication(\n         AuthenticationResult<User> authResult,\n         Authentication.RealmRef realmRef\n     ) {\n-        assert authResult.isAuthenticated() : \"cloud access token authn result must be successful\";\n-        final User user = authResult.getValue();\n-        return new Authentication(\n-            new Subject(user, realmRef, TransportVersion.current(), authResult.getMetadata()),\n-            AuthenticationType.TOKEN\n-        );\n+        return newUnifiedAuthentication(Subject.Type.USER, authResult, null, AuthenticationType.TOKEN, realmRef);\n     }\n \n     public static Authentication newCloudApiKeyAuthentication(AuthenticationResult<User> authResult, String nodeName) {\n-        assert authResult.isAuthenticated() : \"cloud API Key authn result must be successful\";\n-        final User apiKeyUser = authResult.getValue();\n-        final Authentication.RealmRef authenticatedBy = newCloudApiKeyRealmRef(nodeName);\n-        return new Authentication(\n-            new Subject(apiKeyUser, authenticatedBy, TransportVersion.current(), authResult.getMetadata()),\n-            AuthenticationType.API_KEY\n-        );\n+        return newUnifiedAuthentication(Subject.Type.CLOUD_API_KEY, authResult, nodeName);\n     }\n \n     public static Authentication newApiKeyAuthentication(AuthenticationResult<User> authResult, String nodeName) {\n-        assert authResult.isAuthenticated() : \"API Key authn result must be successful\";\n-        final User apiKeyUser = authResult.getValue();\n-        assert apiKeyUser.roles().length == 0 : \"The user associated to an API key authentication must have no role\";\n-        final Authentication.RealmRef authenticatedBy = newApiKeyRealmRef(nodeName);\n-        Authentication authentication = new Authentication(\n-            new Subject(apiKeyUser, authenticatedBy, TransportVersion.current(), authResult.getMetadata()),\n-            AuthenticationType.API_KEY\n-        );\n-        return authentication;\n+        return newUnifiedAuthentication(Subject.Type.API_KEY, authResult, nodeName);\n     }\n \n     public Authentication toCrossClusterAccess(CrossClusterAccessSubjectInfo crossClusterAccessSubjectInfo) {\n@@ -1713,6 +1686,130 @@ public final class Authentication implements ToXContentObject {\n         }\n     }\n \n+    /**\n+     * Unified method to create authentication for different subject types and authentication methods.\n+     * Supports request-scoped-tokens by handling both User and API Key authentication creation methods\n+     * in a single unified method that accommodates different authentication types and subject types.\n+     *\n+     * @param subjectType The type of subject (USER, API_KEY, CLOUD_API_KEY, SERVICE_ACCOUNT, CROSS_CLUSTER_ACCESS)\n+     * @param authResult The authentication result containing the user and metadata\n+     * @param nodeName The node name for the realm reference\n+     * @param authenticationType The authentication type (REALM, API_KEY, TOKEN, ANONYMOUS, INTERNAL)\n+     * @param realmRef Optional realm reference, if null one will be created based on subject type\n+     * @return A new Authentication object configured for the specified subject and authentication type\n+     */\n+    public static Authentication newUnifiedAuthentication(\n+        Subject.Type subjectType,\n+        AuthenticationResult<User> authResult,\n+        String nodeName,\n+        AuthenticationType authenticationType,\n+        @Nullable Authentication.RealmRef realmRef\n+    ) {\n+        assert authResult.isAuthenticated() : \"Authentication result must be successful\";\n+        final User user = authResult.getValue();\n+        \n+        // Create appropriate realm reference based on subject type if not provided\n+        if (realmRef == null) {\n+            switch (subjectType) {\n+                case API_KEY:\n+                    assert user.roles().length == 0 : \"The user associated with an API key authentication must have no role\";\n+                    realmRef = newApiKeyRealmRef(nodeName);\n+                    authenticationType = AuthenticationType.API_KEY;\n+                    break;\n+                case CLOUD_API_KEY:\n+                    // Cloud API keys can have roles in some contexts, defer validation to the validation method\n+                    realmRef = newCloudApiKeyRealmRef(nodeName);\n+                    authenticationType = AuthenticationType.API_KEY;\n+                    break;\n+                case SERVICE_ACCOUNT:\n+                    realmRef = newServiceAccountRealmRef(nodeName);\n+                    authenticationType = AuthenticationType.TOKEN;\n+                    break;\n+                case USER:\n+                default:\n+                    if (realmRef == null) {\n+                        throw new IllegalArgumentException(\"Realm reference must be provided for USER subject type\");\n+                    }\n+                    authenticationType = AuthenticationType.REALM;\n+                    break;\n+            }\n+        }\n+\n+        Subject subject = new Subject(user, realmRef, TransportVersion.current(), authResult.getMetadata());\n+        \n+        // Validate consistency between subject type and authentication type\n+        validateSubjectAuthenticationTypeCompatibility(subjectType, authenticationType, authResult);\n+        \n+        return new Authentication(subject, authenticationType);\n+    }\n+\n+    /**\n+     * Overloaded method for creating unified authentication with automatic realm reference creation\n+     *\n+     * @param subjectType The type of subject (USER, API_KEY, CLOUD_API_KEY, SERVICE_ACCOUNT, CROSS_CLUSTER_ACCESS)\n+     * @param authResult The authentication result containing the user and metadata\n+     * @param nodeName The node name for the realm reference\n+     * @return A new Authentication object configured for the specified subject type\n+     */\n+    public static Authentication newUnifiedAuthentication(\n+        Subject.Type subjectType,\n+        AuthenticationResult<User> authResult,\n+        String nodeName\n+    ) {\n+        return newUnifiedAuthentication(subjectType, authResult, nodeName, null, null);\n+    }\n+\n+    /**\n+     * Validates the compatibility between subject type and authentication type\n+     *\n+     * @param subjectType The subject type to validate\n+     * @param authenticationType The authentication type to validate  \n+     * @param authResult The authentication result for additional validation\n+     */\n+    private static void validateSubjectAuthenticationTypeCompatibility(\n+        Subject.Type subjectType,\n+        AuthenticationType authenticationType,\n+        AuthenticationResult<User> authResult\n+    ) {\n+        User user = authResult.getValue();\n+        \n+        switch (subjectType) {\n+            case API_KEY:\n+                if (authenticationType != AuthenticationType.API_KEY) {\n+                    throw new IllegalArgumentException(\"API key subject type requires API_KEY authentication type\");\n+                }\n+                if (user.roles().length != 0) {\n+                    throw new IllegalArgumentException(\"API key authentication user must have no roles\");\n+                }\n+                break;\n+            case CLOUD_API_KEY:\n+                if (authenticationType != AuthenticationType.API_KEY) {\n+                    throw new IllegalArgumentException(\"Cloud API key subject type requires API_KEY authentication type\");\n+                }\n+                // Cloud API keys may have roles in some contexts (unlike regular API keys)\n+                // Validation is deferred to higher-level components\n+                break;\n+            case SERVICE_ACCOUNT:\n+                if (authenticationType != AuthenticationType.TOKEN) {\n+                    throw new IllegalArgumentException(\"Service account subject type requires TOKEN authentication type\");\n+                }\n+                break;\n+            case USER:\n+                if (authenticationType != AuthenticationType.REALM && authenticationType != AuthenticationType.TOKEN) {\n+                    throw new IllegalArgumentException(\"User subject type requires REALM or TOKEN authentication type\");\n+                }\n+                break;\n+            case CROSS_CLUSTER_ACCESS:\n+                if (authenticationType != AuthenticationType.API_KEY) {\n+                    throw new IllegalArgumentException(\"Cross cluster access subject type requires API_KEY authentication type\");\n+                }\n+                if (user.roles().length != 0) {\n+                    throw new IllegalArgumentException(\"Cross cluster access authentication user must have no roles\");\n+                }\n+                break;\n+        }\n+    }\n+\n     public static class AuthenticationSerializationHelper {\n \n         private AuthenticationSerializationHelper() {}",
  "logs_path": "factory/glm-4.6/24634b85/elastic_elasticsearch_pr134776/logs.jsonl",
  "errors": [],
  "edit_run_id": "24634b85",
  "test_label": null
}