{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4478,
  "base_commit": "2b6214cff72423fc5c948c7b4c39027c93494400",
  "runner": "factory",
  "model": "glm-4.6",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 155086,
  "patch_unified": "diff --git a/pom.xml b/pom.xml\nindex e70a6c8..ba97607 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -321,8 +321,8 @@\n                 <artifactId>maven-compiler-plugin</artifactId>\n                 <version>3.1</version>\n                 <configuration>\n-                    <source>1.6</source>\n-                    <target>1.6</target>\n+                    <source>1.8</source>\n+                    <target>1.8</target>\n                     <fork>true</fork>\n                     <!-- REMOVE WHEN UPGRADE:\n                          see https://jira.codehaus.org/browse/MCOMPILER-209 it's a bug where\ndiff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java\nindex 2e67160..f7de024 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java\n@@ -37,6 +37,7 @@ import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.node.settings.NodeSettingsService;\n \n import java.util.*;\n+import java.util.Map;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;\n import static org.elasticsearch.cluster.routing.ShardRoutingState.RELOCATING;\n@@ -584,6 +585,153 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n             }\n         }\n \n+        /**\n+         * Early termination check to see if cluster-wide allocation is disabled for all shards\n+         */\n+        private boolean isAllocationGloballyDisabled(RoutingNodes.UnassignedShards unassigned) {\n+            if (unassigned.isEmpty()) {\n+                return false;\n+            }\n+            \n+            // Check a sample shard to determine if allocation is globally disabled\n+            MutableShardRouting sampleShard = unassigned.iterator().next();\n+            \n+            // Check cluster-wide disable settings using the same logic as DisableAllocationDecider\n+            boolean hasPrimaries = false;\n+            boolean hasReplicas = false;\n+            for (MutableShardRouting shard : unassigned) {\n+                if (shard.primary()) {\n+                    hasPrimaries = true;\n+                } else {\n+                    hasReplicas = true;\n+                }\n+                if (hasPrimaries && hasReplicas) {\n+                    break;\n+                }\n+            }\n+            \n+            // Quick cluster setting checks\n+            Settings indexSettings = allocation.routingNodes().metaData().index(sampleShard.index()).settings();\n+            \n+            // Check if all allocation is disabled\n+            if (indexSettings.getAsBoolean(\"cluster.routing.allocation.disable_allocation\", false) ||\n+                indexSettings.getAsBoolean(\"index.routing.allocation.disable_allocation\", false)) {\n+                return true;\n+            }\n+            \n+            // Check if replica allocation is disabled and we only have replicas\n+            if (hasReplicas && !hasPrimaries) {\n+                if (indexSettings.getAsBoolean(\"cluster.routing.allocation.disable_replica_allocation\", false) ||\n+                    indexSettings.getAsBoolean(\"index.routing.allocation.disable_replica_allocation\", false)) {\n+                    return true;\n+                }\n+            }\n+            \n+            return false;\n+        }\n+\n+        /**\n+         * Node eligibility information for cached allocation decisions\n+         */\n+        private static class NodeEligibility {\n+            final boolean canAcceptPrimaries;\n+            final boolean canAcceptReplicas;\n+            final boolean hasDiskSpace;\n+            final Decision lastDecision;\n+            \n+            NodeEligibility(boolean canAcceptPrimaries, boolean canAcceptReplicas, boolean hasDiskSpace, Decision lastDecision) {\n+                this.canAcceptPrimaries = canAcceptPrimaries;\n+                this.canAcceptReplicas = canAcceptReplicas;\n+                this.hasDiskSpace = hasDiskSpace;\n+                this.lastDecision = lastDecision;\n+            }\n+        }\n+\n+        /**\n+         * Pre-filters nodes to determine eligibility and cache decisions to avoid unnecessary checks\n+         */\n+        private Map<String, NodeEligibility> preFilterNodes(RoutingNodes.UnassignedShards unassigned) {\n+            Map<String, NodeEligibility> eligibilityCache = new java.util.HashMap<>();\n+            \n+            if (unassigned.isEmpty()) {\n+                return eligibilityCache;\n+            }\n+            \n+            // Sample a primary and replica shard for node eligibility testing\n+            MutableShardRouting samplePrimary = null;\n+            MutableShardRouting sampleReplica = null;\n+            \n+            for (MutableShardRouting shard : unassigned) {\n+                if (samplePrimary == null && shard.primary()) {\n+                    samplePrimary = shard;\n+                } else if (sampleReplica == null && !shard.primary()) {\n+                    sampleReplica = shard;\n+                }\n+                \n+                if (samplePrimary != null && sampleReplica != null) {\n+                    break;\n+                }\n+            }\n+            \n+            // Use the first available shard as fallback\n+            MutableShardRouting fallbackShard = samplePrimary != null ? samplePrimary : \n+                                              sampleReplica != null ? sampleReplica : \n+                                              unassigned.iterator().next();\n+            \n+            for (ModelNode node : nodes.values()) {\n+                RoutingNode routingNode = routingNodes.node(node.getNodeId());\n+                if (routingNode == null) {\n+                    continue;\n+                }\n+                \n+                boolean canAcceptPrimaries = true;\n+                boolean canAcceptReplicas = true;\n+                boolean hasDiskSpace = true;\n+                Decision lastDecision = Decision.YES;\n+                \n+                // Test primary allocation if we have primaries\n+                if (samplePrimary != null) {\n+                    Decision primaryDecision = allocation.deciders().canAllocate(samplePrimary, routingNode, allocation);\n+                    if (primaryDecision.type() == Decision.Type.NO) {\n+                        canAcceptPrimaries = false;\n+                        if (sampleReplica == null) {\n+                            // If we only have primaries and this node can't accept them, cache as completely ineligible\n+                            eligibilityCache.put(node.getNodeId(), new NodeEligibility(false, false, false, primaryDecision));\n+                            continue;\n+                        }\n+                        lastDecision = primaryDecision;\n+                    }\n+                }\n+                \n+                // Test replica allocation if we have replicas  \n+                if (sampleReplica != null) {\n+                    Decision replicaDecision = allocation.deciders().canAllocate(sampleReplica, routingNode, allocation);\n+                    if (replicaDecision.type() == Decision.Type.NO) {\n+                        canAcceptReplicas = false;\n+                        if (samplePrimary == null) {\n+                            // If we only have replicas and this node can't accept them, cache as completely ineligible\n+                            eligibilityCache.put(node.getNodeId(), new NodeEligibility(false, false, false, replicaDecision));\n+                            continue;\n+                        }\n+                        if (lastDecision == Decision.YES) {\n+                            lastDecision = replicaDecision;\n+                        }\n+                    }\n+                }\n+                \n+                // Quick disk space check if disk threshold decider is enabled\n+                Decision diskDecision = allocation.deciders().canAllocate(fallbackShard, routingNode, allocation);\n+                if (diskDecision.type() == Decision.Type.NO && diskDecision.toString().contains(\"disk\")) {\n+                    hasDiskSpace = false;\n+                    lastDecision = diskDecision;\n+                }\n+                \n+                eligibilityCache.put(node.getNodeId(), new NodeEligibility(canAcceptPrimaries, canAcceptReplicas, hasDiskSpace, lastDecision));\n+            }\n+            \n+            return eligibilityCache;\n+        }\n+\n         /**\n          * Allocates all given shards on the minimal eligable node for the shards index\n          * with respect to the weight function. All given shards must be unassigned.\n@@ -596,6 +744,23 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n             if (unassigned.isEmpty()) {\n                 return false;\n             }\n+            \n+            // Early termination: Check if cluster-wide allocation is disabled\n+            if (isAllocationGloballyDisabled(unassigned)) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"Allocation is globally disabled, skipping all allocation attempts\");\n+                }\n+                // Move all unassigned shards to ignored list\n+                for (MutableShardRouting shard : unassigned) {\n+                    ignoredUnassigned.add(shard);\n+                }\n+                unassigned.clear();\n+                return false;\n+            }\n+            \n+            // Pre-filter eligible nodes to avoid checking nodes that cannot accept any allocation\n+            Map<String, NodeEligibility> nodeEligibilityCache = preFilterNodes(unassigned);\n+            \n             boolean changed = false;\n           \n             /*\n@@ -637,6 +802,24 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n                     ModelNode minNode = null;\n                     Decision decision = null;\n                     for (ModelNode node : nodes.values()) {\n+                        /*\n+                         * Early termination: Check node eligibility cache before proceeding with expensive operations\n+                         */\n+                        NodeEligibility eligibility = nodeEligibilityCache.get(node.getNodeId());\n+                        if (eligibility != null) {\n+                            // Skip nodes that cannot accept this shard type\n+                            if (shard.primary() && !eligibility.canAcceptPrimaries) {\n+                                continue;\n+                            }\n+                            if (!shard.primary() && !eligibility.canAcceptReplicas) {\n+                                continue;\n+                            }\n+                            // Skip nodes with insufficient disk space\n+                            if (!eligibility.hasDiskSpace) {\n+                                continue;\n+                            }\n+                        }\n+                        \n                         /*\n                          * The shard we add is removed below to simulate the\n \t                     * addition for weight calculation we use Decision.ALWAYS to\n@@ -656,7 +839,13 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n \t                         * don't check deciders\n \t                         */\n                             if (currentWeight <= minWeight) {\n-                                Decision currentDecision = deciders.canAllocate(shard, routingNodes.node(node.getNodeId()), allocation);\n+                                // Use cached decision if available and still valid, otherwise compute new decision\n+                                Decision currentDecision;\n+                                if (eligibility != null && eligibility.lastDecision.type() == Decision.Type.NO) {\n+                                    currentDecision = eligibility.lastDecision; // Use cached NO decision\n+                                } else {\n+                                    currentDecision = deciders.canAllocate(shard, routingNodes.node(node.getNodeId()), allocation);\n+                                }\n                                 NOUPDATE:\n                                 if (currentDecision.type() == Type.YES || currentDecision.type() == Type.THROTTLE) {\n                                     if (currentWeight == minWeight) {",
  "logs_path": "factory/glm-4.6/24634b85/elastic_elasticsearch_pr4478/logs.jsonl",
  "errors": [],
  "edit_run_id": "24634b85",
  "test_label": null
}