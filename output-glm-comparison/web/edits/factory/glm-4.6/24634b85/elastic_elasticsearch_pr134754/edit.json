{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134754,
  "base_commit": "d70e2bd0d84d610b8ad101288141196261ad7628",
  "runner": "factory",
  "model": "glm-4.6",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 163981,
  "patch_unified": "diff --git a/qa/lucene-index-compatibility/src/javaRestTest/java/org/elasticsearch/lucene/FullClusterRestartSystemIndexCompatibilityIT.java b/qa/lucene-index-compatibility/src/javaRestTest/java/org/elasticsearch/lucene/FullClusterRestartSystemIndexCompatibilityIT.java\nindex 3bc2fde3..1eea9b0a 100644\n--- a/qa/lucene-index-compatibility/src/javaRestTest/java/org/elasticsearch/lucene/FullClusterRestartSystemIndexCompatibilityIT.java\n+++ b/qa/lucene-index-compatibility/src/javaRestTest/java/org/elasticsearch/lucene/FullClusterRestartSystemIndexCompatibilityIT.java\n@@ -24,6 +24,7 @@ import java.util.HashMap;\n import java.util.Map;\n import java.util.concurrent.TimeUnit;\n \n+import static org.elasticsearch.test.ESTestCase.assertBusy;\n import static org.hamcrest.Matchers.equalTo;\n \n public class FullClusterRestartSystemIndexCompatibilityIT extends FullClusterRestartIndexCompatibilityTestCase {\n@@ -74,16 +75,27 @@ public class FullClusterRestartSystemIndexCompatibilityIT extends FullClusterRes\n         }\n \n         if (isFullyUpgradedTo(VERSION_MINUS_1)) {\n-            // check .async-search index is readable\n-            assertThat(indexVersion(asyncSearchIndex, true), equalTo(VERSION_MINUS_2));\n+            // check .async-search index is readable - add retry for cluster startup stability\n+            assertBusy(() -> {\n+                try {\n+                    assertThat(indexVersion(asyncSearchIndex, true), equalTo(VERSION_MINUS_2));\n+                } catch (Exception e) {\n+                    throw new AssertionError(\"System index not yet available after upgrade\", e);\n+                }\n+            }, 30, TimeUnit.SECONDS);\n             assertAsyncSearchHitCount(async_search_ids.get(\"n-2_id\"), numDocs);\n \n-            // migrate system indices\n-            Request migrateRequest = new Request(\"POST\", \"/_migration/system_features\");\n-            assertThat(\n-                ObjectPath.createFromResponse(client().performRequest(migrateRequest)).evaluate(\"features.0.feature_name\"),\n-                equalTo(\"async_search\")\n-            );\n+            // migrate system indices - add retry for request stability\n+            assertBusy(() -> {\n+                try {\n+                    Request migrateRequest = new Request(\"POST\", \"/_migration/system_features\");\n+                    ObjectPath migrateResp = ObjectPath.createFromResponse(client().performRequest(migrateRequest));\n+                    assertThat(migrateResp.evaluate(\"features.0.feature_name\"), equalTo(\"async_search\"));\n+                } catch (Exception e) {\n+                    throw new AssertionError(\"System feature migration request failed\", e);\n+                }\n+            }, 30, TimeUnit.SECONDS);\n+            \n             assertBusy(() -> {\n                 Request checkMigrateProgress = new Request(\"GET\", \"/_migration/system_features\");\n                 Response resp = null;\n@@ -98,7 +110,7 @@ public class FullClusterRestartSystemIndexCompatibilityIT extends FullClusterRes\n                 }\n             }, 30, TimeUnit.SECONDS);\n \n-            // check search results from n-2 search are still readable\n+            // check search results from n-2 search are still readable after migration\n             assertAsyncSearchHitCount(async_search_ids.get(\"n-2_id\"), numDocs);\n \n             // perform new async search and check its readable\n@@ -111,7 +123,15 @@ public class FullClusterRestartSystemIndexCompatibilityIT extends FullClusterRes\n         }\n \n         if (isFullyUpgradedTo(VERSION_CURRENT)) {\n-            assertThat(indexVersion(index, true), equalTo(VERSION_MINUS_2));\n+            // Add retry for final cluster upgrade stability\n+            assertBusy(() -> {\n+                try {\n+                    assertThat(indexVersion(index, true), equalTo(VERSION_MINUS_2));\n+                } catch (Exception e) {\n+                    throw new AssertionError(\"Index not yet available after final upgrade\", e);\n+                }\n+            }, 30, TimeUnit.SECONDS);\n+            \n             assertAsyncSearchHitCount(async_search_ids.get(\"n-2_id\"), numDocs);\n             assertAsyncSearchHitCount(async_search_ids.get(\"n-1_id\"), numDocs);\n \n@@ -123,18 +143,41 @@ public class FullClusterRestartSystemIndexCompatibilityIT extends FullClusterRes\n \n     }\n \n-    private static String searchAsyncAndStoreId(Request asyncSearchRequest, String asyncIdName) throws IOException {\n+    private static String searchAsyncAndStoreId(Request asyncSearchRequest, String asyncIdName) throws Exception {\n+        // Submit the async search and get the ID\n         ObjectPath resp = ObjectPath.createFromResponse(client().performRequest(asyncSearchRequest));\n         String asyncId = resp.evaluate(\"id\");\n         assertNotNull(asyncId);\n         async_search_ids.put(asyncIdName, asyncId);\n+        \n+        // Wait a moment for the async search to be fully indexed in the system index\n+        // This prevents race conditions where the async search document isn't immediately available\n+        assertBusy(() -> {\n+            try {\n+                var asyncGet = new Request(\"GET\", \"/_async_search/\" + asyncId);\n+                ObjectPath checkResp = ObjectPath.createFromResponse(client().performRequest(asyncGet));\n+                // Just check that we can retrieve the response - the actual hit count assertion will happen separately\n+                assertNotNull(checkResp.evaluate(\"id\"));\n+            } catch (IOException e) {\n+                // Wrap as AssertionError for assertBusy to retry\n+                throw new AssertionError(\"Async search not yet available for id: \" + asyncId, e);\n+            }\n+        }, 10, TimeUnit.SECONDS);\n+        \n         return asyncId;\n     }\n \n-    private static void assertAsyncSearchHitCount(String asyncId, int numDocs) throws IOException {\n-        var asyncGet = new Request(\"GET\", \"/_async_search/\" + asyncId);\n-        ObjectPath resp = ObjectPath.createFromResponse(client().performRequest(asyncGet));\n-        assertEquals(Integer.valueOf(numDocs), resp.evaluate(\"response.hits.total.value\"));\n+    private static void assertAsyncSearchHitCount(String asyncId, int numDocs) throws Exception {\n+        assertBusy(() -> {\n+            try {\n+                var asyncGet = new Request(\"GET\", \"/_async_search/\" + asyncId);\n+                ObjectPath resp = ObjectPath.createFromResponse(client().performRequest(asyncGet));\n+                assertEquals(Integer.valueOf(numDocs), resp.evaluate(\"response.hits.total.value\"));\n+            } catch (IOException e) {\n+                // Wrap IOException as AssertionError for assertBusy to retry\n+                throw new AssertionError(\"Failed to assert async search hit count for id: \" + asyncId, e);\n+            }\n+        }, 30, TimeUnit.SECONDS);\n     }\n \n     /**",
  "logs_path": "factory/glm-4.6/24634b85/elastic_elasticsearch_pr134754/logs.jsonl",
  "errors": [],
  "edit_run_id": "24634b85",
  "test_label": null
}