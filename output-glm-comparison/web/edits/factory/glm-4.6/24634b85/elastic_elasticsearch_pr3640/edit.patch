diff --git a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java
index 9764831..05f820f 100644
--- a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java
+++ b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java
@@ -151,7 +151,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
 
     private volatile BoundTransportAddress boundAddress;
 
-    private final Object[] connectMutex;
+    private final ConcurrentMap<String, Object> nodeLocks = newConcurrentMap();
     // this lock is here to make sure we close this transport and disconnect all the client nodes
     // connections while no connect operations is going on... (this might help with 100% CPU when stopping the transport?)
     private final ReadWriteLock globalLock = new ReentrantReadWriteLock();
@@ -167,10 +167,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
             System.setProperty("org.jboss.netty.epollBugWorkaround", "true");
         }
 
-        this.connectMutex = new Object[500];
-        for (int i = 0; i < connectMutex.length; i++) {
-            connectMutex[i] = new Object();
-        }
+        
 
         this.workerCount = componentSettings.getAsInt("worker_count", EsExecutors.boundedNumberOfProcessors() * 2);
         this.bossCount = componentSettings.getAsInt("boss_count", 1);
@@ -761,16 +758,20 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
                 }
             }
         }
+        // Clean up the node lock to prevent memory leaks
+        removeNodeLock(node.id());
     }
 
     /**
      * Disconnects from a node, only if the relevant channel is found to be part of the node channels.
      */
     private void disconnectFromNode(DiscoveryNode node, Channel channel, String reason) {
+        boolean shouldRemoveLock = false;
         synchronized (connectLock(node.id())) {
             NodeChannels nodeChannels = connectedNodes.get(node);
             if (nodeChannels != null && nodeChannels.hasChannel(channel)) {
                 connectedNodes.remove(node);
+                shouldRemoveLock = true;
                 try {
                     nodeChannels.close();
                 } finally {
@@ -779,26 +780,37 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
                 }
             }
         }
+        // Clean up the node lock if we disconnected the node
+        if (shouldRemoveLock) {
+            removeNodeLock(node.id());
+        }
     }
 
     /**
      * Disconnects from a node if a channel is found as part of that nodes channels.
      */
     private void disconnectFromNodeChannel(Channel channel, Throwable failure) {
+        String nodeIdToRemove = null;
         for (DiscoveryNode node : connectedNodes.keySet()) {
             synchronized (connectLock(node.id())) {
                 NodeChannels nodeChannels = connectedNodes.get(node);
                 if (nodeChannels != null && nodeChannels.hasChannel(channel)) {
                     connectedNodes.remove(node);
+                    nodeIdToRemove = node.id();
                     try {
                         nodeChannels.close();
                     } finally {
                         logger.debug("disconnected from [{}] on channel failure", failure, node);
                         transportServiceAdapter.raiseNodeDisconnected(node);
                     }
+                    break; // Only remove the first matching node
                 }
             }
         }
+        // Clean up the node lock if we disconnected a node
+        if (nodeIdToRemove != null) {
+            removeNodeLock(nodeIdToRemove);
+        }
     }
 
     private Channel nodeChannel(DiscoveryNode node, TransportRequestOptions options) throws ConnectTransportException {
@@ -810,12 +822,22 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
     }
 
     private Object connectLock(String nodeId) {
-        int hash = nodeId.hashCode();
-        // abs returns Integer.MIN_VALUE, so we need to protect against it...
-        if (hash == Integer.MIN_VALUE) {
-            hash = 0;
+        Object lock = nodeLocks.get(nodeId);
+        if (lock == null) {
+            // Double-checked locking pattern to ensure thread-safe creation
+            synchronized (this) {
+                lock = nodeLocks.get(nodeId);
+                if (lock == null) {
+                    lock = new Object();
+                    nodeLocks.put(nodeId, lock);
+                }
+            }
         }
-        return connectMutex[Math.abs(hash) % connectMutex.length];
+        return lock;
+    }
+
+    private void removeNodeLock(String nodeId) {
+        nodeLocks.remove(nodeId);
     }
 
     private class ChannelCloseListener implements ChannelFutureListener {