{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 3640,
  "base_commit": "4155741f7f486537d4a5f7193d79098d523a6ae8",
  "runner": "factory",
  "model": "glm-4.6",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 133934,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\nindex 9764831..05f820f 100644\n--- a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\n+++ b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\n@@ -151,7 +151,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n \n     private volatile BoundTransportAddress boundAddress;\n \n-    private final Object[] connectMutex;\n+    private final ConcurrentMap<String, Object> nodeLocks = newConcurrentMap();\n     // this lock is here to make sure we close this transport and disconnect all the client nodes\n     // connections while no connect operations is going on... (this might help with 100% CPU when stopping the transport?)\n     private final ReadWriteLock globalLock = new ReentrantReadWriteLock();\n@@ -167,10 +167,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n             System.setProperty(\"org.jboss.netty.epollBugWorkaround\", \"true\");\n         }\n \n-        this.connectMutex = new Object[500];\n-        for (int i = 0; i < connectMutex.length; i++) {\n-            connectMutex[i] = new Object();\n-        }\n+        \n \n         this.workerCount = componentSettings.getAsInt(\"worker_count\", EsExecutors.boundedNumberOfProcessors() * 2);\n         this.bossCount = componentSettings.getAsInt(\"boss_count\", 1);\n@@ -761,16 +758,20 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n                 }\n             }\n         }\n+        // Clean up the node lock to prevent memory leaks\n+        removeNodeLock(node.id());\n     }\n \n     /**\n      * Disconnects from a node, only if the relevant channel is found to be part of the node channels.\n      */\n     private void disconnectFromNode(DiscoveryNode node, Channel channel, String reason) {\n+        boolean shouldRemoveLock = false;\n         synchronized (connectLock(node.id())) {\n             NodeChannels nodeChannels = connectedNodes.get(node);\n             if (nodeChannels != null && nodeChannels.hasChannel(channel)) {\n                 connectedNodes.remove(node);\n+                shouldRemoveLock = true;\n                 try {\n                     nodeChannels.close();\n                 } finally {\n@@ -779,26 +780,37 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n                 }\n             }\n         }\n+        // Clean up the node lock if we disconnected the node\n+        if (shouldRemoveLock) {\n+            removeNodeLock(node.id());\n+        }\n     }\n \n     /**\n      * Disconnects from a node if a channel is found as part of that nodes channels.\n      */\n     private void disconnectFromNodeChannel(Channel channel, Throwable failure) {\n+        String nodeIdToRemove = null;\n         for (DiscoveryNode node : connectedNodes.keySet()) {\n             synchronized (connectLock(node.id())) {\n                 NodeChannels nodeChannels = connectedNodes.get(node);\n                 if (nodeChannels != null && nodeChannels.hasChannel(channel)) {\n                     connectedNodes.remove(node);\n+                    nodeIdToRemove = node.id();\n                     try {\n                         nodeChannels.close();\n                     } finally {\n                         logger.debug(\"disconnected from [{}] on channel failure\", failure, node);\n                         transportServiceAdapter.raiseNodeDisconnected(node);\n                     }\n+                    break; // Only remove the first matching node\n                 }\n             }\n         }\n+        // Clean up the node lock if we disconnected a node\n+        if (nodeIdToRemove != null) {\n+            removeNodeLock(nodeIdToRemove);\n+        }\n     }\n \n     private Channel nodeChannel(DiscoveryNode node, TransportRequestOptions options) throws ConnectTransportException {\n@@ -810,12 +822,22 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n     }\n \n     private Object connectLock(String nodeId) {\n-        int hash = nodeId.hashCode();\n-        // abs returns Integer.MIN_VALUE, so we need to protect against it...\n-        if (hash == Integer.MIN_VALUE) {\n-            hash = 0;\n+        Object lock = nodeLocks.get(nodeId);\n+        if (lock == null) {\n+            // Double-checked locking pattern to ensure thread-safe creation\n+            synchronized (this) {\n+                lock = nodeLocks.get(nodeId);\n+                if (lock == null) {\n+                    lock = new Object();\n+                    nodeLocks.put(nodeId, lock);\n+                }\n+            }\n         }\n-        return connectMutex[Math.abs(hash) % connectMutex.length];\n+        return lock;\n+    }\n+\n+    private void removeNodeLock(String nodeId) {\n+        nodeLocks.remove(nodeId);\n     }\n \n     private class ChannelCloseListener implements ChannelFutureListener {",
  "logs_path": "factory/glm-4.6/24634b85/elastic_elasticsearch_pr3640/logs.jsonl",
  "errors": [],
  "edit_run_id": "24634b85",
  "test_label": null
}