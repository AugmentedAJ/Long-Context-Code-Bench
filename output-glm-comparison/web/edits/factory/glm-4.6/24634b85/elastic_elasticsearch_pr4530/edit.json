{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4530,
  "base_commit": "bbffeb1b39b864a8bf6c9844dfa23869e44c8639",
  "runner": "factory",
  "model": "glm-4.6",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 98105,
  "patch_unified": "diff --git a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\nindex a394166..0ced1d0 100644\n--- a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\n+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\n@@ -25,6 +25,7 @@ import com.google.common.base.Charsets;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n+import com.google.common.collect.MapBuilder;\n import org.apache.lucene.util.CollectionUtil;\n import org.apache.lucene.util.IOUtils;\n import org.elasticsearch.ElasticSearchException;\n@@ -48,6 +49,7 @@ import org.elasticsearch.common.io.Streams;\n import org.elasticsearch.common.regex.Regex;\n import org.elasticsearch.common.settings.ImmutableSettings;\n import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.settings.loader.SettingsLoader;\n import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.xcontent.XContentFactory;\n import org.elasticsearch.common.xcontent.XContentHelper;\n@@ -480,9 +482,86 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n                 for (File templatesFile : templatesFiles) {\n                     XContentParser parser = null;\n                     try {\n+                        // Derive template name from filename (without extension)\n+                        String templateName = templatesFile.getName();\n+                        int lastDotIndex = templateName.lastIndexOf('.');\n+                        if (lastDotIndex != -1) {\n+                            templateName = templateName.substring(0, lastDotIndex);\n+                        }\n+                        \n                         byte[] templatesData = Streams.copyToByteArray(templatesFile);\n                         parser = XContentHelper.createParser(templatesData, 0, templatesData.length);\n-                        IndexTemplateMetaData template = IndexTemplateMetaData.Builder.fromXContent(parser);\n+                        \n+                        // Parse the template content directly (0.90.7 format)\n+                        // The template file contains the template content directly, not wrapped in a named object\n+                        IndexTemplateMetaData.Builder templateBuilder = IndexTemplateMetaData.builder(templateName);\n+                        \n+                        String currentFieldName = null;\n+                        XContentParser.Token token = parser.nextToken();\n+                        if (token != XContentParser.Token.START_OBJECT) {\n+                            throw new IOException(\"template file should start with an object\");\n+                        }\n+                        \n+                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n+                            if (token == XContentParser.Token.FIELD_NAME) {\n+                                currentFieldName = parser.currentName();\n+                            } else if (token == XContentParser.Token.START_OBJECT) {\n+                                if (\"settings\".equals(currentFieldName)) {\n+                                    ImmutableSettings.Builder templateSettingsBuilder = ImmutableSettings.settingsBuilder();\n+                                    Map<String, String> settingsMap = SettingsLoader.Helper.loadNestedFromMap(parser.mapOrdered());\n+                                    for (Map.Entry<String, String> entry : settingsMap.entrySet()) {\n+                                        if (!entry.getKey().startsWith(\"index.\")) {\n+                                            templateSettingsBuilder.put(\"index.\" + entry.getKey(), entry.getValue());\n+                                        } else {\n+                                            templateSettingsBuilder.put(entry.getKey(), entry.getValue());\n+                                        }\n+                                    }\n+                                    templateBuilder.settings(templateSettingsBuilder.build());\n+                                } else if (\"mappings\".equals(currentFieldName)) {\n+                                    while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n+                                        if (token == XContentParser.Token.FIELD_NAME) {\n+                                            currentFieldName = parser.currentName();\n+                                        } else if (token == XContentParser.Token.START_OBJECT) {\n+                                            String mappingType = currentFieldName;\n+                                            Map<String, Object> mappingSource = MapBuilder.<String, Object>newMapBuilder().put(mappingType, parser.mapOrdered()).map();\n+                                            templateBuilder.putMapping(mappingType, XContentFactory.jsonBuilder().map(mappingSource).string());\n+                                        }\n+                                    }\n+                                } else {\n+                                    // check if its a custom index metadata\n+                                    IndexMetaData.Custom.Factory<IndexMetaData.Custom> factory = IndexMetaData.lookupFactory(currentFieldName);\n+                                    if (factory == null) {\n+                                        //TODO warn\n+                                        parser.skipChildren();\n+                                    } else {\n+                                        templateBuilder.putCustom(factory.type(), factory.fromXContent(parser));\n+                                    }\n+                                }\n+                            } else if (token == XContentParser.Token.START_ARRAY) {\n+                                if (\"mappings\".equals(currentFieldName)) {\n+                                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n+                                        Map<String, Object> mapping = parser.mapOrdered();\n+                                        if (mapping.size() == 1) {\n+                                            String mappingType = mapping.keySet().iterator().next();\n+                                            String mappingSource = XContentFactory.jsonBuilder().map(mapping).string();\n+                                            if (mappingSource == null) {\n+                                                // crap, no mapping source, warn?\n+                                            } else {\n+                                                templateBuilder.putMapping(mappingType, mappingSource);\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                            } else if (token.isValue()) {\n+                                if (\"template\".equals(currentFieldName)) {\n+                                    templateBuilder.template(parser.text());\n+                                } else if (\"order\".equals(currentFieldName)) {\n+                                    templateBuilder.order(parser.intValue());\n+                                }\n+                            }\n+                        }\n+                        \n+                        IndexTemplateMetaData template = templateBuilder.build();\n                         if (Regex.simpleMatch(template.template(), request.index)) {\n                             templates.add(template);\n                         }",
  "logs_path": "factory/glm-4.6/24634b85/elastic_elasticsearch_pr4530/logs.jsonl",
  "errors": [],
  "edit_run_id": "24634b85",
  "test_label": null
}