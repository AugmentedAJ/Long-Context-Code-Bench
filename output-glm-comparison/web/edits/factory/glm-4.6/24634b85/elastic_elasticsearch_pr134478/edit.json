{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134478,
  "base_commit": "7295189560dee0151019e46059d5b5e1fe0f5378",
  "runner": "factory",
  "model": "glm-4.6",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 291027,
  "patch_unified": "diff --git a/x-pack/plugin/esql/compute/src/main/java/org/elasticsearch/compute/data/Block.java b/x-pack/plugin/esql/compute/src/main/java/org/elasticsearch/compute/data/Block.java\nindex b57b4369..c0a3138a 100644\n--- a/x-pack/plugin/esql/compute/src/main/java/org/elasticsearch/compute/data/Block.java\n+++ b/x-pack/plugin/esql/compute/src/main/java/org/elasticsearch/compute/data/Block.java\n@@ -53,10 +53,11 @@ public interface Block extends Accountable, BlockLoader.Block, Writeable, RefCou\n      * For now, we approximate this overhead, per block, using this value.\n      *\n      * The exact overhead per block would be (more correctly) {@link RamUsageEstimator#NUM_BYTES_OBJECT_REF},\n-     * but we approximate it with {@link RamUsageEstimator#NUM_BYTES_OBJECT_ALIGNMENT} to avoid further alignments\n-     * to object size (at the end of the alignment, it would make no practical difference).\n+     * but we use an increased value to better handle circuit breaking with many small pages.\n+     * This increased estimate provides more conservative memory tracking to prevent circuit breaker issues\n+     * when dealing with pages containing many small blocks.\n      */\n-    int PAGE_MEM_OVERHEAD_PER_BLOCK = RamUsageEstimator.NUM_BYTES_OBJECT_ALIGNMENT;\n+    int PAGE_MEM_OVERHEAD_PER_BLOCK = RamUsageEstimator.NUM_BYTES_OBJECT_ALIGNMENT * 4;\n \n     /**\n      * {@return an efficient dense single-value view of this block}.",
  "logs_path": "factory/glm-4.6/24634b85/elastic_elasticsearch_pr134478/logs.jsonl",
  "errors": [],
  "edit_run_id": "24634b85",
  "test_label": null
}