{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134506,
  "base_commit": "e5559ef012c066ddfe75ccbc3961d7923e92af3b",
  "runner": "factory",
  "model": "glm-4.6",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 284527,
  "patch_unified": "diff --git a/server/src/main/java/org/elasticsearch/TransportVersion.java b/server/src/main/java/org/elasticsearch/TransportVersion.java\nindex f130f7d6..4e412620 100644\n--- a/server/src/main/java/org/elasticsearch/TransportVersion.java\n+++ b/server/src/main/java/org/elasticsearch/TransportVersion.java\n@@ -239,11 +239,113 @@ public record TransportVersion(String name, int id, TransportVersion nextPatchVe\n     public static TransportVersion fromName(String name) {\n         TransportVersion known = VersionsHolder.ALL_VERSIONS_BY_NAME.get(name);\n         if (known == null) {\n-            throw new IllegalStateException(\"unknown transport version [\" + name + \"]\");\n+            throw new IllegalStateException(createUnknownVersionErrorMessage(name));\n         }\n         return known;\n     }\n \n+    /**\n+     * Creates a helpful error message for unknown transport versions by suggesting similar versions.\n+     */\n+    private static String createUnknownVersionErrorMessage(String name) {\n+        List<String> suggestions = findSimilarVersionNames(name);\n+        \n+        StringBuilder errorMsg = new StringBuilder(\"unknown transport version [\")\n+            .append(name)\n+            .append(\"]\");\n+            \n+        if (!suggestions.isEmpty()) {\n+            errorMsg.append(\". Did you mean \");\n+            if (suggestions.size() == 1) {\n+                errorMsg.append(\"[\").append(suggestions.get(0)).append(\"]?\");\n+            } else {\n+                errorMsg.append(\"one of: \");\n+                for (int i = 0; i < suggestions.size(); i++) {\n+                    if (i > 0) {\n+                        errorMsg.append(\", \");\n+                    }\n+                    if (i == suggestions.size() - 1) {\n+                        errorMsg.append(\"or \");\n+                    }\n+                    errorMsg.append(\"[\").append(suggestions.get(i)).append(\"]\");\n+                }\n+                errorMsg.append(\"?\");\n+            }\n+        }\n+        \n+        return errorMsg.toString();\n+    }\n+\n+    /**\n+     * Finds version names that are similar to the given name using Levenshtein distance.\n+     * Returns up to 3 most similar version names.\n+     */\n+    private static List<String> findSimilarVersionNames(String name) {\n+        if (name == null || name.trim().isEmpty()) {\n+            return List.of();\n+        }\n+        \n+        String targetName = name.trim().toLowerCase();\n+        return VersionsHolder.ALL_VERSIONS_BY_NAME.keySet().stream()\n+            .filter(knownName -> !knownName.equalsIgnoreCase(targetName))\n+            .map(knownName -> new VersionSuggestion(knownName, calculateSimilarity(targetName, knownName.toLowerCase())))\n+            .filter(suggestion -> suggestion.similarity > 0.5) // Only include reasonably similar names\n+            .sorted((a, b) -> Double.compare(b.similarity, a.similarity))\n+            .limit(3)\n+            .map(suggestion -> suggestion.name)\n+            .toList();\n+    }\n+\n+    /**\n+     * Calculates similarity between two strings using a simplified Levenshtein distance.\n+     * Returns a value between 0.0 (no similarity) and 1.0 (exact match).\n+     */\n+    private static double calculateSimilarity(String s1, String s2) {\n+        if (s1.equals(s2)) {\n+            return 1.0;\n+        }\n+        \n+        int maxLength = Math.max(s1.length(), s2.length());\n+        if (maxLength == 0) {\n+            return 0.0;\n+        }\n+        \n+        int distance = levenshteinDistance(s1, s2);\n+        return 1.0 - ((double) distance / maxLength);\n+    }\n+\n+    /**\n+     * Calculates the Levenshtein distance between two strings.\n+     */\n+    private static int levenshteinDistance(String s1, String s2) {\n+        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\n+        \n+        for (int i = 0; i <= s1.length(); i++) {\n+            dp[i][0] = i;\n+        }\n+        \n+        for (int j = 0; j <= s2.length(); j++) {\n+            dp[0][j] = j;\n+        }\n+        \n+        for (int i = 1; i <= s1.length(); i++) {\n+            for (int j = 1; j <= s2.length(); j++) {\n+                int cost = s1.charAt(i - 1) == s2.charAt(j - 1) ? 0 : 1;\n+                dp[i][j] = Math.min(\n+                    Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1),\n+                    dp[i - 1][j - 1] + cost\n+                );\n+            }\n+        }\n+        \n+        return dp[s1.length()][s2.length()];\n+    }\n+\n+    /**\n+     * Helper class to hold version name suggestions with similarity scores.\n+     */\n+    private static record VersionSuggestion(String name, double similarity) {}\n+\n     public static void writeVersion(TransportVersion version, StreamOutput out) throws IOException {\n         out.writeVInt(version.id);\n     }\ndiff --git a/server/src/test/java/org/elasticsearch/TransportVersionTests.java b/server/src/test/java/org/elasticsearch/TransportVersionTests.java\nindex e51ca0c5..6af124cd 100644\n--- a/server/src/test/java/org/elasticsearch/TransportVersionTests.java\n+++ b/server/src/test/java/org/elasticsearch/TransportVersionTests.java\n@@ -29,6 +29,7 @@ import static org.hamcrest.Matchers.greaterThan;\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.lessThan;\n import static org.hamcrest.Matchers.sameInstance;\n+import static org.hamcrest.Matchers.startsWith;\n \n public class TransportVersionTests extends ESTestCase {\n \n@@ -391,4 +392,80 @@ public class TransportVersionTests extends ESTestCase {\n         );\n         assertThat(new TransportVersion(null, 1000000, null).supports(test3), is(true));\n     }\n+\n+    public void testUnknownVersionErrorMessageWithSuggestions() {\n+        // Test with a version name that might have a typo\n+        IllegalStateException exception1 = expectThrows(IllegalStateException.class, \n+            () -> TransportVersion.fromName(\"transpor_version\"));\n+        assertThat(exception1.getMessage(), containsString(\"unknown transport version [transpor_version]\"));\n+        \n+        // The error message should contain suggestions if there are similar versions\n+        // Note: This test might not find exact matches depending on the available versions\n+        // but verifies the structure of the error message\n+        if (exception1.getMessage().contains(\"Did you mean\")) {\n+            assertThat(exception1.getMessage(), containsString(\"Did you mean\"));\n+            // Should be properly formatted with brackets around suggestions\n+            assertThat(exception1.getMessage(), containsString(\"[\"));\n+            assertThat(exception1.getMessage(), containsString(\"]\"));\n+        }\n+        \n+        // Test with a completely different string\n+        IllegalStateException exception2 = expectThrows(IllegalStateException.class, \n+            () -> TransportVersion.fromName(\"completely_random_version_name\"));\n+        assertThat(exception2.getMessage(), containsString(\"unknown transport version [completely_random_version_name]\"));\n+        // Probably won't have suggestions for this completely different name\n+        \n+        // Test with empty string\n+        IllegalStateException exception3 = expectThrows(IllegalStateException.class, \n+            () -> TransportVersion.fromName(\"\"));\n+        assertThat(exception3.getMessage(), containsString(\"unknown transport version []\"));\n+        \n+        // Test with null\n+        IllegalStateException exception4 = expectThrows(IllegalStateException.class, \n+            () -> TransportVersion.fromName(null));\n+        assertThat(exception4.getMessage(), containsString(\"unknown transport version [null]\"));\n+    }\n+\n+    public void testVersionSuggestionAlgorithm() {\n+        // We can't directly test the private methods, but we can verify the functionality\n+        // through the public interface by checking error messages\n+        \n+        // Test with a name that's likely to have similar versions (if they exist in the codebase)\n+        try {\n+            TransportVersion.fromName(\"version\");\n+            // If this succeeds, it means \"version\" is a valid transport version name\n+            // which is fine, the test just passes\n+        } catch (IllegalStateException e) {\n+            // Check if the error message is properly formatted\n+            assertThat(e.getMessage(), startsWith(\"unknown transport version [version]\"));\n+            \n+            // If there are suggestions, verify they're properly formatted\n+            if (e.getMessage().contains(\"Did you mean\")) {\n+                assertThat(e.getMessage(), containsString(\"[\"));\n+                assertThat(e.getMessage(), containsString(\"]\"));\n+                \n+                // Should end with a question mark\n+                assertThat(e.getMessage(), endsWith(\"?\"));\n+                \n+                // Should not contain duplicate suggestions\n+                String message = e.getMessage();\n+                int firstBracket = message.indexOf('[');\n+                String suggestionsPart = message.substring(firstBracket);\n+                \n+                // Count occurrences of each suggestion pattern to check for duplicates\n+                String[] suggestions = suggestionsPart.split(\"\\\\[|\\\\]|, | or \");\n+                for (int i = 1; i < suggestions.length; i += 2) { // Skip empty strings and delimiters\n+                    String suggestion = suggestions[i].trim();\n+                    int occurrences = 0;\n+                    for (int j = 1; j < suggestions.length; j += 2) {\n+                        if (suggestions[j].trim().equals(suggestion)) {\n+                            occurrences++;\n+                        }\n+                    }\n+                    // Each suggestion should appear exactly once\n+                    assertThat(\"Duplicate suggestion found: \" + suggestion, occurrences, is(1));\n+                }\n+            }\n+        }\n+    }\n }",
  "logs_path": "factory/glm-4.6/24634b85/elastic_elasticsearch_pr134506/logs.jsonl",
  "errors": [],
  "edit_run_id": "24634b85",
  "test_label": null
}