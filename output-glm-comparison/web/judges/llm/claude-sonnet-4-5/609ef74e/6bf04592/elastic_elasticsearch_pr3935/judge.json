{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 3935,
  "base_commit": "60550e4cc27bd11488540d911081794d69434478",
  "head_commit": "f749db26e86064d52d6e3304d5771d49a8f5ace0",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.3,
    "completeness": -0.7,
    "code_reuse": -0.4,
    "best_practices": -0.2,
    "unsolicited_docs": 1.0
  },
  "aggregate": -0.11999999999999997,
  "rationale": "The agent's implementation has several critical issues: (1) The logic is incorrect - it checks for empty string INSIDE the 'if (awarenessAttributes != null)' block, but getAsArray() returns null for empty strings, so this code path is never reached. Ground truth correctly checks BEFORE the null check. (2) Missing the Strings import that provides EMPTY_ARRAY constant. (3) Uses 'new String[0]' instead of the idiomatic Strings.EMPTY_ARRAY. (4) Adds unnecessary .trim() which wasn't requested and changes behavior. (5) Completely missing the test file changes that verify the feature works. (6) Adds duplicate logic in 4 places when only the onRefreshSettings method needed modification for the API reset feature. (7) Adds unsolicited comments. The ground truth is minimal and correct with only 3 lines added to onRefreshSettings plus comprehensive tests, while the agent adds 28 lines across multiple methods with broken logic.",
  "edit_run_id": "6bf04592",
  "judge_run_id": "609ef74e",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AwarenessAllocationDecider.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AwarenessAllocationDecider.java\nindex 21ab3bbf28c1..08c49da07460 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AwarenessAllocationDecider.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AwarenessAllocationDecider.java\n@@ -26,6 +26,7 @@ import org.elasticsearch.cluster.routing.MutableShardRouting;\n import org.elasticsearch.cluster.routing.RoutingNode;\n import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.settings.ImmutableSettings;\n import org.elasticsearch.common.settings.Settings;\n@@ -88,6 +89,9 @@ public class AwarenessAllocationDecider extends AllocationDecider {\n         @Override\n         public void onRefreshSettings(Settings settings) {\n             String[] awarenessAttributes = settings.getAsArray(CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTES, null);\n+            if (awarenessAttributes == null && \"\".equals(settings.get(CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTES, null))) {\n+                awarenessAttributes = Strings.EMPTY_ARRAY; // the empty string resets this\n+            }\n             if (awarenessAttributes != null) {\n                 logger.info(\"updating [cluster.routing.allocation.awareness.attributes] from [{}] to [{}]\", AwarenessAllocationDecider.this.awarenessAttributes, awarenessAttributes);\n                 AwarenessAllocationDecider.this.awarenessAttributes = awarenessAttributes;\ndiff --git a/src/test/java/org/elasticsearch/cluster/allocation/AwarenessAllocationTests.java b/src/test/java/org/elasticsearch/cluster/allocation/AwarenessAllocationTests.java\nindex 424c029831fe..23f92eaafa14 100644\n--- a/src/test/java/org/elasticsearch/cluster/allocation/AwarenessAllocationTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/allocation/AwarenessAllocationTests.java\n@@ -179,5 +179,52 @@ public class AwarenessAllocationTests extends AbstractIntegrationTest {\n         assertThat(counts.get(A_0), equalTo(5));\n         assertThat(counts.get(B_0), equalTo(3));\n         assertThat(counts.get(B_1), equalTo(2));\n+        \n+        String noZoneNode = cluster().startNode();\n+        health = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().setWaitForNodes(\"4\").execute().actionGet();\n+        assertThat(health.isTimedOut(), equalTo(false));\n+        client().admin().cluster().prepareReroute().get();\n+        health = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().setWaitForNodes(\"4\").setWaitForActiveShards(10).setWaitForRelocatingShards(0).execute().actionGet();\n+\n+        assertThat(health.isTimedOut(), equalTo(false));\n+        clusterState = client().admin().cluster().prepareState().execute().actionGet().getState();\n+\n+        counts = new ObjectIntOpenHashMap<String>();\n+\n+        for (IndexRoutingTable indexRoutingTable : clusterState.routingTable()) {\n+            for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {\n+                for (ShardRouting shardRouting : indexShardRoutingTable) {\n+                    counts.addTo(clusterState.nodes().get(shardRouting.currentNodeId()).name(), 1);\n+                }\n+            }\n+        }\n+        \n+        assertThat(counts.get(A_0), equalTo(5));\n+        assertThat(counts.get(B_0), equalTo(3));\n+        assertThat(counts.get(B_1), equalTo(2));\n+        assertThat(counts.containsKey(noZoneNode), equalTo(false));\n+        client().admin().cluster().prepareUpdateSettings().setTransientSettings(ImmutableSettings.settingsBuilder().put(\"cluster.routing.allocation.awareness.attributes\", \"\").build()).get();\n+        \n+        \n+        client().admin().cluster().prepareReroute().get();\n+        health = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().setWaitForNodes(\"4\").setWaitForActiveShards(10).setWaitForRelocatingShards(0).execute().actionGet();\n+\n+        assertThat(health.isTimedOut(), equalTo(false));\n+        clusterState = client().admin().cluster().prepareState().execute().actionGet().getState();\n+\n+        counts = new ObjectIntOpenHashMap<String>();\n+\n+        for (IndexRoutingTable indexRoutingTable : clusterState.routingTable()) {\n+            for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {\n+                for (ShardRouting shardRouting : indexShardRoutingTable) {\n+                    counts.addTo(clusterState.nodes().get(shardRouting.currentNodeId()).name(), 1);\n+                }\n+            }\n+        }\n+        \n+        assertThat(counts.get(A_0), equalTo(3));\n+        assertThat(counts.get(B_0), equalTo(3));\n+        assertThat(counts.get(B_1), equalTo(2));\n+        assertThat(counts.get(noZoneNode), equalTo(2));\n     }\n }"
}