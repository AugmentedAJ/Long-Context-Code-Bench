{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 1600,
  "base_commit": "ed8a46ce09ccf43adec55af91a72fc9c5dc1ec05",
  "head_commit": "682176497f9f454943d2373dc24501ad37b8dbb0",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.6,
    "completeness": -0.3,
    "code_reuse": -0.4,
    "best_practices": -0.3,
    "unsolicited_docs": 0.8
  },
  "aggregate": -0.15999999999999998,
  "rationale": "The agent's implementation has several critical issues compared to ground truth:\n\n1. **Correctness (-0.6)**: The agent's approach to extracting and handling timestamp/TTL is fundamentally flawed. It tries to extract timestamp from TimestampFieldMapper (which ground truth removes) and incorrectly calculates TTL from an 'expiration timestamp' that doesn't exist in the actual field structure. Ground truth correctly gets TTL from the field, stores getDate for time calculation, and properly handles script context variables (_timestamp, _ttl from ctx). The agent's logic would likely fail at runtime.\n\n2. **Completeness (-0.3)**: Missing critical functionality from ground truth: (a) TimeValue import for parsing TTL strings, (b) extraction of timestamp/TTL from script context (ctx.get(\"_timestamp\"), ctx.get(\"_ttl\")), (c) proper TTL calculation with time delta approximation, (d) handling TTL as both Number and String from script context. The agent added unnecessary UpdateRequest/RestUpdateAction modifications not in ground truth.\n\n3. **Code Reuse (-0.4)**: Agent keeps TimestampFieldMapper import when ground truth removes it (replacing with TTLFieldMapper only). Agent adds entire new API surface (UpdateRequest timestamp/ttl methods, REST parameter handling) that ground truth doesn't include, suggesting overengineering.\n\n4. **Best Practices (-0.3)**: Ground truth uses getDate timestamp and calculates TTL delta to approximate remaining TTL; agent's approach assumes fields contain data they don't. Agent's request-level timestamp/ttl handling adds complexity not needed for the task.\n\n5. **Unsolicited Docs (0.8)**: Agent added javadoc comments to UpdateRequest methods, which weren't requested, but these are minimal compared to README/CHANGELOG additions.",
  "edit_run_id": "6bf04592",
  "judge_run_id": "609ef74e",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\nindex 5a296cdf925f..ae9eea79b9f0 100644\n--- a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\n+++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\n@@ -43,6 +43,7 @@ import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.common.collect.Tuple;\n import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.xcontent.XContentHelper;\n import org.elasticsearch.common.xcontent.XContentType;\n import org.elasticsearch.index.engine.DocumentMissingException;\n@@ -52,7 +53,7 @@ import org.elasticsearch.index.get.GetResult;\n import org.elasticsearch.index.mapper.internal.ParentFieldMapper;\n import org.elasticsearch.index.mapper.internal.RoutingFieldMapper;\n import org.elasticsearch.index.mapper.internal.SourceFieldMapper;\n-import org.elasticsearch.index.mapper.internal.TimestampFieldMapper;\n+import org.elasticsearch.index.mapper.internal.TTLFieldMapper;\n import org.elasticsearch.index.service.IndexService;\n import org.elasticsearch.index.shard.IllegalIndexShardStateException;\n import org.elasticsearch.index.shard.ShardId;\n@@ -152,8 +153,9 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         IndexService indexService = indicesService.indexServiceSafe(request.index());\n         IndexShard indexShard = indexService.shardSafe(request.shardId());\n \n+        long getDate = System.currentTimeMillis();\n         GetResult getResult = indexShard.getService().get(request.type(), request.id(),\n-                new String[]{SourceFieldMapper.NAME, RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TimestampFieldMapper.NAME}, true);\n+                new String[]{SourceFieldMapper.NAME, RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TTLFieldMapper.NAME}, true);\n \n         // no doc, what to do, what to do...\n         if (!getResult.exists()) {\n@@ -183,12 +185,28 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         }\n \n         String operation = (String) ctx.get(\"op\");\n+        String timestamp = (String) ctx.get(\"_timestamp\");\n+        Long ttl = null;\n+        Object fetchedTTL = ctx.get(\"_ttl\");\n+        if (fetchedTTL != null) {\n+            if (fetchedTTL instanceof Number) {\n+                ttl = ((Number) fetchedTTL).longValue();\n+            } else {\n+                ttl = TimeValue.parseTimeValue((String) fetchedTTL, null).millis();\n+            }\n+        }\n         source = (Map<String, Object>) ctx.get(\"_source\");\n \n         // apply script to update the source\n         String routing = getResult.fields().containsKey(RoutingFieldMapper.NAME) ? getResult.field(RoutingFieldMapper.NAME).value().toString() : null;\n         String parent = getResult.fields().containsKey(ParentFieldMapper.NAME) ? getResult.field(ParentFieldMapper.NAME).value().toString() : null;\n-        // TODO ttl/timestamp\n+        // No TTL has been given in the update script so we keep previous TTL value if there is one\n+        if (ttl == null) {\n+            ttl = getResult.fields().containsKey(TTLFieldMapper.NAME) ? (Long) getResult.field(TTLFieldMapper.NAME).value() : null;\n+            if (ttl != null) {\n+                ttl = ttl - (System.currentTimeMillis() - getDate); // It is an approximation of exact TTL value, could be improved\n+            }\n+        }\n \n         // TODO percolate?\n \n@@ -197,7 +215,8 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         if (operation == null || \"index\".equals(operation)) {\n             IndexRequest indexRequest = Requests.indexRequest(request.index()).type(request.type()).id(request.id()).routing(routing).parent(parent)\n                     .source(source, sourceAndContent.v1())\n-                    .version(getResult.version()).replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel());\n+                    .version(getResult.version()).replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel())\n+                    .timestamp(timestamp).ttl(ttl);\n             indexRequest.operationThreaded(false);\n             indexAction.execute(indexRequest, new ActionListener<IndexResponse>() {\n                 @Override"
}