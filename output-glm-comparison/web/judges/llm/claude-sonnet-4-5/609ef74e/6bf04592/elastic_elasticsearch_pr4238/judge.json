{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4238,
  "base_commit": "8e17d636ef441a9be80977d34acfaabc12982eb7",
  "head_commit": "e3d4d73242d215389280b1d7b9facb7b1bd9bd7d",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": 0.0,
    "completeness": -0.9,
    "code_reuse": 0.0,
    "best_practices": 0.0,
    "unsolicited_docs": -0.3
  },
  "aggregate": -0.24,
  "rationale": "The agent correctly identified and fixed the core bug in ThrottlingAllocationDecider.java by adding the `shard.relocatingNodeId() == null` condition to exclude relocating primaries from the recovery count. However, the agent is missing all test files: it did not create the new test file PreferLocalPrimariesToRelocatingPrimariesTests.java (125 lines) and did not add the helper method `startRandomInitializingShard` to RoutingAllocationTests.java. The ground truth includes comprehensive tests to verify the fix works correctly, which are completely absent from the agent's output. The comment style in the agent's diff is more verbose than the ground truth (3 lines vs 2 lines of comments), which goes against the instruction to avoid over-commenting. The agent added unsolicited commentary beyond what was in the ground truth.",
  "edit_run_id": "6bf04592",
  "judge_run_id": "609ef74e",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java\nindex 8af6d8547768..0d556d093f8f 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java\n@@ -82,7 +82,9 @@ public class ThrottlingAllocationDecider extends AllocationDecider {\n                 List<MutableShardRouting> shards = node.shards();\n                 for (int i = 0; i < shards.size(); i++) {\n                     MutableShardRouting shard = shards.get(i);\n-                    if (shard.state() == ShardRoutingState.INITIALIZING && shard.primary()) {\n+                    // when a primary shard is INITIALIZING, it can be because of *initial recovery* or *relocation from another node*\n+                    // we only count initial recoveries here, so we need to make sure that relocating node is null\n+                    if (shard.state() == ShardRoutingState.INITIALIZING && shard.primary() && shard.relocatingNodeId() == null) {\n                         primariesInRecovery++;\n                     }\n                 }\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/PreferLocalPrimariesToRelocatingPrimariesTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/PreferLocalPrimariesToRelocatingPrimariesTests.java\nnew file mode 100644\nindex 000000000000..206fa7bdeaeb\n--- /dev/null\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/PreferLocalPrimariesToRelocatingPrimariesTests.java\n@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to ElasticSearch and Shay Banon under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. ElasticSearch licenses this\n+ * file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.cluster.routing.allocation;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.cluster.routing.MutableShardRouting;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.junit.Test;\n+\n+import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n+import static org.elasticsearch.cluster.routing.allocation.RoutingAllocationTests.newNode;\n+import static org.elasticsearch.cluster.routing.allocation.RoutingAllocationTests.startRandomInitializingShard;\n+import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+/**\n+ */\n+public class PreferLocalPrimariesToRelocatingPrimariesTests extends ElasticsearchTestCase {\n+    @Test\n+    public void testPreferLocalPrimaryAllocationOverFiltered() {\n+        int concurrentRecoveries = randomIntBetween(1, 10);\n+        int primaryRecoveries = randomIntBetween(1, 10);\n+        int numberOfShards = randomIntBetween(5, 20);\n+        int totalNumberOfShards = numberOfShards * 2;\n+\n+        logger.info(\"create an allocation with [{}] initial primary recoveries and [{}] concurrent recoveries\", primaryRecoveries, concurrentRecoveries);\n+        AllocationService strategy = new AllocationService(settingsBuilder()\n+                .put(\"cluster.routing.allocation.node_concurrent_recoveries\", concurrentRecoveries)\n+                .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", primaryRecoveries)\n+                .build());\n+\n+        logger.info(\"create 2 indices with [{}] no replicas, and wait till all are allocated\", numberOfShards);\n+\n+        MetaData metaData = MetaData.builder()\n+                .put(IndexMetaData.builder(\"test1\").numberOfShards(numberOfShards).numberOfReplicas(0))\n+                .put(IndexMetaData.builder(\"test2\").numberOfShards(numberOfShards).numberOfReplicas(0))\n+                .build();\n+\n+        RoutingTable routingTable = RoutingTable.builder()\n+                .addAsNew(metaData.index(\"test1\"))\n+                .addAsNew(metaData.index(\"test2\"))\n+                .build();\n+\n+        ClusterState clusterState = ClusterState.builder().metaData(metaData).routingTable(routingTable).build();\n+\n+        logger.info(\"adding two nodes and performing rerouting till all are allocated\");\n+        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder()\n+                .put(newNode(\"node1\", ImmutableMap.of(\"tag1\", \"value1\")))\n+                .put(newNode(\"node2\", ImmutableMap.of(\"tag1\", \"value2\")))).build();\n+\n+        routingTable = strategy.reroute(clusterState).routingTable();\n+        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n+\n+        while (!clusterState.routingNodes().shardsWithState(INITIALIZING).isEmpty()) {\n+            routingTable = strategy.applyStartedShards(clusterState, clusterState.routingNodes().shardsWithState(INITIALIZING)).routingTable();\n+            clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n+        }\n+\n+        logger.info(\"remove one of the nodes and apply filter to move everything from another node\");\n+\n+        metaData = MetaData.builder()\n+                .put(IndexMetaData.builder(\"test1\").settings(settingsBuilder()\n+                        .put(\"index.number_of_shards\", numberOfShards)\n+                        .put(\"index.number_of_replicas\", 0)\n+                        .put(\"index.routing.allocation.exclude.tag1\", \"value2\")\n+                        .build()))\n+                .put(IndexMetaData.builder(\"test2\").settings(settingsBuilder()\n+                        .put(\"index.number_of_shards\", numberOfShards)\n+                        .put(\"index.number_of_replicas\", 0)\n+                        .put(\"index.routing.allocation.exclude.tag1\", \"value2\")\n+                        .build()))\n+                .build();\n+        clusterState = ClusterState.builder(clusterState).metaData(metaData).nodes(DiscoveryNodes.builder(clusterState.nodes()).remove(\"node1\")).build();\n+        routingTable = strategy.reroute(clusterState).routingTable();\n+        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n+\n+        logger.info(\"[{}] primaries should be still started but [{}] other primaries should be unassigned\", numberOfShards, numberOfShards);\n+        assertThat(clusterState.routingNodes().shardsWithState(STARTED).size(), equalTo(numberOfShards));\n+        assertThat(clusterState.routingNodes().shardsWithState(INITIALIZING).size(), equalTo(0));\n+        assertThat(clusterState.routingTable().shardsWithState(UNASSIGNED).size(), equalTo(numberOfShards));\n+\n+        logger.info(\"start node back up\");\n+        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n+                .put(newNode(\"node1\", ImmutableMap.of(\"tag1\", \"value1\")))).build();\n+        routingTable = strategy.reroute(clusterState).routingTable();\n+        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n+\n+        while (clusterState.routingNodes().shardsWithState(STARTED).size() < totalNumberOfShards) {\n+            int localInitializations = 0;\n+            int relocatingInitializations = 0;\n+            for (MutableShardRouting routing : clusterState.routingNodes().shardsWithState(INITIALIZING)) {\n+                if (routing.relocatingNodeId() == null) {\n+                    localInitializations++;\n+                } else {\n+                    relocatingInitializations++;\n+                }\n+            }\n+            int needToInitialize = totalNumberOfShards - clusterState.routingNodes().shardsWithState(STARTED).size() - clusterState.routingNodes().shardsWithState(RELOCATING).size();\n+            logger.info(\"local initializations: [{}], relocating: [{}], need to initialize: {}\", localInitializations, relocatingInitializations, needToInitialize);\n+            assertThat(localInitializations, equalTo(Math.min(primaryRecoveries, needToInitialize)));\n+            clusterState = startRandomInitializingShard(clusterState, strategy);\n+        }\n+    }\n+}\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocationTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocationTests.java\nindex c55cf1450203..f972a39dc95b 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocationTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocationTests.java\n@@ -20,14 +20,21 @@\n package org.elasticsearch.cluster.routing.allocation;\n \n import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.MutableShardRouting;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.transport.DummyTransportAddress;\n import org.elasticsearch.common.transport.TransportAddress;\n import org.elasticsearch.test.ElasticsearchTestCase;\n import org.junit.Ignore;\n \n+import java.util.List;\n import java.util.Map;\n \n+import static com.google.common.collect.Lists.newArrayList;\n+import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;\n+\n @Ignore(\"Not a test\")\n public class RoutingAllocationTests extends ElasticsearchTestCase {\n \n@@ -42,4 +49,14 @@ public class RoutingAllocationTests extends ElasticsearchTestCase {\n     public static DiscoveryNode newNode(String nodeId, Map<String, String> attributes) {\n         return new DiscoveryNode(\"\", nodeId, DummyTransportAddress.INSTANCE, attributes, Version.CURRENT);\n     }\n+\n+    public static ClusterState startRandomInitializingShard(ClusterState clusterState, AllocationService strategy) {\n+        List<MutableShardRouting> initializingShards = clusterState.routingNodes().shardsWithState(INITIALIZING);\n+        if (initializingShards.isEmpty()) {\n+            return clusterState;\n+        }\n+        RoutingTable routingTable = strategy.applyStartedShards(clusterState, newArrayList(initializingShards.get(randomInt(initializingShards.size() - 1)))).routingTable();\n+        return ClusterState.builder(clusterState).routingTable(routingTable).build();\n+    }\n+\n }\n\\ No newline at end of file"
}