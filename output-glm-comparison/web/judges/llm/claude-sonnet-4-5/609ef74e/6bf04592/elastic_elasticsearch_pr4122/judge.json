{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4122,
  "base_commit": "6f286c338207f2a333294e9e576d0f1319981148",
  "head_commit": "4aa59aff0058b05e822592431eda4a469a6b9eef",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.8,
    "completeness": -0.9,
    "code_reuse": -0.5,
    "best_practices": -0.6,
    "unsolicited_docs": 0.0
  },
  "aggregate": -0.56,
  "rationale": "The agent's solution attempts to fix the postings highlighter external query issue but takes a fundamentally different and inferior approach compared to ground truth. Ground truth introduces a HighlightQuery wrapper class to track original/rewritten queries and propagates this throughout the highlighting infrastructure (HighlighterContext, FastVectorHighlighter, PlainHighlighter, PostingsHighlighter), fixing the issue comprehensively for all highlighters. The agent only patches PostingsHighlighter using cache key differentiation based on query hashCode, which is fragile (hashCode collisions), doesn't fix FastVectorHighlighter (which also needs the fix per ground truth), and doesn't properly handle the rewrite logic. The agent also made unsolicited changes to pom.xml upgrading Java from 1.6 to 1.8, which is completely unrelated to the task. The test changes are minimal compared to ground truth's comprehensive test updates. The approach is hacky (string concatenation with hashCode) versus ground truth's proper architectural solution with a dedicated data structure.",
  "edit_run_id": "6bf04592",
  "judge_run_id": "609ef74e",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/search/highlight/FastVectorHighlighter.java b/src/main/java/org/elasticsearch/search/highlight/FastVectorHighlighter.java\nindex 1c0fe824079d..3342388ff72e 100644\n--- a/src/main/java/org/elasticsearch/search/highlight/FastVectorHighlighter.java\n+++ b/src/main/java/org/elasticsearch/search/highlight/FastVectorHighlighter.java\n@@ -80,13 +80,13 @@ public class FastVectorHighlighter implements Highlighter {\n             if (field.requireFieldMatch()) {\n                 if (cache.fieldMatchFieldQuery == null) {\n                     // we use top level reader to rewrite the query against all readers, with use caching it across hits (and across readers...)\n-                    cache.fieldMatchFieldQuery = new CustomFieldQuery(highlighterContext.highlightQuery, hitContext.topLevelReader(), true, field.requireFieldMatch());\n+                    cache.fieldMatchFieldQuery = new CustomFieldQuery(highlighterContext.query.originalQuery(), hitContext.topLevelReader(), true, field.requireFieldMatch());\n                 }\n                 fieldQuery = cache.fieldMatchFieldQuery;\n             } else {\n                 if (cache.noFieldMatchFieldQuery == null) {\n                     // we use top level reader to rewrite the query against all readers, with use caching it across hits (and across readers...)\n-                    cache.noFieldMatchFieldQuery = new CustomFieldQuery(highlighterContext.highlightQuery, hitContext.topLevelReader(), true, field.requireFieldMatch());\n+                    cache.noFieldMatchFieldQuery = new CustomFieldQuery(highlighterContext.query.originalQuery(), hitContext.topLevelReader(), true, field.requireFieldMatch());\n                 }\n                 fieldQuery = cache.noFieldMatchFieldQuery;\n             }\ndiff --git a/src/main/java/org/elasticsearch/search/highlight/HighlightPhase.java b/src/main/java/org/elasticsearch/search/highlight/HighlightPhase.java\nindex a580770d27a0..8804733a7fea 100644\n--- a/src/main/java/org/elasticsearch/search/highlight/HighlightPhase.java\n+++ b/src/main/java/org/elasticsearch/search/highlight/HighlightPhase.java\n@@ -21,7 +21,6 @@ package org.elasticsearch.search.highlight;\n \n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n-import org.apache.lucene.search.Query;\n import org.apache.lucene.index.FieldInfo;\n import org.elasticsearch.ElasticSearchException;\n import org.elasticsearch.ElasticSearchIllegalArgumentException;\n@@ -108,11 +107,11 @@ public class HighlightPhase extends AbstractComponent implements FetchSubPhase {\n                     throw new ElasticSearchIllegalArgumentException(\"unknown highlighter type [\" + field.highlighterType() + \"] for the field [\" + fieldName + \"]\");\n                 }\n \n-                Query highlightQuery = field.highlightQuery();\n-                if (highlightQuery == null) {\n-                    // Don't use the context.query() since it might be rewritten, and we need to pass the non rewritten queries to\n-                    // let the highlighter handle MultiTerm ones\n-                    highlightQuery = context.parsedQuery().query();\n+                HighlighterContext.HighlightQuery highlightQuery;\n+                if (field.highlightQuery() == null) {\n+                    highlightQuery = new HighlighterContext.HighlightQuery(context.parsedQuery().query(), context.query(), context.queryRewritten());\n+                } else {\n+                    highlightQuery = new HighlighterContext.HighlightQuery(field.highlightQuery(), field.highlightQuery(), false);\n                 }\n                 HighlighterContext highlighterContext = new HighlighterContext(fieldName, field, fieldMapper, context, hitContext, highlightQuery);\n                 HighlightField highlightField = highlighter.highlight(highlighterContext);\ndiff --git a/src/main/java/org/elasticsearch/search/highlight/HighlighterContext.java b/src/main/java/org/elasticsearch/search/highlight/HighlighterContext.java\nindex b1d39210d535..344f8b5c8139 100644\n--- a/src/main/java/org/elasticsearch/search/highlight/HighlighterContext.java\n+++ b/src/main/java/org/elasticsearch/search/highlight/HighlighterContext.java\n@@ -33,15 +33,39 @@ public class HighlighterContext {\n     public final FieldMapper<?> mapper;\n     public final SearchContext context;\n     public final FetchSubPhase.HitContext hitContext;\n-    public final Query highlightQuery;\n+    public final HighlightQuery query;\n \n     public HighlighterContext(String fieldName, SearchContextHighlight.Field field, FieldMapper<?> mapper, SearchContext context,\n-            FetchSubPhase.HitContext hitContext, Query highlightQuery) {\n+            FetchSubPhase.HitContext hitContext, HighlightQuery query) {\n         this.fieldName = fieldName;\n         this.field = field;\n         this.mapper = mapper;\n         this.context = context;\n         this.hitContext = hitContext;\n-        this.highlightQuery = highlightQuery;\n+        this.query = query;\n+    }\n+\n+    static class HighlightQuery {\n+        private final Query originalQuery;\n+        private final Query query;\n+        private final boolean queryRewritten;\n+\n+        HighlightQuery(Query originalQuery, Query query, boolean queryRewritten) {\n+            this.originalQuery = originalQuery;\n+            this.query = query;\n+            this.queryRewritten = queryRewritten;\n+        }\n+\n+        public boolean queryRewritten() {\n+            return queryRewritten;\n+        }\n+\n+        public Query originalQuery() {\n+            return originalQuery;\n+        }\n+\n+        public Query query() {\n+            return query;\n+        }\n     }\n }\ndiff --git a/src/main/java/org/elasticsearch/search/highlight/PlainHighlighter.java b/src/main/java/org/elasticsearch/search/highlight/PlainHighlighter.java\nindex 4a3ee6cc045a..f6596f4a1a3f 100644\n--- a/src/main/java/org/elasticsearch/search/highlight/PlainHighlighter.java\n+++ b/src/main/java/org/elasticsearch/search/highlight/PlainHighlighter.java\n@@ -68,7 +68,7 @@ public class PlainHighlighter implements Highlighter {\n \n         org.apache.lucene.search.highlight.Highlighter entry = cache.get(mapper);\n         if (entry == null) {\n-            Query query = highlighterContext.highlightQuery;\n+            Query query = highlighterContext.query.originalQuery();\n             QueryScorer queryScorer = new CustomQueryScorer(query, field.requireFieldMatch() ? mapper.names().indexName() : null);\n             queryScorer.setExpandMultiTermQuery(true);\n             Fragmenter fragmenter;\ndiff --git a/src/main/java/org/elasticsearch/search/highlight/PostingsHighlighter.java b/src/main/java/org/elasticsearch/search/highlight/PostingsHighlighter.java\nindex 796cf886fa4e..b45f8b560a17 100644\n--- a/src/main/java/org/elasticsearch/search/highlight/PostingsHighlighter.java\n+++ b/src/main/java/org/elasticsearch/search/highlight/PostingsHighlighter.java\n@@ -71,7 +71,7 @@ public class PostingsHighlighter implements Highlighter {\n             //get the non rewritten query and rewrite it\n             Query query;\n             try {\n-                query = rewrite(context, hitContext.topLevelReader());\n+                query = rewrite(highlighterContext, hitContext.topLevelReader());\n             } catch (IOException e) {\n                 throw new FetchPhaseExecutionException(context, \"Failed to highlight field [\" + highlighterContext.fieldName + \"]\", e);\n             }\n@@ -146,11 +146,11 @@ public class PostingsHighlighter implements Highlighter {\n         return null;\n     }\n \n-    private static Query rewrite(SearchContext searchContext, IndexReader reader) throws IOException {\n+    private static Query rewrite(HighlighterContext highlighterContext, IndexReader reader) throws IOException {\n         //rewrite is expensive: if the query was already rewritten we try not to rewrite\n-        boolean mustRewrite = !searchContext.queryRewritten();\n+        boolean mustRewrite = !highlighterContext.query.queryRewritten();\n \n-        Query original = searchContext.parsedQuery().query();\n+        Query original = highlighterContext.query.originalQuery();\n \n         MultiTermQuery originalMultiTermQuery = null;\n         MultiTermQuery.RewriteMethod originalRewriteMethod = null;\n@@ -166,7 +166,7 @@ public class PostingsHighlighter implements Highlighter {\n \n         if (!mustRewrite) {\n             //return the rewritten query\n-            return searchContext.query();\n+            return highlighterContext.query.query();\n         }\n \n         Query query = original;\ndiff --git a/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java b/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java\nindex f0356d022c80..5f71a375d270 100644\n--- a/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java\n+++ b/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java\n@@ -1301,55 +1301,57 @@ public class HighlighterSearchTests extends AbstractIntegrationTest {\n     @Test\n     public void testHighlightUsesHighlightQuery() throws IOException {\n         assertAcked(prepareCreate(\"test\")\n-                .addMapping(\"type1\", \"text\", \"type=string,store=yes,term_vector=with_positions_offsets\"));\n+                .addMapping(\"type1\", \"text\", \"type=string,\" + randomStoreField() + \"term_vector=with_positions_offsets,index_options=offsets\"));\n         ensureGreen();\n \n-        index(\"test\", \"type1\", \"1\", \"text\", \"some stuff stuff stuff stuff stuff to highlight against the stuff phrase\");\n+        index(\"test\", \"type1\", \"1\", \"text\", \"Testing the highlight query feature\");\n         refresh();\n \n-        // Make sure the fvh doesn't highlight in the same way as we're going to do with a scoreQuery because\n-        // that would invalidate the test results.\n-        Matcher<String> highlightedMatcher = anyOf(\n-                containsString(\"<em>stuff phrase</em>\"),            //t FHV normally does this\n-                containsString(\"<em>stuff</em> <em>phrase</em>\"));  // Plain normally does this\n-        HighlightBuilder.Field field = new HighlightBuilder.Field(\"text\")\n-                .fragmentSize(20)\n-                .numOfFragments(1)\n-                .highlighterType(\"fvh\");\n-        SearchRequestBuilder search = client().prepareSearch(\"test\")\n-                .setQuery(QueryBuilders.matchQuery(\"text\", \"stuff\"))\n-                .setHighlighterOrder(\"score\")\n+        HighlightBuilder.Field field = new HighlightBuilder.Field(\"text\");\n+\n+        SearchRequestBuilder search = client().prepareSearch(\"test\").setQuery(QueryBuilders.matchQuery(\"text\", \"testing\"))\n                 .addHighlightedField(field);\n-        SearchResponse response = search.get();\n-        assertHighlight(response, 0, \"text\", 0, not(highlightedMatcher));\n+        Matcher<String> searchQueryMatcher = equalTo(\"<em>Testing</em> the highlight query feature\");\n \n-        // And do the same for the plain highlighter\n         field.highlighterType(\"plain\");\n+        SearchResponse response = search.get();\n+        assertHighlight(response, 0, \"text\", 0, searchQueryMatcher);\n+        field.highlighterType(\"fvh\");\n+        response = search.get();\n+        assertHighlight(response, 0, \"text\", 0, searchQueryMatcher);\n+        field.highlighterType(\"postings\");\n         response = search.get();\n-        assertHighlight(response, 0, \"text\", 0, not(highlightedMatcher));\n+        assertHighlight(response, 0, \"text\", 0, searchQueryMatcher);\n \n-        // Make sure the fvh takes the highlightQuery into account\n-        field.highlighterType(\"fvh\").highlightQuery(matchPhraseQuery(\"text\", \"stuff phrase\"));\n+\n+        Matcher<String> hlQueryMatcher = equalTo(\"Testing the highlight <em>query</em> feature\");\n+        field.highlightQuery(matchQuery(\"text\", \"query\"));\n+\n+        field.highlighterType(\"fvh\");\n         response = search.get();\n-        assertHighlight(response, 0, \"text\", 0, highlightedMatcher);\n+        assertHighlight(response, 0, \"text\", 0, hlQueryMatcher);\n \n-        // And do the same for the plain highlighter\n         field.highlighterType(\"plain\");\n         response = search.get();\n-        assertHighlight(response, 0, \"text\", 0, highlightedMatcher);\n-        // Note that the plain highlighter doesn't join the highlighted elements for us\n+        assertHighlight(response, 0, \"text\", 0, hlQueryMatcher);\n \n-        // Make sure the fvh takes the highlightQuery into account when it is set on the highlight context instead of the field\n-        search.setHighlighterQuery(matchPhraseQuery(\"text\", \"stuff phrase\"));\n+        field.highlighterType(\"postings\");\n+        response = search.get();\n+        assertHighlight(response, 0, \"text\", 0, hlQueryMatcher);\n+\n+        // Make sure the the highlightQuery is taken into account when it is set on the highlight context instead of the field\n+        search.setHighlighterQuery(matchQuery(\"text\", \"query\"));\n         field.highlighterType(\"fvh\").highlightQuery(null);\n         response = search.get();\n-        assertHighlight(response, 0, \"text\", 0, highlightedMatcher);\n+        assertHighlight(response, 0, \"text\", 0, hlQueryMatcher);\n \n-        // And do the same for the plain highlighter\n         field.highlighterType(\"plain\");\n         response = search.get();\n-        assertHighlight(response, 0, \"text\", 0, highlightedMatcher);\n-        // Note that the plain highlighter doesn't join the highlighted elements for us\n+        assertHighlight(response, 0, \"text\", 0, hlQueryMatcher);\n+\n+        field.highlighterType(\"postings\");\n+        response = search.get();\n+        assertHighlight(response, 0, \"text\", 0, hlQueryMatcher);\n     }\n \n     private static String randomStoreField() {"
}