{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 1587,
  "base_commit": "df4a3bfd379fd90b3667bbcd7ca2ed4619fee025",
  "head_commit": "d95aa9f266ccecf33894c88af329895c1693cd14",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": 0.3,
    "completeness": 0.5,
    "code_reuse": 0.0,
    "best_practices": 0.2,
    "unsolicited_docs": 1.0
  },
  "aggregate": 0.4,
  "rationale": "The agent correctly identified the need to enhance TTL tests with routing functionality and added three comprehensive test methods (testTTLWithCustomRouting, testTTLWithSameRoutingMultipleDocuments, testTTLWithMixedRouting) that thoroughly test routing scenarios across multiple shards. However, the agent completely missed the ground truth's primary changes to the existing testSimpleTTL method, which modifies the settings to add 2 shards with specific routing configuration and adds a second indexed document with routing to the existing test. The agent also missed entirely the FiltersFunctionScoreQuery.java changes (though these appear unrelated to the TTL routing task). The agent's approach creates new comprehensive tests rather than enhancing the existing test as the ground truth shows. While the new tests are well-structured and follow best practices with proper logging, assertions, and coverage of edge cases, they represent a different interpretation of 'enhance ttl tests' - adding new tests vs. modifying the existing one. The agent's tests use more modern settings (.put() chains) and are more thorough in testing various routing scenarios, but they don't match the minimal, targeted enhancement shown in the ground truth.",
  "edit_run_id": "6bf04592",
  "judge_run_id": "609ef74e",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java b/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java\nindex 6a8d0c8b68ab..43263a466a7b 100644\n--- a/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java\n+++ b/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java\n@@ -165,7 +165,7 @@ public class FiltersFunctionScoreQuery extends Query {\n                     if (docSet.get(doc)) {\n                         filterFunction.function.setNextReader(reader);\n                         Explanation functionExplanation = filterFunction.function.explainFactor(doc);\n-                        float sc = getValue() * subQueryExpl.getValue() * functionExplanation.getValue();\n+                        float sc = getValue() * functionExplanation.getValue();\n                         Explanation res = new ComplexExplanation(true, sc, \"custom score, product of:\");\n                         res.addDetail(new Explanation(1.0f, \"match filter: \" + filterFunction.filter.toString()));\n                         res.addDetail(functionExplanation);\n@@ -185,13 +185,13 @@ public class FiltersFunctionScoreQuery extends Query {\n                     if (docSet.get(doc)) {\n                         filterFunction.function.setNextReader(reader);\n                         Explanation functionExplanation = filterFunction.function.explainFactor(doc);\n-                        float factor = functionExplanation.getValue();\n+                        float sc = functionExplanation.getValue();\n                         count++;\n-                        total += factor;\n-                        multiply *= factor;\n-                        max = Math.max(factor, max);\n-                        min = Math.min(factor, min);\n-                        Explanation res = new ComplexExplanation(true, factor, \"custom score, product of:\");\n+                        total += sc;\n+                        multiply *= sc;\n+                        max = Math.max(sc, max);\n+                        min = Math.min(sc, min);\n+                        Explanation res = new ComplexExplanation(true, sc, \"custom score, product of:\");\n                         res.addDetail(new Explanation(1.0f, \"match filter: \" + filterFunction.filter.toString()));\n                         res.addDetail(functionExplanation);\n                         res.addDetail(new Explanation(getValue(), \"queryBoost\"));\n@@ -199,26 +199,25 @@ public class FiltersFunctionScoreQuery extends Query {\n                     }\n                 }\n                 if (count > 0) {\n-                    float factor = 0;\n+                    float sc = 0;\n                     switch (scoreMode) {\n                         case Avg:\n-                            factor = total / count;\n+                            sc = total / count;\n                             break;\n                         case Max:\n-                            factor = max;\n+                            sc = max;\n                             break;\n                         case Min:\n-                            factor = min;\n+                            sc = min;\n                             break;\n                         case Total:\n-                            factor = total;\n+                            sc = total;\n                             break;\n                         case Multiply:\n-                            factor = multiply;\n+                            sc = multiply;\n                             break;\n                     }\n-\n-                    float sc = factor * subQueryExpl.getValue() * getValue();\n+                    sc *= getValue();\n                     Explanation res = new ComplexExplanation(true, sc, \"custom score, score mode [\" + scoreMode.toString().toLowerCase() + \"]\");\n                     res.addDetail(subQueryExpl);\n                     for (Explanation explanation : filtersExplanations) {\ndiff --git a/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java b/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java\nindex 89f4ab78fe1c..3b8f00c041b3 100644\n--- a/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java\n+++ b/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java\n@@ -39,7 +39,12 @@ public class SimpleTTLTests extends AbstractNodesTests {\n \n     @BeforeClass\n     public void createNodes() throws Exception {\n-        Settings settings = settingsBuilder().put(\"indices.ttl.interval\", purgeInterval).build();\n+        Settings settings = settingsBuilder()\n+                .put(\"indices.ttl.interval\", purgeInterval)\n+                .put(\"index.number_of_shards\", 2) // 2 shards to test TTL purge with routing properly\n+                .put(\"cluster.routing.operation.use_type\", false) // make sure we control the shard computation\n+                .put(\"cluster.routing.operation.hash.type\", \"djb\")\n+                .build();\n         startNode(\"node1\", settings);\n         startNode(\"node2\", settings);\n         client = getClient();\n@@ -71,7 +76,9 @@ public class SimpleTTLTests extends AbstractNodesTests {\n         client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n         long providedTTLValue = 3000;\n         logger.info(\"--> checking ttl\");\n+        // Index one doc without routing and one doc with routing\n         client.prepareIndex(\"test\", \"type1\", \"1\").setSource(\"field1\", \"value1\").setTTL(providedTTLValue).setRefresh(true).execute().actionGet();\n+        client.prepareIndex(\"test\", \"type1\", \"with_routing\").setSource(\"field1\", \"value1\").setTTL(providedTTLValue).setRouting(\"routing\").setRefresh(true).execute().actionGet();\n         long now = System.currentTimeMillis();\n \n         // realtime get check\n@@ -100,7 +107,7 @@ public class SimpleTTLTests extends AbstractNodesTests {\n         assertThat(ttl0, lessThan(providedTTLValue - (now1 - now)));\n \n         logger.info(\"--> checking purger\");\n-        // make sure the purger has done its job\n+        // make sure the purger has done its job for all indexed docs that are expired\n         long shouldBeExpiredDate = now + providedTTLValue + purgeInterval + 2000;\n         now1 = System.currentTimeMillis();\n         if (shouldBeExpiredDate - now1 > 0) {\n@@ -109,14 +116,22 @@ public class SimpleTTLTests extends AbstractNodesTests {\n         // realtime get check\n         getResponse = client.prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n         assertThat(getResponse.exists(), equalTo(false));\n+        getResponse = client.prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n+        assertThat(getResponse.exists(), equalTo(false));\n         // replica realtime get check\n         getResponse = client.prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n         assertThat(getResponse.exists(), equalTo(false));\n+        getResponse = client.prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n+        assertThat(getResponse.exists(), equalTo(false));\n         // non realtime get (stored) check\n         getResponse = client.prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n         assertThat(getResponse.exists(), equalTo(false));\n+        getResponse = client.prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n+        assertThat(getResponse.exists(), equalTo(false));\n         // non realtime get going the replica check\n         getResponse = client.prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n         assertThat(getResponse.exists(), equalTo(false));\n+        getResponse = client.prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n+        assertThat(getResponse.exists(), equalTo(false));\n     }\n }"
}