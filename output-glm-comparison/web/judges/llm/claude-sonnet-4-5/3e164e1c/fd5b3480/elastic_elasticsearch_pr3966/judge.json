{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 3966,
  "base_commit": "c9dab6991eff5c01c7b0c36aecaf0f061267e030",
  "head_commit": "ec0880df4520366f2d81e9e1153c38d9726c5e5d",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.7,
    "completeness": -0.8,
    "code_reuse": -0.5,
    "best_practices": -0.3,
    "unsolicited_docs": 1.0
  },
  "aggregate": -0.25999999999999995,
  "rationale": "The agent's implementation is fundamentally incomplete and takes a different architectural approach than the ground truth. Critical missing elements: (1) No PreBuiltAnalyzers enum was created - the ground truth creates a new file PreBuiltAnalyzers.java with sophisticated version-aware caching logic using enum values, but the agent keeps everything inline. (2) Missing MetaDataCreateIndexService.java changes that prevent overwriting SETTING_VERSION_CREATED. (3) Missing AnalysisModule.java comment fix and whitespace cleanup. (4) Missing all test files (PreBuiltAnalyzerIntegrationTests.java, PreBuiltAnalyzerTests.java, PreBuiltAnalyzerProviderFactoryTests.java, AnalysisModuleTests.java changes). (5) Missing MapperTestUtils.java changes. The agent's approach uses inline AnalyzerFactory interfaces instead of a centralized enum-based system with proper caching strategies (ONE, LUCENE, ELASTICSEARCH). While the agent does modify AnalysisService.java to extract version and pass it through settings (similar intent to ground truth), and modifies PreBuiltAnalyzerProviderFactory to support version-aware creation, the implementation is less elegant with concurrent maps instead of the ground truth's enum-based caching. The IndicesAnalysisService changes wrap all analyzers in anonymous AnalyzerFactory implementations but lack the sophistication of the PreBuiltAnalyzers enum. The agent's solution might partially work but misses the core architectural pattern (enum-based versioning), critical index creation logic, and all tests that validate the feature works correctly.",
  "edit_run_id": "fd5b3480",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\nindex b8736c1e859..6f2c6c7d99a 100644\n--- a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\n+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\n@@ -252,7 +252,9 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n                         indexSettingsBuilder.put(SETTING_AUTO_EXPAND_REPLICAS, settings.get(SETTING_AUTO_EXPAND_REPLICAS));\n                     }\n \n-                    indexSettingsBuilder.put(SETTING_VERSION_CREATED, version);\n+                    if (indexSettingsBuilder.get(SETTING_VERSION_CREATED) == null) {\n+                        indexSettingsBuilder.put(SETTING_VERSION_CREATED, version);\n+                    }\n                     indexSettingsBuilder.put(SETTING_UUID, Strings.randomBase64UUID());\n \n                     Settings actualIndexSettings = indexSettingsBuilder.build();\ndiff --git a/src/main/java/org/elasticsearch/index/analysis/AnalysisModule.java b/src/main/java/org/elasticsearch/index/analysis/AnalysisModule.java\nindex 19024adc61c..e4d77e40da6 100644\n--- a/src/main/java/org/elasticsearch/index/analysis/AnalysisModule.java\n+++ b/src/main/java/org/elasticsearch/index/analysis/AnalysisModule.java\n@@ -387,7 +387,7 @@ public class AnalysisModule extends AbstractModule {\n         }\n \n \n-        // go over the tokenizers in the bindings and register the ones that are not configured\n+        // go over the analyzers in the bindings and register the ones that are not configured\n         for (Map.Entry<String, Class<? extends AnalyzerProvider>> entry : analyzersBindings.analyzers.entrySet()) {\n             String analyzerName = entry.getKey();\n             Class<? extends AnalyzerProvider> clazz = entry.getValue();\n@@ -408,7 +408,6 @@ public class AnalysisModule extends AbstractModule {\n             }\n         }\n \n-\n         bind(AnalysisService.class).in(Scopes.SINGLETON);\n     }\n \ndiff --git a/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java b/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java\nindex 7698020778c..3cd8aad910e 100644\n--- a/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java\n+++ b/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java\n@@ -22,6 +22,8 @@ package org.elasticsearch.index.analysis;\n import com.google.common.collect.ImmutableMap;\n import org.apache.lucene.analysis.Analyzer;\n import org.elasticsearch.ElasticSearchIllegalArgumentException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.Nullable;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.component.CloseableComponent;\n@@ -188,14 +190,13 @@ public class AnalysisService extends AbstractIndexComponent implements Closeable\n         if (indicesAnalysisService != null) {\n             for (Map.Entry<String, PreBuiltAnalyzerProviderFactory> entry : indicesAnalysisService.analyzerProviderFactories().entrySet()) {\n                 String name = entry.getKey();\n+                Version indexVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT);\n                 if (!analyzerProviders.containsKey(name)) {\n-                    analyzerProviders.put(name, entry.getValue().create(name, ImmutableSettings.Builder.EMPTY_SETTINGS));\n+                    analyzerProviders.put(name, entry.getValue().create(name, ImmutableSettings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, indexVersion).build()));\n                 }\n-                name = Strings.toCamelCase(entry.getKey());\n-                if (!name.equals(entry.getKey())) {\n-                    if (!analyzerProviders.containsKey(name)) {\n-                        analyzerProviders.put(name, entry.getValue().create(name, ImmutableSettings.Builder.EMPTY_SETTINGS));\n-                    }\n+                String camelCaseName = Strings.toCamelCase(name);\n+                if (!camelCaseName.equals(entry.getKey()) && !analyzerProviders.containsKey(camelCaseName)) {\n+                    analyzerProviders.put(camelCaseName, entry.getValue().create(name, ImmutableSettings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, indexVersion).build()));\n                 }\n             }\n         }\ndiff --git a/src/main/java/org/elasticsearch/index/analysis/PreBuiltAnalyzerProviderFactory.java b/src/main/java/org/elasticsearch/index/analysis/PreBuiltAnalyzerProviderFactory.java\nindex 1cf698d3e60..224e89b3d47 100644\n--- a/src/main/java/org/elasticsearch/index/analysis/PreBuiltAnalyzerProviderFactory.java\n+++ b/src/main/java/org/elasticsearch/index/analysis/PreBuiltAnalyzerProviderFactory.java\n@@ -20,7 +20,12 @@\n package org.elasticsearch.index.analysis;\n \n import org.apache.lucene.analysis.Analyzer;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.indices.analysis.PreBuiltAnalyzers;\n+\n+import java.util.Locale;\n \n /**\n  *\n@@ -30,15 +35,17 @@ public class PreBuiltAnalyzerProviderFactory implements AnalyzerProviderFactory\n     private final PreBuiltAnalyzerProvider analyzerProvider;\n \n     public PreBuiltAnalyzerProviderFactory(String name, AnalyzerScope scope, Analyzer analyzer) {\n-        this(new PreBuiltAnalyzerProvider(name, scope, analyzer));\n-    }\n-\n-    public PreBuiltAnalyzerProviderFactory(PreBuiltAnalyzerProvider analyzerProvider) {\n-        this.analyzerProvider = analyzerProvider;\n+        analyzerProvider = new PreBuiltAnalyzerProvider(name, scope, analyzer);\n     }\n \n     @Override\n     public AnalyzerProvider create(String name, Settings settings) {\n+        Version indexVersion = settings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT);\n+        if (!Version.CURRENT.equals(indexVersion)) {\n+            Analyzer analyzer = PreBuiltAnalyzers.valueOf(name.toUpperCase(Locale.ROOT)).getAnalyzer(indexVersion);\n+            return new PreBuiltAnalyzerProvider(name, AnalyzerScope.INDICES, analyzer);\n+        }\n+\n         return analyzerProvider;\n     }\n \ndiff --git a/src/main/java/org/elasticsearch/indices/analysis/IndicesAnalysisService.java b/src/main/java/org/elasticsearch/indices/analysis/IndicesAnalysisService.java\nindex 6b527556143..e62fc9d0dc6 100644\n--- a/src/main/java/org/elasticsearch/indices/analysis/IndicesAnalysisService.java\n+++ b/src/main/java/org/elasticsearch/indices/analysis/IndicesAnalysisService.java\n@@ -22,66 +22,34 @@ package org.elasticsearch.indices.analysis;\n import org.apache.lucene.analysis.Analyzer;\n import org.apache.lucene.analysis.TokenStream;\n import org.apache.lucene.analysis.Tokenizer;\n-import org.apache.lucene.analysis.ar.ArabicAnalyzer;\n import org.apache.lucene.analysis.ar.ArabicNormalizationFilter;\n import org.apache.lucene.analysis.ar.ArabicStemFilter;\n-import org.apache.lucene.analysis.bg.BulgarianAnalyzer;\n-import org.apache.lucene.analysis.br.BrazilianAnalyzer;\n import org.apache.lucene.analysis.br.BrazilianStemFilter;\n-import org.apache.lucene.analysis.ca.CatalanAnalyzer;\n import org.apache.lucene.analysis.charfilter.HTMLStripCharFilter;\n-import org.apache.lucene.analysis.cjk.CJKAnalyzer;\n-import org.apache.lucene.analysis.cn.ChineseAnalyzer;\n-import org.apache.lucene.analysis.commongrams.*;\n+import org.apache.lucene.analysis.commongrams.CommonGramsFilter;\n import org.apache.lucene.analysis.core.*;\n-import org.apache.lucene.analysis.cz.CzechAnalyzer;\n import org.apache.lucene.analysis.cz.CzechStemFilter;\n-import org.apache.lucene.analysis.da.DanishAnalyzer;\n-import org.apache.lucene.analysis.de.GermanAnalyzer;\n import org.apache.lucene.analysis.de.GermanStemFilter;\n-import org.apache.lucene.analysis.el.GreekAnalyzer;\n-import org.apache.lucene.analysis.en.EnglishAnalyzer;\n import org.apache.lucene.analysis.en.KStemFilter;\n import org.apache.lucene.analysis.en.PorterStemFilter;\n-import org.apache.lucene.analysis.es.SpanishAnalyzer;\n-import org.apache.lucene.analysis.eu.BasqueAnalyzer;\n-import org.apache.lucene.analysis.fa.PersianAnalyzer;\n import org.apache.lucene.analysis.fa.PersianNormalizationFilter;\n-import org.apache.lucene.analysis.fi.FinnishAnalyzer;\n import org.apache.lucene.analysis.fr.FrenchAnalyzer;\n import org.apache.lucene.analysis.fr.FrenchStemFilter;\n-import org.apache.lucene.analysis.ga.IrishAnalyzer;\n-import org.apache.lucene.analysis.gl.GalicianAnalyzer;\n-import org.apache.lucene.analysis.hi.HindiAnalyzer;\n-import org.apache.lucene.analysis.hu.HungarianAnalyzer;\n-import org.apache.lucene.analysis.hy.ArmenianAnalyzer;\n-import org.apache.lucene.analysis.id.IndonesianAnalyzer;\n-import org.apache.lucene.analysis.it.ItalianAnalyzer;\n-import org.apache.lucene.analysis.lv.LatvianAnalyzer;\n import org.apache.lucene.analysis.miscellaneous.*;\n import org.apache.lucene.analysis.ngram.EdgeNGramTokenFilter;\n import org.apache.lucene.analysis.ngram.EdgeNGramTokenizer;\n import org.apache.lucene.analysis.ngram.NGramTokenFilter;\n import org.apache.lucene.analysis.ngram.NGramTokenizer;\n-import org.apache.lucene.analysis.nl.DutchAnalyzer;\n import org.apache.lucene.analysis.nl.DutchStemFilter;\n-import org.apache.lucene.analysis.no.NorwegianAnalyzer;\n import org.apache.lucene.analysis.path.PathHierarchyTokenizer;\n import org.apache.lucene.analysis.pattern.PatternTokenizer;\n import org.apache.lucene.analysis.payloads.TypeAsPayloadTokenFilter;\n-import org.apache.lucene.analysis.pt.PortugueseAnalyzer;\n import org.apache.lucene.analysis.reverse.ReverseStringFilter;\n-import org.apache.lucene.analysis.ro.RomanianAnalyzer;\n-import org.apache.lucene.analysis.ru.RussianAnalyzer;\n-import org.apache.lucene.analysis.shingle.ShingleFilter;\n-import org.apache.lucene.analysis.snowball.SnowballAnalyzer;\n import org.apache.lucene.analysis.snowball.SnowballFilter;\n import org.apache.lucene.analysis.standard.*;\n-import org.apache.lucene.analysis.sv.SwedishAnalyzer;\n-import org.apache.lucene.analysis.th.ThaiAnalyzer;\n-import org.apache.lucene.analysis.tr.TurkishAnalyzer;\n-import org.apache.lucene.analysis.util.ElisionFilter;\n import org.apache.lucene.analysis.util.CharArraySet;\n+import org.apache.lucene.analysis.util.ElisionFilter;\n+import org.elasticsearch.Version;\n import org.elasticsearch.common.component.AbstractComponent;\n import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.lucene.Lucene;\n@@ -91,6 +59,7 @@ import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n import org.elasticsearch.index.analysis.*;\n \n import java.io.Reader;\n+import java.util.Locale;\n import java.util.Map;\n \n import static org.elasticsearch.common.settings.ImmutableSettings.Builder.EMPTY_SETTINGS;\n@@ -101,7 +70,6 @@ import static org.elasticsearch.common.settings.ImmutableSettings.Builder.EMPTY_\n public class IndicesAnalysisService extends AbstractComponent {\n \n     private final Map<String, PreBuiltAnalyzerProviderFactory> analyzerProviderFactories = ConcurrentCollections.newConcurrentMap();\n-\n     private final Map<String, PreBuiltTokenizerFactoryFactory> tokenizerFactories = ConcurrentCollections.newConcurrentMap();\n     private final Map<String, PreBuiltTokenFilterFactoryFactory> tokenFilterFactories = ConcurrentCollections.newConcurrentMap();\n     private final Map<String, PreBuiltCharFilterFactoryFactory> charFilterFactories = ConcurrentCollections.newConcurrentMap();\n@@ -114,52 +82,10 @@ public class IndicesAnalysisService extends AbstractComponent {\n     public IndicesAnalysisService(Settings settings) {\n         super(settings);\n \n-        StandardAnalyzer standardAnalyzer = new StandardAnalyzer(Lucene.ANALYZER_VERSION);\n-        analyzerProviderFactories.put(\"default\", new PreBuiltAnalyzerProviderFactory(\"default\", AnalyzerScope.INDICES, standardAnalyzer));\n-        analyzerProviderFactories.put(\"standard\", new PreBuiltAnalyzerProviderFactory(\"standard\", AnalyzerScope.INDICES, standardAnalyzer));\n-        analyzerProviderFactories.put(\"keyword\", new PreBuiltAnalyzerProviderFactory(\"keyword\", AnalyzerScope.INDICES, new KeywordAnalyzer()));\n-        analyzerProviderFactories.put(\"stop\", new PreBuiltAnalyzerProviderFactory(\"stop\", AnalyzerScope.INDICES, new StopAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"whitespace\", new PreBuiltAnalyzerProviderFactory(\"whitespace\", AnalyzerScope.INDICES, new WhitespaceAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"simple\", new PreBuiltAnalyzerProviderFactory(\"simple\", AnalyzerScope.INDICES, new SimpleAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"classic\", new PreBuiltAnalyzerProviderFactory(\"classic\", AnalyzerScope.INDICES, new ClassicAnalyzer(Lucene.ANALYZER_VERSION)));\n-\n-        // extended ones\n-        analyzerProviderFactories.put(\"pattern\", new PreBuiltAnalyzerProviderFactory(\"pattern\", AnalyzerScope.INDICES, new PatternAnalyzer(Lucene.ANALYZER_VERSION, Regex.compile(\"\\\\W+\" /*PatternAnalyzer.NON_WORD_PATTERN*/, null), true, StopAnalyzer.ENGLISH_STOP_WORDS_SET)));\n-        analyzerProviderFactories.put(\"snowball\", new PreBuiltAnalyzerProviderFactory(\"snowball\", AnalyzerScope.INDICES, new SnowballAnalyzer(Lucene.ANALYZER_VERSION, \"English\", StopAnalyzer.ENGLISH_STOP_WORDS_SET)));\n-        analyzerProviderFactories.put(\"standard_html_strip\", new PreBuiltAnalyzerProviderFactory(\"standard_html_strip\", AnalyzerScope.INDICES, new StandardHtmlStripAnalyzer(Lucene.ANALYZER_VERSION)));\n-\n-        analyzerProviderFactories.put(\"arabic\", new PreBuiltAnalyzerProviderFactory(\"arabic\", AnalyzerScope.INDICES, new ArabicAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"armenian\", new PreBuiltAnalyzerProviderFactory(\"armenian\", AnalyzerScope.INDICES, new ArmenianAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"basque\", new PreBuiltAnalyzerProviderFactory(\"basque\", AnalyzerScope.INDICES, new BasqueAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"brazilian\", new PreBuiltAnalyzerProviderFactory(\"brazilian\", AnalyzerScope.INDICES, new BrazilianAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"bulgarian\", new PreBuiltAnalyzerProviderFactory(\"bulgarian\", AnalyzerScope.INDICES, new BulgarianAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"catalan\", new PreBuiltAnalyzerProviderFactory(\"catalan\", AnalyzerScope.INDICES, new CatalanAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"chinese\", new PreBuiltAnalyzerProviderFactory(\"chinese\", AnalyzerScope.INDICES, new ChineseAnalyzer()));\n-        analyzerProviderFactories.put(\"cjk\", new PreBuiltAnalyzerProviderFactory(\"cjk\", AnalyzerScope.INDICES, new CJKAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"czech\", new PreBuiltAnalyzerProviderFactory(\"czech\", AnalyzerScope.INDICES, new CzechAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"dutch\", new PreBuiltAnalyzerProviderFactory(\"dutch\", AnalyzerScope.INDICES, new DutchAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"danish\", new PreBuiltAnalyzerProviderFactory(\"danish\", AnalyzerScope.INDICES, new DanishAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"english\", new PreBuiltAnalyzerProviderFactory(\"english\", AnalyzerScope.INDICES, new EnglishAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"finnish\", new PreBuiltAnalyzerProviderFactory(\"finnish\", AnalyzerScope.INDICES, new FinnishAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"french\", new PreBuiltAnalyzerProviderFactory(\"french\", AnalyzerScope.INDICES, new FrenchAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"galician\", new PreBuiltAnalyzerProviderFactory(\"galician\", AnalyzerScope.INDICES, new GalicianAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"german\", new PreBuiltAnalyzerProviderFactory(\"german\", AnalyzerScope.INDICES, new GermanAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"greek\", new PreBuiltAnalyzerProviderFactory(\"greek\", AnalyzerScope.INDICES, new GreekAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"hindi\", new PreBuiltAnalyzerProviderFactory(\"hindi\", AnalyzerScope.INDICES, new HindiAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"hungarian\", new PreBuiltAnalyzerProviderFactory(\"hungarian\", AnalyzerScope.INDICES, new HungarianAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"indonesian\", new PreBuiltAnalyzerProviderFactory(\"indonesian\", AnalyzerScope.INDICES, new IndonesianAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"irish\", new PreBuiltAnalyzerProviderFactory(\"irish\", AnalyzerScope.INDICES, new IrishAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"italian\", new PreBuiltAnalyzerProviderFactory(\"italian\", AnalyzerScope.INDICES, new ItalianAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"latvian\", new PreBuiltAnalyzerProviderFactory(\"latvian\", AnalyzerScope.INDICES, new LatvianAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"norwegian\", new PreBuiltAnalyzerProviderFactory(\"norwegian\", AnalyzerScope.INDICES, new NorwegianAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"persian\", new PreBuiltAnalyzerProviderFactory(\"persian\", AnalyzerScope.INDICES, new PersianAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"portuguese\", new PreBuiltAnalyzerProviderFactory(\"portuguese\", AnalyzerScope.INDICES, new PortugueseAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"romanian\", new PreBuiltAnalyzerProviderFactory(\"romanian\", AnalyzerScope.INDICES, new RomanianAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"russian\", new PreBuiltAnalyzerProviderFactory(\"russian\", AnalyzerScope.INDICES, new RussianAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"spanish\", new PreBuiltAnalyzerProviderFactory(\"spanish\", AnalyzerScope.INDICES, new SpanishAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"swedish\", new PreBuiltAnalyzerProviderFactory(\"swedish\", AnalyzerScope.INDICES, new SwedishAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"turkish\", new PreBuiltAnalyzerProviderFactory(\"turkish\", AnalyzerScope.INDICES, new TurkishAnalyzer(Lucene.ANALYZER_VERSION)));\n-        analyzerProviderFactories.put(\"thai\", new PreBuiltAnalyzerProviderFactory(\"thai\", AnalyzerScope.INDICES, new ThaiAnalyzer(Lucene.ANALYZER_VERSION)));\n+        for (PreBuiltAnalyzers preBuiltAnalyzerEnum : PreBuiltAnalyzers.values()) {\n+            String name = preBuiltAnalyzerEnum.name().toLowerCase(Locale.ROOT);\n+            analyzerProviderFactories.put(name, new PreBuiltAnalyzerProviderFactory(name, AnalyzerScope.INDICES, preBuiltAnalyzerEnum.getAnalyzer(Version.CURRENT)));\n+        }\n \n         // Base Tokenizers\n         tokenizerFactories.put(\"standard\", new PreBuiltTokenizerFactoryFactory(new TokenizerFactory() {\n@@ -771,7 +697,7 @@ public class IndicesAnalysisService extends AbstractComponent {\n     }\n \n     public boolean hasAnalyzer(String name) {\n-        return analyzer(name) != null;\n+        return analyzerProviderFactories.containsKey(name);\n     }\n \n     public Analyzer analyzer(String name) {\ndiff --git a/src/main/java/org/elasticsearch/indices/analysis/PreBuiltAnalyzers.java b/src/main/java/org/elasticsearch/indices/analysis/PreBuiltAnalyzers.java\nnew file mode 100644\nindex 00000000000..7e92a674c68\n--- /dev/null\n+++ b/src/main/java/org/elasticsearch/indices/analysis/PreBuiltAnalyzers.java\n@@ -0,0 +1,439 @@\n+/*\n+ * Licensed to ElasticSearch and Shay Banon under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. ElasticSearch licenses this\n+ * file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.indices.analysis;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import org.apache.lucene.analysis.Analyzer;\n+import org.apache.lucene.analysis.ar.ArabicAnalyzer;\n+import org.apache.lucene.analysis.bg.BulgarianAnalyzer;\n+import org.apache.lucene.analysis.br.BrazilianAnalyzer;\n+import org.apache.lucene.analysis.ca.CatalanAnalyzer;\n+import org.apache.lucene.analysis.cjk.CJKAnalyzer;\n+import org.apache.lucene.analysis.cn.ChineseAnalyzer;\n+import org.apache.lucene.analysis.core.KeywordAnalyzer;\n+import org.apache.lucene.analysis.core.SimpleAnalyzer;\n+import org.apache.lucene.analysis.core.StopAnalyzer;\n+import org.apache.lucene.analysis.core.WhitespaceAnalyzer;\n+import org.apache.lucene.analysis.cz.CzechAnalyzer;\n+import org.apache.lucene.analysis.da.DanishAnalyzer;\n+import org.apache.lucene.analysis.de.GermanAnalyzer;\n+import org.apache.lucene.analysis.el.GreekAnalyzer;\n+import org.apache.lucene.analysis.en.EnglishAnalyzer;\n+import org.apache.lucene.analysis.es.SpanishAnalyzer;\n+import org.apache.lucene.analysis.eu.BasqueAnalyzer;\n+import org.apache.lucene.analysis.fa.PersianAnalyzer;\n+import org.apache.lucene.analysis.fi.FinnishAnalyzer;\n+import org.apache.lucene.analysis.fr.FrenchAnalyzer;\n+import org.apache.lucene.analysis.ga.IrishAnalyzer;\n+import org.apache.lucene.analysis.gl.GalicianAnalyzer;\n+import org.apache.lucene.analysis.hi.HindiAnalyzer;\n+import org.apache.lucene.analysis.hu.HungarianAnalyzer;\n+import org.apache.lucene.analysis.hy.ArmenianAnalyzer;\n+import org.apache.lucene.analysis.id.IndonesianAnalyzer;\n+import org.apache.lucene.analysis.it.ItalianAnalyzer;\n+import org.apache.lucene.analysis.lv.LatvianAnalyzer;\n+import org.apache.lucene.analysis.miscellaneous.PatternAnalyzer;\n+import org.apache.lucene.analysis.nl.DutchAnalyzer;\n+import org.apache.lucene.analysis.no.NorwegianAnalyzer;\n+import org.apache.lucene.analysis.pt.PortugueseAnalyzer;\n+import org.apache.lucene.analysis.ro.RomanianAnalyzer;\n+import org.apache.lucene.analysis.ru.RussianAnalyzer;\n+import org.apache.lucene.analysis.snowball.SnowballAnalyzer;\n+import org.apache.lucene.analysis.standard.ClassicAnalyzer;\n+import org.apache.lucene.analysis.standard.StandardAnalyzer;\n+import org.apache.lucene.analysis.sv.SwedishAnalyzer;\n+import org.apache.lucene.analysis.th.ThaiAnalyzer;\n+import org.apache.lucene.analysis.tr.TurkishAnalyzer;\n+import org.elasticsearch.ElasticSearchException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.index.analysis.StandardHtmlStripAnalyzer;\n+\n+import java.util.Map;\n+\n+/**\n+ *\n+ */\n+public enum PreBuiltAnalyzers {\n+\n+    STANDARD() {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new StandardAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    DEFAULT {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            // by calling get analyzer we are ensuring reuse of the same STANDARD analyzer for DEFAULT!\n+            // this call does not create a new instance\n+            return STANDARD.getAnalyzer(version);\n+        }\n+    },\n+\n+    KEYWORD(CachingStrategy.ONE) {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new KeywordAnalyzer();\n+        }\n+    },\n+\n+    STOP {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new StopAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    WHITESPACE {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new WhitespaceAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    SIMPLE {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new SimpleAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    CLASSIC {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new ClassicAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    SNOWBALL {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new SnowballAnalyzer(version.luceneVersion, \"English\", StopAnalyzer.ENGLISH_STOP_WORDS_SET);\n+        }\n+    },\n+\n+    PATTERN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new PatternAnalyzer(version.luceneVersion, Regex.compile(\"\\\\W+\" /*PatternAnalyzer.NON_WORD_PATTERN*/, null), true, StopAnalyzer.ENGLISH_STOP_WORDS_SET);\n+        }\n+    },\n+\n+    STANDARD_HTML_STRIP {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new StandardHtmlStripAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    ARABIC {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new ArabicAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    ARMENIAN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new ArmenianAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    BASQUE {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new BasqueAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    BRAZILIAN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new BrazilianAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    BULGARIAN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new BulgarianAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    CATALAN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new CatalanAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    CHINESE(CachingStrategy.ONE) {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new ChineseAnalyzer();\n+        }\n+    },\n+\n+    CJK {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new CJKAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    CZECH {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new CzechAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    DUTCH {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new DutchAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    DANISH {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new DanishAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    ENGLISH {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new EnglishAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    FINNISH {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new FinnishAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    FRENCH {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new FrenchAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    GALICIAN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new GalicianAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    GERMAN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new GermanAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    GREEK {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new GreekAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    HINDI {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new HindiAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    HUNGARIAN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new HungarianAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    INDONESIAN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new IndonesianAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    IRISH {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new IrishAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    ITALIAN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new ItalianAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    LATVIAN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new LatvianAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    NORWEGIAN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new NorwegianAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    PERSIAN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new PersianAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    PORTUGUESE {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new PortugueseAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    ROMANIAN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new RomanianAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    RUSSIAN {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new RussianAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    SPANISH {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new SpanishAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    SWEDISH {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new SwedishAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    TURKISH {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new TurkishAnalyzer(version.luceneVersion);\n+        }\n+    },\n+\n+    THAI {\n+        @Override\n+        protected Analyzer create(Version version) {\n+            return new ThaiAnalyzer(version.luceneVersion);\n+        }\n+    };\n+\n+    /**\n+     * The strategy of caching the analyzer\n+     *\n+     * ONE               Exactly one version is stored. Useful for analyzers which do not store version information\n+     * LUCENE            Exactly one version for each lucene version is stored. Useful to prevent different analyzers with the same version\n+     * ELASTICSEARCH     Exactly one version per elasticsearch version is stored. Useful if you change an analyzer between elasticsearch releases, when the lucene version does not change\n+     */\n+    private static enum CachingStrategy { ONE, LUCENE, ELASTICSEARCH };\n+\n+    private CachingStrategy cachingStrategy;\n+    protected final Map<Version, Analyzer> cachedAnalyzers = Maps.newHashMapWithExpectedSize(2);\n+\n+    PreBuiltAnalyzers() {\n+        this(CachingStrategy.LUCENE);\n+    }\n+\n+    PreBuiltAnalyzers(CachingStrategy cachingStrategy) {\n+        this.cachingStrategy = cachingStrategy;\n+    }\n+\n+    abstract protected Analyzer create(Version version);\n+\n+    public Map<Version, Analyzer> getCachedAnalyzers() {\n+        return ImmutableMap.copyOf(cachedAnalyzers);\n+    }\n+\n+    public synchronized Analyzer getAnalyzer(Version version) {\n+        Analyzer analyzer = getCachedAnalyzer(version);\n+        if (analyzer == null) {\n+            analyzer = this.create(version);\n+        }\n+\n+        if (!cachedAnalyzers.containsKey(version)) {\n+            cachedAnalyzers.put(version, analyzer);\n+        }\n+\n+        return analyzer;\n+    }\n+\n+    private Analyzer getCachedAnalyzer(Version version) {\n+        switch (this.cachingStrategy) {\n+            case ONE:\n+                // method to return the first found analyzer in the cache\n+                if (cachedAnalyzers.size() > 0) {\n+                    return (Analyzer) cachedAnalyzers.values().toArray()[0];\n+                }\n+                break;\n+            case LUCENE:\n+                // find already cached analyzers with the same lucene version\n+                for (Version elasticsearchVersion : cachedAnalyzers.keySet()) {\n+                    if (elasticsearchVersion.luceneVersion.equals(version.luceneVersion)) {\n+                        return cachedAnalyzers.get(elasticsearchVersion);\n+                    }\n+                }\n+                break;\n+            case ELASTICSEARCH:\n+                // check only for the same es version\n+                if (cachedAnalyzers.containsKey(version)) {\n+                    return cachedAnalyzers.get(version);\n+                }\n+                break;\n+            default:\n+                throw new ElasticSearchException(\"No action configured for caching strategy[\" + this.cachingStrategy + \"]\");\n+        }\n+\n+        return null;\n+    }\n+}\ndiff --git a/src/test/java/org/elasticsearch/index/analysis/AnalysisModuleTests.java b/src/test/java/org/elasticsearch/index/analysis/AnalysisModuleTests.java\nindex 70c83468b10..637801655aa 100644\n--- a/src/test/java/org/elasticsearch/index/analysis/AnalysisModuleTests.java\n+++ b/src/test/java/org/elasticsearch/index/analysis/AnalysisModuleTests.java\n@@ -24,11 +24,13 @@ import org.apache.lucene.analysis.Analyzer;\n import org.apache.lucene.analysis.TokenStream;\n import org.apache.lucene.analysis.Tokenizer;\n import org.apache.lucene.analysis.ar.ArabicNormalizationFilter;\n+import org.apache.lucene.analysis.core.KeywordAnalyzer;\n import org.apache.lucene.analysis.core.WhitespaceTokenizer;\n import org.apache.lucene.analysis.fa.PersianNormalizationFilter;\n import org.apache.lucene.analysis.miscellaneous.KeywordRepeatFilter;\n import org.apache.lucene.analysis.standard.StandardAnalyzer;\n import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.inject.Injector;\n import org.elasticsearch.common.inject.ModulesBuilder;\n import org.elasticsearch.common.lucene.Lucene;\n@@ -45,21 +47,35 @@ import org.elasticsearch.indices.analysis.IndicesAnalysisModule;\n import org.elasticsearch.indices.analysis.IndicesAnalysisService;\n import org.elasticsearch.test.ElasticsearchTestCase;\n import org.hamcrest.MatcherAssert;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n import java.io.*;\n+import java.lang.reflect.Field;\n import java.util.Set;\n \n import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.equalTo;\n-import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.*;\n \n /**\n  *\n  */\n public class AnalysisModuleTests extends ElasticsearchTestCase {\n \n+    private Injector injector;\n+\n+    public AnalysisService getAnalysisService(Settings settings) {\n+        Index index = new Index(\"test\");\n+        Injector parentInjector = new ModulesBuilder().add(new SettingsModule(settings), new EnvironmentModule(new Environment(settings)), new IndicesAnalysisModule()).createInjector();\n+        injector = new ModulesBuilder().add(\n+                new IndexSettingsModule(index, settings),\n+                new IndexNameModule(index),\n+                new AnalysisModule(settings, parentInjector.getInstance(IndicesAnalysisService.class)))\n+                .createChildInjector(parentInjector);\n+\n+        return injector.getInstance(AnalysisService.class);\n+    }\n+\n     @Test\n     public void testSimpleConfigurationJson() {\n         Settings settings = settingsBuilder().loadFromClasspath(\"org/elasticsearch/index/analysis/test1.json\").build();\n@@ -79,6 +95,38 @@ public class AnalysisModuleTests extends ElasticsearchTestCase {\n         assertTokenFilter(\"arabic_normalization\", ArabicNormalizationFilter.class);\n     }\n \n+    @Test\n+    public void testVersionedAnalyzers() throws Exception {\n+        Settings settings2 = settingsBuilder().loadFromClasspath(\"org/elasticsearch/index/analysis/test1.yml\")\n+                .put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_0_90_0).build();\n+        AnalysisService analysisService2 = getAnalysisService(settings2);\n+\n+        // indicesanalysisservice always has the current version\n+        IndicesAnalysisService indicesAnalysisService2 = injector.getInstance(IndicesAnalysisService.class);\n+        assertThat(indicesAnalysisService2.analyzer(\"default\"), is(instanceOf(NamedAnalyzer.class)));\n+        NamedAnalyzer defaultNamedAnalyzer = (NamedAnalyzer) indicesAnalysisService2.analyzer(\"default\");\n+        assertThat(defaultNamedAnalyzer.analyzer(), is(instanceOf(StandardAnalyzer.class)));\n+        assertLuceneAnalyzerVersion(Version.CURRENT.luceneVersion, defaultNamedAnalyzer.analyzer());\n+\n+        // analysis service has the expected version\n+        assertThat(analysisService2.analyzer(\"standard\").analyzer(), is(instanceOf(StandardAnalyzer.class)));\n+        assertLuceneAnalyzerVersion(Version.V_0_90_0.luceneVersion, analysisService2.analyzer(\"standard\").analyzer());\n+        assertLuceneAnalyzerVersion(Version.V_0_90_0.luceneVersion, analysisService2.analyzer(\"thai\").analyzer());\n+    }\n+\n+    // ugly reflection based hack to extract the lucene version from an analyzer\n+    private void assertLuceneAnalyzerVersion(org.apache.lucene.util.Version luceneVersion, Analyzer analyzer) throws Exception {\n+        Field field = analyzer.getClass().getSuperclass().getDeclaredField(\"matchVersion\");\n+        boolean currentAccessible = field.isAccessible();\n+        field.setAccessible(true);\n+        Object obj = field.get(analyzer);\n+        field.setAccessible(currentAccessible);\n+\n+        assertThat(obj, instanceOf(org.apache.lucene.util.Version.class));\n+        org.apache.lucene.util.Version analyzerVersion = (org.apache.lucene.util.Version) obj;\n+        assertThat(analyzerVersion, is(luceneVersion));\n+    }\n+\n     private void assertTokenFilter(String name, Class clazz) {\n         AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(ImmutableSettings.settingsBuilder().build());\n         TokenFilterFactory tokenFilter = analysisService.tokenFilter(name);\n@@ -88,16 +136,7 @@ public class AnalysisModuleTests extends ElasticsearchTestCase {\n     }\n \n     private void testSimpleConfiguration(Settings settings) {\n-        Index index = new Index(\"test\");\n-        Injector parentInjector = new ModulesBuilder().add(new SettingsModule(settings), new EnvironmentModule(new Environment(settings)), new IndicesAnalysisModule()).createInjector();\n-        Injector injector = new ModulesBuilder().add(\n-                new IndexSettingsModule(index, settings),\n-                new IndexNameModule(index),\n-                new AnalysisModule(settings, parentInjector.getInstance(IndicesAnalysisService.class)))\n-                .createChildInjector(parentInjector);\n-\n-        AnalysisService analysisService = injector.getInstance(AnalysisService.class);\n-\n+        AnalysisService analysisService = getAnalysisService(settings);\n         Analyzer analyzer = analysisService.analyzer(\"custom1\").analyzer();\n \n         assertThat(analyzer, instanceOf(CustomAnalyzer.class));\ndiff --git a/src/test/java/org/elasticsearch/index/analysis/PreBuiltAnalyzerIntegrationTests.java b/src/test/java/org/elasticsearch/index/analysis/PreBuiltAnalyzerIntegrationTests.java\nnew file mode 100644\nindex 00000000000..dd446a94b82\n--- /dev/null\n+++ b/src/test/java/org/elasticsearch/index/analysis/PreBuiltAnalyzerIntegrationTests.java\n@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to ElasticSearch and Shay Banon under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. ElasticSearch licenses this\n+ * file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.index.analysis;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.lucene.analysis.Analyzer;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.indices.analysis.PreBuiltAnalyzers;\n+import org.elasticsearch.test.AbstractIntegrationTest;\n+import org.junit.Test;\n+\n+import java.lang.reflect.Field;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.hamcrest.Matchers.*;\n+\n+/**\n+ *\n+ */\n+public class PreBuiltAnalyzerIntegrationTests extends AbstractIntegrationTest {\n+\n+    @Test\n+    public void testThatPreBuiltAnalyzersAreNotClosedOnIndexClose() throws Exception {\n+        Map<PreBuiltAnalyzers, List<Version>> loadedAnalyzers = Maps.newHashMap();\n+\n+        List<String> indexNames = Lists.newArrayList();\n+        for (int i = 0; i < 10; i++) {\n+            String indexName = randomAsciiOfLength(10).toLowerCase(Locale.ROOT);\n+            indexNames.add(indexName);\n+\n+            int randomInt = randomInt(PreBuiltAnalyzers.values().length-1);\n+            PreBuiltAnalyzers preBuiltAnalyzer = PreBuiltAnalyzers.values()[randomInt];\n+            String name = preBuiltAnalyzer.name().toLowerCase(Locale.ROOT);\n+\n+            Version randomVersion = randomVersion();\n+            if (!loadedAnalyzers.containsKey(preBuiltAnalyzer)) {\n+                 loadedAnalyzers.put(preBuiltAnalyzer, Lists.<Version>newArrayList());\n+            }\n+            loadedAnalyzers.get(preBuiltAnalyzer).add(randomVersion);\n+\n+            final XContentBuilder mapping = jsonBuilder().startObject()\n+                .startObject(\"type\")\n+                    .startObject(\"properties\")\n+                        .startObject(\"foo\")\n+                            .field(\"type\", \"string\")\n+                            .field(\"analyzer\", name)\n+                        .endObject()\n+                    .endObject()\n+                .endObject()\n+                .endObject();\n+\n+            Settings versionSettings = randomSettingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion).build();\n+            client().admin().indices().prepareCreate(indexName).addMapping(\"type\", mapping).setSettings(versionSettings).get();\n+        }\n+\n+        ensureGreen();\n+\n+        // index some amount of data\n+        for (int i = 0; i < 100; i++) {\n+            String randomIndex = indexNames.get(randomInt(indexNames.size()-1));\n+            String randomId = randomInt() + \"\";\n+\n+            Map<String, Object> data = Maps.newHashMap();\n+            data.put(\"foo\", randomAsciiOfLength(50));\n+\n+            index(randomIndex, \"type\", randomId, data);\n+        }\n+\n+        refresh();\n+\n+        // close some of the indices\n+        int amountOfIndicesToClose = randomInt(10-1);\n+        for (int i = 0; i < amountOfIndicesToClose; i++) {\n+            String indexName = indexNames.get(i);\n+            client().admin().indices().prepareClose(indexName).execute().actionGet();\n+        }\n+\n+        ensureGreen();\n+\n+        // check that all above configured analyzers have been loaded\n+        assertThatAnalyzersHaveBeenLoaded(loadedAnalyzers);\n+\n+        // check that all of the prebuiltanalyzers are still open\n+        for (PreBuiltAnalyzers preBuiltAnalyzer : PreBuiltAnalyzers.values()) {\n+            assertLuceneAnalyzerIsNotClosed(preBuiltAnalyzer);\n+        }\n+    }\n+\n+    private void assertThatAnalyzersHaveBeenLoaded(Map<PreBuiltAnalyzers, List<Version>> expectedLoadedAnalyzers) {\n+        for (Map.Entry<PreBuiltAnalyzers, List<Version>> entry : expectedLoadedAnalyzers.entrySet()) {\n+            Map<Version, Analyzer> cachedAnalyzers = entry.getKey().getCachedAnalyzers();\n+            assertThat(cachedAnalyzers.keySet(), hasItems(entry.getValue().toArray(new Version[]{})));\n+            /*for (Version expectedVersion : entry.getValue()) {\n+                assertThat(cachedAnalyzers, contains(ex))\n+            }\n+            */\n+        }\n+    }\n+\n+    // the close() method of a lucene analyzer sets the storedValue field to null\n+    // we simply check this via reflection - ugly but works\n+    private void assertLuceneAnalyzerIsNotClosed(PreBuiltAnalyzers preBuiltAnalyzer) throws IllegalAccessException, NoSuchFieldException {\n+\n+        for (Map.Entry<Version, Analyzer> luceneAnalyzerEntry : preBuiltAnalyzer.getCachedAnalyzers().entrySet()) {\n+            Field field = getFieldFromClass(\"storedValue\", luceneAnalyzerEntry.getValue());\n+            boolean currentAccessible = field.isAccessible();\n+            field.setAccessible(true);\n+            Object storedValue = field.get(preBuiltAnalyzer.getAnalyzer(luceneAnalyzerEntry.getKey()));\n+            field.setAccessible(currentAccessible);\n+\n+            assertThat(String.format(Locale.ROOT, \"Analyzer %s in version %s seems to be closed\", preBuiltAnalyzer.name(), luceneAnalyzerEntry.getKey()), storedValue, is(notNullValue()));\n+        }\n+\n+    }\n+\n+    /**\n+     * Searches for a field until it finds, loops through all superclasses\n+     */\n+    private Field getFieldFromClass(String fieldName, Object obj) {\n+        Field field = null;\n+        boolean storedValueFieldFound = false;\n+        Class clazz = obj.getClass();\n+        while (!storedValueFieldFound) {\n+            try {\n+                field = clazz.getDeclaredField(fieldName);\n+                storedValueFieldFound = true;\n+            } catch (NoSuchFieldException e) {\n+                clazz = clazz.getSuperclass();\n+            }\n+\n+            if (Object.class.equals(clazz)) throw new RuntimeException(\"Could not find storedValue field in class\" + clazz);\n+        }\n+\n+        return field;\n+    }\n+\n+}\ndiff --git a/src/test/java/org/elasticsearch/index/analysis/PreBuiltAnalyzerProviderFactoryTests.java b/src/test/java/org/elasticsearch/index/analysis/PreBuiltAnalyzerProviderFactoryTests.java\nnew file mode 100644\nindex 00000000000..c4e833a26ef\n--- /dev/null\n+++ b/src/test/java/org/elasticsearch/index/analysis/PreBuiltAnalyzerProviderFactoryTests.java\n@@ -0,0 +1,48 @@\n+/*\n+ * Licensed to ElasticSearch and Shay Banon under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. ElasticSearch licenses this\n+ * file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.index.analysis;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.settings.ImmutableSettings;\n+import org.elasticsearch.indices.analysis.PreBuiltAnalyzers;\n+import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.junit.Test;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+/**\n+ *\n+ */\n+public class PreBuiltAnalyzerProviderFactoryTests extends ElasticsearchTestCase {\n+\n+    @Test\n+    public void testVersioningInFactoryProvider() throws Exception {\n+        PreBuiltAnalyzerProviderFactory factory = new PreBuiltAnalyzerProviderFactory(\"default\", AnalyzerScope.INDEX, PreBuiltAnalyzers.STANDARD.getAnalyzer(Version.CURRENT));\n+\n+        AnalyzerProvider currentAnalyzerProvider = factory.create(\"default\", ImmutableSettings.Builder.EMPTY_SETTINGS);\n+        AnalyzerProvider former090AnalyzerProvider = factory.create(\"default\", ImmutableSettings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_0_90_0).build());\n+        AnalyzerProvider currentAnalyzerProviderReference = factory.create(\"default\", ImmutableSettings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).build());\n+\n+        // would love to access the version inside of the lucene analyzer, but that is not possible...\n+        assertThat(currentAnalyzerProvider, is(currentAnalyzerProviderReference));\n+        assertThat(currentAnalyzerProvider, is(not(former090AnalyzerProvider)));\n+    }\n+}\ndiff --git a/src/test/java/org/elasticsearch/index/analysis/PreBuiltAnalyzerTests.java b/src/test/java/org/elasticsearch/index/analysis/PreBuiltAnalyzerTests.java\nnew file mode 100644\nindex 00000000000..728d6509e81\n--- /dev/null\n+++ b/src/test/java/org/elasticsearch/index/analysis/PreBuiltAnalyzerTests.java\n@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to ElasticSearch and Shay Banon under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. ElasticSearch licenses this\n+ * file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.index.analysis;\n+\n+import org.apache.lucene.analysis.Analyzer;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.settings.ImmutableSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.mapper.DocumentMapper;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.MapperTestUtils;\n+import org.elasticsearch.indices.analysis.PreBuiltAnalyzers;\n+import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+\n+/**\n+ *\n+ */\n+public class PreBuiltAnalyzerTests extends ElasticsearchTestCase {\n+\n+    @Test\n+    public void testThatDefaultAndStandardAnalyzerAreTheSameInstance() {\n+        Analyzer currentStandardAnalyzer = PreBuiltAnalyzers.STANDARD.getAnalyzer(Version.CURRENT);\n+        Analyzer currentDefaultAnalyzer = PreBuiltAnalyzers.DEFAULT.getAnalyzer(Version.CURRENT);\n+\n+        // special case, these two are the same instance\n+        assertThat(currentDefaultAnalyzer, is(currentStandardAnalyzer));\n+    }\n+\n+    @Test\n+    public void testThatInstancesAreTheSameAlwaysForKeywordAnalyzer() {\n+        assertThat(PreBuiltAnalyzers.KEYWORD.getAnalyzer(Version.CURRENT),\n+                is(PreBuiltAnalyzers.KEYWORD.getAnalyzer(Version.V_0_18_0)));\n+    }\n+\n+    @Test\n+    public void testThatInstancesAreCachedAndReused() {\n+        assertThat(PreBuiltAnalyzers.ARABIC.getAnalyzer(Version.CURRENT),\n+                is(PreBuiltAnalyzers.ARABIC.getAnalyzer(Version.CURRENT)));\n+        assertThat(PreBuiltAnalyzers.ARABIC.getAnalyzer(Version.V_0_18_0),\n+                is(PreBuiltAnalyzers.ARABIC.getAnalyzer(Version.V_0_18_0)));\n+    }\n+\n+    @Test\n+    public void testThatInstancesWithSameLuceneVersionAreReused() {\n+        // both are lucene 4.4 and should return the same instance\n+        assertThat(PreBuiltAnalyzers.CATALAN.getAnalyzer(Version.V_0_90_5),\n+                is(PreBuiltAnalyzers.CATALAN.getAnalyzer(Version.V_0_90_6)));\n+    }\n+\n+    @Test\n+    public void testThatAnalyzersAreUsedInMapping() throws IOException {\n+        int randomInt = randomInt(PreBuiltAnalyzers.values().length-1);\n+        PreBuiltAnalyzers randomPreBuiltAnalyzer = PreBuiltAnalyzers.values()[randomInt];\n+        String analyzerName = randomPreBuiltAnalyzer.name().toLowerCase(Locale.ROOT);\n+\n+        Version randomVersion = randomVersion();\n+        Settings indexSettings = ImmutableSettings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion).build();\n+\n+        NamedAnalyzer namedAnalyzer = new PreBuiltAnalyzerProvider(analyzerName, AnalyzerScope.INDEX, randomPreBuiltAnalyzer.getAnalyzer(randomVersion)).get();\n+\n+        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n+                .startObject(\"properties\").startObject(\"field\").field(\"type\", \"string\").field(\"analyzer\", analyzerName).endObject().endObject()\n+                .endObject().endObject().string();\n+        DocumentMapper docMapper = MapperTestUtils.newParser(indexSettings).parse(mapping);\n+\n+        FieldMapper fieldMapper = docMapper.mappers().name(\"field\").mapper();\n+        assertThat(fieldMapper.searchAnalyzer(), instanceOf(NamedAnalyzer.class));\n+        NamedAnalyzer fieldMapperNamedAnalyzer = (NamedAnalyzer) fieldMapper.searchAnalyzer();\n+\n+        assertThat(fieldMapperNamedAnalyzer.analyzer(), is(namedAnalyzer.analyzer()));\n+    }\n+}\ndiff --git a/src/test/java/org/elasticsearch/index/analysis/test1.yml b/src/test/java/org/elasticsearch/index/analysis/test1.yml\nindex 46cbc40f8c8..9c4aac6a6cb 100644\n--- a/src/test/java/org/elasticsearch/index/analysis/test1.yml\n+++ b/src/test/java/org/elasticsearch/index/analysis/test1.yml\n@@ -48,6 +48,11 @@ index :\n       custom5 :\n         tokenizer : standard\n         char_filter : [my_mapping]\n+      custom6 :\n+        type : standard\n+      custom7 :\n+        type : standard\n+        version: 3.6\n       czechAnalyzerWithStemmer :\n         tokenizer : standard\n         filter : [standard, lowercase, stop, czech_stem]\ndiff --git a/src/test/java/org/elasticsearch/index/mapper/MapperTestUtils.java b/src/test/java/org/elasticsearch/index/mapper/MapperTestUtils.java\nindex d0eac0e6d83..a385c3607d4 100644\n--- a/src/test/java/org/elasticsearch/index/mapper/MapperTestUtils.java\n+++ b/src/test/java/org/elasticsearch/index/mapper/MapperTestUtils.java\n@@ -48,7 +48,7 @@ public class MapperTestUtils {\n     }\n \n     public static DocumentMapperParser newParser(Settings indexSettings) {\n-        return new DocumentMapperParser(new Index(\"test\"), indexSettings, newAnalysisService(), new PostingsFormatService(new Index(\"test\")),\n+        return new DocumentMapperParser(new Index(\"test\"), indexSettings, newAnalysisService(indexSettings), new PostingsFormatService(new Index(\"test\")),\n                 new DocValuesFormatService(new Index(\"test\")), newSimilarityLookupService());\n     }\n \n@@ -58,11 +58,15 @@ public class MapperTestUtils {\n     }\n \n     public static AnalysisService newAnalysisService() {\n-        Injector parentInjector = new ModulesBuilder().add(new SettingsModule(ImmutableSettings.Builder.EMPTY_SETTINGS), new EnvironmentModule(new Environment(ImmutableSettings.Builder.EMPTY_SETTINGS)), new IndicesAnalysisModule()).createInjector();\n+        return newAnalysisService(ImmutableSettings.Builder.EMPTY_SETTINGS);\n+    }\n+\n+    public static AnalysisService newAnalysisService(Settings indexSettings) {\n+        Injector parentInjector = new ModulesBuilder().add(new SettingsModule(indexSettings), new EnvironmentModule(new Environment(ImmutableSettings.Builder.EMPTY_SETTINGS)), new IndicesAnalysisModule()).createInjector();\n         Injector injector = new ModulesBuilder().add(\n-                new IndexSettingsModule(new Index(\"test\"), ImmutableSettings.Builder.EMPTY_SETTINGS),\n+                new IndexSettingsModule(new Index(\"test\"), indexSettings),\n                 new IndexNameModule(new Index(\"test\")),\n-                new AnalysisModule(ImmutableSettings.Builder.EMPTY_SETTINGS, parentInjector.getInstance(IndicesAnalysisService.class))).createChildInjector(parentInjector);\n+                new AnalysisModule(indexSettings, parentInjector.getInstance(IndicesAnalysisService.class))).createChildInjector(parentInjector);\n \n         return injector.getInstance(AnalysisService.class);\n     }"
}