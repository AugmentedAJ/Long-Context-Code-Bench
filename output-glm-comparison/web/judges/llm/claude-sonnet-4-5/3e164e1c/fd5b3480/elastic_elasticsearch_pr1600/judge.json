{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 1600,
  "base_commit": "ed8a46ce09ccf43adec55af91a72fc9c5dc1ec05",
  "head_commit": "682176497f9f454943d2373dc24501ad37b8dbb0",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.3,
    "completeness": 0.6,
    "code_reuse": -0.2,
    "best_practices": 0.3,
    "unsolicited_docs": 1.0
  },
  "aggregate": 0.27999999999999997,
  "rationale": "The agent implemented timestamp and TTL handling but with critical differences from ground truth. CORRECTNESS: Agent extracts timestamp/TTL from getResult fields and uses expiry-time based approach with helper methods parseTimestamp/parseTtl/applyTimestampAndTTL, while ground truth uses simpler direct extraction with TTL as duration and getDate timestamp for approximation. The agent's approach of computing ttlExpiryTime from nowInMillis + ttlValue, then later computing ttlValue = ttlExpiryTime - timestamp creates logical issues when timestamp is modified in script. Ground truth correctly tracks getDate at retrieval time and adjusts TTL by elapsed time. COMPLETENESS: Agent adds timestamp/TTL extraction from getResult and passes them to IndexRequest, covering the core requirement, but misses the simpler pattern of ground truth (fetching TTL field, adjusting by elapsed time). REUSE: Agent adds 56 lines of new helper methods and complex logic instead of inline handling; ground truth adds ~15 lines inline. Best practices: Agent's approach is more elaborate but introduces unnecessary complexity and potential bugs with timestamp/TTL expiry time calculations. The ground truth's simpler inline approach with elapsed-time adjustment is more appropriate. No unsolicited docs.",
  "edit_run_id": "fd5b3480",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\nindex 5a296cdf925..ae9eea79b9f 100644\n--- a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\n+++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\n@@ -43,6 +43,7 @@ import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.common.collect.Tuple;\n import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.xcontent.XContentHelper;\n import org.elasticsearch.common.xcontent.XContentType;\n import org.elasticsearch.index.engine.DocumentMissingException;\n@@ -52,7 +53,7 @@ import org.elasticsearch.index.get.GetResult;\n import org.elasticsearch.index.mapper.internal.ParentFieldMapper;\n import org.elasticsearch.index.mapper.internal.RoutingFieldMapper;\n import org.elasticsearch.index.mapper.internal.SourceFieldMapper;\n-import org.elasticsearch.index.mapper.internal.TimestampFieldMapper;\n+import org.elasticsearch.index.mapper.internal.TTLFieldMapper;\n import org.elasticsearch.index.service.IndexService;\n import org.elasticsearch.index.shard.IllegalIndexShardStateException;\n import org.elasticsearch.index.shard.ShardId;\n@@ -152,8 +153,9 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         IndexService indexService = indicesService.indexServiceSafe(request.index());\n         IndexShard indexShard = indexService.shardSafe(request.shardId());\n \n+        long getDate = System.currentTimeMillis();\n         GetResult getResult = indexShard.getService().get(request.type(), request.id(),\n-                new String[]{SourceFieldMapper.NAME, RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TimestampFieldMapper.NAME}, true);\n+                new String[]{SourceFieldMapper.NAME, RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TTLFieldMapper.NAME}, true);\n \n         // no doc, what to do, what to do...\n         if (!getResult.exists()) {\n@@ -183,12 +185,28 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         }\n \n         String operation = (String) ctx.get(\"op\");\n+        String timestamp = (String) ctx.get(\"_timestamp\");\n+        Long ttl = null;\n+        Object fetchedTTL = ctx.get(\"_ttl\");\n+        if (fetchedTTL != null) {\n+            if (fetchedTTL instanceof Number) {\n+                ttl = ((Number) fetchedTTL).longValue();\n+            } else {\n+                ttl = TimeValue.parseTimeValue((String) fetchedTTL, null).millis();\n+            }\n+        }\n         source = (Map<String, Object>) ctx.get(\"_source\");\n \n         // apply script to update the source\n         String routing = getResult.fields().containsKey(RoutingFieldMapper.NAME) ? getResult.field(RoutingFieldMapper.NAME).value().toString() : null;\n         String parent = getResult.fields().containsKey(ParentFieldMapper.NAME) ? getResult.field(ParentFieldMapper.NAME).value().toString() : null;\n-        // TODO ttl/timestamp\n+        // No TTL has been given in the update script so we keep previous TTL value if there is one\n+        if (ttl == null) {\n+            ttl = getResult.fields().containsKey(TTLFieldMapper.NAME) ? (Long) getResult.field(TTLFieldMapper.NAME).value() : null;\n+            if (ttl != null) {\n+                ttl = ttl - (System.currentTimeMillis() - getDate); // It is an approximation of exact TTL value, could be improved\n+            }\n+        }\n \n         // TODO percolate?\n \n@@ -197,7 +215,8 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         if (operation == null || \"index\".equals(operation)) {\n             IndexRequest indexRequest = Requests.indexRequest(request.index()).type(request.type()).id(request.id()).routing(routing).parent(parent)\n                     .source(source, sourceAndContent.v1())\n-                    .version(getResult.version()).replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel());\n+                    .version(getResult.version()).replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel())\n+                    .timestamp(timestamp).ttl(ttl);\n             indexRequest.operationThreaded(false);\n             indexAction.execute(indexRequest, new ActionListener<IndexResponse>() {\n                 @Override"
}