{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4597,
  "base_commit": "2a73cf4f823e113926232864b8c7468f9103f88a",
  "head_commit": "611dd0a3962fbb2b17dffbcbc17433f47cc07968",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": 0.0,
    "completeness": 0.0,
    "code_reuse": 0.0,
    "best_practices": 0.1,
    "unsolicited_docs": 1.0
  },
  "aggregate": 0.22000000000000003,
  "rationale": "Both the agent's and ground truth implementations correctly apply the Haversine formula to calculate arc distance. The agent uses a more traditional variable naming approach (sourceLatRad, targetLatRad, deltaLat, deltaLon, sinHalfLat, sinHalfLon) which is more readable and explicit than the ground truth's terse naming (x1, x2, h1, h2, h). Both implementations properly handle numerical stability: the agent uses Math.max(0d, Math.min(1d, a)) to clamp the value before Math.sqrt, while the ground truth uses Math.min(1, Math.sqrt(h)) before Math.asin. Mathematically, both are equivalent - the agent computes a = sin²(Δlat/2) + cos(lat1)cos(lat2)sin²(Δlon/2), then c = 2*asin(sqrt(a)), while ground truth computes h = (1-cos(Δlat))/2 + cos(lat1)cos(lat2)(1-cos(Δlon))/2, then uses 2*asin(sqrt(h)). Using the identity sin²(x/2) = (1-cos(x))/2, these are mathematically identical. The agent's code is slightly more verbose (17 lines vs 12) but uses clearer variable names and follows standard Haversine implementations found in literature. Both correctly implement the requested Haversine formula. No unsolicited documentation was added.",
  "edit_run_id": "fd5b3480",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/common/geo/GeoDistance.java b/src/main/java/org/elasticsearch/common/geo/GeoDistance.java\nindex 6e49621d57f..0cad9dd3376 100644\n--- a/src/main/java/org/elasticsearch/common/geo/GeoDistance.java\n+++ b/src/main/java/org/elasticsearch/common/geo/GeoDistance.java\n@@ -79,18 +79,12 @@ public enum GeoDistance {\n     ARC() {\n         @Override\n         public double calculate(double sourceLatitude, double sourceLongitude, double targetLatitude, double targetLongitude, DistanceUnit unit) {\n-            double longitudeDifference = targetLongitude - sourceLongitude;\n-            double a = Math.toRadians(90D - sourceLatitude);\n-            double c = Math.toRadians(90D - targetLatitude);\n-            double factor = (Math.cos(a) * Math.cos(c)) + (Math.sin(a) * Math.sin(c) * Math.cos(Math.toRadians(longitudeDifference)));\n-\n-            if (factor < -1D) {\n-                return unit.fromMeters(Math.PI * GeoUtils.EARTH_MEAN_RADIUS);\n-            } else if (factor >= 1D) {\n-                return 0;\n-            } else {\n-                return unit.fromMeters(Math.acos(factor) * GeoUtils.EARTH_MEAN_RADIUS);\n-            }\n+            double x1 = sourceLatitude * Math.PI / 180D;\n+            double x2 = targetLatitude * Math.PI / 180D;\n+            double h1 = (1D - Math.cos(x1 - x2)) / 2D;\n+            double h2 = (1D - Math.cos((sourceLongitude - targetLongitude) * Math.PI / 180D)) / 2D;\n+            double h = h1 + Math.cos(x1) * Math.cos(x2) * h2;\n+            return unit.fromMeters(GeoUtils.EARTH_MEAN_RADIUS * 2D * Math.asin(Math.min(1, Math.sqrt(h))));\n         }\n \n         @Override"
}