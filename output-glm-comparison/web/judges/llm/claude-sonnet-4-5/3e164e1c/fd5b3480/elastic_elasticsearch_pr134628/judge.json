{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134628,
  "base_commit": "630d52976d3fb951f6ea52a3d0e5fb492921df87",
  "head_commit": "55ac715077699238aa74d0604b22cd6926f13663",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": 0.0,
    "completeness": -0.3,
    "code_reuse": 0.0,
    "best_practices": -0.4,
    "unsolicited_docs": 1.0
  },
  "aggregate": 0.06000000000000001,
  "rationale": "The agent correctly modernized most pattern matching instances but has two significant issues: (1) Completeness: Failed to convert the unwrap() method's if-else chain to a switch statement with pattern matching, which is a key part of the modernization task shown in ground truth. (2) Best Practices: Used verbose variable names (constantScoreQuery, indexSortSortedNumericDocValuesRangeQuery, pointRangeQuery, extraPointRangeQuery) instead of the concise abbreviations (csq, isq, q1, q2) used in ground truth. While verbose names might seem clearer, the ground truth demonstrates the idiomatic practice in this codebase of using short, contextual names for pattern variables, especially when the type is already clear from the pattern. The agent's changes are functionally correct and don't break anything, but missing the switch statement conversion is a notable omission from the modernization task.",
  "edit_run_id": "fd5b3480",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/QueryToFilterAdapter.java b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/QueryToFilterAdapter.java\nindex 9c6f7ddd6cc..4b7b41c9022 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/QueryToFilterAdapter.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/QueryToFilterAdapter.java\n@@ -51,14 +51,14 @@ public class QueryToFilterAdapter {\n         // Wrapping with a ConstantScoreQuery enables a few more rewrite\n         // rules as of Lucene 9.2\n         query = searcher.rewrite(new ConstantScoreQuery(query));\n-        if (query instanceof ConstantScoreQuery) {\n+        if (query instanceof ConstantScoreQuery csq) {\n             /*\n              * Unwrap constant score because it gets in the way of us\n              * understanding what the queries are trying to do and we\n              * don't use the score at all anyway. Effectively we always\n              * run in constant score mode.\n              */\n-            query = ((ConstantScoreQuery) query).getQuery();\n+            query = csq.getQuery();\n         }\n         return new QueryToFilterAdapter(searcher, key, query);\n     }\n@@ -132,8 +132,8 @@ public class QueryToFilterAdapter {\n         extraQuery = searcher().rewrite(new ConstantScoreQuery(extraQuery));\n         Query unwrappedExtraQuery = unwrap(extraQuery);\n         Query unwrappedQuery = unwrap(query);\n-        if (unwrappedQuery instanceof PointRangeQuery && unwrappedExtraQuery instanceof PointRangeQuery) {\n-            Query merged = MergedPointRangeQuery.merge((PointRangeQuery) unwrappedQuery, (PointRangeQuery) unwrappedExtraQuery);\n+        if (unwrappedQuery instanceof PointRangeQuery q1 && unwrappedExtraQuery instanceof PointRangeQuery q2) {\n+            Query merged = MergedPointRangeQuery.merge(q1, q2);\n             if (merged != null) {\n                 // Should we rewrap here?\n                 return new QueryToFilterAdapter(searcher(), key(), merged);\n@@ -157,19 +157,19 @@ public class QueryToFilterAdapter {\n \n     private static Query unwrap(Query query) {\n         while (true) {\n-            if (query instanceof ConstantScoreQuery) {\n-                query = ((ConstantScoreQuery) query).getQuery();\n-                continue;\n+            switch (query) {\n+                case ConstantScoreQuery csq:\n+                    query = csq.getQuery();\n+                    continue;\n+                case IndexSortSortedNumericDocValuesRangeQuery isq:\n+                    query = isq.getFallbackQuery();\n+                    continue;\n+                case IndexOrDocValuesQuery idq:\n+                    query = idq.getIndexQuery();\n+                    continue;\n+                default:\n+                    return query;\n             }\n-            if (query instanceof IndexSortSortedNumericDocValuesRangeQuery) {\n-                query = ((IndexSortSortedNumericDocValuesRangeQuery) query).getFallbackQuery();\n-                continue;\n-            }\n-            if (query instanceof IndexOrDocValuesQuery) {\n-                query = ((IndexOrDocValuesQuery) query).getIndexQuery();\n-                continue;\n-            }\n-            return query;\n         }\n     }\n "
}