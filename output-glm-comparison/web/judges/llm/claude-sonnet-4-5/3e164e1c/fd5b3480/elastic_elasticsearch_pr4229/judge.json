{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4229,
  "base_commit": "0ec3eaf53d470a309d3976c7f6798f578bd668d5",
  "head_commit": "630641f2927436b2954d79d110614f58400558a6",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.9,
    "completeness": -0.8,
    "code_reuse": -0.5,
    "best_practices": -0.7,
    "unsolicited_docs": 1.0
  },
  "aggregate": -0.38000000000000006,
  "rationale": "The agent's diff is critically incomplete and incorrect. Ground truth creates a new PutMappingClusterStateUpdateRequest class extending IndicesClusterStateUpdateRequest to properly encapsulate the put mapping request data, modifies PutMappingRequest to extend AcknowledgedRequest (removing custom timeout handling), refactors PutMappingResponse to extend AcknowledgedResponse, updates TransportPutMappingAction to use the new request object and ClusterStateUpdateListener, updates MappingUpdatedAction to use ClusterStateUpdateListener, removes NodeMappingCreatedAction entirely, refactors MetaDataMappingService.putMapping to accept PutMappingClusterStateUpdateRequest and use AckedClusterStateUpdateTask, updates REST handler to use AcknowledgedRestResponseActionListener, and adds comprehensive tests. The agent's diff only deletes NodeMappingCreatedAction and partially modifies MetaDataMappingService.putMapping with a fundamentally broken implementation: it uses TimeoutClusterStateUpdateTask (deprecated) instead of AckedClusterStateUpdateTask, manually implements node acknowledgment tracking with AtomicBoolean and Set<String> instead of using the generic ack mechanism, imports unused classes (IndexShardRoutingTable, ShardRouting, AtomicBoolean), and completely omits the new PutMappingClusterStateUpdateRequest class, changes to PutMappingRequest/Response/RequestBuilder, TransportPutMappingAction refactoring, REST handler update, and test additions. The manual ack tracking contradicts the task instruction to 'use the new generic ack mechanism'. This is a failed refactoring attempt that breaks the intended architecture and leaves the codebase in an inconsistent state.",
  "edit_run_id": "fd5b3480",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingClusterStateUpdateRequest.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingClusterStateUpdateRequest.java\nnew file mode 100644\nindex 00000000000..a0d212236f0\n--- /dev/null\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingClusterStateUpdateRequest.java\n@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to ElasticSearch and Shay Banon under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. ElasticSearch licenses this\n+ * file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.mapping.put;\n+\n+import org.elasticsearch.cluster.ack.IndicesClusterStateUpdateRequest;\n+\n+/**\n+ * Cluster state update request that allows to put a mapping\n+ */\n+public class PutMappingClusterStateUpdateRequest extends IndicesClusterStateUpdateRequest<PutMappingClusterStateUpdateRequest> {\n+\n+    private String type;\n+\n+    private String source;\n+\n+    private boolean ignoreConflicts = false;\n+\n+    PutMappingClusterStateUpdateRequest() {\n+\n+    }\n+\n+    public String type() {\n+        return type;\n+    }\n+\n+    public PutMappingClusterStateUpdateRequest type(String type) {\n+        this.type = type;\n+        return this;\n+    }\n+\n+    public String source() {\n+        return source;\n+    }\n+\n+    public PutMappingClusterStateUpdateRequest source(String source) {\n+        this.source = source;\n+        return this;\n+    }\n+\n+    public boolean ignoreConflicts() {\n+        return ignoreConflicts;\n+    }\n+\n+    public PutMappingClusterStateUpdateRequest ignoreConflicts(boolean ignoreConflicts) {\n+        this.ignoreConflicts = ignoreConflicts;\n+        return this;\n+    }\n+}\ndiff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java\nindex 9eb3352d999..6c2667ef179 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java\n@@ -23,21 +23,18 @@ import com.carrotsearch.hppc.ObjectOpenHashSet;\n import org.elasticsearch.ElasticSearchGenerationException;\n import org.elasticsearch.ElasticSearchIllegalArgumentException;\n import org.elasticsearch.action.ActionRequestValidationException;\n-import org.elasticsearch.action.support.master.MasterNodeOperationRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n-import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.common.xcontent.XContentFactory;\n import org.elasticsearch.common.xcontent.XContentType;\n \n import java.io.IOException;\n import java.util.Map;\n-import java.util.concurrent.TimeUnit;\n \n import static org.elasticsearch.action.ValidateActions.addValidationError;\n-import static org.elasticsearch.common.unit.TimeValue.readTimeValue;\n \n /**\n  * Puts mapping definition registered under a specific type into one or more indices. Best created with\n@@ -51,7 +48,7 @@ import static org.elasticsearch.common.unit.TimeValue.readTimeValue;\n  * @see org.elasticsearch.client.IndicesAdminClient#putMapping(PutMappingRequest)\n  * @see PutMappingResponse\n  */\n-public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequest> {\n+public class PutMappingRequest extends AcknowledgedRequest<PutMappingRequest> {\n \n     private static ObjectOpenHashSet<String> RESERVED_FIELDS = ObjectOpenHashSet.from(\n             \"_uid\", \"_id\", \"_type\", \"_source\",  \"_all\", \"_analyzer\", \"_boost\", \"_parent\", \"_routing\", \"_index\",\n@@ -64,8 +61,6 @@ public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequ\n \n     private String source;\n \n-    private TimeValue timeout = new TimeValue(10, TimeUnit.SECONDS);\n-\n     private boolean ignoreConflicts = false;\n \n     PutMappingRequest() {\n@@ -206,6 +201,7 @@ public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequ\n     /**\n      * The mapping source definition.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public PutMappingRequest source(Map mappingSource) {\n         try {\n             XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n@@ -224,31 +220,6 @@ public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequ\n         return this;\n     }\n \n-    /**\n-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to\n-     * <tt>10s</tt>.\n-     */\n-    TimeValue timeout() {\n-        return timeout;\n-    }\n-\n-    /**\n-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to\n-     * <tt>10s</tt>.\n-     */\n-    public PutMappingRequest timeout(TimeValue timeout) {\n-        this.timeout = timeout;\n-        return this;\n-    }\n-\n-    /**\n-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to\n-     * <tt>10s</tt>.\n-     */\n-    public PutMappingRequest timeout(String timeout) {\n-        return timeout(TimeValue.parseTimeValue(timeout, null));\n-    }\n-\n     /**\n      * If there is already a mapping definition registered against the type, then it will be merged. If there are\n      * elements that can't be merged are detected, the request will be rejected unless the\n@@ -274,7 +245,7 @@ public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequ\n         indices = in.readStringArray();\n         type = in.readOptionalString();\n         source = in.readString();\n-        timeout = readTimeValue(in);\n+        readTimeout(in);\n         ignoreConflicts = in.readBoolean();\n     }\n \n@@ -284,7 +255,7 @@ public class PutMappingRequest extends MasterNodeOperationRequest<PutMappingRequ\n         out.writeStringArrayNullable(indices);\n         out.writeOptionalString(type);\n         out.writeString(source);\n-        timeout.writeTo(out);\n+        writeTimeout(out);\n         out.writeBoolean(ignoreConflicts);\n     }\n }\ndiff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequestBuilder.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequestBuilder.java\nindex e93ca844a01..c9695fc9ade 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequestBuilder.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequestBuilder.java\n@@ -20,18 +20,17 @@\n package org.elasticsearch.action.admin.indices.mapping.put;\n \n import org.elasticsearch.action.ActionListener;\n-import org.elasticsearch.action.support.master.MasterNodeOperationRequestBuilder;\n+import org.elasticsearch.action.support.master.AcknowledgedRequestBuilder;\n import org.elasticsearch.client.IndicesAdminClient;\n import org.elasticsearch.client.internal.InternalIndicesAdminClient;\n-import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n \n import java.util.Map;\n \n /**\n- *\n+ * Builder for a put mapping request\n  */\n-public class PutMappingRequestBuilder extends MasterNodeOperationRequestBuilder<PutMappingRequest, PutMappingResponse, PutMappingRequestBuilder> {\n+public class PutMappingRequestBuilder extends AcknowledgedRequestBuilder<PutMappingRequest, PutMappingResponse, PutMappingRequestBuilder> {\n \n     public PutMappingRequestBuilder(IndicesAdminClient indicesClient) {\n         super((InternalIndicesAdminClient) indicesClient, new PutMappingRequest());\n@@ -83,24 +82,6 @@ public class PutMappingRequestBuilder extends MasterNodeOperationRequestBuilder<\n         return this;\n     }\n \n-    /**\n-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to\n-     * <tt>10s</tt>.\n-     */\n-    public PutMappingRequestBuilder setTimeout(TimeValue timeout) {\n-        request.timeout(timeout);\n-        return this;\n-    }\n-\n-    /**\n-     * Timeout to wait till the put mapping gets acknowledged of all current cluster nodes. Defaults to\n-     * <tt>10s</tt>.\n-     */\n-    public PutMappingRequestBuilder setTimeout(String timeout) {\n-        request.timeout(timeout);\n-        return this;\n-    }\n-\n     /**\n      * If there is already a mapping definition registered against the type, then it will be merged. If there are\n      * elements that can't be merged are detected, the request will be rejected unless the\ndiff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java\nindex 58edc44ab02..33160862ab5 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingResponse.java\n@@ -19,7 +19,7 @@\n \n package org.elasticsearch.action.admin.indices.mapping.put;\n \n-import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n \n@@ -28,35 +28,25 @@ import java.io.IOException;\n /**\n  * The response of put mapping operation.\n  */\n-public class PutMappingResponse extends ActionResponse {\n-\n-    private boolean acknowledged;\n+public class PutMappingResponse extends AcknowledgedResponse {\n \n     PutMappingResponse() {\n \n     }\n \n     PutMappingResponse(boolean acknowledged) {\n-        this.acknowledged = acknowledged;\n-    }\n-\n-    /**\n-     * Has the put mapping creation been acknowledged by all current cluster nodes within the\n-     * provided {@link PutMappingRequest#timeout(org.elasticsearch.common.unit.TimeValue)}.\n-     */\n-    public boolean isAcknowledged() {\n-        return acknowledged;\n+        super(acknowledged);\n     }\n \n     @Override\n     public void readFrom(StreamInput in) throws IOException {\n         super.readFrom(in);\n-        acknowledged = in.readBoolean();\n+        readAcknowledged(in);\n     }\n \n     @Override\n     public void writeTo(StreamOutput out) throws IOException {\n         super.writeTo(out);\n-        out.writeBoolean(acknowledged);\n+        writeAcknowledged(out);\n     }\n }\ndiff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java\nindex e12a4a5a922..270ca5a20d8 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java\n@@ -24,6 +24,8 @@ import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.support.master.TransportMasterNodeOperationAction;\n import org.elasticsearch.cluster.ClusterService;\n import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ack.ClusterStateUpdateListener;\n+import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;\n import org.elasticsearch.cluster.block.ClusterBlockException;\n import org.elasticsearch.cluster.block.ClusterBlockLevel;\n import org.elasticsearch.cluster.metadata.MetaDataMappingService;\n@@ -81,10 +83,16 @@ public class TransportPutMappingAction extends TransportMasterNodeOperationActio\n     @Override\n     protected void masterOperation(final PutMappingRequest request, final ClusterState state, final ActionListener<PutMappingResponse> listener) throws ElasticSearchException {\n \n-        metaDataMappingService.putMapping(new MetaDataMappingService.PutRequest(request.indices(), request.type(), request.source()).ignoreConflicts(request.ignoreConflicts()).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataMappingService.Listener() {\n+        PutMappingClusterStateUpdateRequest updateRequest = new PutMappingClusterStateUpdateRequest()\n+                .ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout())\n+                .indices(request.indices()).type(request.type())\n+                .source(request.source()).ignoreConflicts(request.ignoreConflicts());\n+\n+        metaDataMappingService.putMapping(updateRequest, new ClusterStateUpdateListener() {\n+\n             @Override\n-            public void onResponse(MetaDataMappingService.Response response) {\n-                listener.onResponse(new PutMappingResponse(response.acknowledged()));\n+            public void onResponse(ClusterStateUpdateResponse response) {\n+                listener.onResponse(new PutMappingResponse(response.isAcknowledged()));\n             }\n \n             @Override\ndiff --git a/src/main/java/org/elasticsearch/cluster/ClusterModule.java b/src/main/java/org/elasticsearch/cluster/ClusterModule.java\nindex 491deadf79a..5edfa236e04 100644\n--- a/src/main/java/org/elasticsearch/cluster/ClusterModule.java\n+++ b/src/main/java/org/elasticsearch/cluster/ClusterModule.java\n@@ -73,7 +73,6 @@ public class ClusterModule extends AbstractModule implements SpawnModules {\n         bind(ShardStateAction.class).asEagerSingleton();\n         bind(NodeIndexCreatedAction.class).asEagerSingleton();\n         bind(NodeIndexDeletedAction.class).asEagerSingleton();\n-        bind(NodeMappingCreatedAction.class).asEagerSingleton();\n         bind(NodeMappingRefreshAction.class).asEagerSingleton();\n         bind(MappingUpdatedAction.class).asEagerSingleton();\n \ndiff --git a/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java b/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java\nindex f8062700e57..f8cad2b88f8 100644\n--- a/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java\n+++ b/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java\n@@ -28,6 +28,8 @@ import org.elasticsearch.action.support.master.MasterNodeOperationRequest;\n import org.elasticsearch.action.support.master.TransportMasterNodeOperationAction;\n import org.elasticsearch.cluster.ClusterService;\n import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ack.ClusterStateUpdateListener;\n+import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.cluster.metadata.MetaDataMappingService;\n import org.elasticsearch.common.compress.CompressedString;\n@@ -78,9 +80,9 @@ public class MappingUpdatedAction extends TransportMasterNodeOperationAction<Map\n \n     @Override\n     protected void masterOperation(final MappingUpdatedRequest request, final ClusterState state, final ActionListener<MappingUpdatedResponse> listener) throws ElasticSearchException {\n-        metaDataMappingService.updateMapping(request.index(), request.indexUUID(), request.type(), request.mappingSource(), new MetaDataMappingService.Listener() {\n+        metaDataMappingService.updateMapping(request.index(), request.indexUUID(), request.type(), request.mappingSource(), new ClusterStateUpdateListener() {\n             @Override\n-            public void onResponse(MetaDataMappingService.Response response) {\n+            public void onResponse(ClusterStateUpdateResponse response) {\n                 listener.onResponse(new MappingUpdatedResponse());\n             }\n \ndiff --git a/src/main/java/org/elasticsearch/cluster/action/index/NodeMappingCreatedAction.java b/src/main/java/org/elasticsearch/cluster/action/index/NodeMappingCreatedAction.java\ndeleted file mode 100644\nindex d39c6e88ecc..00000000000\n--- a/src/main/java/org/elasticsearch/cluster/action/index/NodeMappingCreatedAction.java\n+++ /dev/null\n@@ -1,171 +0,0 @@\n-/*\n- * Licensed to ElasticSearch and Shay Banon under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. ElasticSearch licenses this\n- * file to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.cluster.action.index;\n-\n-import org.elasticsearch.ElasticSearchException;\n-import org.elasticsearch.cluster.ClusterState;\n-import org.elasticsearch.common.component.AbstractComponent;\n-import org.elasticsearch.common.inject.Inject;\n-import org.elasticsearch.common.io.stream.StreamInput;\n-import org.elasticsearch.common.io.stream.StreamOutput;\n-import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.common.unit.TimeValue;\n-import org.elasticsearch.threadpool.ThreadPool;\n-import org.elasticsearch.transport.*;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-\n-/**\n- *\n- */\n-public class NodeMappingCreatedAction extends AbstractComponent {\n-\n-    private final ThreadPool threadPool;\n-    private final TransportService transportService;\n-    private final List<Listener> listeners = new CopyOnWriteArrayList<Listener>();\n-\n-    @Inject\n-    public NodeMappingCreatedAction(Settings settings, ThreadPool threadPool, TransportService transportService) {\n-        super(settings);\n-        this.threadPool = threadPool;\n-        this.transportService = transportService;\n-        transportService.registerHandler(NodeMappingCreatedTransportHandler.ACTION, new NodeMappingCreatedTransportHandler());\n-    }\n-\n-    public void add(final Listener listener, TimeValue timeout) {\n-        listeners.add(listener);\n-        threadPool.schedule(timeout, ThreadPool.Names.GENERIC, new Runnable() {\n-            @Override\n-            public void run() {\n-                boolean removed = listeners.remove(listener);\n-                if (removed) {\n-                    listener.onTimeout();\n-                }\n-            }\n-        });\n-    }\n-\n-    public void remove(Listener listener) {\n-        listeners.remove(listener);\n-    }\n-\n-    public void nodeMappingCreated(final ClusterState state, final NodeMappingCreatedResponse response) throws ElasticSearchException {\n-        logger.debug(\"Sending mapping created for index {}, type {} (cluster state version: {})\", response.index, response.type, response.clusterStateVersion);\n-        if (state.nodes().localNodeMaster()) {\n-            threadPool.generic().execute(new Runnable() {\n-                @Override\n-                public void run() {\n-                    innerNodeIndexCreated(response);\n-                }\n-            });\n-        } else {\n-            transportService.sendRequest(state.nodes().masterNode(),\n-                    NodeMappingCreatedTransportHandler.ACTION, response, EmptyTransportResponseHandler.INSTANCE_SAME);\n-        }\n-    }\n-\n-    private void innerNodeIndexCreated(NodeMappingCreatedResponse response) {\n-        for (Listener listener : listeners) {\n-            listener.onNodeMappingCreated(response);\n-        }\n-    }\n-\n-\n-    public static interface Listener {\n-        void onNodeMappingCreated(NodeMappingCreatedResponse response);\n-\n-        void onTimeout();\n-    }\n-\n-    private class NodeMappingCreatedTransportHandler extends BaseTransportRequestHandler<NodeMappingCreatedResponse> {\n-\n-        static final String ACTION = \"cluster/nodeMappingCreated\";\n-\n-        @Override\n-        public NodeMappingCreatedResponse newInstance() {\n-            return new NodeMappingCreatedResponse();\n-        }\n-\n-        @Override\n-        public void messageReceived(NodeMappingCreatedResponse response, TransportChannel channel) throws Exception {\n-            innerNodeIndexCreated(response);\n-            channel.sendResponse(TransportResponse.Empty.INSTANCE);\n-        }\n-\n-        @Override\n-        public String executor() {\n-            return ThreadPool.Names.SAME;\n-        }\n-    }\n-\n-    public static class NodeMappingCreatedResponse extends TransportRequest {\n-\n-        private String index;\n-        private String type;\n-        private String nodeId;\n-        private long clusterStateVersion;\n-\n-        private NodeMappingCreatedResponse() {\n-        }\n-\n-        public NodeMappingCreatedResponse(String index, String type, String nodeId, long clusterStateVersion) {\n-            this.index = index;\n-            this.type = type;\n-            this.nodeId = nodeId;\n-            this.clusterStateVersion = clusterStateVersion;\n-        }\n-\n-        public String index() {\n-            return index;\n-        }\n-\n-        public String type() {\n-            return type;\n-        }\n-\n-        public String nodeId() {\n-            return nodeId;\n-        }\n-\n-        public long clusterStateVersion() {\n-            return clusterStateVersion;\n-        }\n-\n-        @Override\n-        public void writeTo(StreamOutput out) throws IOException {\n-            super.writeTo(out);\n-            out.writeString(index);\n-            out.writeString(type);\n-            out.writeString(nodeId);\n-            out.writeVLong(clusterStateVersion);\n-        }\n-\n-        @Override\n-        public void readFrom(StreamInput in) throws IOException {\n-            super.readFrom(in);\n-            index = in.readString();\n-            type = in.readString();\n-            nodeId = in.readString();\n-            clusterStateVersion = in.readVLong();\n-        }\n-    }\n-}\ndiff --git a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java\nindex 412fd86a8cf..9ca59f86968 100644\n--- a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java\n+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java\n@@ -23,13 +23,14 @@ import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import org.elasticsearch.action.admin.indices.mapping.delete.DeleteMappingClusterStateUpdateRequest;\n-import org.elasticsearch.action.support.master.MasterNodeOperationRequest;\n-import org.elasticsearch.cluster.*;\n+import org.elasticsearch.action.admin.indices.mapping.put.PutMappingClusterStateUpdateRequest;\n+import org.elasticsearch.cluster.AckedClusterStateUpdateTask;\n+import org.elasticsearch.cluster.ClusterService;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateUpdateTask;\n import org.elasticsearch.cluster.ack.ClusterStateUpdateListener;\n import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;\n-import org.elasticsearch.cluster.action.index.NodeMappingCreatedAction;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n-import org.elasticsearch.cluster.routing.IndexRoutingTable;\n import org.elasticsearch.common.Nullable;\n import org.elasticsearch.common.Priority;\n import org.elasticsearch.common.component.AbstractComponent;\n@@ -38,7 +39,6 @@ import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n-import org.elasticsearch.common.util.concurrent.CountDown;\n import org.elasticsearch.index.Index;\n import org.elasticsearch.index.mapper.DocumentMapper;\n import org.elasticsearch.index.mapper.MapperService;\n@@ -57,7 +57,7 @@ import static com.google.common.collect.Maps.newHashMap;\n import static org.elasticsearch.index.mapper.DocumentMapper.MergeFlags.mergeFlags;\n \n /**\n- *\n+ * Service responsible for submitting mapping changes\n  */\n public class MetaDataMappingService extends AbstractComponent {\n \n@@ -65,16 +65,13 @@ public class MetaDataMappingService extends AbstractComponent {\n \n     private final IndicesService indicesService;\n \n-    private final NodeMappingCreatedAction mappingCreatedAction;\n-\n     private final BlockingQueue<MappingTask> refreshOrUpdateQueue = ConcurrentCollections.newBlockingQueue();\n \n     @Inject\n-    public MetaDataMappingService(Settings settings, ClusterService clusterService, IndicesService indicesService, NodeMappingCreatedAction mappingCreatedAction) {\n+    public MetaDataMappingService(Settings settings, ClusterService clusterService, IndicesService indicesService) {\n         super(settings);\n         this.clusterService = clusterService;\n         this.indicesService = indicesService;\n-        this.mappingCreatedAction = mappingCreatedAction;\n     }\n \n     static class MappingTask {\n@@ -99,9 +96,9 @@ public class MetaDataMappingService extends AbstractComponent {\n     static class UpdateTask extends MappingTask {\n         final String type;\n         final CompressedString mappingSource;\n-        final Listener listener;\n+        final ClusterStateUpdateListener listener;\n \n-        UpdateTask(String index, String indexUUID, String type, CompressedString mappingSource, Listener listener) {\n+        UpdateTask(String index, String indexUUID, String type, CompressedString mappingSource, ClusterStateUpdateListener listener) {\n             super(index, indexUUID);\n             this.type = type;\n             this.mappingSource = mappingSource;\n@@ -247,7 +244,7 @@ public class MetaDataMappingService extends AbstractComponent {\n                 }\n                 for (Object task : tasks) {\n                     if (task instanceof UpdateTask) {\n-                        ((UpdateTask) task).listener.onResponse(new Response(true));\n+                        ((UpdateTask) task).listener.onResponse(new ClusterStateUpdateResponse(true));\n                     }\n                 }\n             }\n@@ -277,7 +274,7 @@ public class MetaDataMappingService extends AbstractComponent {\n         });\n     }\n \n-    public void updateMapping(final String index, final String indexUUID, final String type, final CompressedString mappingSource, final Listener listener) {\n+    public void updateMapping(final String index, final String indexUUID, final String type, final CompressedString mappingSource, final ClusterStateUpdateListener listener) {\n         refreshOrUpdateQueue.add(new UpdateTask(index, indexUUID, type, mappingSource, listener));\n         clusterService.submitStateUpdateTask(\"update-mapping [\" + index + \"][\" + type + \"]\", Priority.HIGH, new ClusterStateUpdateTask() {\n             @Override\n@@ -362,15 +359,33 @@ public class MetaDataMappingService extends AbstractComponent {\n         });\n     }\n \n-    public void putMapping(final PutRequest request, final Listener listener) {\n+    public void putMapping(final PutMappingClusterStateUpdateRequest request, final ClusterStateUpdateListener listener) {\n \n-        clusterService.submitStateUpdateTask(\"put-mapping [\" + request.mappingType + \"]\", Priority.HIGH, new TimeoutClusterStateUpdateTask() {\n+        clusterService.submitStateUpdateTask(\"put-mapping [\" + request.type() + \"]\", Priority.HIGH, new AckedClusterStateUpdateTask() {\n \n-            CountDownListener countDownListener; // used to count ack responses before confirming operation is complete\n+            @Override\n+            public boolean mustAck(DiscoveryNode discoveryNode) {\n+                return true;\n+            }\n+\n+            @Override\n+            public void onAllNodesAcked(@Nullable Throwable t) {\n+                listener.onResponse(new ClusterStateUpdateResponse(true));\n+            }\n+\n+            @Override\n+            public void onAckTimeout() {\n+                listener.onResponse(new ClusterStateUpdateResponse(false));\n+            }\n+\n+            @Override\n+            public TimeValue ackTimeout() {\n+                return request.ackTimeout();\n+            }\n \n             @Override\n             public TimeValue timeout() {\n-                return request.masterTimeout;\n+                return request.masterNodeTimeout();\n             }\n \n             @Override\n@@ -382,17 +397,17 @@ public class MetaDataMappingService extends AbstractComponent {\n             public ClusterState execute(final ClusterState currentState) throws Exception {\n                 List<String> indicesToClose = Lists.newArrayList();\n                 try {\n-                    if (request.indices.length == 0) {\n+                    if (request.indices().length == 0) {\n                         throw new IndexMissingException(new Index(\"_all\"));\n                     }\n-                    for (String index : request.indices) {\n+                    for (String index : request.indices()) {\n                         if (!currentState.metaData().hasIndex(index)) {\n                             throw new IndexMissingException(new Index(index));\n                         }\n                     }\n \n                     // pre create indices here and add mappings to them so we can merge the mappings here if needed\n-                    for (String index : request.indices) {\n+                    for (String index : request.indices()) {\n                         if (indicesService.hasIndex(index)) {\n                             continue;\n                         }\n@@ -404,29 +419,29 @@ public class MetaDataMappingService extends AbstractComponent {\n                             indexService.mapperService().merge(MapperService.DEFAULT_MAPPING, indexMetaData.mappings().get(MapperService.DEFAULT_MAPPING).source(), false);\n                         }\n                         // only add the current relevant mapping (if exists)\n-                        if (indexMetaData.mappings().containsKey(request.mappingType)) {\n-                            indexService.mapperService().merge(request.mappingType, indexMetaData.mappings().get(request.mappingType).source(), false);\n+                        if (indexMetaData.mappings().containsKey(request.type())) {\n+                            indexService.mapperService().merge(request.type(), indexMetaData.mappings().get(request.type()).source(), false);\n                         }\n                     }\n \n                     Map<String, DocumentMapper> newMappers = newHashMap();\n                     Map<String, DocumentMapper> existingMappers = newHashMap();\n-                    for (String index : request.indices) {\n+                    for (String index : request.indices()) {\n                         IndexService indexService = indicesService.indexService(index);\n                         if (indexService != null) {\n                             // try and parse it (no need to add it here) so we can bail early in case of parsing exception\n                             DocumentMapper newMapper;\n-                            DocumentMapper existingMapper = indexService.mapperService().documentMapper(request.mappingType);\n-                            if (MapperService.DEFAULT_MAPPING.equals(request.mappingType)) {\n+                            DocumentMapper existingMapper = indexService.mapperService().documentMapper(request.type());\n+                            if (MapperService.DEFAULT_MAPPING.equals(request.type())) {\n                                 // _default_ types do not go through merging, but we do test the new settings. Also don't apply the old default\n-                                newMapper = indexService.mapperService().parse(request.mappingType, new CompressedString(request.mappingSource), false);\n+                                newMapper = indexService.mapperService().parse(request.type(), new CompressedString(request.source()), false);\n                             } else {\n-                                newMapper = indexService.mapperService().parse(request.mappingType, new CompressedString(request.mappingSource));\n+                                newMapper = indexService.mapperService().parse(request.type(), new CompressedString(request.source()));\n                                 if (existingMapper != null) {\n                                     // first, simulate\n                                     DocumentMapper.MergeResult mergeResult = existingMapper.merge(newMapper, mergeFlags().simulate(true));\n                                     // if we have conflicts, and we are not supposed to ignore them, throw an exception\n-                                    if (!request.ignoreConflicts && mergeResult.hasConflicts()) {\n+                                    if (!request.ignoreConflicts() && mergeResult.hasConflicts()) {\n                                         throw new MergeMappingException(mergeResult.conflicts());\n                                     }\n                                 }\n@@ -442,7 +457,7 @@ public class MetaDataMappingService extends AbstractComponent {\n                         }\n                     }\n \n-                    String mappingType = request.mappingType;\n+                    String mappingType = request.type();\n                     if (mappingType == null) {\n                         mappingType = newMappers.values().iterator().next().type();\n                     } else if (!mappingType.equals(newMappers.values().iterator().next().type())) {\n@@ -489,12 +504,11 @@ public class MetaDataMappingService extends AbstractComponent {\n \n                     if (mappings.isEmpty()) {\n                         // no changes, return\n-                        listener.onResponse(new Response(true));\n                         return currentState;\n                     }\n \n                     MetaData.Builder builder = MetaData.builder(currentState.metaData());\n-                    for (String indexName : request.indices) {\n+                    for (String indexName : request.indices()) {\n                         IndexMetaData indexMetaData = currentState.metaData().index(indexName);\n                         if (indexMetaData == null) {\n                             throw new IndexMissingException(new Index(indexName));\n@@ -505,26 +519,7 @@ public class MetaDataMappingService extends AbstractComponent {\n                         }\n                     }\n \n-                    ClusterState updatedState = ClusterState.builder(currentState).metaData(builder).build();\n-\n-                    int counter = 1; // we want to wait on the master node to apply it on its cluster state\n-                    // also wait for nodes that actually have the index created on them to apply the mappings internally\n-                    for (String index : request.indices) {\n-                        IndexRoutingTable indexRoutingTable = updatedState.routingTable().index(index);\n-                        if (indexRoutingTable != null) {\n-                            counter += indexRoutingTable.numberOfNodesShardsAreAllocatedOn(updatedState.nodes().masterNodeId());\n-                        }\n-                    }\n-\n-                    logger.debug(\"Expecting {} mapping created responses for other nodes\", counter - 1);\n-\n-                    // TODO: adding one to the version is based on knowledge on how the parent class will increment the version\n-                    //       move this to the base class or add another callback before publishing the new cluster state so we\n-                    //       capture its version.\n-                    countDownListener = new CountDownListener(counter, currentState.version() + 1, listener);\n-                    mappingCreatedAction.add(countDownListener, request.timeout);\n-\n-                    return updatedState;\n+                    return ClusterState.builder(currentState).metaData(builder).build();\n                 } finally {\n                     for (String index : indicesToClose) {\n                         indicesService.removeIndex(index, \"created for mapping processing\");\n@@ -534,107 +529,8 @@ public class MetaDataMappingService extends AbstractComponent {\n \n             @Override\n             public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n-                if (countDownListener != null) {\n-                    // the master has applied it on its cluster state\n-                    countDownListener.decrementCounter();\n-                }\n-            }\n-        });\n-    }\n-\n-    public static interface Listener {\n-\n-        void onResponse(Response response);\n-\n-        void onFailure(Throwable t);\n-    }\n \n-    public static class PutRequest {\n-\n-        final String[] indices;\n-\n-        final String mappingType;\n-\n-        final String mappingSource;\n-\n-        boolean ignoreConflicts = false;\n-\n-        TimeValue timeout = TimeValue.timeValueSeconds(10);\n-        TimeValue masterTimeout = MasterNodeOperationRequest.DEFAULT_MASTER_NODE_TIMEOUT;\n-\n-        public PutRequest(String[] indices, String mappingType, String mappingSource) {\n-            this.indices = indices;\n-            this.mappingType = mappingType;\n-            this.mappingSource = mappingSource;\n-        }\n-\n-        public PutRequest ignoreConflicts(boolean ignoreConflicts) {\n-            this.ignoreConflicts = ignoreConflicts;\n-            return this;\n-        }\n-\n-        public PutRequest timeout(TimeValue timeout) {\n-            this.timeout = timeout;\n-            return this;\n-        }\n-\n-        public PutRequest masterTimeout(TimeValue masterTimeout) {\n-            this.masterTimeout = masterTimeout;\n-            return this;\n-        }\n-    }\n-\n-    public static class Response {\n-        private final boolean acknowledged;\n-\n-        public Response(boolean acknowledged) {\n-            this.acknowledged = acknowledged;\n-        }\n-\n-        public boolean acknowledged() {\n-            return acknowledged;\n-        }\n-    }\n-\n-    private class CountDownListener implements NodeMappingCreatedAction.Listener {\n-\n-        private final CountDown countDown;\n-        private final Listener listener;\n-        private final long minClusterStateVersion;\n-\n-        /**\n-         * @param countDown              initial counter value\n-         * @param minClusterStateVersion the minimum cluster state version for which accept responses\n-         * @param listener               listener to call when counter reaches 0.\n-         */\n-        public CountDownListener(int countDown, long minClusterStateVersion, Listener listener) {\n-            this.countDown = new CountDown(countDown);\n-            this.listener = listener;\n-            this.minClusterStateVersion = minClusterStateVersion;\n-        }\n-\n-        @Override\n-        public void onNodeMappingCreated(NodeMappingCreatedAction.NodeMappingCreatedResponse response) {\n-            if (response.clusterStateVersion() < minClusterStateVersion) {\n-                return;\n             }\n-            decrementCounter();\n-\n-        }\n-\n-        public void decrementCounter() {\n-            if (countDown.countDown()) {\n-                mappingCreatedAction.remove(this);\n-                listener.onResponse(new Response(true));\n-            }\n-        }\n-\n-        @Override\n-        public void onTimeout() {\n-            if (countDown.fastForward()) {\n-                mappingCreatedAction.remove(this);\n-                listener.onResponse(new Response(false));\n-            }\n-        }\n+        });\n     }\n }\ndiff --git a/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\nindex c92cb9120ce..b14c83d277c 100644\n--- a/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\n+++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\n@@ -30,7 +30,6 @@ import org.elasticsearch.cluster.ClusterService;\n import org.elasticsearch.cluster.ClusterStateListener;\n import org.elasticsearch.cluster.action.index.NodeIndexCreatedAction;\n import org.elasticsearch.cluster.action.index.NodeIndexDeletedAction;\n-import org.elasticsearch.cluster.action.index.NodeMappingCreatedAction;\n import org.elasticsearch.cluster.action.index.NodeMappingRefreshAction;\n import org.elasticsearch.cluster.action.shard.ShardStateAction;\n import org.elasticsearch.cluster.metadata.AliasMetaData;\n@@ -89,7 +88,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n     private final ShardStateAction shardStateAction;\n     private final NodeIndexCreatedAction nodeIndexCreatedAction;\n     private final NodeIndexDeletedAction nodeIndexDeletedAction;\n-    private final NodeMappingCreatedAction nodeMappingCreatedAction;\n     private final NodeMappingRefreshAction nodeMappingRefreshAction;\n \n     // a map of mappings type we have seen per index due to cluster state\n@@ -119,7 +117,7 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n                                       ThreadPool threadPool, RecoveryTarget recoveryTarget,\n                                       ShardStateAction shardStateAction,\n                                       NodeIndexCreatedAction nodeIndexCreatedAction, NodeIndexDeletedAction nodeIndexDeletedAction,\n-                                      NodeMappingCreatedAction nodeMappingCreatedAction, NodeMappingRefreshAction nodeMappingRefreshAction) {\n+                                      NodeMappingRefreshAction nodeMappingRefreshAction) {\n         super(settings);\n         this.indicesService = indicesService;\n         this.clusterService = clusterService;\n@@ -128,7 +126,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n         this.shardStateAction = shardStateAction;\n         this.nodeIndexCreatedAction = nodeIndexCreatedAction;\n         this.nodeIndexDeletedAction = nodeIndexDeletedAction;\n-        this.nodeMappingCreatedAction = nodeMappingCreatedAction;\n         this.nodeMappingRefreshAction = nodeMappingRefreshAction;\n     }\n \n@@ -357,7 +354,7 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n             MapperService mapperService = indexService.mapperService();\n             // first, go over and update the _default_ mapping (if exists)\n             if (indexMetaData.mappings().containsKey(MapperService.DEFAULT_MAPPING)) {\n-                processMapping(event, index, mapperService, MapperService.DEFAULT_MAPPING, indexMetaData.mapping(MapperService.DEFAULT_MAPPING).source());\n+                processMapping(index, mapperService, MapperService.DEFAULT_MAPPING, indexMetaData.mapping(MapperService.DEFAULT_MAPPING).source());\n             }\n \n             // go over and add the relevant mappings (or update them)\n@@ -368,7 +365,7 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n                 if (mappingType.equals(MapperService.DEFAULT_MAPPING)) { // we processed _default_ first\n                     continue;\n                 }\n-                boolean requireRefresh = processMapping(event, index, mapperService, mappingType, mappingSource);\n+                boolean requireRefresh = processMapping(index, mapperService, mappingType, mappingSource);\n                 if (requireRefresh) {\n                     if (typesToRefresh == null) {\n                         typesToRefresh = Lists.newArrayList();\n@@ -392,7 +389,7 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n         }\n     }\n \n-    private boolean processMapping(ClusterChangedEvent event, String index, MapperService mapperService, String mappingType, CompressedString mappingSource) {\n+    private boolean processMapping(String index, MapperService mapperService, String mappingType, CompressedString mappingSource) {\n         if (!seenMappings.containsKey(new Tuple<String, String>(index, mappingType))) {\n             seenMappings.put(new Tuple<String, String>(index, mappingType), true);\n         }\n@@ -410,8 +407,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n                     logger.debug(\"[{}] parsed mapping [{}], and got different sources\\noriginal:\\n{}\\nparsed:\\n{}\", index, mappingType, mappingSource, mapperService.documentMapper(mappingType).mappingSource());\n                     requiresRefresh = true;\n                 }\n-                nodeMappingCreatedAction.nodeMappingCreated(event.state(),\n-                        new NodeMappingCreatedAction.NodeMappingCreatedResponse(index, mappingType, event.state().nodes().localNodeId(), event.state().version()));\n             } else {\n                 DocumentMapper existingMapper = mapperService.documentMapper(mappingType);\n                 if (!mappingSource.equals(existingMapper.mappingSource())) {\n@@ -426,8 +421,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n                         // this might happen when upgrading from 0.15 to 0.16\n                         logger.debug(\"[{}] parsed mapping [{}], and got different sources\\noriginal:\\n{}\\nparsed:\\n{}\", index, mappingType, mappingSource, mapperService.documentMapper(mappingType).mappingSource());\n                     }\n-                    nodeMappingCreatedAction.nodeMappingCreated(event.state(),\n-                            new NodeMappingCreatedAction.NodeMappingCreatedResponse(index, mappingType, event.state().nodes().localNodeId(), event.state().version()));\n                 }\n             }\n         } catch (Throwable e) {\ndiff --git a/src/main/java/org/elasticsearch/rest/action/admin/indices/mapping/put/RestPutMappingAction.java b/src/main/java/org/elasticsearch/rest/action/admin/indices/mapping/put/RestPutMappingAction.java\nindex bd05b43b27b..a497ef96141 100644\n--- a/src/main/java/org/elasticsearch/rest/action/admin/indices/mapping/put/RestPutMappingAction.java\n+++ b/src/main/java/org/elasticsearch/rest/action/admin/indices/mapping/put/RestPutMappingAction.java\n@@ -19,24 +19,17 @@\n \n package org.elasticsearch.rest.action.admin.indices.mapping.put;\n \n-import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.admin.indices.mapping.put.PutMappingRequest;\n import org.elasticsearch.action.admin.indices.mapping.put.PutMappingResponse;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.rest.*;\n-import org.elasticsearch.rest.action.support.RestXContentBuilder;\n-\n-import java.io.IOException;\n \n import static org.elasticsearch.client.Requests.putMappingRequest;\n-import static org.elasticsearch.common.unit.TimeValue.timeValueSeconds;\n import static org.elasticsearch.rest.RestRequest.Method.POST;\n import static org.elasticsearch.rest.RestRequest.Method.PUT;\n-import static org.elasticsearch.rest.RestStatus.OK;\n \n /**\n  *\n@@ -59,32 +52,9 @@ public class RestPutMappingAction extends BaseRestHandler {\n         putMappingRequest.listenerThreaded(false);\n         putMappingRequest.type(request.param(\"type\"));\n         putMappingRequest.source(request.content().toUtf8());\n-        putMappingRequest.timeout(request.paramAsTime(\"timeout\", timeValueSeconds(10)));\n+        putMappingRequest.timeout(request.paramAsTime(\"timeout\", putMappingRequest.timeout()));\n         putMappingRequest.ignoreConflicts(request.paramAsBoolean(\"ignore_conflicts\", putMappingRequest.ignoreConflicts()));\n         putMappingRequest.masterNodeTimeout(request.paramAsTime(\"master_timeout\", putMappingRequest.masterNodeTimeout()));\n-        client.admin().indices().putMapping(putMappingRequest, new ActionListener<PutMappingResponse>() {\n-            @Override\n-            public void onResponse(PutMappingResponse response) {\n-                try {\n-                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n-                    builder.startObject()\n-                            .field(\"ok\", true)\n-                            .field(\"acknowledged\", response.isAcknowledged());\n-                    builder.endObject();\n-                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n-                } catch (IOException e) {\n-                    onFailure(e);\n-                }\n-            }\n-\n-            @Override\n-            public void onFailure(Throwable e) {\n-                try {\n-                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n-                } catch (IOException e1) {\n-                    logger.error(\"Failed to send failure response\", e1);\n-                }\n-            }\n-        });\n+        client.admin().indices().putMapping(putMappingRequest, new AcknowledgedRestResponseActionListener<PutMappingResponse>(request, channel, logger));\n     }\n }\ndiff --git a/src/test/java/org/elasticsearch/cluster/ack/AckTests.java b/src/test/java/org/elasticsearch/cluster/ack/AckTests.java\nindex a4bbf4ac0c6..516f68e9df0 100644\n--- a/src/test/java/org/elasticsearch/cluster/ack/AckTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/ack/AckTests.java\n@@ -30,6 +30,7 @@ import org.elasticsearch.action.admin.indices.alias.IndicesAliasesResponse;\n import org.elasticsearch.action.admin.indices.close.CloseIndexResponse;\n import org.elasticsearch.action.admin.indices.mapping.delete.DeleteMappingResponse;\n import org.elasticsearch.action.admin.indices.mapping.get.GetMappingsResponse;\n+import org.elasticsearch.action.admin.indices.mapping.put.PutMappingResponse;\n import org.elasticsearch.action.admin.indices.open.OpenIndexResponse;\n import org.elasticsearch.action.admin.indices.settings.UpdateSettingsResponse;\n import org.elasticsearch.action.admin.indices.warmer.get.GetWarmersResponse;\n@@ -451,6 +452,27 @@ public class AckTests extends ElasticsearchIntegrationTest {\n         assertThat(openIndexResponse.isAcknowledged(), equalTo(false));\n     }\n \n+    @Test\n+    public void testPutMappingAcknowledgement() {\n+        createIndex(\"test\");\n+        ensureGreen();\n+\n+        assertAcked(client().admin().indices().preparePutMapping(\"test\").setType(\"test\").setSource(\"field\", \"type=string,index=not_analyzed\"));\n+\n+        for (Client client : clients()) {\n+            assertThat(getLocalClusterState(client).metaData().indices().get(\"test\").mapping(\"test\"), notNullValue());\n+        }\n+    }\n+\n+    @Test\n+    public void testPutMappingNoAcknowledgement() {\n+        createIndex(\"test\");\n+        ensureGreen();\n+\n+        PutMappingResponse putMappingResponse = client().admin().indices().preparePutMapping(\"test\").setType(\"test\").setSource(\"field\", \"type=string,index=not_analyzed\").setTimeout(\"0s\").get();\n+        assertThat(putMappingResponse.isAcknowledged(), equalTo(false));\n+    }\n+\n     private static ClusterState getLocalClusterState(Client client) {\n         return client.admin().cluster().prepareState().setLocal(true).get().getState();\n     }\ndiff --git a/src/test/java/org/elasticsearch/test/hamcrest/ElasticsearchAssertions.java b/src/test/java/org/elasticsearch/test/hamcrest/ElasticsearchAssertions.java\nindex 57fad0dde06..3fa71527c60 100644\n--- a/src/test/java/org/elasticsearch/test/hamcrest/ElasticsearchAssertions.java\n+++ b/src/test/java/org/elasticsearch/test/hamcrest/ElasticsearchAssertions.java\n@@ -75,15 +75,6 @@ public class ElasticsearchAssertions {\n         assertVersionSerializable(response);\n     }\n \n-    public static void assertAcked(PutMappingRequestBuilder builder) {\n-        assertAcked(builder.get());\n-    }\n-\n-    private static void assertAcked(PutMappingResponse response) {\n-        assertThat(\"Put Mapping failed - not acked\", response.isAcknowledged(), equalTo(true));\n-        assertVersionSerializable(response);\n-    }\n-\n     public static void assertAcked(DeleteIndexRequestBuilder builder) {\n         assertAcked(builder.get());\n     }"
}