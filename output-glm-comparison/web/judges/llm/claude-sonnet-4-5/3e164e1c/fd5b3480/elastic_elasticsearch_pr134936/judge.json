{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134936,
  "base_commit": "0d0c0ad2354f522d2dbd3ecd2db295f3cf085ba0",
  "head_commit": "e75974063e20ef78b33d4b25344493d87a09fe1a",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.3,
    "completeness": -0.4,
    "code_reuse": -0.5,
    "best_practices": 0.0,
    "unsolicited_docs": 1.0
  },
  "aggregate": -0.039999999999999994,
  "rationale": "The agent correctly adds UnmodifiableIngestSet and wraps Sets in wrapUnmodifiable, but has significant issues: (1) Missing UnmodifiableIterator class extraction - the ground truth refactors UnmodifiableIngestList to use a shared UnmodifiableIterator, but the agent duplicates the iterator logic inline in UnmodifiableIngestSet; (2) Missing the refactoring of UnmodifiableIngestList.iterator() to use UnmodifiableIterator; (3) Incomplete test coverage - missing 4 critical test assertions from ground truth (Map mutation tests, nested List-in-Set tests, and deeply nested List-in-List-in-Set test); (4) Missing @SuppressWarnings(\"unchecked\") annotation on assertMutatingCtxThrows; (5) Missing the changelog file docs/changelog/134936.yaml; (6) Adds unnecessary toArray methods with wrapping logic not present in ground truth, and adds unnecessary equals/hashCode overrides. The core security fix for Sets is correct, but the poor code reuse (duplicating iterator logic instead of extracting UnmodifiableIterator) and incomplete testing significantly reduce quality.",
  "edit_run_id": "fd5b3480",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/docs/changelog/134936.yaml b/docs/changelog/134936.yaml\nnew file mode 100644\nindex 00000000000..d9ff3aef5c0\n--- /dev/null\n+++ b/docs/changelog/134936.yaml\n@@ -0,0 +1,5 @@\n+pr: 134936\n+summary: Fixing conditional processor mutability bugs\n+area: Ingest Node\n+type: bug\n+issues: []\ndiff --git a/server/src/main/java/org/elasticsearch/ingest/ConditionalProcessor.java b/server/src/main/java/org/elasticsearch/ingest/ConditionalProcessor.java\nindex 24e093d5e18..9582279bfbe 100644\n--- a/server/src/main/java/org/elasticsearch/ingest/ConditionalProcessor.java\n+++ b/server/src/main/java/org/elasticsearch/ingest/ConditionalProcessor.java\n@@ -158,6 +158,8 @@ public class ConditionalProcessor extends AbstractProcessor implements WrappingP\n             return new UnmodifiableIngestData((Map<String, Object>) raw);\n         } else if (raw instanceof List) {\n             return new UnmodifiableIngestList((List<Object>) raw);\n+        } else if (raw instanceof Set<?> rawSet) {\n+            return new UnmodifiableIngestSet((Set<Object>) rawSet);\n         } else if (raw instanceof byte[] bytes) {\n             return bytes.clone();\n         }\n@@ -287,23 +289,7 @@ public class ConditionalProcessor extends AbstractProcessor implements WrappingP\n \n         @Override\n         public Iterator<Object> iterator() {\n-            Iterator<Object> wrapped = data.iterator();\n-            return new Iterator<Object>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return wrapped.hasNext();\n-                }\n-\n-                @Override\n-                public Object next() {\n-                    return wrapped.next();\n-                }\n-\n-                @Override\n-                public void remove() {\n-                    throw unmodifiableException();\n-                }\n-            };\n+            return new UnmodifiableIterator(data.iterator());\n         }\n \n         @Override\n@@ -465,4 +451,100 @@ public class ConditionalProcessor extends AbstractProcessor implements WrappingP\n             }\n         }\n     }\n+\n+    private static final class UnmodifiableIngestSet implements Set<Object> {\n+        private final Set<Object> data;\n+\n+        UnmodifiableIngestSet(Set<Object> data) {\n+            this.data = data;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return data.size();\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return data.isEmpty();\n+        }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+            return data.contains(o);\n+        }\n+\n+        @Override\n+        public Iterator<Object> iterator() {\n+            return new UnmodifiableIterator(data.iterator());\n+        }\n+\n+        @Override\n+        public Object[] toArray() {\n+            return data.toArray();\n+        }\n+\n+        @Override\n+        public <T> T[] toArray(T[] a) {\n+            return data.toArray(a);\n+        }\n+\n+        @Override\n+        public boolean add(Object o) {\n+            throw unmodifiableException();\n+        }\n+\n+        @Override\n+        public boolean remove(Object o) {\n+            throw unmodifiableException();\n+        }\n+\n+        @Override\n+        public boolean containsAll(Collection<?> c) {\n+            return data.containsAll(c);\n+        }\n+\n+        @Override\n+        public boolean addAll(Collection<?> c) {\n+            throw unmodifiableException();\n+        }\n+\n+        @Override\n+        public boolean retainAll(Collection<?> c) {\n+            throw unmodifiableException();\n+        }\n+\n+        @Override\n+        public boolean removeAll(Collection<?> c) {\n+            throw unmodifiableException();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            throw unmodifiableException();\n+        }\n+    }\n+\n+    private static final class UnmodifiableIterator implements Iterator<Object> {\n+        private final Iterator<Object> it;\n+\n+        UnmodifiableIterator(Iterator<Object> it) {\n+            this.it = it;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return it.hasNext();\n+        }\n+\n+        @Override\n+        public Object next() {\n+            return wrapUnmodifiable(it.next());\n+        }\n+\n+        @Override\n+        public void remove() {\n+            throw unmodifiableException();\n+        }\n+    }\n }\ndiff --git a/server/src/test/java/org/elasticsearch/ingest/ConditionalProcessorTests.java b/server/src/test/java/org/elasticsearch/ingest/ConditionalProcessorTests.java\nindex 1317233d310..144036ce80e 100644\n--- a/server/src/test/java/org/elasticsearch/ingest/ConditionalProcessorTests.java\n+++ b/server/src/test/java/org/elasticsearch/ingest/ConditionalProcessorTests.java\n@@ -26,8 +26,10 @@ import org.elasticsearch.test.ESTestCase;\n import java.text.ParseException;\n import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.function.BiConsumer;\n@@ -141,6 +143,14 @@ public class ConditionalProcessorTests extends ESTestCase {\n         assertMutatingCtxThrows(ctx -> ctx.put(\"foo\", \"bar\"));\n         assertMutatingCtxThrows(ctx -> ((List<Object>) ctx.get(\"listField\")).add(\"bar\"));\n         assertMutatingCtxThrows(ctx -> ((List<Object>) ctx.get(\"listField\")).remove(\"bar\"));\n+        assertMutatingCtxThrows(ctx -> ((Map<String, Object>) ctx.get(\"mapField\")).put(\"bar\", \"baz\"));\n+        assertMutatingCtxThrows(ctx -> ((Map<?, ?>) ctx.get(\"mapField\")).remove(\"bar\"));\n+        assertMutatingCtxThrows(ctx -> ((Set<Object>) ctx.get(\"setField\")).add(\"bar\"));\n+        assertMutatingCtxThrows(ctx -> ((Set<Object>) ctx.get(\"setField\")).remove(\"bar\"));\n+        assertMutatingCtxThrows(ctx -> ((List<Object>) ((Set<Object>) ctx.get(\"setField\")).iterator().next()).add(\"bar\"));\n+        assertMutatingCtxThrows(\n+            ctx -> ((List<Object>) ((List<Object>) ((Set<Object>) ctx.get(\"setField\")).iterator().next()).iterator().next()).add(\"bar\")\n+        );\n     }\n \n     public void testPrecompiledError() {\n@@ -194,6 +204,7 @@ public class ConditionalProcessorTests extends ESTestCase {\n         execProcessor(processor, ingestDoc, (doc, e) -> { assertThat(e.getMessage(), equalTo(\"runtime problem\")); });\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private static void assertMutatingCtxThrows(Consumer<Map<String, Object>> mutation) throws Exception {\n         String scriptName = \"conditionalScript\";\n         PlainActionFuture<Exception> expectedException = new PlainActionFuture<>();\n@@ -221,6 +232,11 @@ public class ConditionalProcessorTests extends ESTestCase {\n         );\n         IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random(), document);\n         ingestDocument.setFieldValue(\"listField\", new ArrayList<>());\n+        ingestDocument.setFieldValue(\"mapField\", new HashMap<>());\n+        ingestDocument.setFieldValue(\"setField\", new HashSet<>());\n+        List<Object> listWithinSet = new ArrayList<>();\n+        listWithinSet.add(new ArrayList<>());\n+        ingestDocument.getFieldValue(\"setField\", Set.class).add(listWithinSet);\n         execProcessor(processor, ingestDocument, (result, e) -> {});\n         Exception e = safeGet(expectedException);\n         assertThat(e, instanceOf(UnsupportedOperationException.class));"
}