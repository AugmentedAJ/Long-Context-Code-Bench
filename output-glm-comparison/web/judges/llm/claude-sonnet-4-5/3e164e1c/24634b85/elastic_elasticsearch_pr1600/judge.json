{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 1600,
  "base_commit": "ed8a46ce09ccf43adec55af91a72fc9c5dc1ec05",
  "head_commit": "682176497f9f454943d2373dc24501ad37b8dbb0",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.6,
    "completeness": -0.5,
    "code_reuse": -0.2,
    "best_practices": -0.3,
    "unsolicited_docs": 0.0
  },
  "aggregate": -0.32,
  "rationale": "The agent's implementation has several critical issues compared to the ground truth: (1) Missing TimeValue import needed for TTL parsing, (2) Missing getDate timestamp for TTL calculation, (3) Fails to extract timestamp from script context ctx.get('_timestamp'), instead incorrectly reading from existing document fields, (4) Fails to extract TTL from script context ctx.get('_ttl') with proper Number/String parsing, (5) Fails to implement TTL preservation logic with time adjustment when TTL is not set in script, (6) Does not set .ttl() on IndexRequest, (7) Keeps TimestampFieldMapper in get() call instead of replacing with TTLFieldMapper. The agent adds TTLFieldMapper to the get() call but keeps TimestampFieldMapper (ground truth replaces it), extracts timestamp from wrong source (document fields vs script context), and completely omits the core TTL handling logic including parsing from script context and time-based recalculation. The comment about 'TTL field stores expiration timestamp' shows a fundamental misunderstanding of the implementation requirements. These are not minor differences but missing core functionality that would prevent timestamp and TTL handling from working as intended.",
  "edit_run_id": "24634b85",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\nindex 5a296cdf925..ae9eea79b9f 100644\n--- a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\n+++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\n@@ -43,6 +43,7 @@ import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.common.collect.Tuple;\n import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.xcontent.XContentHelper;\n import org.elasticsearch.common.xcontent.XContentType;\n import org.elasticsearch.index.engine.DocumentMissingException;\n@@ -52,7 +53,7 @@ import org.elasticsearch.index.get.GetResult;\n import org.elasticsearch.index.mapper.internal.ParentFieldMapper;\n import org.elasticsearch.index.mapper.internal.RoutingFieldMapper;\n import org.elasticsearch.index.mapper.internal.SourceFieldMapper;\n-import org.elasticsearch.index.mapper.internal.TimestampFieldMapper;\n+import org.elasticsearch.index.mapper.internal.TTLFieldMapper;\n import org.elasticsearch.index.service.IndexService;\n import org.elasticsearch.index.shard.IllegalIndexShardStateException;\n import org.elasticsearch.index.shard.ShardId;\n@@ -152,8 +153,9 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         IndexService indexService = indicesService.indexServiceSafe(request.index());\n         IndexShard indexShard = indexService.shardSafe(request.shardId());\n \n+        long getDate = System.currentTimeMillis();\n         GetResult getResult = indexShard.getService().get(request.type(), request.id(),\n-                new String[]{SourceFieldMapper.NAME, RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TimestampFieldMapper.NAME}, true);\n+                new String[]{SourceFieldMapper.NAME, RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TTLFieldMapper.NAME}, true);\n \n         // no doc, what to do, what to do...\n         if (!getResult.exists()) {\n@@ -183,12 +185,28 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         }\n \n         String operation = (String) ctx.get(\"op\");\n+        String timestamp = (String) ctx.get(\"_timestamp\");\n+        Long ttl = null;\n+        Object fetchedTTL = ctx.get(\"_ttl\");\n+        if (fetchedTTL != null) {\n+            if (fetchedTTL instanceof Number) {\n+                ttl = ((Number) fetchedTTL).longValue();\n+            } else {\n+                ttl = TimeValue.parseTimeValue((String) fetchedTTL, null).millis();\n+            }\n+        }\n         source = (Map<String, Object>) ctx.get(\"_source\");\n \n         // apply script to update the source\n         String routing = getResult.fields().containsKey(RoutingFieldMapper.NAME) ? getResult.field(RoutingFieldMapper.NAME).value().toString() : null;\n         String parent = getResult.fields().containsKey(ParentFieldMapper.NAME) ? getResult.field(ParentFieldMapper.NAME).value().toString() : null;\n-        // TODO ttl/timestamp\n+        // No TTL has been given in the update script so we keep previous TTL value if there is one\n+        if (ttl == null) {\n+            ttl = getResult.fields().containsKey(TTLFieldMapper.NAME) ? (Long) getResult.field(TTLFieldMapper.NAME).value() : null;\n+            if (ttl != null) {\n+                ttl = ttl - (System.currentTimeMillis() - getDate); // It is an approximation of exact TTL value, could be improved\n+            }\n+        }\n \n         // TODO percolate?\n \n@@ -197,7 +215,8 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         if (operation == null || \"index\".equals(operation)) {\n             IndexRequest indexRequest = Requests.indexRequest(request.index()).type(request.type()).id(request.id()).routing(routing).parent(parent)\n                     .source(source, sourceAndContent.v1())\n-                    .version(getResult.version()).replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel());\n+                    .version(getResult.version()).replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel())\n+                    .timestamp(timestamp).ttl(ttl);\n             indexRequest.operationThreaded(false);\n             indexAction.execute(indexRequest, new ActionListener<IndexResponse>() {\n                 @Override"
}