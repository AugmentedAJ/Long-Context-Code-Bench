{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4225,
  "base_commit": "81e13a870b112ad2921e1627bb3aabab48bf763c",
  "head_commit": "937a4e9d9d01ca88fce3b8d0d68e9e37d2d02927",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.9,
    "completeness": -0.95,
    "code_reuse": -0.8,
    "best_practices": -0.7,
    "unsolicited_docs": 1.0
  },
  "aggregate": -0.4700000000000001,
  "rationale": "The agent's diff only modifies a test file (GeoFilterTests.java) to use SloppyMath.haversinMeters() instead of the manual calculation, but completely misses the core task requirement. The ground truth replaces the manual haversin calculation in the production code (GeoDistance.java) with SloppyMath.haversin(), including both the ARC enum's calculate() method and the ArcFixedSourceDistance class. The agent failed to touch the main GeoDistance.java file at all, which is where the actual manual haversin implementation exists. Additionally, the agent used haversinMeters() while ground truth uses haversin() with unit conversion, showing a different API usage. The ground truth also adds constants to GeoUtils.java and creates comprehensive tests in SloppyMathTests.java - all missing from the agent's output. This represents a fundamental misunderstanding of the task scope, addressing only a test helper function rather than the production geo distance calculation logic.",
  "edit_run_id": "24634b85",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/common/geo/GeoDistance.java b/src/main/java/org/elasticsearch/common/geo/GeoDistance.java\nindex 0ded5587e84..b26fb285dc7 100644\n--- a/src/main/java/org/elasticsearch/common/geo/GeoDistance.java\n+++ b/src/main/java/org/elasticsearch/common/geo/GeoDistance.java\n@@ -19,6 +19,7 @@\n \n package org.elasticsearch.common.geo;\n \n+import org.apache.lucene.util.SloppyMath;\n import org.elasticsearch.ElasticSearchIllegalArgumentException;\n import org.elasticsearch.common.unit.DistanceUnit;\n \n@@ -75,18 +76,7 @@ public enum GeoDistance {\n     ARC() {\n         @Override\n         public double calculate(double sourceLatitude, double sourceLongitude, double targetLatitude, double targetLongitude, DistanceUnit unit) {\n-            double longitudeDifference = targetLongitude - sourceLongitude;\n-            double a = Math.toRadians(90D - sourceLatitude);\n-            double c = Math.toRadians(90D - targetLatitude);\n-            double factor = (Math.cos(a) * Math.cos(c)) + (Math.sin(a) * Math.sin(c) * Math.cos(Math.toRadians(longitudeDifference)));\n-\n-            if (factor < -1D) {\n-                return Math.PI * unit.getEarthRadius();\n-            } else if (factor >= 1D) {\n-                return 0;\n-            } else {\n-                return Math.acos(factor) * unit.getEarthRadius();\n-            }\n+            return unit.fromMeters(SloppyMath.haversin(sourceLatitude, sourceLongitude, targetLatitude, targetLongitude) * 1000.0);\n         }\n \n         @Override\n@@ -288,39 +278,21 @@ public enum GeoDistance {\n         }\n     }\n \n-\n     public static class ArcFixedSourceDistance implements FixedSourceDistance {\n \n         private final double sourceLatitude;\n         private final double sourceLongitude;\n-        private final double earthRadius;\n-\n-        private final double a;\n-        private final double sinA;\n-        private final double cosA;\n+        private final DistanceUnit unit;\n \n         public ArcFixedSourceDistance(double sourceLatitude, double sourceLongitude, DistanceUnit unit) {\n             this.sourceLatitude = sourceLatitude;\n             this.sourceLongitude = sourceLongitude;\n-            this.earthRadius = unit.getEarthRadius();\n-            this.a = Math.toRadians(90D - sourceLatitude);\n-            this.sinA = Math.sin(a);\n-            this.cosA = Math.cos(a);\n+            this.unit = unit;\n         }\n \n         @Override\n         public double calculate(double targetLatitude, double targetLongitude) {\n-            double longitudeDifference = targetLongitude - sourceLongitude;\n-            double c = Math.toRadians(90D - targetLatitude);\n-            double factor = (cosA * Math.cos(c)) + (sinA * Math.sin(c) * Math.cos(Math.toRadians(longitudeDifference)));\n-\n-            if (factor < -1D) {\n-                return Math.PI * earthRadius;\n-            } else if (factor >= 1D) {\n-                return 0;\n-            } else {\n-                return Math.acos(factor) * earthRadius;\n-            }\n+            return unit.fromMeters(SloppyMath.haversin(sourceLatitude, sourceLongitude, targetLatitude, targetLongitude) * 1000.0);\n         }\n     }\n }\ndiff --git a/src/main/java/org/elasticsearch/common/geo/GeoUtils.java b/src/main/java/org/elasticsearch/common/geo/GeoUtils.java\nindex 2964aa910dc..381f252a560 100644\n--- a/src/main/java/org/elasticsearch/common/geo/GeoUtils.java\n+++ b/src/main/java/org/elasticsearch/common/geo/GeoUtils.java\n@@ -32,13 +32,19 @@ public class GeoUtils {\n \n     /** Earth ellipsoid minor axis defined by WGS 84 in meters */\n     public static final double EARTH_SEMI_MINOR_AXIS = 6356752.314245; // meters (WGS 84)\n-    \n+\n+    /** Earth mean radius defined by WGS 84 in meters */\n+    public static final double EARTH_MEAN_RADIUS = 6371008.7714D;      // meters (WGS 84)\n+\n+    /** Earth axis ratio defined by WGS 84 (0.996647189335) */\n+    public static final double EARTH_AXIS_RATIO = EARTH_SEMI_MINOR_AXIS / EARTH_SEMI_MAJOR_AXIS;\n+\n     /** Earth ellipsoid equator length in meters */\n     public static final double EARTH_EQUATOR = 2*Math.PI * EARTH_SEMI_MAJOR_AXIS;\n \n     /** Earth ellipsoid polar distance in meters */\n     public static final double EARTH_POLAR_DISTANCE = Math.PI * EARTH_SEMI_MINOR_AXIS;\n-    \n+\n     /**\n      * Calculate the width (in meters) of geohash cells at a specific level \n      * @param level geohash level must be greater or equal to zero \ndiff --git a/src/test/java/org/apache/lucene/util/SloppyMathTests.java b/src/test/java/org/apache/lucene/util/SloppyMathTests.java\nnew file mode 100644\nindex 00000000000..dbead96c0cc\n--- /dev/null\n+++ b/src/test/java/org/apache/lucene/util/SloppyMathTests.java\n@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to ElasticSearch and Shay Banon under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. ElasticSearch licenses this\n+ * file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.lucene.util;\n+\n+import org.elasticsearch.common.geo.GeoDistance;\n+import org.elasticsearch.common.geo.GeoUtils;\n+import org.elasticsearch.common.unit.DistanceUnit;\n+import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.junit.Test;\n+\n+import static org.hamcrest.number.IsCloseTo.closeTo;\n+\n+public class SloppyMathTests extends ElasticsearchTestCase {\n+\n+    @Test\n+    public void testAccuracy() {\n+        for (double lat1 = -90; lat1 <= 90; lat1+=1) {\n+            final double lon1 = randomLongitude();\n+\n+            for (double i = -180; i <= 180; i+=1) {\n+                final double lon2 = i;\n+                final double lat2 = randomLatitude();\n+\n+                assertAccurate(lat1, lon1, lat2, lon2);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testSloppyMath() {\n+        assertThat(GeoDistance.ARC.calculate(-46.645, -171.057, -46.644, -171.058, DistanceUnit.METERS), closeTo(134.87709, maxError(134.87709)));\n+        assertThat(GeoDistance.ARC.calculate(-77.912, -81.173, -77.912, -81.171, DistanceUnit.METERS), closeTo(46.57161, maxError(46.57161)));\n+        assertThat(GeoDistance.ARC.calculate(65.75, -20.708, 65.75, -20.709, DistanceUnit.METERS), closeTo(45.66996, maxError(45.66996)));\n+        assertThat(GeoDistance.ARC.calculate(-86.9, 53.738, -86.9, 53.741, DistanceUnit.METERS), closeTo(18.03998, maxError(18.03998)));\n+        assertThat(GeoDistance.ARC.calculate(89.041, 115.93, 89.04, 115.946, DistanceUnit.METERS), closeTo(115.11711, maxError(115.11711)));\n+        \n+        testSloppyMath(DistanceUnit.METERS, 0.01, 5, 45, 90);\n+        testSloppyMath(DistanceUnit.KILOMETERS, 0.01, 5, 45, 90);\n+        testSloppyMath(DistanceUnit.INCH, 0.01, 5, 45, 90);\n+        testSloppyMath(DistanceUnit.MILES, 0.01, 5, 45, 90);\n+    }\n+\n+    private static double maxError(double distance) {\n+        return distance / 10000.0;\n+    }\n+    \n+    private void testSloppyMath(DistanceUnit unit, double...deltaDeg) {\n+        final double lat1 = randomLatitude();\n+        final double lon1 = randomLongitude();\n+        logger.info(\"testing SloppyMath with {} at \\\"{}, {}\\\"\", unit, lat1, lon1);\n+\n+        GeoDistance.ArcFixedSourceDistance src = new GeoDistance.ArcFixedSourceDistance(lat1, lon1, unit); \n+\n+        for (int test = 0; test < deltaDeg.length; test++) {\n+            for (int i = 0; i < 100; i++) {\n+                final double lon2 = lon1 + (randomDouble() - 0.5) * 2 * deltaDeg[test];\n+                final double lat2 = lat1 + (randomDouble() - 0.5) * 2 * deltaDeg[test];\n+    \n+                final double accurate = unit.fromMeters(accurateHaversin(lat1, lon1, lat2, lon2));\n+                final double dist1 = GeoDistance.ARC.calculate(lat1, lon1, lat2, lon2, unit);\n+                final double dist2 = src.calculate(lat2, lon2);\n+    \n+                assertThat(\"distance between(\"+lat1+\", \"+lon1+\") and (\"+lat2+\", \"+lon2+\"))\", dist1, closeTo(accurate, maxError(accurate)));\n+                assertThat(\"distance between(\"+lat1+\", \"+lon1+\") and (\"+lat2+\", \"+lon2+\"))\", dist2, closeTo(accurate, maxError(accurate)));\n+            }\n+        }\n+    }\n+    \n+    // Slow but accurate implementation of the haversin function\n+    private static double accurateHaversin(double lat1, double lon1, double lat2, double lon2) {\n+        double longitudeDifference = lon2 - lon1;\n+        double a = Math.toRadians(90D - lat1);\n+        double c = Math.toRadians(90D - lat2);\n+        double factor = (Math.cos(a) * Math.cos(c)) + (Math.sin(a) * Math.sin(c) * Math.cos(Math.toRadians(longitudeDifference)));\n+\n+        if (factor < -1D) {\n+            return Math.PI * GeoUtils.EARTH_MEAN_RADIUS;\n+        } else if (factor >= 1D) {\n+            return 0;\n+        } else {\n+            return Math.acos(factor) * GeoUtils.EARTH_MEAN_RADIUS;\n+        }\n+    }\n+    \n+    private static void assertAccurate(double lat1, double lon1, double lat2, double lon2) {\n+        double accurate = accurateHaversin(lat1, lon1, lat2, lon2);\n+        double sloppy = GeoDistance.ARC.calculate(lat1, lon1, lat2, lon2, DistanceUnit.METERS);\n+        assertThat(\"distance between(\"+lat1+\", \"+lon1+\") and (\"+lat2+\", \"+lon2+\"))\", sloppy, closeTo(accurate, maxError(accurate)));\n+    }\n+\n+    private static final double randomLatitude() {\n+        return (getRandom().nextDouble() - 0.5) * 180d;\n+    }\n+\n+    private static final double randomLongitude() {\n+        return (getRandom().nextDouble() - 0.5) * 360d;\n+    }\n+}"
}