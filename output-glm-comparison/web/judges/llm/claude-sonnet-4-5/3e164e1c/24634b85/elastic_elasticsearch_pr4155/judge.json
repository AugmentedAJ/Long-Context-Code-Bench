{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4155,
  "base_commit": "16ee74268240118c59b64ea3ee2ee854c7566505",
  "head_commit": "1e06c76467b16b4c673dbac2cc0d567d396f010b",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -1.0,
    "completeness": -1.0,
    "code_reuse": 0.0,
    "best_practices": 0.0,
    "unsolicited_docs": 0.0
  },
  "aggregate": -0.4,
  "rationale": "The agent produced an empty diff, making no changes whatsoever to the codebase. The ground truth demonstrates a critical bug fix: wrapping the semaphore-protected code in a try-finally block with a success flag to ensure the semaphore is released when client.bulk() throws an exception (not just when the async callbacks fail). The task explicitly requested fixing a resource leak where 'the semaphore in BulkProcessor is not being released when client.bulk throws an exception.' The agent failed to implement any part of this fix - no try-finally restructuring, no success flag, no semaphore.release() in the exception path. This is a complete failure on correctness (no bug fix implemented) and completeness (0% of required changes made). Code reuse, best practices, and unsolicited docs are scored as neutral/0.0 since no code was written at all.",
  "edit_run_id": "24634b85",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/action/bulk/BulkProcessor.java b/src/main/java/org/elasticsearch/action/bulk/BulkProcessor.java\nindex b8fb83a02c8..a850cfc2ae0 100644\n--- a/src/main/java/org/elasticsearch/action/bulk/BulkProcessor.java\n+++ b/src/main/java/org/elasticsearch/action/bulk/BulkProcessor.java\n@@ -276,32 +276,39 @@ public class BulkProcessor {\n                 listener.afterBulk(executionId, bulkRequest, e);\n             }\n         } else {\n+            boolean success = false;\n             try {\n                 semaphore.acquire();\n+                listener.beforeBulk(executionId, bulkRequest);\n+                client.bulk(bulkRequest, new ActionListener<BulkResponse>() {\n+                    @Override\n+                    public void onResponse(BulkResponse response) {\n+                        try {\n+                            listener.afterBulk(executionId, bulkRequest, response);\n+                        } finally {\n+                            semaphore.release();\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Throwable e) {\n+                        try {\n+                            listener.afterBulk(executionId, bulkRequest, e);\n+                        } finally {\n+                            semaphore.release();\n+                        }\n+                    }\n+                });\n+                success = true;\n             } catch (InterruptedException e) {\n+                Thread.interrupted();\n                 listener.afterBulk(executionId, bulkRequest, e);\n-                return;\n+            } finally {\n+                 if (!success) {  // if we fail on client.bulk() release the semaphore\n+                     semaphore.release();\n+                 }\n             }\n-            listener.beforeBulk(executionId, bulkRequest);\n-            client.bulk(bulkRequest, new ActionListener<BulkResponse>() {\n-                @Override\n-                public void onResponse(BulkResponse response) {\n-                    try {\n-                        listener.afterBulk(executionId, bulkRequest, response);\n-                    } finally {\n-                        semaphore.release();\n-                    }\n-                }\n \n-                @Override\n-                public void onFailure(Throwable e) {\n-                    try {\n-                        listener.afterBulk(executionId, bulkRequest, e);\n-                    } finally {\n-                        semaphore.release();\n-                    }\n-                }\n-            });\n         }\n     }\n "
}