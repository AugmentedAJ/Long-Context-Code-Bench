{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4419,
  "base_commit": "4e7ce4ee02a85ca02b8a07a27ae4e82341e2db39",
  "head_commit": "173a91bb4615c5a98c2347ea2f08d15b1b60d46a",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.6,
    "completeness": -0.7,
    "code_reuse": -0.8,
    "best_practices": -0.7,
    "unsolicited_docs": 0.0
  },
  "aggregate": -0.5599999999999999,
  "rationale": "The agent's implementation has several critical issues compared to ground truth: (1) Missing the `changeState()` helper method that centralizes state change logic and lifecycle notifications - ground truth refactors all state changes to use this method, but agent duplicates notification code at every call site; (2) Missing the initial 'shard created' notification in InternalIndexService.java; (3) Missing the complete test file IndicesLifecycleListenerTests.java that validates the functionality; (4) Method naming inconsistency - agent uses 'shardStateChanged' while ground truth uses 'indexShardStateChanged' (more consistent with existing naming like 'afterIndexShardCreated'); (5) Different method signature - ground truth passes current state via indexShard.state() in the implementation rather than as a parameter; (6) Poor code reuse - agent adds 6 separate oldState captures and lifecycle calls instead of centralizing in a single changeState() method, violating DRY principle. The agent implements the basic notification mechanism but misses the key refactoring that makes the solution maintainable and complete.",
  "edit_run_id": "24634b85",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/index/service/InternalIndexService.java b/src/main/java/org/elasticsearch/index/service/InternalIndexService.java\nindex 5e63e25e362..26dcb24ee28 100644\n--- a/src/main/java/org/elasticsearch/index/service/InternalIndexService.java\n+++ b/src/main/java/org/elasticsearch/index/service/InternalIndexService.java\n@@ -351,6 +351,7 @@ public class InternalIndexService extends AbstractIndexComponent implements Inde\n \n         IndexShard indexShard = shardInjector.getInstance(IndexShard.class);\n \n+        indicesLifecycle.indexShardStateChanged(indexShard, null, \"shard created\");\n         indicesLifecycle.afterIndexShardCreated(indexShard);\n \n         shards = newMapBuilder(shards).put(shardId.id(), indexShard).immutableMap();\ndiff --git a/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java b/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java\nindex 1eaf50f6d32..3e841c1775e 100644\n--- a/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java\n+++ b/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java\n@@ -289,8 +289,7 @@ public class InternalIndexShard extends AbstractIndexShardComponent implements I\n                 synchronized (mutex) {\n                     // do the check under a mutex, so we make sure to only change to STARTED if in POST_RECOVERY\n                     if (state == IndexShardState.POST_RECOVERY) {\n-                        logger.debug(\"state: [{}]->[{}], reason [global state is [{}]]\", state, IndexShardState.STARTED, newRouting.state());\n-                        state = IndexShardState.STARTED;\n+                        changeState(IndexShardState.STARTED, \"global state is [\" + newRouting.state() + \"]\");\n                         movedToStarted = true;\n                     } else {\n                         logger.debug(\"state [{}] not changed, not in POST_RECOVERY, global state is [{}]\", state, newRouting.state());\n@@ -314,7 +313,6 @@ public class InternalIndexShard extends AbstractIndexShardComponent implements I\n     public IndexShardState recovering(String reason) throws IndexShardStartedException,\n             IndexShardRelocatedException, IndexShardRecoveringException, IndexShardClosedException {\n         synchronized (mutex) {\n-            IndexShardState returnValue = state;\n             if (state == IndexShardState.CLOSED) {\n                 throw new IndexShardClosedException(shardId);\n             }\n@@ -330,9 +328,7 @@ public class InternalIndexShard extends AbstractIndexShardComponent implements I\n             if (state == IndexShardState.POST_RECOVERY) {\n                 throw new IndexShardRecoveringException(shardId);\n             }\n-            logger.debug(\"state: [{}]->[{}], reason [{}]\", state, IndexShardState.RECOVERING, reason);\n-            state = IndexShardState.RECOVERING;\n-            return returnValue;\n+            return changeState(IndexShardState.RECOVERING, reason);\n         }\n     }\n \n@@ -341,8 +337,7 @@ public class InternalIndexShard extends AbstractIndexShardComponent implements I\n             if (state != IndexShardState.STARTED) {\n                 throw new IndexShardNotStartedException(shardId, state);\n             }\n-            logger.debug(\"state: [{}]->[{}], reason [{}]\", state, IndexShardState.RELOCATED, reason);\n-            state = IndexShardState.RELOCATED;\n+            changeState(IndexShardState.RELOCATED, reason);\n         }\n         return this;\n     }\n@@ -352,6 +347,20 @@ public class InternalIndexShard extends AbstractIndexShardComponent implements I\n         return state;\n     }\n \n+    /**\n+     * Changes the state of the current shard\n+     * @param newState the new shard state\n+     * @param reason the reason for the state change\n+     * @return the previous shard state\n+     */\n+    private IndexShardState changeState(IndexShardState newState, String reason) {\n+        logger.debug(\"state: [{}]->[{}], reason [{}]\", state, newState, reason);\n+        IndexShardState previousState = state;\n+        state = newState;\n+        this.indicesLifecycle.indexShardStateChanged(this, previousState, reason);\n+        return previousState;\n+    }\n+\n     @Override\n     public Engine.Create prepareCreate(SourceToParse source) throws ElasticSearchException {\n         long startTime = System.nanoTime();\n@@ -653,10 +662,7 @@ public class InternalIndexShard extends AbstractIndexShardComponent implements I\n                     mergeScheduleFuture = null;\n                 }\n             }\n-            if (logger.isDebugEnabled()) {\n-                logger.debug(\"state: [{}]->[{}], reason [{}]\", state, IndexShardState.CLOSED, reason);\n-            }\n-            state = IndexShardState.CLOSED;\n+            changeState(IndexShardState.CLOSED, reason);\n         }\n     }\n \n@@ -681,8 +687,7 @@ public class InternalIndexShard extends AbstractIndexShardComponent implements I\n             }\n             engine.start();\n             startScheduledTasksIfNeeded();\n-            logger.debug(\"state: [{}]->[{}], reason [{}]\", state, IndexShardState.POST_RECOVERY, reason);\n-            state = IndexShardState.POST_RECOVERY;\n+            changeState(IndexShardState.POST_RECOVERY, reason);\n         }\n         indicesLifecycle.afterIndexShardPostRecovery(this);\n         return this;\n@@ -725,8 +730,7 @@ public class InternalIndexShard extends AbstractIndexShardComponent implements I\n         translog.clearUnreferenced();\n         engine.refresh(new Engine.Refresh(\"recovery_finalization\").force(true));\n         synchronized (mutex) {\n-            logger.debug(\"state: [{}]->[{}], reason [post recovery]\", state, IndexShardState.POST_RECOVERY);\n-            state = IndexShardState.POST_RECOVERY;\n+            changeState(IndexShardState.POST_RECOVERY, \"post recovery\");\n         }\n         indicesLifecycle.afterIndexShardPostRecovery(this);\n         startScheduledTasksIfNeeded();\ndiff --git a/src/main/java/org/elasticsearch/indices/IndicesLifecycle.java b/src/main/java/org/elasticsearch/indices/IndicesLifecycle.java\nindex 9c95dd56133..978ac25a777 100644\n--- a/src/main/java/org/elasticsearch/indices/IndicesLifecycle.java\n+++ b/src/main/java/org/elasticsearch/indices/IndicesLifecycle.java\n@@ -23,6 +23,7 @@ import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.common.Nullable;\n import org.elasticsearch.index.Index;\n import org.elasticsearch.index.service.IndexService;\n+import org.elasticsearch.index.shard.IndexShardState;\n import org.elasticsearch.index.shard.ShardId;\n import org.elasticsearch.index.shard.service.IndexShard;\n \n@@ -132,6 +133,19 @@ public interface IndicesLifecycle {\n         public void afterIndexShardClosed(ShardId shardId) {\n \n         }\n+\n+        /**\n+         * Called after a shard's {@link org.elasticsearch.index.shard.IndexShardState} changes.\n+         * The order of concurrent events is preserved. The execution must be lightweight.\n+         *\n+         * @param indexShard the shard the new state was applied to\n+         * @param previousState the previous index shard state if there was one, null otherwise\n+         * @param currentState the new shard state\n+         * @param reason the reason for the state change if there is one, null otherwise\n+         */\n+        public void indexShardStateChanged(IndexShard indexShard, @Nullable IndexShardState previousState, IndexShardState currentState, @Nullable String reason) {\n+\n+        }\n     }\n \n }\ndiff --git a/src/main/java/org/elasticsearch/indices/InternalIndicesLifecycle.java b/src/main/java/org/elasticsearch/indices/InternalIndicesLifecycle.java\nindex b196f9ed1e2..b933d87853b 100644\n--- a/src/main/java/org/elasticsearch/indices/InternalIndicesLifecycle.java\n+++ b/src/main/java/org/elasticsearch/indices/InternalIndicesLifecycle.java\n@@ -26,6 +26,7 @@ import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.index.Index;\n import org.elasticsearch.index.service.IndexService;\n+import org.elasticsearch.index.shard.IndexShardState;\n import org.elasticsearch.index.shard.ShardId;\n import org.elasticsearch.index.shard.service.IndexShard;\n \n@@ -160,4 +161,14 @@ public class InternalIndicesLifecycle extends AbstractComponent implements Indic\n             }\n         }\n     }\n+\n+    public void indexShardStateChanged(IndexShard indexShard, @Nullable IndexShardState previousState, @Nullable String reason) {\n+        for (Listener listener : listeners) {\n+            try {\n+                listener.indexShardStateChanged(indexShard, previousState, indexShard.state(), reason);\n+            } catch (Throwable t) {\n+                logger.warn(\"{} failed to invoke index shard state changed callback\", t, indexShard.shardId());\n+            }\n+        }\n+    }\n }\ndiff --git a/src/test/java/org/elasticsearch/indices/IndicesLifecycleListenerTests.java b/src/test/java/org/elasticsearch/indices/IndicesLifecycleListenerTests.java\nnew file mode 100644\nindex 00000000000..9db1d0b367b\n--- /dev/null\n+++ b/src/test/java/org/elasticsearch/indices/IndicesLifecycleListenerTests.java\n@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to ElasticSearch and Shay Banon under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. ElasticSearch licenses this\n+ * file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.elasticsearch.indices;\n+\n+import com.google.common.collect.Maps;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.index.shard.IndexShardState;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.shard.service.IndexShard;\n+import org.elasticsearch.test.ElasticsearchIntegrationTest;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.cluster.routing.allocation.decider.DisableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_DISABLE_ALLOCATION;\n+import static org.elasticsearch.common.settings.ImmutableSettings.builder;\n+import static org.elasticsearch.index.shard.IndexShardState.*;\n+import static org.elasticsearch.test.ElasticsearchIntegrationTest.ClusterScope;\n+import static org.elasticsearch.test.ElasticsearchIntegrationTest.Scope;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+\n+@ClusterScope(scope = Scope.TEST, numNodes = 0)\n+public class IndicesLifecycleListenerTests extends ElasticsearchIntegrationTest {\n+\n+    @Test\n+    public void testIndexStateShardChanged() throws Throwable {\n+\n+        //start with a single node\n+        String node1 = cluster().startNode();\n+        IndexShardStateChangeListener stateChangeListenerNode1 = new IndexShardStateChangeListener();\n+        //add a listener that keeps track of the shard state changes\n+        cluster().getInstance(IndicesLifecycle.class, node1).addListener(stateChangeListenerNode1);\n+\n+        //create an index\n+        assertAcked(client().admin().indices().prepareCreate(\"test\")\n+                .setSettings(SETTING_NUMBER_OF_SHARDS, 6, SETTING_NUMBER_OF_REPLICAS, 0));\n+        ensureGreen();\n+\n+        //new shards got started\n+        assertShardStatesMatch(stateChangeListenerNode1, 6, CREATED, RECOVERING, POST_RECOVERY, STARTED);\n+\n+\n+        //add a node: 3 out of the 6 shards will be relocated to it\n+        //disable allocation before starting a new node, as we need to register the listener first\n+        assertAcked(client().admin().cluster().prepareUpdateSettings()\n+                .setPersistentSettings(builder().put(CLUSTER_ROUTING_ALLOCATION_DISABLE_ALLOCATION, true)));\n+        String node2 = cluster().startNode();\n+        IndexShardStateChangeListener stateChangeListenerNode2 = new IndexShardStateChangeListener();\n+        //add a listener that keeps track of the shard state changes\n+        cluster().getInstance(IndicesLifecycle.class, node2).addListener(stateChangeListenerNode2);\n+        //re-enable allocation\n+        assertAcked(client().admin().cluster().prepareUpdateSettings()\n+                .setPersistentSettings(builder().put(CLUSTER_ROUTING_ALLOCATION_DISABLE_ALLOCATION, false)));\n+        ensureGreen();\n+\n+        //the 3 relocated shards get closed on the first node\n+        assertShardStatesMatch(stateChangeListenerNode1, 3, CLOSED);\n+        //the 3 relocated shards get created on the second node\n+        assertShardStatesMatch(stateChangeListenerNode2, 3, CREATED, RECOVERING, POST_RECOVERY, STARTED);\n+\n+\n+        //increase replicas from 0 to 1\n+        assertAcked(client().admin().indices().prepareUpdateSettings(\"test\").setSettings(builder().put(SETTING_NUMBER_OF_REPLICAS, 1)));\n+        ensureGreen();\n+\n+        //3 replicas are allocated to the first node\n+        assertShardStatesMatch(stateChangeListenerNode1, 3, CREATED, RECOVERING, POST_RECOVERY, STARTED);\n+\n+        //3 replicas are allocated to the second node\n+        assertShardStatesMatch(stateChangeListenerNode2, 3, CREATED, RECOVERING, POST_RECOVERY, STARTED);\n+\n+\n+        //close the index\n+        assertAcked(client().admin().indices().prepareClose(\"test\"));\n+\n+        assertShardStatesMatch(stateChangeListenerNode1, 6, CLOSED);\n+        assertShardStatesMatch(stateChangeListenerNode2, 6, CLOSED);\n+    }\n+\n+    private static void assertShardStatesMatch(IndexShardStateChangeListener stateChangeListener, int numShards, IndexShardState... shardStates) {\n+        assertThat(stateChangeListener.shardStates.size(), equalTo(numShards));\n+        for (List<IndexShardState> indexShardStates : stateChangeListener.shardStates.values()) {\n+            assertThat(indexShardStates, notNullValue());\n+            assertThat(indexShardStates.size(), equalTo(shardStates.length));\n+            for (int i = 0; i < shardStates.length; i++) {\n+                assertThat(indexShardStates.get(i), equalTo(shardStates[i]));\n+            }\n+        }\n+        stateChangeListener.shardStates.clear();\n+    }\n+\n+    private static class IndexShardStateChangeListener extends IndicesLifecycle.Listener {\n+        //we keep track of all the states (ordered) a shard goes through\n+        final ConcurrentMap<ShardId, List<IndexShardState>> shardStates = Maps.newConcurrentMap();\n+\n+        @Override\n+        public void indexShardStateChanged(IndexShard indexShard, @Nullable IndexShardState previousState, IndexShardState newState, @Nullable String reason) {\n+            List<IndexShardState> shardStates = this.shardStates.putIfAbsent(indexShard.shardId(),\n+                    new CopyOnWriteArrayList<IndexShardState>(new IndexShardState[]{newState}));\n+            if (shardStates != null) {\n+                shardStates.add(newState);\n+            }\n+        }\n+    }\n+}"
}