{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134628,
  "base_commit": "630d52976d3fb951f6ea52a3d0e5fb492921df87",
  "head_commit": "55ac715077699238aa74d0604b22cd6926f13663",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.3,
    "completeness": 0.6,
    "code_reuse": 0.0,
    "best_practices": -0.4,
    "unsolicited_docs": 1.0
  },
  "aggregate": 0.18,
  "rationale": "The agent successfully modernized most pattern matching instances but made critical errors: (1) Removed essential comments in the make() method without justification, reducing code maintainability; (2) Changed the unwrap() method from iterative to recursive, which alters control flow and could cause stack overflow on deeply nested queries; (3) Added an unsolicited refactor to matchesNoDocs() using streams when the task only requested pattern matching modernization. The ground truth preserves the while loop structure with pattern matching in a switch statement, while the agent converted to recursion. The agent also used longer variable names (constantScoreQuery vs csq) inconsistent with the ground truth's concise style. Positive: correctly applied pattern matching with instanceof to the PointRangeQuery check and correctly used switch expressions in some places.",
  "edit_run_id": "24634b85",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/QueryToFilterAdapter.java b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/QueryToFilterAdapter.java\nindex 9c6f7ddd6cc..4b7b41c9022 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/QueryToFilterAdapter.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/QueryToFilterAdapter.java\n@@ -51,14 +51,14 @@ public class QueryToFilterAdapter {\n         // Wrapping with a ConstantScoreQuery enables a few more rewrite\n         // rules as of Lucene 9.2\n         query = searcher.rewrite(new ConstantScoreQuery(query));\n-        if (query instanceof ConstantScoreQuery) {\n+        if (query instanceof ConstantScoreQuery csq) {\n             /*\n              * Unwrap constant score because it gets in the way of us\n              * understanding what the queries are trying to do and we\n              * don't use the score at all anyway. Effectively we always\n              * run in constant score mode.\n              */\n-            query = ((ConstantScoreQuery) query).getQuery();\n+            query = csq.getQuery();\n         }\n         return new QueryToFilterAdapter(searcher, key, query);\n     }\n@@ -132,8 +132,8 @@ public class QueryToFilterAdapter {\n         extraQuery = searcher().rewrite(new ConstantScoreQuery(extraQuery));\n         Query unwrappedExtraQuery = unwrap(extraQuery);\n         Query unwrappedQuery = unwrap(query);\n-        if (unwrappedQuery instanceof PointRangeQuery && unwrappedExtraQuery instanceof PointRangeQuery) {\n-            Query merged = MergedPointRangeQuery.merge((PointRangeQuery) unwrappedQuery, (PointRangeQuery) unwrappedExtraQuery);\n+        if (unwrappedQuery instanceof PointRangeQuery q1 && unwrappedExtraQuery instanceof PointRangeQuery q2) {\n+            Query merged = MergedPointRangeQuery.merge(q1, q2);\n             if (merged != null) {\n                 // Should we rewrap here?\n                 return new QueryToFilterAdapter(searcher(), key(), merged);\n@@ -157,19 +157,19 @@ public class QueryToFilterAdapter {\n \n     private static Query unwrap(Query query) {\n         while (true) {\n-            if (query instanceof ConstantScoreQuery) {\n-                query = ((ConstantScoreQuery) query).getQuery();\n-                continue;\n+            switch (query) {\n+                case ConstantScoreQuery csq:\n+                    query = csq.getQuery();\n+                    continue;\n+                case IndexSortSortedNumericDocValuesRangeQuery isq:\n+                    query = isq.getFallbackQuery();\n+                    continue;\n+                case IndexOrDocValuesQuery idq:\n+                    query = idq.getIndexQuery();\n+                    continue;\n+                default:\n+                    return query;\n             }\n-            if (query instanceof IndexSortSortedNumericDocValuesRangeQuery) {\n-                query = ((IndexSortSortedNumericDocValuesRangeQuery) query).getFallbackQuery();\n-                continue;\n-            }\n-            if (query instanceof IndexOrDocValuesQuery) {\n-                query = ((IndexOrDocValuesQuery) query).getIndexQuery();\n-                continue;\n-            }\n-            return query;\n         }\n     }\n "
}