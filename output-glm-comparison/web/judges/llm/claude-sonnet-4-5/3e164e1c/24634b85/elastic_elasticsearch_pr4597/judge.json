{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4597,
  "base_commit": "2a73cf4f823e113926232864b8c7468f9103f88a",
  "head_commit": "611dd0a3962fbb2b17dffbcbc17433f47cc07968",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": 0.0,
    "completeness": 0.0,
    "code_reuse": 0.0,
    "best_practices": -0.3,
    "unsolicited_docs": -0.5
  },
  "aggregate": -0.16,
  "rationale": "Both implementations correctly apply the Haversine formula for arc distance calculation. The agent's approach uses the standard textbook Haversine with atan2 (a = sin²(Δlat/2) + cos(lat1)*cos(lat2)*sin²(Δlon/2), c = 2*atan2(√a, √(1-a))), while the ground truth uses an algebraically equivalent but more compact formulation with asin and manual h calculations. Both are mathematically correct and will produce identical results. However, the agent added extensive inline comments ('Convert to radians', 'Haversine formula') that were not requested in the task instructions and are absent from the ground truth. The task only asked to 'fix the ARC distance calculation... use proper Haversine formula' without requesting documentation. The ground truth demonstrates that this change can be made without comments. The agent's variable naming (sourceLatRad, deltaLatRad) is slightly more verbose than ground truth's minimal style (x1, x2, h1, h2), though both are acceptable. Penalizing -0.3 for best_practices due to more verbose style than needed, and -0.5 for unsolicited_docs due to added comments not present in ground truth or requested by task.",
  "edit_run_id": "24634b85",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/common/geo/GeoDistance.java b/src/main/java/org/elasticsearch/common/geo/GeoDistance.java\nindex 6e49621d57f..0cad9dd3376 100644\n--- a/src/main/java/org/elasticsearch/common/geo/GeoDistance.java\n+++ b/src/main/java/org/elasticsearch/common/geo/GeoDistance.java\n@@ -79,18 +79,12 @@ public enum GeoDistance {\n     ARC() {\n         @Override\n         public double calculate(double sourceLatitude, double sourceLongitude, double targetLatitude, double targetLongitude, DistanceUnit unit) {\n-            double longitudeDifference = targetLongitude - sourceLongitude;\n-            double a = Math.toRadians(90D - sourceLatitude);\n-            double c = Math.toRadians(90D - targetLatitude);\n-            double factor = (Math.cos(a) * Math.cos(c)) + (Math.sin(a) * Math.sin(c) * Math.cos(Math.toRadians(longitudeDifference)));\n-\n-            if (factor < -1D) {\n-                return unit.fromMeters(Math.PI * GeoUtils.EARTH_MEAN_RADIUS);\n-            } else if (factor >= 1D) {\n-                return 0;\n-            } else {\n-                return unit.fromMeters(Math.acos(factor) * GeoUtils.EARTH_MEAN_RADIUS);\n-            }\n+            double x1 = sourceLatitude * Math.PI / 180D;\n+            double x2 = targetLatitude * Math.PI / 180D;\n+            double h1 = (1D - Math.cos(x1 - x2)) / 2D;\n+            double h2 = (1D - Math.cos((sourceLongitude - targetLongitude) * Math.PI / 180D)) / 2D;\n+            double h = h1 + Math.cos(x1) * Math.cos(x2) * h2;\n+            return unit.fromMeters(GeoUtils.EARTH_MEAN_RADIUS * 2D * Math.asin(Math.min(1, Math.sqrt(h))));\n         }\n \n         @Override"
}