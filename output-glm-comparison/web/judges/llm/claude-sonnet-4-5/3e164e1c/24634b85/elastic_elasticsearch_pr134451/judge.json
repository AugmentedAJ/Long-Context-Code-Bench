{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134451,
  "base_commit": "fc5a7efb564eb387866cf6d00997c435a21f9d69",
  "head_commit": "5b267fe291d068b6ee370b3394a6327bf63bdc9a",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": 0.0,
    "completeness": -0.9,
    "code_reuse": 0.0,
    "best_practices": -0.3,
    "unsolicited_docs": 1.0
  },
  "aggregate": -0.039999999999999994,
  "rationale": "The agent correctly fixed the equals() and hashCode() methods in SourceConfirmedTextQuery to only compare the inner query (correctness: 0.0, matches ground truth). However, the agent made a critical omission: it completely missed the mandatory changelog files (docs/changelog/131111.yaml and docs/changelog/134451.yaml), the massive docs/redirects.yml changes, the new test file FieldCapabilitiesRequestSemanticIndexFilterTests.java, the FieldCapabilitiesRequest.java validation logic additions, and the muted-tests.yml update. The agent only modified 2 files (SourceConfirmedTextQuery.java and SourceConfirmedTextQueryTests.java) out of 7 files in the ground truth, missing approximately 80% of the required changes (completeness: -0.9). The test updates the agent did make are reasonable - converting SOURCE_FETCHER_PROVIDER to a method and updating assertions to expect equality when only inner queries differ - but these deviate from ground truth's approach which added a new test case instead of modifying existing assertions (best_practices: -0.3 for diverging from expected test pattern). Code reuse is appropriate (0.0). No unsolicited documentation was added (1.0).",
  "edit_run_id": "24634b85",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/docs/changelog/131111.yaml b/docs/changelog/131111.yaml\nnew file mode 100644\nindex 00000000000..ac5d950a3d3\n--- /dev/null\n+++ b/docs/changelog/131111.yaml\n@@ -0,0 +1,5 @@\n+pr: 131111\n+summary: Don't allow field caps to use semantic queries as index filters\n+area: Search\n+type: bug\n+issues: []\ndiff --git a/docs/changelog/134451.yaml b/docs/changelog/134451.yaml\nnew file mode 100644\nindex 00000000000..94fec239548\n--- /dev/null\n+++ b/docs/changelog/134451.yaml\n@@ -0,0 +1,6 @@\n+pr: 134451\n+summary: Use inner query for equals/hashCode() in `SourceConfirmedTextQuery`\n+area: \"Search\"\n+type: bug\n+issues:\n+ - 134432\ndiff --git a/docs/redirects.yml b/docs/redirects.yml\nindex 5d0c161511b..60b18ccc8ec 100644\n--- a/docs/redirects.yml\n+++ b/docs/redirects.yml\n@@ -99,9 +99,52 @@ redirects:\n       - to: 'reference/elasticsearch/rest-apis/rescore-search-results.md'\n         anchors: {'multiple-rescores'}\n \n-  'reference/query-languages/esql/kibana/docs/functions/st_geohash_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n-  'reference/query-languages/esql/kibana/docs/functions/st_geotile_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n-  'reference/query-languages/esql/kibana/docs/functions/st_geohex_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n-  'reference/query-languages/esql/kibana/docs/functions/st_geohash_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n-  'reference/query-languages/esql/kibana/docs/functions/st_geotile_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n-  'reference/query-languages/esql/kibana/docs/functions/st_geohex_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  # Dummy redirects for deleted snippets to get round a bug in redirects validation\n+  'docs/reference/query-languages/esql/_snippets/functions/description/st_geohash_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/description/st_geotile_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/description/st_geohex_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/description/st_geohash_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/description/st_geotile_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/description/st_geohex_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/examples/st_geohash_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/examples/st_geotile_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/examples/st_geohex_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/examples/st_geohash_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/examples/st_geotile_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/examples/st_geohex_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/layout/st_geohash_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/layout/st_geotile_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/layout/st_geohex_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/layout/st_geohash_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/layout/st_geotile_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/layout/st_geohex_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/parameters/st_geohash_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/parameters/st_geotile_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/parameters/st_geohex_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/parameters/st_geohash_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/parameters/st_geotile_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/parameters/st_geohex_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/types/st_geohash_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/types/st_geotile_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/types/st_geohex_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/types/st_geohash_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/types/st_geotile_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/_snippets/functions/types/st_geohex_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/images/functions/st_geohash_to_string.svg': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/images/functions/st_geotile_to_string.svg': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/images/functions/st_geohex_to_string.svg': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/images/functions/st_geohash_to_long.svg': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/images/functions/st_geotile_to_long.svg': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/images/functions/st_geohex_to_long.svg': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/kibana/definition/functions/st_geohash_to_string.json': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/kibana/definition/functions/st_geotile_to_string.json': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/kibana/definition/functions/st_geohex_to_string.json': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/kibana/definition/functions/st_geohash_to_long.json': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/kibana/definition/functions/st_geotile_to_long.json': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/kibana/definition/functions/st_geohex_to_long.json': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/kibana/docs/functions/st_geohash_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/kibana/docs/functions/st_geotile_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/kibana/docs/functions/st_geohex_to_string.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/kibana/docs/functions/st_geohash_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/kibana/docs/functions/st_geotile_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\n+  'docs/reference/query-languages/esql/kibana/docs/functions/st_geohex_to_long.md': 'reference/query-languages/esql/esql-functions-operators.md'\ndiff --git a/modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/extras/SourceConfirmedTextQuery.java b/modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/extras/SourceConfirmedTextQuery.java\nindex 2628de589d7..312c626eb62 100644\n--- a/modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/extras/SourceConfirmedTextQuery.java\n+++ b/modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/extras/SourceConfirmedTextQuery.java\n@@ -176,14 +176,18 @@ public final class SourceConfirmedTextQuery extends Query {\n             return false;\n         }\n         SourceConfirmedTextQuery that = (SourceConfirmedTextQuery) obj;\n-        return Objects.equals(in, that.in)\n-            && Objects.equals(valueFetcherProvider, that.valueFetcherProvider)\n-            && Objects.equals(indexAnalyzer, that.indexAnalyzer);\n+        // We intentionally do not compare the value fetcher or analyzer, as they\n+        // do not typically implement equals() themselves, and the inner\n+        // Query is sufficient to establish identity.\n+        return Objects.equals(in, that.in);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 31 * Objects.hash(in, valueFetcherProvider, indexAnalyzer) + classHash();\n+        // We intentionally do not hash the value fetcher or analyzer, as they\n+        // do not typically implement hashCode() themselves, and the inner\n+        // Query is sufficient to establish identity.\n+        return 31 * Objects.hash(in) + classHash();\n     }\n \n     @Override\ndiff --git a/modules/mapper-extras/src/test/java/org/elasticsearch/index/mapper/extras/SourceConfirmedTextQueryTests.java b/modules/mapper-extras/src/test/java/org/elasticsearch/index/mapper/extras/SourceConfirmedTextQueryTests.java\nindex be6a4510ba0..51b34eb7274 100644\n--- a/modules/mapper-extras/src/test/java/org/elasticsearch/index/mapper/extras/SourceConfirmedTextQueryTests.java\n+++ b/modules/mapper-extras/src/test/java/org/elasticsearch/index/mapper/extras/SourceConfirmedTextQueryTests.java\n@@ -59,11 +59,13 @@ import static org.hamcrest.Matchers.greaterThan;\n public class SourceConfirmedTextQueryTests extends ESTestCase {\n \n     private static final AtomicInteger sourceFetchCount = new AtomicInteger();\n-    private static final IOFunction<LeafReaderContext, CheckedIntFunction<List<Object>, IOException>> SOURCE_FETCHER_PROVIDER =\n-        context -> docID -> {\n+\n+    private static IOFunction<LeafReaderContext, CheckedIntFunction<List<Object>, IOException>> sourceFetcherProvider() {\n+        return context -> docID -> {\n             sourceFetchCount.incrementAndGet();\n-            return Collections.<Object>singletonList(context.reader().storedFields().document(docID).get(\"body\"));\n+            return Collections.singletonList(context.reader().storedFields().document(docID).get(\"body\"));\n         };\n+    }\n \n     public void testTerm() throws Exception {\n         try (Directory dir = newDirectory(); IndexWriter w = new IndexWriter(dir, newIndexWriterConfig(Lucene.STANDARD_ANALYZER))) {\n@@ -84,7 +86,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                 IndexSearcher searcher = newSearcher(reader);\n \n                 TermQuery query = new TermQuery(new Term(\"body\", \"c\"));\n-                Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n \n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n                 ScoreDoc[] phraseHits = searcher.search(query, 10).scoreDocs;\n@@ -95,7 +97,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n \n                 // Term query with missing term\n                 query = new TermQuery(new Term(\"body\", \"e\"));\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n                 assertArrayEquals(new ScoreDoc[0], searcher.search(sourceConfirmedPhraseQuery, 10).scoreDocs);\n             }\n@@ -112,7 +114,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n             try (IndexReader reader = DirectoryReader.open(w)) {\n                 IndexSearcher searcher = newSearcher(reader);\n                 PhraseQuery query = new PhraseQuery(\"missing_field\", \"b\", \"c\");\n-                Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 Explanation explanation = searcher.explain(sourceConfirmedPhraseQuery, 0);\n                 assertFalse(explanation.isMatch());\n \n@@ -141,7 +143,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                 IndexSearcher searcher = newSearcher(reader);\n \n                 PhraseQuery query = new PhraseQuery(\"body\", \"b\", \"c\");\n-                Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n \n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n                 ScoreDoc[] phraseHits = searcher.search(query, 10).scoreDocs;\n@@ -152,7 +154,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n \n                 // Sloppy phrase query\n                 query = new PhraseQuery(1, \"body\", \"b\", \"d\");\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n                 phraseHits = searcher.search(query, 10).scoreDocs;\n                 assertEquals(2, phraseHits.length);\n@@ -162,13 +164,13 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n \n                 // Phrase query with no matches\n                 query = new PhraseQuery(\"body\", \"d\", \"c\");\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n                 assertArrayEquals(new ScoreDoc[0], searcher.search(sourceConfirmedPhraseQuery, 10).scoreDocs);\n \n                 // Phrase query with one missing term\n                 query = new PhraseQuery(\"body\", \"b\", \"e\");\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n                 assertArrayEquals(new ScoreDoc[0], searcher.search(sourceConfirmedPhraseQuery, 10).scoreDocs);\n             }\n@@ -197,7 +199,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                     .add(new Term[] { new Term(\"body\", \"c\") }, 1)\n                     .build();\n \n-                Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n \n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n \n@@ -212,7 +214,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                     .add(new Term[] { new Term(\"body\", \"d\") }, 1)\n                     .setSlop(1)\n                     .build();\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n                 phraseHits = searcher.search(query, 10).scoreDocs;\n                 assertEquals(2, phraseHits.length);\n@@ -224,7 +226,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                 query = new MultiPhraseQuery.Builder().add(new Term[] { new Term(\"body\", \"d\"), new Term(\"body\", \"c\") }, 0)\n                     .add(new Term[] { new Term(\"body\", \"a\") }, 1)\n                     .build();\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n                 assertArrayEquals(new ScoreDoc[0], searcher.search(sourceConfirmedPhraseQuery, 10).scoreDocs);\n \n@@ -232,7 +234,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                 query = new MultiPhraseQuery.Builder().add(new Term[] { new Term(\"body\", \"d\"), new Term(\"body\", \"c\") }, 0)\n                     .add(new Term[] { new Term(\"body\", \"e\") }, 1)\n                     .build();\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n                 assertArrayEquals(new ScoreDoc[0], searcher.search(sourceConfirmedPhraseQuery, 10).scoreDocs);\n             }\n@@ -258,7 +260,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                 IndexSearcher searcher = newSearcher(reader);\n \n                 MultiPhrasePrefixQuery query = new MultiPhrasePrefixQuery(\"body\");\n-                Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 ScoreDoc[] phrasePrefixHits = searcher.search(query, 10).scoreDocs;\n                 ScoreDoc[] sourceConfirmedHits = searcher.search(sourceConfirmedPhraseQuery, 10).scoreDocs;\n                 CheckHits.checkEqual(query, phrasePrefixHits, sourceConfirmedHits);\n@@ -267,7 +269,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n \n                 query = new MultiPhrasePrefixQuery(\"body\");\n                 query.add(new Term(\"body\", \"c\"));\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 phrasePrefixHits = searcher.search(query, 10).scoreDocs;\n                 sourceConfirmedHits = searcher.search(sourceConfirmedPhraseQuery, 10).scoreDocs;\n                 CheckHits.checkEqual(query, phrasePrefixHits, sourceConfirmedHits);\n@@ -277,7 +279,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                 query = new MultiPhrasePrefixQuery(\"body\");\n                 query.add(new Term(\"body\", \"b\"));\n                 query.add(new Term(\"body\", \"c\"));\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 phrasePrefixHits = searcher.search(query, 10).scoreDocs;\n                 sourceConfirmedHits = searcher.search(sourceConfirmedPhraseQuery, 10).scoreDocs;\n                 CheckHits.checkEqual(query, phrasePrefixHits, sourceConfirmedHits);\n@@ -289,7 +291,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                 query.add(new Term(\"body\", \"a\"));\n                 query.add(new Term(\"body\", \"c\"));\n                 query.setSlop(2);\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 phrasePrefixHits = searcher.search(query, 10).scoreDocs;\n                 sourceConfirmedHits = searcher.search(sourceConfirmedPhraseQuery, 10).scoreDocs;\n                 CheckHits.checkEqual(query, phrasePrefixHits, sourceConfirmedHits);\n@@ -300,7 +302,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                 query = new MultiPhrasePrefixQuery(\"body\");\n                 query.add(new Term(\"body\", \"d\"));\n                 query.add(new Term(\"body\", \"b\"));\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n                 assertArrayEquals(new ScoreDoc[0], searcher.search(sourceConfirmedPhraseQuery, 10).scoreDocs);\n \n@@ -308,7 +310,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                 query = new MultiPhrasePrefixQuery(\"body\");\n                 query.add(new Term(\"body\", \"d\"));\n                 query.add(new Term(\"body\", \"f\"));\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 assertEquals(0, searcher.count(sourceConfirmedPhraseQuery));\n                 assertArrayEquals(new ScoreDoc[0], searcher.search(sourceConfirmedPhraseQuery, 10).scoreDocs);\n             }\n@@ -338,7 +340,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                     0,\n                     false\n                 );\n-                Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n \n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n                 ScoreDoc[] spanHits = searcher.search(query, 10).scoreDocs;\n@@ -353,7 +355,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                     1,\n                     false\n                 );\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n                 spanHits = searcher.search(query, 10).scoreDocs;\n                 assertEquals(2, spanHits.length);\n@@ -367,7 +369,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                     0,\n                     false\n                 );\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n                 assertArrayEquals(new ScoreDoc[0], searcher.search(sourceConfirmedPhraseQuery, 10).scoreDocs);\n \n@@ -377,7 +379,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n                     0,\n                     false\n                 );\n-                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 assertEquals(searcher.count(query), searcher.count(sourceConfirmedPhraseQuery));\n                 assertArrayEquals(new ScoreDoc[0], searcher.search(sourceConfirmedPhraseQuery, 10).scoreDocs);\n             }\n@@ -386,30 +388,28 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n \n     public void testToString() {\n         PhraseQuery query = new PhraseQuery(\"body\", \"b\", \"c\");\n-        Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+        Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n         assertEquals(query.toString(), sourceConfirmedPhraseQuery.toString());\n     }\n \n     public void testEqualsHashCode() {\n         PhraseQuery query1 = new PhraseQuery(\"body\", \"b\", \"c\");\n-        Query sourceConfirmedPhraseQuery1 = new SourceConfirmedTextQuery(query1, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+        Query sourceConfirmedPhraseQuery1 = new SourceConfirmedTextQuery(query1, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n \n         assertEquals(sourceConfirmedPhraseQuery1, sourceConfirmedPhraseQuery1);\n         assertEquals(sourceConfirmedPhraseQuery1.hashCode(), sourceConfirmedPhraseQuery1.hashCode());\n \n         PhraseQuery query2 = new PhraseQuery(\"body\", \"b\", \"c\");\n-        Query sourceConfirmedPhraseQuery2 = new SourceConfirmedTextQuery(query2, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+        Query sourceConfirmedPhraseQuery2 = new SourceConfirmedTextQuery(query2, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n         assertEquals(sourceConfirmedPhraseQuery1, sourceConfirmedPhraseQuery2);\n \n         PhraseQuery query3 = new PhraseQuery(\"body\", \"b\", \"d\");\n-        Query sourceConfirmedPhraseQuery3 = new SourceConfirmedTextQuery(query3, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+        Query sourceConfirmedPhraseQuery3 = new SourceConfirmedTextQuery(query3, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n         assertNotEquals(sourceConfirmedPhraseQuery1, sourceConfirmedPhraseQuery3);\n \n-        Query sourceConfirmedPhraseQuery4 = new SourceConfirmedTextQuery(query1, context -> null, Lucene.STANDARD_ANALYZER);\n-        assertNotEquals(sourceConfirmedPhraseQuery1, sourceConfirmedPhraseQuery4);\n-\n-        Query sourceConfirmedPhraseQuery5 = new SourceConfirmedTextQuery(query1, SOURCE_FETCHER_PROVIDER, Lucene.KEYWORD_ANALYZER);\n-        assertNotEquals(sourceConfirmedPhraseQuery1, sourceConfirmedPhraseQuery5);\n+        PhraseQuery query4 = new PhraseQuery(\"body\", \"b\", \"c\");\n+        Query sourceConfirmedPhraseQuery6 = new SourceConfirmedTextQuery(query4, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n+        assertEquals(sourceConfirmedPhraseQuery1, sourceConfirmedPhraseQuery6);\n     }\n \n     public void testApproximation() {\n@@ -461,7 +461,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n             try (IndexReader reader = DirectoryReader.open(w)) {\n                 IndexSearcher searcher = newSearcher(reader);\n                 PhraseQuery query = new PhraseQuery(\"body\", \"a\", \"b\");\n-                Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+                Query sourceConfirmedPhraseQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n                 assertEquals(0, searcher.count(sourceConfirmedPhraseQuery));\n             }\n         }\n@@ -489,7 +489,7 @@ public class SourceConfirmedTextQueryTests extends ESTestCase {\n             doc.add(new KeywordField(\"sort\", \"2\", Store.NO));\n             w.addDocument(doc);\n \n-            Query sourceConfirmedQuery = new SourceConfirmedTextQuery(query, SOURCE_FETCHER_PROVIDER, Lucene.STANDARD_ANALYZER);\n+            Query sourceConfirmedQuery = new SourceConfirmedTextQuery(query, sourceFetcherProvider(), Lucene.STANDARD_ANALYZER);\n \n             try (IndexReader ir = DirectoryReader.open(w)) {\n                 {\ndiff --git a/muted-tests.yml b/muted-tests.yml\nindex b9b5ece2d48..9424aaa0a28 100644\n--- a/muted-tests.yml\n+++ b/muted-tests.yml\n@@ -516,9 +516,6 @@ tests:\n - class: org.elasticsearch.xpack.esql.expression.function.scalar.score.DecayTests\n   method: \"testEvaluateBlockWithNulls {TestCase=<double>, <double>, <double>, <_source> #11}\"\n   issue: https://github.com/elastic/elasticsearch/issues/134447\n-- class: org.elasticsearch.action.admin.cluster.state.TransportClusterStateActionTests\n-  method: testGetClusterStateWithDefaultProjectOnly\n-  issue: https://github.com/elastic/elasticsearch/issues/134450\n \n # Examples:\n #\ndiff --git a/server/src/main/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesRequest.java b/server/src/main/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesRequest.java\nindex b856448b1dc..7d2da61055a 100644\n--- a/server/src/main/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesRequest.java\n+++ b/server/src/main/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesRequest.java\n@@ -18,7 +18,13 @@ import org.elasticsearch.action.support.IndicesOptions;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.BoostingQueryBuilder;\n+import org.elasticsearch.index.query.ConstantScoreQueryBuilder;\n+import org.elasticsearch.index.query.DisMaxQueryBuilder;\n+import org.elasticsearch.index.query.NestedQueryBuilder;\n import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.index.query.functionscore.FunctionScoreQueryBuilder;\n import org.elasticsearch.tasks.CancellableTask;\n import org.elasticsearch.tasks.Task;\n import org.elasticsearch.tasks.TaskId;\n@@ -284,9 +290,53 @@ public final class FieldCapabilitiesRequest extends LegacyActionRequest implemen\n         if (fields == null || fields.length == 0) {\n             validationException = ValidateActions.addValidationError(\"no fields specified\", validationException);\n         }\n+\n+        // Band-aid fix for https://github.com/elastic/elasticsearch/issues/116106.\n+        // Semantic queries are high-recall queries, making them poor filters and effectively the same as an exists query when used in that\n+        // context.\n+        if (containsSemanticQuery(indexFilter)) {\n+            validationException = ValidateActions.addValidationError(\n+                \"index filter cannot contain semantic queries. Use an exists query instead.\",\n+                validationException\n+            );\n+        }\n+\n         return validationException;\n     }\n \n+    /**\n+     * Recursively checks if a query builder contains any semantic queries\n+     */\n+    private static boolean containsSemanticQuery(QueryBuilder queryBuilder) {\n+        boolean containsSemanticQuery = false;\n+\n+        if (queryBuilder == null) {\n+            return containsSemanticQuery;\n+        }\n+\n+        if (\"semantic\".equals(queryBuilder.getWriteableName())) {\n+            containsSemanticQuery = true;\n+        } else if (queryBuilder instanceof BoolQueryBuilder boolQuery) {\n+            containsSemanticQuery = boolQuery.must().stream().anyMatch(FieldCapabilitiesRequest::containsSemanticQuery)\n+                || boolQuery.mustNot().stream().anyMatch(FieldCapabilitiesRequest::containsSemanticQuery)\n+                || boolQuery.should().stream().anyMatch(FieldCapabilitiesRequest::containsSemanticQuery)\n+                || boolQuery.filter().stream().anyMatch(FieldCapabilitiesRequest::containsSemanticQuery);\n+        } else if (queryBuilder instanceof DisMaxQueryBuilder disMaxQuery) {\n+            containsSemanticQuery = disMaxQuery.innerQueries().stream().anyMatch(FieldCapabilitiesRequest::containsSemanticQuery);\n+        } else if (queryBuilder instanceof NestedQueryBuilder nestedQuery) {\n+            containsSemanticQuery = containsSemanticQuery(nestedQuery.query());\n+        } else if (queryBuilder instanceof BoostingQueryBuilder boostingQuery) {\n+            containsSemanticQuery = containsSemanticQuery(boostingQuery.positiveQuery())\n+                || containsSemanticQuery(boostingQuery.negativeQuery());\n+        } else if (queryBuilder instanceof ConstantScoreQueryBuilder constantScoreQuery) {\n+            containsSemanticQuery = containsSemanticQuery(constantScoreQuery.innerQuery());\n+        } else if (queryBuilder instanceof FunctionScoreQueryBuilder functionScoreQuery) {\n+            containsSemanticQuery = containsSemanticQuery(functionScoreQuery.query());\n+        }\n+\n+        return containsSemanticQuery;\n+    }\n+\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) return true;\ndiff --git a/x-pack/plugin/inference/src/test/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesRequestSemanticIndexFilterTests.java b/x-pack/plugin/inference/src/test/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesRequestSemanticIndexFilterTests.java\nnew file mode 100644\nindex 00000000000..9fd1c3921fc\n--- /dev/null\n+++ b/x-pack/plugin/inference/src/test/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesRequestSemanticIndexFilterTests.java\n@@ -0,0 +1,136 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License\n+ * 2.0; you may not use this file except in compliance with the Elastic License\n+ * 2.0.\n+ */\n+\n+package org.elasticsearch.action.fieldcaps;\n+\n+import org.apache.lucene.search.join.ScoreMode;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.BoostingQueryBuilder;\n+import org.elasticsearch.index.query.ConstantScoreQueryBuilder;\n+import org.elasticsearch.index.query.DisMaxQueryBuilder;\n+import org.elasticsearch.index.query.MatchAllQueryBuilder;\n+import org.elasticsearch.index.query.NestedQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.index.query.TermQueryBuilder;\n+import org.elasticsearch.index.query.functionscore.FunctionScoreQueryBuilder;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.inference.queries.SemanticQueryBuilder;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+public class FieldCapabilitiesRequestSemanticIndexFilterTests extends ESTestCase {\n+    private static final String EXPECTED_ERROR_MESSAGE = \"index filter cannot contain semantic queries. Use an exists query instead.\";\n+\n+    public void testValidateWithoutIndexFilter() {\n+        FieldCapabilitiesRequest request = new FieldCapabilitiesRequest();\n+        request.fields(\"field1\", \"field2\");\n+\n+        ActionRequestValidationException validationException = request.validate();\n+        assertNull(validationException);\n+    }\n+\n+    public void testValidateWithNonSemanticIndexFilter() {\n+        FieldCapabilitiesRequest request = new FieldCapabilitiesRequest();\n+        request.fields(\"field1\", \"field2\");\n+        request.indexFilter(randomNonSemanticQuery());\n+\n+        ActionRequestValidationException validationException = request.validate();\n+        assertNull(validationException);\n+    }\n+\n+    public void testValidateWithDirectSemanticQuery() {\n+        FieldCapabilitiesRequest request = new FieldCapabilitiesRequest();\n+        request.fields(\"field1\", \"field2\");\n+        request.indexFilter(randomSemanticQuery());\n+\n+        ActionRequestValidationException validationException = request.validate();\n+        assertThat(validationException, notNullValue());\n+        assertThat(validationException.getMessage(), containsString(EXPECTED_ERROR_MESSAGE));\n+    }\n+\n+    public void testValidateWithRandomCompoundQueryContainingSemantic() {\n+        for (int i = 0; i < 100; i++) {\n+            FieldCapabilitiesRequest request = new FieldCapabilitiesRequest();\n+            request.fields(\"field1\", \"field2\");\n+\n+            // Create a randomly structured compound query containing semantic query\n+            QueryBuilder randomCompoundQuery = randomCompoundQueryWithSemantic(randomIntBetween(1, 3));\n+            request.indexFilter(randomCompoundQuery);\n+\n+            ActionRequestValidationException validationException = request.validate();\n+            assertThat(validationException, notNullValue());\n+            assertThat(validationException.getMessage(), containsString(EXPECTED_ERROR_MESSAGE));\n+        }\n+    }\n+\n+    private static SemanticQueryBuilder randomSemanticQuery() {\n+        return new SemanticQueryBuilder(randomAlphaOfLength(5), randomAlphaOfLength(10));\n+    }\n+\n+    private static QueryBuilder randomNonSemanticQuery() {\n+        return switch (randomIntBetween(0, 2)) {\n+            case 0 -> new TermQueryBuilder(randomAlphaOfLength(5), randomAlphaOfLength(5));\n+            case 1 -> new MatchAllQueryBuilder();\n+            case 2 -> {\n+                BoolQueryBuilder boolQuery = new BoolQueryBuilder();\n+                boolQuery.must(new TermQueryBuilder(randomAlphaOfLength(5), randomAlphaOfLength(5)));\n+                yield boolQuery;\n+            }\n+            default -> throw new IllegalStateException(\"Unexpected value\");\n+        };\n+    }\n+\n+    private static QueryBuilder randomCompoundQueryWithSemantic(int depth) {\n+        if (depth <= 0) {\n+            return randomSemanticQuery();\n+        }\n+\n+        return switch (randomIntBetween(0, 5)) {\n+            case 0 -> {\n+                BoolQueryBuilder boolQuery = new BoolQueryBuilder();\n+                QueryBuilder clauseQuery = randomCompoundQueryWithSemantic(depth - 1);\n+                switch (randomIntBetween(0, 3)) {\n+                    case 0 -> boolQuery.must(clauseQuery);\n+                    case 1 -> boolQuery.mustNot(clauseQuery);\n+                    case 2 -> boolQuery.should(clauseQuery);\n+                    case 3 -> boolQuery.filter(clauseQuery);\n+                    default -> throw new IllegalStateException(\"Unexpected value\");\n+                }\n+\n+                if (randomBoolean()) {\n+                    boolQuery.should(randomNonSemanticQuery());\n+                }\n+\n+                yield boolQuery;\n+            }\n+            case 1 -> {\n+                DisMaxQueryBuilder disMax = new DisMaxQueryBuilder();\n+                disMax.add(randomCompoundQueryWithSemantic(depth - 1));\n+                if (randomBoolean()) {\n+                    disMax.add(randomNonSemanticQuery());\n+                }\n+                yield disMax;\n+            }\n+            case 2 -> new NestedQueryBuilder(randomAlphaOfLength(5), randomCompoundQueryWithSemantic(depth - 1), ScoreMode.Max);\n+            case 3 -> {\n+                boolean positiveSemanticQuery = randomBoolean();\n+                QueryBuilder semanticQuery = randomCompoundQueryWithSemantic(depth - 1);\n+                QueryBuilder nonSemanticQuery = randomNonSemanticQuery();\n+\n+                yield new BoostingQueryBuilder(\n+                    positiveSemanticQuery ? semanticQuery : nonSemanticQuery,\n+                    positiveSemanticQuery ? nonSemanticQuery : semanticQuery\n+                );\n+            }\n+            case 4 -> new ConstantScoreQueryBuilder(randomCompoundQueryWithSemantic(depth - 1));\n+            case 5 -> new FunctionScoreQueryBuilder(randomCompoundQueryWithSemantic(depth - 1));\n+            default -> throw new IllegalStateException(\"Unexpected value\");\n+        };\n+    }\n+}"
}