{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134936,
  "base_commit": "0d0c0ad2354f522d2dbd3ecd2db295f3cf085ba0",
  "head_commit": "e75974063e20ef78b33d4b25344493d87a09fe1a",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.7,
    "completeness": -0.6,
    "code_reuse": 0.8,
    "best_practices": -0.5,
    "unsolicited_docs": 1.0
  },
  "aggregate": 4.4408920985006264e-17,
  "rationale": "The agent's solution has a critical correctness flaw: it uses Collections.unmodifiableSet() which only provides a shallow wrapper and does not recursively wrap nested collections (Lists within Sets), failing to prevent mutations of nested structures. Ground truth implements UnmodifiableIngestSet with UnmodifiableIterator that calls wrapUnmodifiable() on each element, ensuring deep immutability. The agent is missing: (1) the custom UnmodifiableIngestSet class, (2) the refactored UnmodifiableIterator class used by both UnmodifiableIngestList and UnmodifiableIngestSet, (3) comprehensive test cases for nested collection mutations (mapField mutations, nested list-within-set mutations), (4) the changelog file. The agent added basic Set mutation tests but omitted the critical nested mutation tests that would expose the shallow wrapping bug. Code reuse is rated positively because using Collections.unmodifiableSet is attempting to reuse standard library code, though it's the wrong choice here. Best practices are poor because the solution doesn't follow the existing pattern of custom unmodifiable wrappers used for Map and List in the same codebase.",
  "edit_run_id": "8d6f99fc",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/docs/changelog/134936.yaml b/docs/changelog/134936.yaml\nnew file mode 100644\nindex 00000000000..d9ff3aef5c0\n--- /dev/null\n+++ b/docs/changelog/134936.yaml\n@@ -0,0 +1,5 @@\n+pr: 134936\n+summary: Fixing conditional processor mutability bugs\n+area: Ingest Node\n+type: bug\n+issues: []\ndiff --git a/server/src/main/java/org/elasticsearch/ingest/ConditionalProcessor.java b/server/src/main/java/org/elasticsearch/ingest/ConditionalProcessor.java\nindex 24e093d5e18..9582279bfbe 100644\n--- a/server/src/main/java/org/elasticsearch/ingest/ConditionalProcessor.java\n+++ b/server/src/main/java/org/elasticsearch/ingest/ConditionalProcessor.java\n@@ -158,6 +158,8 @@ public class ConditionalProcessor extends AbstractProcessor implements WrappingP\n             return new UnmodifiableIngestData((Map<String, Object>) raw);\n         } else if (raw instanceof List) {\n             return new UnmodifiableIngestList((List<Object>) raw);\n+        } else if (raw instanceof Set<?> rawSet) {\n+            return new UnmodifiableIngestSet((Set<Object>) rawSet);\n         } else if (raw instanceof byte[] bytes) {\n             return bytes.clone();\n         }\n@@ -287,23 +289,7 @@ public class ConditionalProcessor extends AbstractProcessor implements WrappingP\n \n         @Override\n         public Iterator<Object> iterator() {\n-            Iterator<Object> wrapped = data.iterator();\n-            return new Iterator<Object>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return wrapped.hasNext();\n-                }\n-\n-                @Override\n-                public Object next() {\n-                    return wrapped.next();\n-                }\n-\n-                @Override\n-                public void remove() {\n-                    throw unmodifiableException();\n-                }\n-            };\n+            return new UnmodifiableIterator(data.iterator());\n         }\n \n         @Override\n@@ -465,4 +451,100 @@ public class ConditionalProcessor extends AbstractProcessor implements WrappingP\n             }\n         }\n     }\n+\n+    private static final class UnmodifiableIngestSet implements Set<Object> {\n+        private final Set<Object> data;\n+\n+        UnmodifiableIngestSet(Set<Object> data) {\n+            this.data = data;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return data.size();\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return data.isEmpty();\n+        }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+            return data.contains(o);\n+        }\n+\n+        @Override\n+        public Iterator<Object> iterator() {\n+            return new UnmodifiableIterator(data.iterator());\n+        }\n+\n+        @Override\n+        public Object[] toArray() {\n+            return data.toArray();\n+        }\n+\n+        @Override\n+        public <T> T[] toArray(T[] a) {\n+            return data.toArray(a);\n+        }\n+\n+        @Override\n+        public boolean add(Object o) {\n+            throw unmodifiableException();\n+        }\n+\n+        @Override\n+        public boolean remove(Object o) {\n+            throw unmodifiableException();\n+        }\n+\n+        @Override\n+        public boolean containsAll(Collection<?> c) {\n+            return data.containsAll(c);\n+        }\n+\n+        @Override\n+        public boolean addAll(Collection<?> c) {\n+            throw unmodifiableException();\n+        }\n+\n+        @Override\n+        public boolean retainAll(Collection<?> c) {\n+            throw unmodifiableException();\n+        }\n+\n+        @Override\n+        public boolean removeAll(Collection<?> c) {\n+            throw unmodifiableException();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            throw unmodifiableException();\n+        }\n+    }\n+\n+    private static final class UnmodifiableIterator implements Iterator<Object> {\n+        private final Iterator<Object> it;\n+\n+        UnmodifiableIterator(Iterator<Object> it) {\n+            this.it = it;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return it.hasNext();\n+        }\n+\n+        @Override\n+        public Object next() {\n+            return wrapUnmodifiable(it.next());\n+        }\n+\n+        @Override\n+        public void remove() {\n+            throw unmodifiableException();\n+        }\n+    }\n }\ndiff --git a/server/src/test/java/org/elasticsearch/ingest/ConditionalProcessorTests.java b/server/src/test/java/org/elasticsearch/ingest/ConditionalProcessorTests.java\nindex 1317233d310..144036ce80e 100644\n--- a/server/src/test/java/org/elasticsearch/ingest/ConditionalProcessorTests.java\n+++ b/server/src/test/java/org/elasticsearch/ingest/ConditionalProcessorTests.java\n@@ -26,8 +26,10 @@ import org.elasticsearch.test.ESTestCase;\n import java.text.ParseException;\n import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.function.BiConsumer;\n@@ -141,6 +143,14 @@ public class ConditionalProcessorTests extends ESTestCase {\n         assertMutatingCtxThrows(ctx -> ctx.put(\"foo\", \"bar\"));\n         assertMutatingCtxThrows(ctx -> ((List<Object>) ctx.get(\"listField\")).add(\"bar\"));\n         assertMutatingCtxThrows(ctx -> ((List<Object>) ctx.get(\"listField\")).remove(\"bar\"));\n+        assertMutatingCtxThrows(ctx -> ((Map<String, Object>) ctx.get(\"mapField\")).put(\"bar\", \"baz\"));\n+        assertMutatingCtxThrows(ctx -> ((Map<?, ?>) ctx.get(\"mapField\")).remove(\"bar\"));\n+        assertMutatingCtxThrows(ctx -> ((Set<Object>) ctx.get(\"setField\")).add(\"bar\"));\n+        assertMutatingCtxThrows(ctx -> ((Set<Object>) ctx.get(\"setField\")).remove(\"bar\"));\n+        assertMutatingCtxThrows(ctx -> ((List<Object>) ((Set<Object>) ctx.get(\"setField\")).iterator().next()).add(\"bar\"));\n+        assertMutatingCtxThrows(\n+            ctx -> ((List<Object>) ((List<Object>) ((Set<Object>) ctx.get(\"setField\")).iterator().next()).iterator().next()).add(\"bar\")\n+        );\n     }\n \n     public void testPrecompiledError() {\n@@ -194,6 +204,7 @@ public class ConditionalProcessorTests extends ESTestCase {\n         execProcessor(processor, ingestDoc, (doc, e) -> { assertThat(e.getMessage(), equalTo(\"runtime problem\")); });\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private static void assertMutatingCtxThrows(Consumer<Map<String, Object>> mutation) throws Exception {\n         String scriptName = \"conditionalScript\";\n         PlainActionFuture<Exception> expectedException = new PlainActionFuture<>();\n@@ -221,6 +232,11 @@ public class ConditionalProcessorTests extends ESTestCase {\n         );\n         IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random(), document);\n         ingestDocument.setFieldValue(\"listField\", new ArrayList<>());\n+        ingestDocument.setFieldValue(\"mapField\", new HashMap<>());\n+        ingestDocument.setFieldValue(\"setField\", new HashSet<>());\n+        List<Object> listWithinSet = new ArrayList<>();\n+        listWithinSet.add(new ArrayList<>());\n+        ingestDocument.getFieldValue(\"setField\", Set.class).add(listWithinSet);\n         execProcessor(processor, ingestDocument, (result, e) -> {});\n         Exception e = safeGet(expectedException);\n         assertThat(e, instanceOf(UnsupportedOperationException.class));"
}