{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4583,
  "base_commit": "c12427d047b7cf9fd1ac9acc611bc2985ad12c40",
  "head_commit": "beaa9153a629c0950182e4e8c4f8eedd1c63f49f",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.6,
    "completeness": -0.7,
    "code_reuse": -0.8,
    "best_practices": -0.5,
    "unsolicited_docs": 1.0
  },
  "aggregate": -0.31999999999999995,
  "rationale": "The agent addressed two of the required changes: fixing the 'store_term_vector' typo to 'store_term_vectors' and fixing an unrelated 'similariry' typo. However, it missed the core architectural change in the ground truth: refactoring toXContent to use innerToXContent with simulation logic (BytesStreamOutput) to properly detect default values. Instead, the agent only added checks for storeTermVectorOffsets/Positions/Payloads to the existing conditional, which is a much simpler and inferior approach that doesn't match the ground truth's simulation-based default detection. The agent completely missed the AbstractFieldMapper.java changes that fix the term vector setter methods with conditional guards. The agent also missed the comprehensive test additions in SimpleAllMapperTests.java. The solution is functionally incomplete and architecturally different from the ground truth, representing a shallow fix rather than the proper refactoring required.",
  "edit_run_id": "8d6f99fc",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java b/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java\nindex 760f9ef4488..18f92af44e2 100644\n--- a/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java\n+++ b/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java\n@@ -117,24 +117,32 @@ public abstract class AbstractFieldMapper<T> implements FieldMapper<T> {\n         }\n \n         public T storeTermVectors(boolean termVectors) {\n-            this.fieldType.setStoreTermVectors(termVectors);\n+            if (termVectors) {\n+                this.fieldType.setStoreTermVectors(termVectors);\n+            } // don't set it to false, it is default and might be flipped by a more specific option\n             return builder;\n         }\n \n         public T storeTermVectorOffsets(boolean termVectorOffsets) {\n-            this.fieldType.setStoreTermVectors(termVectorOffsets);\n+            if (termVectorOffsets) {\n+                this.fieldType.setStoreTermVectors(termVectorOffsets);\n+            }\n             this.fieldType.setStoreTermVectorOffsets(termVectorOffsets);\n             return builder;\n         }\n \n         public T storeTermVectorPositions(boolean termVectorPositions) {\n-            this.fieldType.setStoreTermVectors(termVectorPositions);\n+            if (termVectorPositions) {\n+                this.fieldType.setStoreTermVectors(termVectorPositions);\n+            }\n             this.fieldType.setStoreTermVectorPositions(termVectorPositions);\n             return builder;\n         }\n \n         public T storeTermVectorPayloads(boolean termVectorPayloads) {\n-            this.fieldType.setStoreTermVectors(termVectorPayloads);\n+            if (termVectorPayloads) {\n+                this.fieldType.setStoreTermVectors(termVectorPayloads);\n+            }\n             this.fieldType.setStoreTermVectorPayloads(termVectorPayloads);\n             return builder;\n         }\ndiff --git a/src/main/java/org/elasticsearch/index/mapper/internal/AllFieldMapper.java b/src/main/java/org/elasticsearch/index/mapper/internal/AllFieldMapper.java\nindex 5dfeebadfbc..8b9afcbcc49 100644\n--- a/src/main/java/org/elasticsearch/index/mapper/internal/AllFieldMapper.java\n+++ b/src/main/java/org/elasticsearch/index/mapper/internal/AllFieldMapper.java\n@@ -28,6 +28,7 @@ import org.apache.lucene.search.Query;\n import org.apache.lucene.search.TermQuery;\n import org.elasticsearch.common.Nullable;\n import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.BytesStreamOutput;\n import org.elasticsearch.common.lucene.Lucene;\n import org.elasticsearch.common.lucene.all.AllField;\n import org.elasticsearch.common.lucene.all.AllTermQuery;\n@@ -256,16 +257,26 @@ public class AllFieldMapper extends AbstractFieldMapper<Void> implements Interna\n \n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n-        // if all are defaults, no need to write it at all\n         boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n-\n-        if (!includeDefaults && enabled == Defaults.ENABLED && fieldType.stored() == Defaults.FIELD_TYPE.stored() &&\n-                fieldType.storeTermVectors() == Defaults.FIELD_TYPE.storeTermVectors() &&\n-                indexAnalyzer == null && searchAnalyzer == null && customFieldDataSettings == null\n-                && fieldType.omitNorms() == Defaults.FIELD_TYPE.omitNorms()) {\n-            return builder;\n+        if (!includeDefaults) {\n+            // simulate the generation to make sure we don't add unnecessary content if all is default\n+            // if all are defaults, no need to write it at all - generating is twice is ok though\n+            BytesStreamOutput bytesStreamOutput = new BytesStreamOutput(0);\n+            XContentBuilder b =  new XContentBuilder(builder.contentType().xContent(), bytesStreamOutput);\n+            long pos = bytesStreamOutput.position();\n+            innerToXContent(b, false);\n+            b.flush();\n+            if (pos == bytesStreamOutput.position()) {\n+                return builder;\n+            }\n         }\n         builder.startObject(CONTENT_TYPE);\n+        innerToXContent(builder, includeDefaults);\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    private void innerToXContent(XContentBuilder builder, boolean includeDefaults) throws IOException {\n         if (includeDefaults || enabled != Defaults.ENABLED) {\n             builder.field(\"enabled\", enabled);\n         }\n@@ -276,7 +287,7 @@ public class AllFieldMapper extends AbstractFieldMapper<Void> implements Interna\n             builder.field(\"store\", fieldType.stored());\n         }\n         if (includeDefaults || fieldType.storeTermVectors() != Defaults.FIELD_TYPE.storeTermVectors()) {\n-            builder.field(\"store_term_vector\", fieldType.storeTermVectors());\n+            builder.field(\"store_term_vectors\", fieldType.storeTermVectors());\n         }\n         if (includeDefaults || fieldType.storeTermVectorOffsets() != Defaults.FIELD_TYPE.storeTermVectorOffsets()) {\n             builder.field(\"store_term_vector_offsets\", fieldType.storeTermVectorOffsets());\n@@ -332,11 +343,9 @@ public class AllFieldMapper extends AbstractFieldMapper<Void> implements Interna\n         } else if (includeDefaults) {\n             builder.field(\"fielddata\", (Map) fieldDataType.getSettings().getAsMap());\n         }\n-\n-        builder.endObject();\n-        return builder;\n     }\n \n+\n     @Override\n     public void merge(Mapper mergeWith, MergeContext mergeContext) throws MergeMappingException {\n         // do nothing here, no merging, but also no exception\ndiff --git a/src/test/java/org/elasticsearch/index/mapper/all/SimpleAllMapperTests.java b/src/test/java/org/elasticsearch/index/mapper/all/SimpleAllMapperTests.java\nindex 098afc1d459..26cccbaf5a1 100644\n--- a/src/test/java/org/elasticsearch/index/mapper/all/SimpleAllMapperTests.java\n+++ b/src/test/java/org/elasticsearch/index/mapper/all/SimpleAllMapperTests.java\n@@ -20,12 +20,18 @@\n package org.elasticsearch.index.mapper.all;\n \n import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n import org.apache.lucene.search.TermQuery;\n import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.BytesStreamOutput;\n import org.elasticsearch.common.lucene.all.AllEntries;\n import org.elasticsearch.common.lucene.all.AllField;\n import org.elasticsearch.common.lucene.all.AllTermQuery;\n import org.elasticsearch.common.lucene.all.AllTokenStream;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentType;\n import org.elasticsearch.index.mapper.DocumentMapper;\n import org.elasticsearch.index.mapper.FieldMapper;\n import org.elasticsearch.index.mapper.MapperTestUtils;\n@@ -34,9 +40,14 @@ import org.elasticsearch.test.ElasticsearchTestCase;\n import org.hamcrest.Matchers;\n import org.junit.Test;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n import static org.elasticsearch.common.io.Streams.copyToBytesFromClasspath;\n import static org.elasticsearch.common.io.Streams.copyToStringFromClasspath;\n-import static org.hamcrest.Matchers.equalTo;\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.hamcrest.Matchers.*;\n \n /**\n  *\n@@ -152,4 +163,121 @@ public class SimpleAllMapperTests extends ElasticsearchTestCase {\n         assertThat(text, equalTo(allEntries.buildText()));\n         assertThat(field.fieldType().omitNorms(), equalTo(false));\n     }\n+\n+    @Test\n+    public void testRandom() throws Exception {\n+        boolean omitNorms = false;\n+        boolean stored = false;\n+        boolean enabled = true;\n+        boolean autoBoost = false;\n+        boolean tv_stored = false;\n+        boolean tv_payloads = false;\n+        boolean tv_offsets = false;\n+        boolean tv_positions = false;\n+        String similarity = null;\n+        boolean fieldData = false;\n+        XContentBuilder mappingBuilder = jsonBuilder();\n+        mappingBuilder.startObject().startObject(\"test\");\n+        List<Tuple<String, Boolean>> booleanOptionList = new ArrayList<Tuple<String, Boolean>>();\n+        boolean allDefault = true;\n+        if (frequently()) {\n+            allDefault = false;\n+            mappingBuilder.startObject(\"_all\");\n+            if (randomBoolean()) {\n+                booleanOptionList.add(new Tuple<String, Boolean>(\"omit_norms\", omitNorms = randomBoolean()));\n+            }\n+            if (randomBoolean()) {\n+                booleanOptionList.add(new Tuple<String, Boolean>(\"store\", stored = randomBoolean()));\n+            }\n+            if (randomBoolean()) {\n+                booleanOptionList.add(new Tuple<String, Boolean>(\"store_term_vectors\", tv_stored = randomBoolean()));\n+            }\n+            if (randomBoolean()) {\n+                booleanOptionList.add(new Tuple<String, Boolean>(\"enabled\", enabled = randomBoolean()));\n+            }\n+            if (randomBoolean()) {\n+                booleanOptionList.add(new Tuple<String, Boolean>(\"auto_boost\", autoBoost = randomBoolean()));\n+            }\n+            if (randomBoolean()) {\n+                booleanOptionList.add(new Tuple<String, Boolean>(\"store_term_vector_offsets\", tv_offsets = randomBoolean()));\n+            }\n+            if (randomBoolean()) {\n+                booleanOptionList.add(new Tuple<String, Boolean>(\"store_term_vector_positions\", tv_positions = randomBoolean()));\n+            }\n+            if (randomBoolean()) {\n+                booleanOptionList.add(new Tuple<String, Boolean>(\"store_term_vector_payloads\", tv_payloads = randomBoolean()));\n+            }\n+            Collections.shuffle(booleanOptionList, getRandom());\n+            for (Tuple<String, Boolean> option : booleanOptionList) {\n+                mappingBuilder.field(option.v1(), option.v2().booleanValue());\n+            }\n+            tv_stored |= tv_positions || tv_payloads || tv_offsets;\n+            if (randomBoolean()) {\n+                mappingBuilder.field(\"similarity\", similarity = randomBoolean() ? \"BM25\" : \"TF/IDF\");\n+            }\n+            if (randomBoolean()) {\n+                fieldData = true;\n+                mappingBuilder.startObject(\"fielddata\");\n+                mappingBuilder.field(\"foo\", \"bar\");\n+                mappingBuilder.endObject();\n+            }\n+            mappingBuilder.endObject();\n+        }\n+\n+        String mapping = mappingBuilder.endObject().endObject().bytes().toUtf8();\n+        logger.info(mapping);\n+        DocumentMapper docMapper = MapperTestUtils.newParser().parse(mapping);\n+        String builtMapping = docMapper.mappingSource().string();\n+        // reparse it\n+        DocumentMapper builtDocMapper = MapperTestUtils.newParser().parse(builtMapping);\n+\n+        byte[] json = jsonBuilder().startObject().startObject(\"test\")\n+                .field(\"foo\", \"bar\")\n+                .field(\"_id\", 1)\n+                .field(\"foobar\", \"foobar\")\n+                .endObject().endObject().bytes().array();\n+        Document doc = builtDocMapper.parse(new BytesArray(json)).rootDoc();\n+        AllField field = (AllField) doc.getField(\"_all\");\n+        if (enabled) {\n+            assertThat(field.fieldType().omitNorms(), equalTo(omitNorms));\n+            assertThat(field.fieldType().stored(), equalTo(stored));\n+            assertThat(field.fieldType().storeTermVectorOffsets(), equalTo(tv_offsets));\n+            assertThat(field.fieldType().storeTermVectorPayloads(), equalTo(tv_payloads));\n+            assertThat(field.fieldType().storeTermVectorPositions(), equalTo(tv_positions));\n+            assertThat(field.fieldType().storeTermVectors(), equalTo(tv_stored));\n+            AllEntries allEntries = ((AllTokenStream) field.tokenStream(docMapper.mappers().indexAnalyzer())).allEntries();\n+            assertThat(allEntries.fields().size(), equalTo(2));\n+            assertThat(allEntries.fields().contains(\"foobar\"), equalTo(true));\n+            assertThat(allEntries.fields().contains(\"foo\"), equalTo(true));\n+            if (!stored) {\n+                assertThat(field.stringValue(), nullValue());\n+            }\n+            String text = stored ? field.stringValue() : \"bar foobar\";\n+            assertThat(text.trim(), equalTo(allEntries.buildText().trim()));\n+        } else {\n+            assertThat(field, nullValue());\n+        }\n+\n+        Term term = new Term(\"foo\", \"bar\");\n+        Query query = builtDocMapper.allFieldMapper().queryStringTermQuery(term);\n+        if (autoBoost) {\n+            assertThat(query, equalTo((Query)new AllTermQuery(term)));\n+        } else {\n+            assertThat(query, equalTo((Query)new TermQuery(term)));\n+        }\n+        if (similarity == null || similarity.equals(\"TF/IDF\")) {\n+            assertThat(builtDocMapper.allFieldMapper().similarity(), nullValue());\n+        }   else {\n+            assertThat(similarity, equalTo(builtDocMapper.allFieldMapper().similarity().name()));\n+        }\n+        assertThat(builtMapping.contains(\"fielddata\"), is(fieldData));\n+        if (allDefault) {\n+            BytesStreamOutput bytesStreamOutput = new BytesStreamOutput(0);\n+            XContentBuilder b =  new XContentBuilder(XContentType.JSON.xContent(), bytesStreamOutput);\n+            XContentBuilder xContentBuilder = builtDocMapper.allFieldMapper().toXContent(b, ToXContent.EMPTY_PARAMS);\n+            xContentBuilder.flush();\n+            assertThat(bytesStreamOutput.size(), equalTo(0));\n+        }\n+\n+    }\n }"
}