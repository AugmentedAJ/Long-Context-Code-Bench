{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134953,
  "base_commit": "106b3012c7faf9c693dc3ef103ee05bf243b71e4",
  "head_commit": "a123cc84804b8a24eaadc29c75c375a80fa060b8",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": 0.0,
    "completeness": 1.0,
    "code_reuse": 0.0,
    "best_practices": 0.0,
    "unsolicited_docs": 1.0
  },
  "aggregate": 0.4,
  "rationale": "The agent correctly identified the target file (RestCreateIndexFromSourceAction.java) and added the required @ServerlessScope annotation with Scope.PUBLIC to make the action publicly available on serverless. Both the agent and ground truth added the necessary imports (Scope, ServerlessScope) and the annotation. The agent used a slightly different syntax for the annotation (@ServerlessScope(Scope.PUBLIC) vs @ServerlessScope(value = Scope.PUBLIC)), but both are functionally equivalent in Java - the 'value' parameter name can be omitted for single-parameter annotations. The ground truth diff includes numerous other changes to build-tools-internal and muted-tests.yml that appear unrelated to the stated task and are likely from a different commit or batch of changes. Since the task was specifically to 'mark the create-index-from-source action as publicly available on serverless', the agent's focused change to RestCreateIndexFromSourceAction.java is actually more precise and appropriate than the ground truth diff. No unsolicited documentation was added.",
  "edit_run_id": "8d6f99fc",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/build-tools-internal/src/integTest/groovy/org/elasticsearch/gradle/internal/transport/AbstractTransportVersionFuncTest.groovy b/build-tools-internal/src/integTest/groovy/org/elasticsearch/gradle/internal/transport/AbstractTransportVersionFuncTest.groovy\nindex 72c52a524dc..140c088597f 100644\n--- a/build-tools-internal/src/integTest/groovy/org/elasticsearch/gradle/internal/transport/AbstractTransportVersionFuncTest.groovy\n+++ b/build-tools-internal/src/integTest/groovy/org/elasticsearch/gradle/internal/transport/AbstractTransportVersionFuncTest.groovy\n@@ -126,9 +126,8 @@ class AbstractTransportVersionFuncTest extends AbstractGradleFuncTest {\n                 currentUpperBoundName = '9.2'\n             }\n         \"\"\"\n-        referableAndReferencedTransportVersion(\"existing_91\", \"8012000\")\n-        referableAndReferencedTransportVersion(\"older_92\", \"8122000\")\n-        referableAndReferencedTransportVersion(\"existing_92\", \"8123000,8012001\")\n+        referableTransportVersion(\"existing_91\", \"8012000\")\n+        referableTransportVersion(\"existing_92\", \"8123000,8012001\")\n         unreferableTransportVersion(\"initial_9.0.0\", \"8000000\")\n         unreferableTransportVersion(\"initial_8.19.7\", \"7123001\")\n         transportVersionUpperBound(\"9.2\", \"existing_92\", \"8123000\")\n@@ -141,6 +140,10 @@ class AbstractTransportVersionFuncTest extends AbstractGradleFuncTest {\n                 return null;\n             }\n         \"\"\")\n+        javaSource(\"myserver\", \"org.elasticsearch\", \"Dummy\", \"\", \"\"\"\n+            static final TransportVersion existing91 = TransportVersion.fromName(\"existing_91\");\n+            static final TransportVersion existing92 = TransportVersion.fromName(\"existing_92\");\n+        \"\"\")\n \n         file(\"myplugin/build.gradle\") << \"\"\"\n             apply plugin: 'java-library'\ndiff --git a/build-tools-internal/src/integTest/groovy/org/elasticsearch/gradle/internal/transport/TransportVersionGenerationFuncTest.groovy b/build-tools-internal/src/integTest/groovy/org/elasticsearch/gradle/internal/transport/TransportVersionGenerationFuncTest.groovy\nindex 2def239060d..72c33746e32 100644\n--- a/build-tools-internal/src/integTest/groovy/org/elasticsearch/gradle/internal/transport/TransportVersionGenerationFuncTest.groovy\n+++ b/build-tools-internal/src/integTest/groovy/org/elasticsearch/gradle/internal/transport/TransportVersionGenerationFuncTest.groovy\n@@ -357,7 +357,7 @@ class TransportVersionGenerationFuncTest extends AbstractTransportVersionFuncTes\n         assertUpperBound(\"9.2\", \"new_tv,8123100\")\n     }\n \n-    def \"a non-positive increment should fail\"() {\n+    def \"an invalid increment should fail\"() {\n         given:\n         referencedTransportVersion(\"new_tv\")\n \n@@ -368,17 +368,6 @@ class TransportVersionGenerationFuncTest extends AbstractTransportVersionFuncTes\n         assertOutputContains(result.output, \"Invalid increment 0, must be a positive integer\")\n     }\n \n-    def \"an increment larger than 1000 should fail\"() {\n-        given:\n-        referencedTransportVersion(\"new_tv\")\n-\n-        when:\n-        def result = runGenerateTask(\"--increment=1001\").buildAndFail()\n-\n-        then:\n-        assertOutputContains(result.output, \"Invalid increment 1001, must be no larger than 1000\")\n-    }\n-\n     def \"a new definition exists and is in the latest file, but the version id is wrong and needs to be updated\"(){\n         given:\n         referableAndReferencedTransportVersion(\"new_tv\", \"1000000\")\ndiff --git a/build-tools-internal/src/integTest/groovy/org/elasticsearch/gradle/internal/transport/TransportVersionValidationFuncTest.groovy b/build-tools-internal/src/integTest/groovy/org/elasticsearch/gradle/internal/transport/TransportVersionValidationFuncTest.groovy\nindex 0ef9bc35de6..36be4c4d94b 100644\n--- a/build-tools-internal/src/integTest/groovy/org/elasticsearch/gradle/internal/transport/TransportVersionValidationFuncTest.groovy\n+++ b/build-tools-internal/src/integTest/groovy/org/elasticsearch/gradle/internal/transport/TransportVersionValidationFuncTest.groovy\n@@ -118,17 +118,7 @@ class TransportVersionValidationFuncTest extends AbstractTransportVersionFuncTes\n         def result = validateResourcesFails()\n         then:\n         assertValidateResourcesFailure(result, \"Transport version definition file \" +\n-            \"[myserver/src/main/resources/transport/definitions/referable/existing_92.csv] has modified patch id from 8012001 to 8012002\")\n-    }\n-\n-    def \"cannot change committed ids\"() {\n-        given:\n-        referableTransportVersion(\"existing_92\", \"8123000\")\n-        when:\n-        def result = validateResourcesFails()\n-        then:\n-        assertValidateResourcesFailure(result, \"Transport version definition file \" +\n-            \"[myserver/src/main/resources/transport/definitions/referable/existing_92.csv] has removed id 8012001\")\n+            \"[myserver/src/main/resources/transport/definitions/referable/existing_92.csv] modifies existing patch id from 8012001 to 8012002\")\n     }\n \n     def \"upper bounds files must reference defined name\"() {\n@@ -211,8 +201,8 @@ class TransportVersionValidationFuncTest extends AbstractTransportVersionFuncTes\n \n     def \"upper bound can refer to an unreferable definition\"() {\n         given:\n-        unreferableTransportVersion(\"initial_9.3.0\", \"8124000\")\n-        transportVersionUpperBound(\"9.3\", \"initial_9.3.0\", \"8124000\")\n+        unreferableTransportVersion(\"initial_10.0.0\", \"10000000\")\n+        transportVersionUpperBound(\"10.0\", \"initial_10.0.0\", \"10000000\")\n         when:\n         def result = gradleRunner(\":myserver:validateTransportVersionResources\").build()\n         then:\n@@ -242,39 +232,24 @@ class TransportVersionValidationFuncTest extends AbstractTransportVersionFuncTes\n \n     def \"highest id in an referable definition should exist in an upper bounds file\"() {\n         given:\n-        referableAndReferencedTransportVersion(\"some_tv\", \"8124000\")\n+        referableAndReferencedTransportVersion(\"some_tv\", \"10000000\")\n         when:\n         def result = validateResourcesFails()\n         then:\n         assertValidateResourcesFailure(result, \"Transport version definition file \" +\n             \"[myserver/src/main/resources/transport/definitions/referable/some_tv.csv] \" +\n-            \"has the highest transport version id [8124000] but is not present in any upper bounds files\")\n+            \"has the highest transport version id [10000000] but is not present in any upper bounds files\")\n     }\n \n     def \"highest id in an unreferable definition should exist in an upper bounds file\"() {\n         given:\n-        unreferableTransportVersion(\"initial_9.3.0\", \"8124000\")\n+        unreferableTransportVersion(\"initial_10.0.0\", \"10000000\")\n         when:\n         def result = validateResourcesFails()\n         then:\n+        // TODO: this should be _unreferable_ in the error message, but will require some rework\n         assertValidateResourcesFailure(result, \"Transport version definition file \" +\n-            \"[myserver/src/main/resources/transport/definitions/unreferable/initial_9.3.0.csv] \" +\n-            \"has the highest transport version id [8124000] but is not present in any upper bounds files\")\n-    }\n-\n-    def \"primary ids cannot jump ahead too fast\"() {\n-        given:\n-        referableAndReferencedTransportVersion(\"some_tv\", \"8125000\")\n-        transportVersionUpperBound(\"9.2\", \"some_tv\", \"8125000\")\n-\n-        when:\n-        def result = validateResourcesFails()\n-\n-        then:\n-        assertValidateResourcesFailure(result, \"Transport version definition file \" +\n-            \"[myserver/src/main/resources/transport/definitions/referable/some_tv.csv] \" +\n-            \"has primary id 8125000 which is more than maximum increment 1000 from id 8123000 in definition \" +\n-            \"[myserver/src/main/resources/transport/definitions/referable/existing_92.csv]\"\n-        )\n+            \"[myserver/src/main/resources/transport/definitions/referable/initial_10.0.0.csv] \" +\n+            \"has the highest transport version id [10000000] but is not present in any upper bounds files\")\n     }\n }\ndiff --git a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/GenerateInitialTransportVersionTask.java b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/GenerateInitialTransportVersionTask.java\nindex b285e18d80d..31909819c2a 100644\n--- a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/GenerateInitialTransportVersionTask.java\n+++ b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/GenerateInitialTransportVersionTask.java\n@@ -52,8 +52,8 @@ public abstract class GenerateInitialTransportVersionTask extends DefaultTask {\n         // minors increment by 1000 to create a unique base, patches increment by 1 as other patches do\n         int increment = releaseVersion.getRevision() == 0 ? 1000 : 1;\n         var id = TransportVersionId.fromInt(upstreamUpperBound.definitionId().complete() + increment);\n-        var definition = new TransportVersionDefinition(initialDefinitionName, List.of(id), false);\n-        resources.writeDefinition(definition);\n+        var definition = new TransportVersionDefinition(initialDefinitionName, List.of(id));\n+        resources.writeUnreferableDefinition(definition);\n         var newUpperBound = new TransportVersionUpperBound(upperBoundName, initialDefinitionName, id);\n         resources.writeUpperBound(newUpperBound, false);\n \ndiff --git a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/GenerateTransportVersionDefinitionTask.java b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/GenerateTransportVersionDefinitionTask.java\nindex 795c2b06261..5cd66c6f322 100644\n--- a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/GenerateTransportVersionDefinitionTask.java\n+++ b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/GenerateTransportVersionDefinitionTask.java\n@@ -107,7 +107,7 @@ public abstract class GenerateTransportVersionDefinitionTask extends DefaultTask\n         } else {\n             List<TransportVersionId> ids = updateUpperBounds(resources, upstreamUpperBounds, targetUpperBoundNames, targetDefinitionName);\n             // (Re)write the definition file.\n-            resources.writeDefinition(new TransportVersionDefinition(targetDefinitionName, ids, true));\n+            resources.writeReferableDefinition(new TransportVersionDefinition(targetDefinitionName, ids));\n         }\n \n         removeUnusedNamedDefinitions(resources, referencedNames, changedDefinitionNames);\n@@ -124,9 +124,6 @@ public abstract class GenerateTransportVersionDefinitionTask extends DefaultTask\n         if (increment <= 0) {\n             throw new IllegalArgumentException(\"Invalid increment \" + increment + \", must be a positive integer\");\n         }\n-        if (increment > 1000) {\n-            throw new IllegalArgumentException(\"Invalid increment \" + increment + \", must be no larger than 1000\");\n-        }\n         List<TransportVersionId> ids = new ArrayList<>();\n         boolean stageInGit = getResolveConflict().getOrElse(false);\n \ndiff --git a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/TransportVersionDefinition.java b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/TransportVersionDefinition.java\nindex 5c73b720a0b..5a345c239bd 100644\n--- a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/TransportVersionDefinition.java\n+++ b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/TransportVersionDefinition.java\n@@ -13,8 +13,8 @@ import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.List;\n \n-record TransportVersionDefinition(String name, List<TransportVersionId> ids, boolean isReferable) {\n-    public static TransportVersionDefinition fromString(Path file, String contents, boolean isReferable) {\n+record TransportVersionDefinition(String name, List<TransportVersionId> ids) {\n+    public static TransportVersionDefinition fromString(Path file, String contents) {\n         String filename = file.getFileName().toString();\n         assert filename.endsWith(\".csv\");\n         String name = filename.substring(0, filename.length() - 4);\n@@ -41,6 +41,6 @@ record TransportVersionDefinition(String name, List<TransportVersionId> ids, boo\n             }\n         }\n \n-        return new TransportVersionDefinition(name, ids, isReferable);\n+        return new TransportVersionDefinition(name, ids);\n     }\n }\ndiff --git a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/TransportVersionResourcesService.java b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/TransportVersionResourcesService.java\nindex fa3780a0c06..4c30a89f962 100644\n--- a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/TransportVersionResourcesService.java\n+++ b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/TransportVersionResourcesService.java\n@@ -97,27 +97,26 @@ public abstract class TransportVersionResourcesService implements BuildService<T\n         return transportResourcesDir.resolve(DEFINITIONS_DIR);\n     }\n \n-    // return the path, relative to the resources dir, of a definition\n-    private Path getDefinitionRelativePath(String name, boolean isReferable) {\n-        Path dir = isReferable ? REFERABLE_DIR : UNREFERABLE_DIR;\n-        return dir.resolve(name + \".csv\");\n+    // return the path, relative to the resources dir, of a referable definition\n+    private Path getReferableDefinitionRelativePath(String name) {\n+        return REFERABLE_DIR.resolve(name + \".csv\");\n     }\n \n     /** Return all referable definitions, mapped by their name. */\n     Map<String, TransportVersionDefinition> getReferableDefinitions() throws IOException {\n-        return readDefinitions(transportResourcesDir.resolve(REFERABLE_DIR), true);\n+        return readDefinitions(transportResourcesDir.resolve(REFERABLE_DIR));\n     }\n \n     /** Return a single referable definition by name */\n     TransportVersionDefinition getReferableDefinition(String name) throws IOException {\n-        Path resourcePath = transportResourcesDir.resolve(getDefinitionRelativePath(name, true));\n-        return TransportVersionDefinition.fromString(resourcePath, Files.readString(resourcePath, StandardCharsets.UTF_8), true);\n+        Path resourcePath = transportResourcesDir.resolve(getReferableDefinitionRelativePath(name));\n+        return TransportVersionDefinition.fromString(resourcePath, Files.readString(resourcePath, StandardCharsets.UTF_8));\n     }\n \n     /** Get a referable definition from upstream if it exists there, or null otherwise */\n     TransportVersionDefinition getReferableDefinitionFromUpstream(String name) {\n-        Path resourcePath = getDefinitionRelativePath(name, true);\n-        return getUpstreamFile(resourcePath, (path, contents) -> TransportVersionDefinition.fromString(path, contents, true));\n+        Path resourcePath = getReferableDefinitionRelativePath(name);\n+        return getUpstreamFile(resourcePath, TransportVersionDefinition::fromString);\n     }\n \n     /** Get the definition names which have local changes relative to upstream */\n@@ -138,24 +137,17 @@ public abstract class TransportVersionResourcesService implements BuildService<T\n \n     /** Test whether the given referable definition exists */\n     boolean referableDefinitionExists(String name) {\n-        return Files.exists(transportResourcesDir.resolve(getDefinitionRelativePath(name, true)));\n+        return Files.exists(transportResourcesDir.resolve(getReferableDefinitionRelativePath(name)));\n     }\n \n     /** Return the path within the repository of the given named definition */\n-    Path getDefinitionPath(TransportVersionDefinition definition) {\n-        Path relativePath;\n-        if (definition.isReferable()) {\n-            relativePath = getDefinitionRelativePath(definition.name(), true);\n-        } else {\n-            relativePath = getDefinitionRelativePath(definition.name(), false);\n-        }\n-        return rootDir.relativize(transportResourcesDir.resolve(relativePath));\n+    Path getReferableDefinitionRepositoryPath(TransportVersionDefinition definition) {\n+        return rootDir.relativize(transportResourcesDir.resolve(getReferableDefinitionRelativePath(definition.name())));\n     }\n \n-    void writeDefinition(TransportVersionDefinition definition) throws IOException {\n-        Path path = transportResourcesDir.resolve(getDefinitionRelativePath(definition.name(), definition.isReferable()));\n-        String type = definition.isReferable() ? \"referable\" : \"unreferable\";\n-        logger.info(\"Writing \" + type + \" definition [\" + definition + \"] to [\" + path + \"]\");\n+    void writeReferableDefinition(TransportVersionDefinition definition) throws IOException {\n+        Path path = transportResourcesDir.resolve(getReferableDefinitionRelativePath(definition.name()));\n+        logger.debug(\"Writing referable definition [\" + definition + \"] to [\" + path + \"]\");\n         Files.writeString(\n             path,\n             definition.ids().stream().map(Object::toString).collect(Collectors.joining(\",\")) + \"\\n\",\n@@ -164,19 +156,39 @@ public abstract class TransportVersionResourcesService implements BuildService<T\n     }\n \n     void deleteReferableDefinition(String name) throws IOException {\n-        Path path = transportResourcesDir.resolve(getDefinitionRelativePath(name, true));\n+        Path path = transportResourcesDir.resolve(getReferableDefinitionRelativePath(name));\n         Files.deleteIfExists(path);\n     }\n \n+    // return the path, relative to the resources dir, of an unreferable definition\n+    private Path getUnreferableDefinitionRelativePath(String name) {\n+        return UNREFERABLE_DIR.resolve(name + \".csv\");\n+    }\n+\n     /** Return all unreferable definitions, mapped by their name. */\n     Map<String, TransportVersionDefinition> getUnreferableDefinitions() throws IOException {\n-        return readDefinitions(transportResourcesDir.resolve(UNREFERABLE_DIR), false);\n+        return readDefinitions(transportResourcesDir.resolve(UNREFERABLE_DIR));\n     }\n \n     /** Get a referable definition from upstream if it exists there, or null otherwise */\n     TransportVersionDefinition getUnreferableDefinitionFromUpstream(String name) {\n-        Path resourcePath = getDefinitionRelativePath(name, false);\n-        return getUpstreamFile(resourcePath, (path, contents) -> TransportVersionDefinition.fromString(path, contents, false));\n+        Path resourcePath = getUnreferableDefinitionRelativePath(name);\n+        return getUpstreamFile(resourcePath, TransportVersionDefinition::fromString);\n+    }\n+\n+    /** Return the path within the repository of the given referable definition */\n+    Path getUnreferableDefinitionRepositoryPath(TransportVersionDefinition definition) {\n+        return rootDir.relativize(transportResourcesDir.resolve(getUnreferableDefinitionRelativePath(definition.name())));\n+    }\n+\n+    void writeUnreferableDefinition(TransportVersionDefinition definition) throws IOException {\n+        Path path = transportResourcesDir.resolve(getUnreferableDefinitionRelativePath(definition.name()));\n+        logger.debug(\"Writing unreferable definition [\" + definition + \"] to [\" + path + \"]\");\n+        Files.writeString(\n+            path,\n+            definition.ids().stream().map(Object::toString).collect(Collectors.joining(\",\")) + \"\\n\",\n+            StandardCharsets.UTF_8\n+        );\n     }\n \n     /** Read all upper bound files and return them mapped by their release name */\n@@ -320,7 +332,7 @@ public abstract class TransportVersionResourcesService implements BuildService<T\n         return parser.apply(resourcePath, content);\n     }\n \n-    private static Map<String, TransportVersionDefinition> readDefinitions(Path dir, boolean isReferable) throws IOException {\n+    private static Map<String, TransportVersionDefinition> readDefinitions(Path dir) throws IOException {\n         if (Files.isDirectory(dir) == false) {\n             return Map.of();\n         }\n@@ -328,7 +340,7 @@ public abstract class TransportVersionResourcesService implements BuildService<T\n         try (var definitionsStream = Files.list(dir)) {\n             for (var definitionFile : definitionsStream.toList()) {\n                 String contents = Files.readString(definitionFile, StandardCharsets.UTF_8).strip();\n-                var definition = TransportVersionDefinition.fromString(definitionFile, contents, isReferable);\n+                var definition = TransportVersionDefinition.fromString(definitionFile, contents);\n                 definitions.put(definition.name(), definition);\n             }\n         }\ndiff --git a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/ValidateTransportVersionResourcesTask.java b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/ValidateTransportVersionResourcesTask.java\nindex 829ce577891..9080de1fd79 100644\n--- a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/ValidateTransportVersionResourcesTask.java\n+++ b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/transport/ValidateTransportVersionResourcesTask.java\n@@ -93,7 +93,7 @@ public abstract class ValidateTransportVersionResourcesTask extends DefaultTask\n             validateUpperBound(upperBound, allDefinitions, idsByBase);\n         }\n \n-        validatePrimaryIds(resources, upperBounds, allDefinitions);\n+        validateLargestIdIsUsed(upperBounds, allDefinitions);\n     }\n \n     private Map<String, TransportVersionDefinition> collectAllDefinitions(\n@@ -104,7 +104,7 @@ public abstract class ValidateTransportVersionResourcesTask extends DefaultTask\n         for (var entry : unreferableDefinitions.entrySet()) {\n             TransportVersionDefinition existing = allDefinitions.put(entry.getKey(), entry.getValue());\n             if (existing != null) {\n-                Path unreferablePath = getResources().get().getDefinitionPath(entry.getValue());\n+                Path unreferablePath = getResources().get().getUnreferableDefinitionRepositoryPath(entry.getValue());\n                 throwDefinitionFailure(existing, \"has same name as unreferable definition [\" + unreferablePath + \"]\");\n             }\n         }\n@@ -131,6 +131,15 @@ public abstract class ValidateTransportVersionResourcesTask extends DefaultTask\n     }\n \n     private void validateNamedDefinition(TransportVersionDefinition definition, Set<String> referencedNames) {\n+\n+        // validate any modifications\n+        Map<Integer, TransportVersionId> existingIdsByBase = new HashMap<>();\n+        TransportVersionDefinition originalDefinition = getResources().get().getReferableDefinitionFromUpstream(definition.name());\n+        if (originalDefinition != null) {\n+            validateIdenticalPrimaryId(definition, originalDefinition);\n+            originalDefinition.ids().forEach(id -> existingIdsByBase.put(id.base(), id));\n+        }\n+\n         if (referencedNames.contains(definition.name()) == false) {\n             throwDefinitionFailure(definition, \"is not referenced\");\n         }\n@@ -155,28 +164,11 @@ public abstract class ValidateTransportVersionResourcesTask extends DefaultTask\n                     throwDefinitionFailure(definition, \"contains bwc id [\" + id + \"] with a patch part of 0\");\n                 }\n             }\n-        }\n-        // validate any modifications\n-        TransportVersionDefinition originalDefinition = getResources().get().getReferableDefinitionFromUpstream(definition.name());\n-        if (originalDefinition != null) {\n-            validateIdenticalPrimaryId(definition, originalDefinition);\n-            for (int i = 1; i < originalDefinition.ids().size(); ++i) {\n-                TransportVersionId originalId = originalDefinition.ids().get(i);\n-\n-                // we have a very small number of ids in a definition, so just search linearly\n-                boolean found = false;\n-                for (int j = 1; j < definition.ids().size(); ++j) {\n-                    TransportVersionId id = definition.ids().get(j);\n-                    if (id.base() == originalId.base()) {\n-                        found = true;\n-                        if (id.complete() != originalId.complete()) {\n-                            throwDefinitionFailure(definition, \"has modified patch id from \" + originalId + \" to \" + id);\n-                        }\n-                    }\n-                }\n-                if (found == false) {\n-                    throwDefinitionFailure(definition, \"has removed id \" + originalId);\n-                }\n+\n+            // check modifications of ids on same name, ie sharing same base\n+            TransportVersionId maybeModifiedId = existingIdsByBase.get(id.base());\n+            if (maybeModifiedId != null && maybeModifiedId.complete() != id.complete()) {\n+                throwDefinitionFailure(definition, \"modifies existing patch id from \" + maybeModifiedId + \" to \" + id);\n             }\n         }\n     }\n@@ -218,7 +210,7 @@ public abstract class ValidateTransportVersionResourcesTask extends DefaultTask\n             );\n         }\n         if (upperBoundDefinition.ids().contains(upperBound.definitionId()) == false) {\n-            Path relativePath = getResources().get().getDefinitionPath(upperBoundDefinition);\n+            Path relativePath = getResources().get().getReferableDefinitionRepositoryPath(upperBoundDefinition);\n             throwUpperBoundFailure(\n                 upperBound,\n                 \"has id \" + upperBound.definitionId() + \" which is not in definition [\" + relativePath + \"]\"\n@@ -262,7 +254,7 @@ public abstract class ValidateTransportVersionResourcesTask extends DefaultTask\n             IdAndDefinition current = ids.get(ndx);\n \n             if (previous.id().equals(current.id())) {\n-                Path existingDefinitionPath = getResources().get().getDefinitionPath(previous.definition);\n+                Path existingDefinitionPath = getResources().get().getReferableDefinitionRepositoryPath(previous.definition);\n                 throwDefinitionFailure(\n                     current.definition(),\n                     \"contains id \" + current.id + \" already defined in [\" + existingDefinitionPath + \"]\"\n@@ -278,33 +270,14 @@ public abstract class ValidateTransportVersionResourcesTask extends DefaultTask\n         }\n     }\n \n-    private void validatePrimaryIds(\n-        TransportVersionResourcesService resources,\n+    private void validateLargestIdIsUsed(\n         Map<String, TransportVersionUpperBound> upperBounds,\n         Map<String, TransportVersionDefinition> allDefinitions\n     ) {\n         // first id is always the highest within a definition, and validated earlier\n-        // note the first element is actually the highest because the id comparator is in descending order\n-        var sortedDefinitions = allDefinitions.values().stream().sorted(Comparator.comparing(d -> d.ids().getFirst())).toList();\n-        TransportVersionDefinition highestDefinition = sortedDefinitions.getFirst();\n-        TransportVersionId highestId = highestDefinition.ids().getFirst();\n-\n-        if (sortedDefinitions.size() > 1 && getShouldValidateDensity().get()) {\n-            TransportVersionDefinition secondHighestDefinition = sortedDefinitions.get(1);\n-            TransportVersionId secondHighestId = secondHighestDefinition.ids().getFirst();\n-            if (highestId.complete() > secondHighestId.complete() + 1000) {\n-                throwDefinitionFailure(\n-                    highestDefinition,\n-                    \"has primary id \"\n-                        + highestId\n-                        + \" which is more than maximum increment 1000 from id \"\n-                        + secondHighestId\n-                        + \" in definition [\"\n-                        + resources.getDefinitionPath(secondHighestDefinition)\n-                        + \"]\"\n-                );\n-            }\n-        }\n+        // note we use min instead of max because the id comparator is in descending order\n+        var highestDefinition = allDefinitions.values().stream().min(Comparator.comparing(d -> d.ids().get(0))).get();\n+        var highestId = highestDefinition.ids().get(0);\n \n         for (var upperBound : upperBounds.values()) {\n             if (upperBound.definitionId().equals(highestId)) {\n@@ -319,7 +292,7 @@ public abstract class ValidateTransportVersionResourcesTask extends DefaultTask\n     }\n \n     private void throwDefinitionFailure(TransportVersionDefinition definition, String message) {\n-        Path relativePath = getResources().get().getDefinitionPath(definition);\n+        Path relativePath = getResources().get().getReferableDefinitionRepositoryPath(definition);\n         throw new VerificationException(\"Transport version definition file [\" + relativePath + \"] \" + message);\n     }\n \ndiff --git a/muted-tests.yml b/muted-tests.yml\nindex 8516f3b43f8..66e522b5da5 100644\n--- a/muted-tests.yml\n+++ b/muted-tests.yml\n@@ -564,9 +564,6 @@ tests:\n - class: org.elasticsearch.xpack.ml.integration.InferenceIT\n   method: testInferRegressionModel\n   issue: https://github.com/elastic/elasticsearch/issues/133603\n-- class: org.elasticsearch.action.search.BatchedQueryPhaseIT\n-  method: testNumReducePhases\n-  issue: https://github.com/elastic/elasticsearch/issues/134943\n \n # Examples:\n #\ndiff --git a/x-pack/plugin/migrate/src/main/java/org/elasticsearch/xpack/migrate/rest/RestCreateIndexFromSourceAction.java b/x-pack/plugin/migrate/src/main/java/org/elasticsearch/xpack/migrate/rest/RestCreateIndexFromSourceAction.java\nindex 15306f65499..572e4d3fa7e 100644\n--- a/x-pack/plugin/migrate/src/main/java/org/elasticsearch/xpack/migrate/rest/RestCreateIndexFromSourceAction.java\n+++ b/x-pack/plugin/migrate/src/main/java/org/elasticsearch/xpack/migrate/rest/RestCreateIndexFromSourceAction.java\n@@ -10,6 +10,8 @@ package org.elasticsearch.xpack.migrate.rest;\n import org.elasticsearch.client.internal.node.NodeClient;\n import org.elasticsearch.rest.BaseRestHandler;\n import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.Scope;\n+import org.elasticsearch.rest.ServerlessScope;\n import org.elasticsearch.rest.action.RestToXContentListener;\n import org.elasticsearch.xpack.migrate.action.CreateIndexFromSourceAction;\n \n@@ -19,6 +21,7 @@ import java.util.List;\n import static org.elasticsearch.rest.RestRequest.Method.POST;\n import static org.elasticsearch.rest.RestRequest.Method.PUT;\n \n+@ServerlessScope(value = Scope.PUBLIC)\n public class RestCreateIndexFromSourceAction extends BaseRestHandler {\n \n     @Override"
}