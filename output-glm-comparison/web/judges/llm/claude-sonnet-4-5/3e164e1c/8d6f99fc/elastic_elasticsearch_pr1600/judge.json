{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 1600,
  "base_commit": "ed8a46ce09ccf43adec55af91a72fc9c5dc1ec05",
  "head_commit": "682176497f9f454943d2373dc24501ad37b8dbb0",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.4,
    "completeness": -0.3,
    "code_reuse": -0.2,
    "best_practices": -0.3,
    "unsolicited_docs": 1.0
  },
  "aggregate": -0.039999999999999994,
  "rationale": "The agent's implementation has several critical issues compared to ground truth: (1) Missing TimeValue import needed for TTL parsing, (2) Missing getDate timestamp for TTL approximation logic, (3) Incorrectly keeps TimestampFieldMapper in get() call instead of replacing it with TTLFieldMapper, (4) Extracts timestamp from script context (_timestamp) in ground truth but from request/fields in agent's version - fundamentally different approaches, (5) Missing TTL parsing logic from script context that handles both Number and String TimeValue formats, (6) Missing TTL approximation calculation (ttl - (currentTime - getDate)), (7) Adds unnecessary UpdateRequest fields/methods and RestUpdateAction changes not present in ground truth, (8) Uses wrong types (long vs Long) for TTL. The agent's approach of pulling timestamp/TTL from request parameters rather than script execution context is architecturally different and likely incorrect for the update action's script-based workflow.",
  "edit_run_id": "8d6f99fc",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\nindex 5a296cdf925..ae9eea79b9f 100644\n--- a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\n+++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\n@@ -43,6 +43,7 @@ import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.common.collect.Tuple;\n import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.xcontent.XContentHelper;\n import org.elasticsearch.common.xcontent.XContentType;\n import org.elasticsearch.index.engine.DocumentMissingException;\n@@ -52,7 +53,7 @@ import org.elasticsearch.index.get.GetResult;\n import org.elasticsearch.index.mapper.internal.ParentFieldMapper;\n import org.elasticsearch.index.mapper.internal.RoutingFieldMapper;\n import org.elasticsearch.index.mapper.internal.SourceFieldMapper;\n-import org.elasticsearch.index.mapper.internal.TimestampFieldMapper;\n+import org.elasticsearch.index.mapper.internal.TTLFieldMapper;\n import org.elasticsearch.index.service.IndexService;\n import org.elasticsearch.index.shard.IllegalIndexShardStateException;\n import org.elasticsearch.index.shard.ShardId;\n@@ -152,8 +153,9 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         IndexService indexService = indicesService.indexServiceSafe(request.index());\n         IndexShard indexShard = indexService.shardSafe(request.shardId());\n \n+        long getDate = System.currentTimeMillis();\n         GetResult getResult = indexShard.getService().get(request.type(), request.id(),\n-                new String[]{SourceFieldMapper.NAME, RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TimestampFieldMapper.NAME}, true);\n+                new String[]{SourceFieldMapper.NAME, RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TTLFieldMapper.NAME}, true);\n \n         // no doc, what to do, what to do...\n         if (!getResult.exists()) {\n@@ -183,12 +185,28 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         }\n \n         String operation = (String) ctx.get(\"op\");\n+        String timestamp = (String) ctx.get(\"_timestamp\");\n+        Long ttl = null;\n+        Object fetchedTTL = ctx.get(\"_ttl\");\n+        if (fetchedTTL != null) {\n+            if (fetchedTTL instanceof Number) {\n+                ttl = ((Number) fetchedTTL).longValue();\n+            } else {\n+                ttl = TimeValue.parseTimeValue((String) fetchedTTL, null).millis();\n+            }\n+        }\n         source = (Map<String, Object>) ctx.get(\"_source\");\n \n         // apply script to update the source\n         String routing = getResult.fields().containsKey(RoutingFieldMapper.NAME) ? getResult.field(RoutingFieldMapper.NAME).value().toString() : null;\n         String parent = getResult.fields().containsKey(ParentFieldMapper.NAME) ? getResult.field(ParentFieldMapper.NAME).value().toString() : null;\n-        // TODO ttl/timestamp\n+        // No TTL has been given in the update script so we keep previous TTL value if there is one\n+        if (ttl == null) {\n+            ttl = getResult.fields().containsKey(TTLFieldMapper.NAME) ? (Long) getResult.field(TTLFieldMapper.NAME).value() : null;\n+            if (ttl != null) {\n+                ttl = ttl - (System.currentTimeMillis() - getDate); // It is an approximation of exact TTL value, could be improved\n+            }\n+        }\n \n         // TODO percolate?\n \n@@ -197,7 +215,8 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         if (operation == null || \"index\".equals(operation)) {\n             IndexRequest indexRequest = Requests.indexRequest(request.index()).type(request.type()).id(request.id()).routing(routing).parent(parent)\n                     .source(source, sourceAndContent.v1())\n-                    .version(getResult.version()).replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel());\n+                    .version(getResult.version()).replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel())\n+                    .timestamp(timestamp).ttl(ttl);\n             indexRequest.operationThreaded(false);\n             indexAction.execute(indexRequest, new ActionListener<IndexResponse>() {\n                 @Override"
}