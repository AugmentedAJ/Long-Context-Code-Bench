{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4422,
  "base_commit": "bb275166f1a1f20f5330691ab854d6dc61c51366",
  "head_commit": "6e4d33bb4d68b06bc296f6793e8b01020233fecc",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.8,
    "completeness": -0.9,
    "code_reuse": -0.5,
    "best_practices": -0.6,
    "unsolicited_docs": 1.0
  },
  "aggregate": -0.36000000000000004,
  "rationale": "The agent's diff is critically incomplete and incorrect. Key missing components: (1) The new CreateIndexClusterStateUpdateRequest class is entirely absent, which is central to the refactoring; (2) CreateIndexRequest still extends the wrong base class (not changed to AcknowledgedRequest); (3) CreateIndexRequestBuilder parent class not updated; (4) TransportCreateIndexAction not refactored to use ClusterStateUpdateListener and the new request class; (5) MetaDataCreateIndexService.createIndex method signature and implementation not properly updated to use AckedClusterStateUpdateTask with onAllNodesAcked/onAckTimeout callbacks; (6) NodeIndexCreatedAction.java file not deleted. The agent only made superficial changes: updated CreateIndexResponse to extend AcknowledgedResponse (correct but incomplete - missing null parameter in readAcknowledged), removed NodeIndexCreatedAction binding and references, removed the old acknowledgment mechanism in MetaDataCreateIndexService, and updated RestCreateIndexAction. The core refactoring to use the generic ack mechanism via AckedClusterStateUpdateTask and CreateIndexClusterStateUpdateRequest is completely missing. The MetaDataCreateIndexService change is particularly incorrect - it simply calls listener.onResponse in clusterStateProcessed without implementing the proper ack mechanism, which defeats the purpose of the refactoring. Test files also not added.",
  "edit_run_id": "8d6f99fc",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexClusterStateUpdateRequest.java b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexClusterStateUpdateRequest.java\nnew file mode 100644\nindex 00000000000..3286ecdd43e\n--- /dev/null\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexClusterStateUpdateRequest.java\n@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to ElasticSearch and Shay Banon under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. ElasticSearch licenses this\n+ * file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.create;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import org.elasticsearch.cluster.ack.ClusterStateUpdateRequest;\n+import org.elasticsearch.cluster.block.ClusterBlock;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.settings.ImmutableSettings;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.google.common.collect.Maps.newHashMap;\n+\n+/**\n+ * Cluster state update request that allows to create an index\n+ */\n+public class CreateIndexClusterStateUpdateRequest extends ClusterStateUpdateRequest<CreateIndexClusterStateUpdateRequest> {\n+\n+    final String cause;\n+    final String index;\n+\n+    private IndexMetaData.State state = IndexMetaData.State.OPEN;\n+\n+    private Settings settings = ImmutableSettings.Builder.EMPTY_SETTINGS;\n+\n+    private Map<String, String> mappings = Maps.newHashMap();\n+\n+    private Map<String, IndexMetaData.Custom> customs = newHashMap();\n+\n+    private Set<ClusterBlock> blocks = Sets.newHashSet();\n+\n+\n+    CreateIndexClusterStateUpdateRequest(String cause, String index) {\n+        this.cause = cause;\n+        this.index = index;\n+    }\n+\n+    public CreateIndexClusterStateUpdateRequest settings(Settings settings) {\n+        this.settings = settings;\n+        return this;\n+    }\n+\n+    public CreateIndexClusterStateUpdateRequest mappings(Map<String, String> mappings) {\n+        this.mappings.putAll(mappings);\n+        return this;\n+    }\n+\n+    public CreateIndexClusterStateUpdateRequest customs(Map<String, IndexMetaData.Custom> customs) {\n+        this.customs.putAll(customs);\n+        return this;\n+    }\n+\n+    public CreateIndexClusterStateUpdateRequest blocks(Set<ClusterBlock> blocks) {\n+        this.blocks.addAll(blocks);\n+        return this;\n+    }\n+\n+    public CreateIndexClusterStateUpdateRequest state(IndexMetaData.State state) {\n+        this.state = state;\n+        return this;\n+    }\n+\n+    public String cause() {\n+        return cause;\n+    }\n+\n+    public String index() {\n+        return index;\n+    }\n+\n+    public IndexMetaData.State state() {\n+        return state;\n+    }\n+\n+    public Settings settings() {\n+        return settings;\n+    }\n+\n+    public Map<String, String> mappings() {\n+        return mappings;\n+    }\n+\n+    public Map<String, IndexMetaData.Custom> customs() {\n+        return customs;\n+    }\n+\n+    public Set<ClusterBlock> blocks() {\n+        return blocks;\n+    }\n+}\ndiff --git a/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java\nindex 9814efc7f8f..f8760f8bea7 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java\n@@ -26,7 +26,6 @@ import org.elasticsearch.ElasticSearchParseException;\n import org.elasticsearch.action.ActionRequestValidationException;\n import org.elasticsearch.action.admin.indices.mapping.put.PutMappingRequest;\n import org.elasticsearch.action.support.master.AcknowledgedRequest;\n-import org.elasticsearch.action.support.master.MasterNodeOperationRequest;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.bytes.BytesArray;\n import org.elasticsearch.common.bytes.BytesReference;\n@@ -35,7 +34,6 @@ import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.common.settings.ImmutableSettings;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.common.xcontent.XContentFactory;\n import org.elasticsearch.common.xcontent.XContentType;\n@@ -48,7 +46,6 @@ import static org.elasticsearch.action.ValidateActions.addValidationError;\n import static org.elasticsearch.common.settings.ImmutableSettings.Builder.EMPTY_SETTINGS;\n import static org.elasticsearch.common.settings.ImmutableSettings.readSettingsFromStream;\n import static org.elasticsearch.common.settings.ImmutableSettings.writeSettingsToStream;\n-import static org.elasticsearch.common.unit.TimeValue.readTimeValue;\n \n /**\n  * A request to create an index. Best created with {@link org.elasticsearch.client.Requests#createIndexRequest(String)}.\n@@ -59,7 +56,7 @@ import static org.elasticsearch.common.unit.TimeValue.readTimeValue;\n  * @see org.elasticsearch.client.Requests#createIndexRequest(String)\n  * @see CreateIndexResponse\n  */\n-public class CreateIndexRequest extends MasterNodeOperationRequest<CreateIndexRequest> {\n+public class CreateIndexRequest extends AcknowledgedRequest<CreateIndexRequest> {\n \n     private String cause = \"\";\n \n@@ -71,8 +68,6 @@ public class CreateIndexRequest extends MasterNodeOperationRequest<CreateIndexRe\n \n     private Map<String, IndexMetaData.Custom> customs = newHashMap();\n \n-    private TimeValue timeout = AcknowledgedRequest.DEFAULT_ACK_TIMEOUT;\n-\n     CreateIndexRequest() {\n     }\n \n@@ -173,6 +168,7 @@ public class CreateIndexRequest extends MasterNodeOperationRequest<CreateIndexRe\n     /**\n      * The settings to crete the index with (either json/yaml/properties format)\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public CreateIndexRequest settings(Map source) {\n         try {\n             XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n@@ -224,6 +220,7 @@ public class CreateIndexRequest extends MasterNodeOperationRequest<CreateIndexRe\n      * @param type   The mapping type\n      * @param source The mapping source\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public CreateIndexRequest mapping(String type, Map source) {\n         // wrap it in a type map if its not\n         if (source.size() != 1 || !source.containsKey(type)) {\n@@ -292,6 +289,7 @@ public class CreateIndexRequest extends MasterNodeOperationRequest<CreateIndexRe\n     /**\n      * Sets the settings and mappings as a single source.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public CreateIndexRequest source(Map<String, Object> source) {\n         boolean found = false;\n         for (Map.Entry<String, Object> entry : source.entrySet()) {\n@@ -338,38 +336,13 @@ public class CreateIndexRequest extends MasterNodeOperationRequest<CreateIndexRe\n         return this.customs;\n     }\n \n-    /**\n-     * Timeout to wait for the index creation to be acknowledged by current cluster nodes. Defaults\n-     * to <tt>10s</tt>.\n-     */\n-    public TimeValue timeout() {\n-        return timeout;\n-    }\n-\n-    /**\n-     * Timeout to wait for the index creation to be acknowledged by current cluster nodes. Defaults\n-     * to <tt>10s</tt>.\n-     */\n-    public CreateIndexRequest timeout(TimeValue timeout) {\n-        this.timeout = timeout;\n-        return this;\n-    }\n-\n-    /**\n-     * Timeout to wait for the index creation to be acknowledged by current cluster nodes. Defaults\n-     * to <tt>10s</tt>.\n-     */\n-    public CreateIndexRequest timeout(String timeout) {\n-        return timeout(TimeValue.parseTimeValue(timeout, null));\n-    }\n-\n     @Override\n     public void readFrom(StreamInput in) throws IOException {\n         super.readFrom(in);\n         cause = in.readString();\n         index = in.readString();\n         settings = readSettingsFromStream(in);\n-        timeout = readTimeValue(in);\n+        readTimeout(in);\n         int size = in.readVInt();\n         for (int i = 0; i < size; i++) {\n             mappings.put(in.readString(), in.readString());\n@@ -388,7 +361,7 @@ public class CreateIndexRequest extends MasterNodeOperationRequest<CreateIndexRe\n         out.writeString(cause);\n         out.writeString(index);\n         writeSettingsToStream(settings, out);\n-        timeout.writeTo(out);\n+        writeTimeout(out);\n         out.writeVInt(mappings.size());\n         for (Map.Entry<String, String> entry : mappings.entrySet()) {\n             out.writeString(entry.getKey());\ndiff --git a/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequestBuilder.java b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequestBuilder.java\nindex 2dcf7d4994d..429e2c0c340 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequestBuilder.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequestBuilder.java\n@@ -20,21 +20,20 @@\n package org.elasticsearch.action.admin.indices.create;\n \n import org.elasticsearch.action.ActionListener;\n-import org.elasticsearch.action.support.master.MasterNodeOperationRequestBuilder;\n+import org.elasticsearch.action.support.master.AcknowledgedRequestBuilder;\n import org.elasticsearch.client.IndicesAdminClient;\n import org.elasticsearch.client.internal.InternalIndicesAdminClient;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.bytes.BytesReference;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n \n import java.util.Map;\n \n /**\n- *\n+ * Builder for a create index request\n  */\n-public class CreateIndexRequestBuilder extends MasterNodeOperationRequestBuilder<CreateIndexRequest, CreateIndexResponse, CreateIndexRequestBuilder> {\n+public class CreateIndexRequestBuilder extends AcknowledgedRequestBuilder<CreateIndexRequest, CreateIndexResponse, CreateIndexRequestBuilder> {\n \n     public CreateIndexRequestBuilder(IndicesAdminClient indicesClient) {\n         super((InternalIndicesAdminClient) indicesClient, new CreateIndexRequest());\n@@ -200,24 +199,6 @@ public class CreateIndexRequestBuilder extends MasterNodeOperationRequestBuilder\n         return this;\n     }\n \n-    /**\n-     * Timeout to wait for the index creation to be acknowledged by current cluster nodes. Defaults\n-     * to <tt>10s</tt>.\n-     */\n-    public CreateIndexRequestBuilder setTimeout(TimeValue timeout) {\n-        request.timeout(timeout);\n-        return this;\n-    }\n-\n-    /**\n-     * Timeout to wait for the index creation to be acknowledged by current cluster nodes. Defaults\n-     * to <tt>10s</tt>.\n-     */\n-    public CreateIndexRequestBuilder setTimeout(String timeout) {\n-        request.timeout(timeout);\n-        return this;\n-    }\n-\n     @Override\n     protected void doExecute(ActionListener<CreateIndexResponse> listener) {\n         ((IndicesAdminClient) client).create(request, listener);\ndiff --git a/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexResponse.java b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexResponse.java\nindex 7052861e8c5..c110a491574 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexResponse.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexResponse.java\n@@ -19,7 +19,7 @@\n \n package org.elasticsearch.action.admin.indices.create;\n \n-import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n \n@@ -28,34 +28,24 @@ import java.io.IOException;\n /**\n  * A response for a create index action.\n  */\n-public class CreateIndexResponse extends ActionResponse {\n-\n-    private boolean acknowledged;\n+public class CreateIndexResponse extends AcknowledgedResponse {\n \n     CreateIndexResponse() {\n     }\n \n     CreateIndexResponse(boolean acknowledged) {\n-        this.acknowledged = acknowledged;\n-    }\n-\n-    /**\n-     * Has the index creation been acknowledged by all current cluster nodes within the\n-     * provided {@link CreateIndexRequest#timeout(org.elasticsearch.common.unit.TimeValue)}.\n-     */\n-    public boolean isAcknowledged() {\n-        return acknowledged;\n+        super(acknowledged);\n     }\n \n     @Override\n     public void readFrom(StreamInput in) throws IOException {\n         super.readFrom(in);\n-        acknowledged = in.readBoolean();\n+        readAcknowledged(in, null);\n     }\n \n     @Override\n     public void writeTo(StreamOutput out) throws IOException {\n         super.writeTo(out);\n-        out.writeBoolean(acknowledged);\n+        writeAcknowledged(out, null);\n     }\n }\ndiff --git a/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java b/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java\nindex 1185016adf7..081ff8223e0 100644\n--- a/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java\n+++ b/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java\n@@ -24,6 +24,8 @@ import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.support.master.TransportMasterNodeOperationAction;\n import org.elasticsearch.cluster.ClusterService;\n import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ack.ClusterStateUpdateListener;\n+import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;\n import org.elasticsearch.cluster.block.ClusterBlockException;\n import org.elasticsearch.cluster.block.ClusterBlockLevel;\n import org.elasticsearch.cluster.metadata.MetaDataCreateIndexService;\n@@ -80,26 +82,27 @@ public class TransportCreateIndexAction extends TransportMasterNodeOperationActi\n             cause = \"api\";\n         }\n \n-        createIndexService.createIndex(new MetaDataCreateIndexService.Request(cause, request.index()).settings(request.settings())\n-                .mappings(request.mappings())\n-                .customs(request.customs())\n-                .timeout(request.timeout())\n-                .masterTimeout(request.masterNodeTimeout()),\n-                new MetaDataCreateIndexService.Listener() {\n-                    @Override\n-                    public void onResponse(MetaDataCreateIndexService.Response response) {\n-                        listener.onResponse(new CreateIndexResponse(response.acknowledged()));\n-                    }\n+        CreateIndexClusterStateUpdateRequest updateRequest = new CreateIndexClusterStateUpdateRequest(cause, request.index())\n+                .ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout())\n+                .settings(request.settings()).mappings(request.mappings())\n+                .customs(request.customs());\n \n-                    @Override\n-                    public void onFailure(Throwable t) {\n-                        if (t instanceof IndexAlreadyExistsException) {\n-                            logger.trace(\"[{}] failed to create\", t, request.index());\n-                        } else {\n-                            logger.debug(\"[{}] failed to create\", t, request.index());\n-                        }\n-                        listener.onFailure(t);\n-                    }\n-                });\n+        createIndexService.createIndex(updateRequest, new ClusterStateUpdateListener() {\n+\n+            @Override\n+            public void onResponse(ClusterStateUpdateResponse response) {\n+                listener.onResponse(new CreateIndexResponse(response.isAcknowledged()));\n+            }\n+\n+            @Override\n+            public void onFailure(Throwable t) {\n+                if (t instanceof IndexAlreadyExistsException) {\n+                    logger.trace(\"[{}] failed to create\", t, request.index());\n+                } else {\n+                    logger.debug(\"[{}] failed to create\", t, request.index());\n+                }\n+                listener.onFailure(t);\n+            }\n+        });\n     }\n }\ndiff --git a/src/main/java/org/elasticsearch/cluster/ClusterModule.java b/src/main/java/org/elasticsearch/cluster/ClusterModule.java\nindex 5edfa236e04..ae123dd45c7 100644\n--- a/src/main/java/org/elasticsearch/cluster/ClusterModule.java\n+++ b/src/main/java/org/elasticsearch/cluster/ClusterModule.java\n@@ -71,7 +71,6 @@ public class ClusterModule extends AbstractModule implements SpawnModules {\n         bind(RoutingService.class).asEagerSingleton();\n \n         bind(ShardStateAction.class).asEagerSingleton();\n-        bind(NodeIndexCreatedAction.class).asEagerSingleton();\n         bind(NodeIndexDeletedAction.class).asEagerSingleton();\n         bind(NodeMappingRefreshAction.class).asEagerSingleton();\n         bind(MappingUpdatedAction.class).asEagerSingleton();\ndiff --git a/src/main/java/org/elasticsearch/cluster/action/index/NodeIndexCreatedAction.java b/src/main/java/org/elasticsearch/cluster/action/index/NodeIndexCreatedAction.java\ndeleted file mode 100644\nindex 71c64970c6b..00000000000\n--- a/src/main/java/org/elasticsearch/cluster/action/index/NodeIndexCreatedAction.java\n+++ /dev/null\n@@ -1,134 +0,0 @@\n-/*\n- * Licensed to ElasticSearch and Shay Banon under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. ElasticSearch licenses this\n- * file to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.cluster.action.index;\n-\n-import org.elasticsearch.ElasticSearchException;\n-import org.elasticsearch.cluster.ClusterState;\n-import org.elasticsearch.cluster.node.DiscoveryNodes;\n-import org.elasticsearch.common.component.AbstractComponent;\n-import org.elasticsearch.common.inject.Inject;\n-import org.elasticsearch.common.io.stream.StreamInput;\n-import org.elasticsearch.common.io.stream.StreamOutput;\n-import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.threadpool.ThreadPool;\n-import org.elasticsearch.transport.*;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-\n-/**\n- *\n- */\n-public class NodeIndexCreatedAction extends AbstractComponent {\n-\n-    private final ThreadPool threadPool;\n-    private final TransportService transportService;\n-    private final List<Listener> listeners = new CopyOnWriteArrayList<Listener>();\n-\n-    @Inject\n-    public NodeIndexCreatedAction(Settings settings, ThreadPool threadPool, TransportService transportService) {\n-        super(settings);\n-        this.threadPool = threadPool;\n-        this.transportService = transportService;\n-        transportService.registerHandler(NodeIndexCreatedTransportHandler.ACTION, new NodeIndexCreatedTransportHandler());\n-    }\n-\n-    public void add(Listener listener) {\n-        listeners.add(listener);\n-    }\n-\n-    public void remove(Listener listener) {\n-        listeners.remove(listener);\n-    }\n-\n-    public void nodeIndexCreated(final ClusterState clusterState, final String index, final String nodeId) throws ElasticSearchException {\n-        DiscoveryNodes nodes = clusterState.nodes();\n-        if (nodes.localNodeMaster()) {\n-            threadPool.generic().execute(new Runnable() {\n-                @Override\n-                public void run() {\n-                    innerNodeIndexCreated(index, nodeId);\n-                }\n-            });\n-        } else {\n-            transportService.sendRequest(clusterState.nodes().masterNode(),\n-                    NodeIndexCreatedTransportHandler.ACTION, new NodeIndexCreatedMessage(index, nodeId), EmptyTransportResponseHandler.INSTANCE_SAME);\n-        }\n-    }\n-\n-    private void innerNodeIndexCreated(String index, String nodeId) {\n-        for (Listener listener : listeners) {\n-            listener.onNodeIndexCreated(index, nodeId);\n-        }\n-    }\n-\n-    public static interface Listener {\n-        void onNodeIndexCreated(String index, String nodeId);\n-    }\n-\n-    private class NodeIndexCreatedTransportHandler extends BaseTransportRequestHandler<NodeIndexCreatedMessage> {\n-\n-        static final String ACTION = \"cluster/nodeIndexCreated\";\n-\n-        @Override\n-        public NodeIndexCreatedMessage newInstance() {\n-            return new NodeIndexCreatedMessage();\n-        }\n-\n-        @Override\n-        public void messageReceived(NodeIndexCreatedMessage message, TransportChannel channel) throws Exception {\n-            innerNodeIndexCreated(message.index, message.nodeId);\n-            channel.sendResponse(TransportResponse.Empty.INSTANCE);\n-        }\n-\n-        @Override\n-        public String executor() {\n-            return ThreadPool.Names.SAME;\n-        }\n-    }\n-\n-    static class NodeIndexCreatedMessage extends TransportRequest {\n-        String index;\n-        String nodeId;\n-\n-        NodeIndexCreatedMessage() {\n-        }\n-\n-        NodeIndexCreatedMessage(String index, String nodeId) {\n-            this.index = index;\n-            this.nodeId = nodeId;\n-        }\n-\n-        @Override\n-        public void writeTo(StreamOutput out) throws IOException {\n-            super.writeTo(out);\n-            out.writeString(index);\n-            out.writeString(nodeId);\n-        }\n-\n-        @Override\n-        public void readFrom(StreamInput in) throws IOException {\n-            super.readFrom(in);\n-            index = in.readString();\n-            nodeId = in.readString();\n-        }\n-    }\n-}\ndiff --git a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\nindex a394166439d..cca1cf3c952 100644\n--- a/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\n+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java\n@@ -24,21 +24,23 @@ import com.carrotsearch.hppc.cursors.ObjectObjectCursor;\n import com.google.common.base.Charsets;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n-import com.google.common.collect.Sets;\n import org.apache.lucene.util.CollectionUtil;\n import org.apache.lucene.util.IOUtils;\n import org.elasticsearch.ElasticSearchException;\n import org.elasticsearch.Version;\n-import org.elasticsearch.action.support.master.MasterNodeOperationRequest;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexClusterStateUpdateRequest;\n+import org.elasticsearch.cluster.AckedClusterStateUpdateTask;\n import org.elasticsearch.cluster.ClusterService;\n import org.elasticsearch.cluster.ClusterState;\n-import org.elasticsearch.cluster.TimeoutClusterStateUpdateTask;\n-import org.elasticsearch.cluster.action.index.NodeIndexCreatedAction;\n+import org.elasticsearch.cluster.ack.ClusterStateUpdateListener;\n+import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;\n import org.elasticsearch.cluster.block.ClusterBlock;\n import org.elasticsearch.cluster.block.ClusterBlocks;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.cluster.routing.allocation.AllocationService;\n import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.common.Nullable;\n import org.elasticsearch.common.Priority;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.component.AbstractComponent;\n@@ -66,21 +68,19 @@ import org.elasticsearch.threadpool.ThreadPool;\n \n import java.io.File;\n import java.io.FileInputStream;\n-import java.io.IOException;\n import java.io.InputStreamReader;\n-import java.util.*;\n-import java.util.concurrent.ScheduledFuture;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n-import static com.google.common.collect.Maps.newHashMap;\n import static org.elasticsearch.cluster.metadata.IndexMetaData.*;\n import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;\n \n /**\n- *\n+ * Service responsible for submitting create index requests\n  */\n public class MetaDataCreateIndexService extends AbstractComponent {\n \n@@ -89,29 +89,27 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n     private final ClusterService clusterService;\n     private final IndicesService indicesService;\n     private final AllocationService allocationService;\n-    private final NodeIndexCreatedAction nodeIndexCreatedAction;\n     private final MetaDataService metaDataService;\n     private final Version version;\n     private final String riverIndexName;\n \n     @Inject\n     public MetaDataCreateIndexService(Settings settings, Environment environment, ThreadPool threadPool, ClusterService clusterService, IndicesService indicesService,\n-                                      AllocationService allocationService, NodeIndexCreatedAction nodeIndexCreatedAction, MetaDataService metaDataService, Version version, @RiverIndexName String riverIndexName) {\n+                                      AllocationService allocationService, MetaDataService metaDataService, Version version, @RiverIndexName String riverIndexName) {\n         super(settings);\n         this.environment = environment;\n         this.threadPool = threadPool;\n         this.clusterService = clusterService;\n         this.indicesService = indicesService;\n         this.allocationService = allocationService;\n-        this.nodeIndexCreatedAction = nodeIndexCreatedAction;\n         this.metaDataService = metaDataService;\n         this.version = version;\n         this.riverIndexName = riverIndexName;\n     }\n \n-    public void createIndex(final Request request, final Listener userListener) {\n+    public void createIndex(final CreateIndexClusterStateUpdateRequest request, final ClusterStateUpdateListener listener) {\n         ImmutableSettings.Builder updatedSettingsBuilder = ImmutableSettings.settingsBuilder();\n-        for (Map.Entry<String, String> entry : request.settings.getAsMap().entrySet()) {\n+        for (Map.Entry<String, String> entry : request.settings().getAsMap().entrySet()) {\n             if (!entry.getKey().startsWith(\"index.\")) {\n                 updatedSettingsBuilder.put(\"index.\" + entry.getKey(), entry.getValue());\n             } else {\n@@ -122,11 +120,11 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n \n         // we lock here, and not within the cluster service callback since we don't want to\n         // block the whole cluster state handling\n-        final Semaphore mdLock = metaDataService.indexMetaDataLock(request.index);\n+        final Semaphore mdLock = metaDataService.indexMetaDataLock(request.index());\n \n         // quick check to see if we can acquire a lock, otherwise spawn to a thread pool\n         if (mdLock.tryAcquire()) {\n-            createIndex(request, userListener, mdLock);\n+            createIndex(request, listener, mdLock);\n             return;\n         }\n \n@@ -134,16 +132,17 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n             @Override\n             public void run() {\n                 try {\n-                    if (!mdLock.tryAcquire(request.masterTimeout.nanos(), TimeUnit.NANOSECONDS)) {\n-                        userListener.onFailure(new ProcessClusterEventTimeoutException(request.masterTimeout, \"acquire index lock\"));\n+                    if (!mdLock.tryAcquire(request.masterNodeTimeout().nanos(), TimeUnit.NANOSECONDS)) {\n+                        listener.onFailure(new ProcessClusterEventTimeoutException(request.masterNodeTimeout(), \"acquire index lock\"));\n                         return;\n                     }\n                 } catch (InterruptedException e) {\n-                    userListener.onFailure(e);\n+                    Thread.interrupted();\n+                    listener.onFailure(e);\n                     return;\n                 }\n \n-                createIndex(request, userListener, mdLock);\n+                createIndex(request, listener, mdLock);\n             }\n         });\n     }\n@@ -172,17 +171,39 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n         }\n     }\n \n-    private void createIndex(final Request request, final Listener userListener, Semaphore mdLock) {\n-        final CreateIndexListener listener = new CreateIndexListener(mdLock, request, userListener);\n-        clusterService.submitStateUpdateTask(\"create-index [\" + request.index + \"], cause [\" + request.cause + \"]\", Priority.URGENT, new TimeoutClusterStateUpdateTask() {\n+    private void createIndex(final CreateIndexClusterStateUpdateRequest request, final ClusterStateUpdateListener listener, final Semaphore mdLock) {\n+        clusterService.submitStateUpdateTask(\"create-index [\" + request.index() + \"], cause [\" + request.cause() + \"]\", Priority.URGENT, new AckedClusterStateUpdateTask() {\n+\n+            @Override\n+            public boolean mustAck(DiscoveryNode discoveryNode) {\n+                return true;\n+            }\n+\n+            @Override\n+            public void onAllNodesAcked(@Nullable Throwable t) {\n+                mdLock.release();\n+                listener.onResponse(new ClusterStateUpdateResponse(true));\n+            }\n+\n+            @Override\n+            public void onAckTimeout() {\n+                mdLock.release();\n+                listener.onResponse(new ClusterStateUpdateResponse(false));\n+            }\n+\n+            @Override\n+            public TimeValue ackTimeout() {\n+                return request.ackTimeout();\n+            }\n \n             @Override\n             public TimeValue timeout() {\n-                return request.masterTimeout;\n+                return request.masterNodeTimeout();\n             }\n \n             @Override\n             public void onFailure(String source, Throwable t) {\n+                mdLock.release();\n                 listener.onFailure(t);\n             }\n \n@@ -202,11 +223,11 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n                     // add the request mapping\n                     Map<String, Map<String, Object>> mappings = Maps.newHashMap();\n \n-                    for (Map.Entry<String, String> entry : request.mappings.entrySet()) {\n+                    for (Map.Entry<String, String> entry : request.mappings().entrySet()) {\n                         mappings.put(entry.getKey(), parseMapping(entry.getValue()));\n                     }\n \n-                    for (Map.Entry<String, Custom> entry : request.customs.entrySet()) {\n+                    for (Map.Entry<String, Custom> entry : request.customs().entrySet()) {\n                         customs.put(entry.getKey(), entry.getValue());\n                     }\n \n@@ -237,7 +258,7 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n                     File mappingsDir = new File(environment.configFile(), \"mappings\");\n                     if (mappingsDir.exists() && mappingsDir.isDirectory()) {\n                         // first index level\n-                        File indexMappingsDir = new File(mappingsDir, request.index);\n+                        File indexMappingsDir = new File(mappingsDir, request.index());\n                         if (indexMappingsDir.exists() && indexMappingsDir.isDirectory()) {\n                             addMappings(mappings, indexMappingsDir);\n                         }\n@@ -255,17 +276,17 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n                         indexSettingsBuilder.put(templates.get(i).settings());\n                     }\n                     // now, put the request settings, so they override templates\n-                    indexSettingsBuilder.put(request.settings);\n+                    indexSettingsBuilder.put(request.settings());\n \n                     if (indexSettingsBuilder.get(SETTING_NUMBER_OF_SHARDS) == null) {\n-                        if (request.index.equals(riverIndexName)) {\n+                        if (request.index().equals(riverIndexName)) {\n                             indexSettingsBuilder.put(SETTING_NUMBER_OF_SHARDS, settings.getAsInt(SETTING_NUMBER_OF_SHARDS, 1));\n                         } else {\n                             indexSettingsBuilder.put(SETTING_NUMBER_OF_SHARDS, settings.getAsInt(SETTING_NUMBER_OF_SHARDS, 5));\n                         }\n                     }\n                     if (indexSettingsBuilder.get(SETTING_NUMBER_OF_REPLICAS) == null) {\n-                        if (request.index.equals(riverIndexName)) {\n+                        if (request.index().equals(riverIndexName)) {\n                             indexSettingsBuilder.put(SETTING_NUMBER_OF_REPLICAS, settings.getAsInt(SETTING_NUMBER_OF_REPLICAS, 1));\n                         } else {\n                             indexSettingsBuilder.put(SETTING_NUMBER_OF_REPLICAS, settings.getAsInt(SETTING_NUMBER_OF_REPLICAS, 1));\n@@ -286,10 +307,10 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n                     // Set up everything, now locally create the index to see that things are ok, and apply\n \n                     // create the index here (on the master) to validate it can be created, as well as adding the mapping\n-                    indicesService.createIndex(request.index, actualIndexSettings, clusterService.localNode().id());\n+                    indicesService.createIndex(request.index(), actualIndexSettings, clusterService.localNode().id());\n                     indexCreated = true;\n                     // now add the mappings\n-                    IndexService indexService = indicesService.indexServiceSafe(request.index);\n+                    IndexService indexService = indicesService.indexServiceSafe(request.index());\n                     MapperService mapperService = indexService.mapperService();\n                     // first, add the default mapping\n                     if (mappings.containsKey(MapperService.DEFAULT_MAPPING)) {\n@@ -319,14 +340,14 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n                         mappingsMetaData.put(mapper.type(), mappingMd);\n                     }\n \n-                    final IndexMetaData.Builder indexMetaDataBuilder = IndexMetaData.builder(request.index).settings(actualIndexSettings);\n+                    final IndexMetaData.Builder indexMetaDataBuilder = IndexMetaData.builder(request.index()).settings(actualIndexSettings);\n                     for (MappingMetaData mappingMd : mappingsMetaData.values()) {\n                         indexMetaDataBuilder.putMapping(mappingMd);\n                     }\n                     for (Map.Entry<String, Custom> customEntry : customs.entrySet()) {\n                         indexMetaDataBuilder.putCustom(customEntry.getKey(), customEntry.getValue());\n                     }\n-                    indexMetaDataBuilder.state(request.state);\n+                    indexMetaDataBuilder.state(request.state());\n                     final IndexMetaData indexMetaData;\n                     try {\n                         indexMetaData = indexMetaDataBuilder.build();\n@@ -339,57 +360,31 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n                             .put(indexMetaData, false)\n                             .build();\n \n-                    logger.info(\"[{}] creating index, cause [{}], shards [{}]/[{}], mappings {}\", request.index, request.cause, indexMetaData.numberOfShards(), indexMetaData.numberOfReplicas(), mappings.keySet());\n+                    logger.info(\"[{}] creating index, cause [{}], shards [{}]/[{}], mappings {}\", request.index(), request.cause(), indexMetaData.numberOfShards(), indexMetaData.numberOfReplicas(), mappings.keySet());\n \n                     ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n-                    if (!request.blocks.isEmpty()) {\n-                        for (ClusterBlock block : request.blocks) {\n-                            blocks.addIndexBlock(request.index, block);\n+                    if (!request.blocks().isEmpty()) {\n+                        for (ClusterBlock block : request.blocks()) {\n+                            blocks.addIndexBlock(request.index(), block);\n                         }\n                     }\n-                    if (request.state == State.CLOSE) {\n-                        blocks.addIndexBlock(request.index, MetaDataIndexStateService.INDEX_CLOSED_BLOCK);\n+                    if (request.state() == State.CLOSE) {\n+                        blocks.addIndexBlock(request.index(), MetaDataIndexStateService.INDEX_CLOSED_BLOCK);\n                     }\n \n                     ClusterState updatedState = ClusterState.builder(currentState).blocks(blocks).metaData(newMetaData).build();\n \n-                    if (request.state == State.OPEN) {\n+                    if (request.state() == State.OPEN) {\n                         RoutingTable.Builder routingTableBuilder = RoutingTable.builder(updatedState.routingTable())\n-                                .addAsNew(updatedState.metaData().index(request.index));\n+                                .addAsNew(updatedState.metaData().index(request.index()));\n                         RoutingAllocation.Result routingResult = allocationService.reroute(ClusterState.builder(updatedState).routingTable(routingTableBuilder).build());\n                         updatedState = ClusterState.builder(updatedState).routingResult(routingResult).build();\n                     }\n-\n-                    // we wait for events from all nodes that the index has been added to the metadata\n-                    final AtomicInteger counter = new AtomicInteger(currentState.nodes().size());\n-\n-                    final NodeIndexCreatedAction.Listener nodeIndexCreatedListener = new NodeIndexCreatedAction.Listener() {\n-                        @Override\n-                        public void onNodeIndexCreated(String index, String nodeId) {\n-                            if (index.equals(request.index)) {\n-                                if (counter.decrementAndGet() == 0) {\n-                                    listener.onResponse(new Response(true, indexMetaData));\n-                                    nodeIndexCreatedAction.remove(this);\n-                                }\n-                            }\n-                        }\n-                    };\n-\n-                    nodeIndexCreatedAction.add(nodeIndexCreatedListener);\n-\n-                    listener.future = threadPool.schedule(request.timeout, ThreadPool.Names.SAME, new Runnable() {\n-                        @Override\n-                        public void run() {\n-                            listener.onResponse(new Response(false, indexMetaData));\n-                            nodeIndexCreatedAction.remove(nodeIndexCreatedListener);\n-                        }\n-                    });\n-\n                     return updatedState;\n                 } finally {\n                     if (indexCreated) {\n                         // Index was already partially created - need to clean up\n-                        indicesService.removeIndex(request.index, failureReason != null ? failureReason : \"failed to create index\");\n+                        indicesService.removeIndex(request.index(), failureReason != null ? failureReason : \"failed to create index\");\n                     }\n                 }\n             }\n@@ -400,44 +395,6 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n         });\n     }\n \n-    class CreateIndexListener implements Listener {\n-\n-        private final AtomicBoolean notified = new AtomicBoolean();\n-        private final Semaphore mdLock;\n-        private final Request request;\n-        private final Listener listener;\n-        volatile ScheduledFuture future;\n-\n-        private CreateIndexListener(Semaphore mdLock, Request request, Listener listener) {\n-            this.mdLock = mdLock;\n-            this.request = request;\n-            this.listener = listener;\n-        }\n-\n-        @Override\n-        public void onResponse(final Response response) {\n-            if (notified.compareAndSet(false, true)) {\n-                mdLock.release();\n-                if (future != null) {\n-                    future.cancel(false);\n-                }\n-                listener.onResponse(response);\n-            }\n-        }\n-\n-        @Override\n-        public void onFailure(Throwable t) {\n-            if (notified.compareAndSet(false, true)) {\n-                mdLock.release();\n-                if (future != null) {\n-                    future.cancel(false);\n-                }\n-                listener.onFailure(t);\n-            }\n-        }\n-    }\n-\n-\n     private Map<String, Object> parseMapping(String mappingSource) throws Exception {\n         return XContentFactory.xContent(mappingSource).createParser(mappingSource).mapAndClose();\n     }\n@@ -463,11 +420,11 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n         }\n     }\n \n-    private List<IndexTemplateMetaData> findTemplates(Request request, ClusterState state) {\n+    private List<IndexTemplateMetaData> findTemplates(CreateIndexClusterStateUpdateRequest request, ClusterState state) {\n         List<IndexTemplateMetaData> templates = Lists.newArrayList();\n         for (ObjectCursor<IndexTemplateMetaData> cursor : state.metaData().templates().values()) {\n             IndexTemplateMetaData template = cursor.value;\n-            if (Regex.simpleMatch(template.template(), request.index)) {\n+            if (Regex.simpleMatch(template.template(), request.index())) {\n                 templates.add(template);\n             }\n         }\n@@ -483,11 +440,11 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n                         byte[] templatesData = Streams.copyToByteArray(templatesFile);\n                         parser = XContentHelper.createParser(templatesData, 0, templatesData.length);\n                         IndexTemplateMetaData template = IndexTemplateMetaData.Builder.fromXContent(parser);\n-                        if (Regex.simpleMatch(template.template(), request.index)) {\n+                        if (Regex.simpleMatch(template.template(), request.index())) {\n                             templates.add(template);\n                         }\n                     } catch (Exception e) {\n-                        logger.warn(\"[{}] failed to read template [{}] from config\", e, request.index, templatesFile.getAbsolutePath());\n+                        logger.warn(\"[{}] failed to read template [{}] from config\", e, request.index(), templatesFile.getAbsolutePath());\n                     } finally {\n                         IOUtils.closeWhileHandlingException(parser);\n                     }\n@@ -504,106 +461,7 @@ public class MetaDataCreateIndexService extends AbstractComponent {\n         return templates;\n     }\n \n-    private void validate(Request request, ClusterState state) throws ElasticSearchException {\n-        validateIndexName(request.index, state);\n-    }\n-\n-    public static interface Listener {\n-\n-        void onResponse(Response response);\n-\n-        void onFailure(Throwable t);\n-    }\n-\n-    public static class Request {\n-\n-        final String cause;\n-        final String index;\n-\n-        State state = State.OPEN;\n-\n-        Settings settings = ImmutableSettings.Builder.EMPTY_SETTINGS;\n-\n-        Map<String, String> mappings = Maps.newHashMap();\n-\n-        Map<String, IndexMetaData.Custom> customs = newHashMap();\n-\n-\n-        TimeValue timeout = TimeValue.timeValueSeconds(5);\n-        TimeValue masterTimeout = MasterNodeOperationRequest.DEFAULT_MASTER_NODE_TIMEOUT;\n-\n-        Set<ClusterBlock> blocks = Sets.newHashSet();\n-\n-        public Request(String cause, String index) {\n-            this.cause = cause;\n-            this.index = index;\n-        }\n-\n-        public Request settings(Settings settings) {\n-            this.settings = settings;\n-            return this;\n-        }\n-\n-        public Request mappings(Map<String, String> mappings) {\n-            this.mappings.putAll(mappings);\n-            return this;\n-        }\n-\n-        public Request mappingsMetaData(Map<String, MappingMetaData> mappings) throws IOException {\n-            for (Map.Entry<String, MappingMetaData> entry : mappings.entrySet()) {\n-                this.mappings.put(entry.getKey(), entry.getValue().source().string());\n-            }\n-            return this;\n-        }\n-\n-        public Request mappingsCompressed(Map<String, CompressedString> mappings) throws IOException {\n-            for (Map.Entry<String, CompressedString> entry : mappings.entrySet()) {\n-                this.mappings.put(entry.getKey(), entry.getValue().string());\n-            }\n-            return this;\n-        }\n-\n-        public Request customs(Map<String, Custom> customs) {\n-            this.customs.putAll(customs);\n-            return this;\n-        }\n-\n-        public Request blocks(Set<ClusterBlock> blocks) {\n-            this.blocks.addAll(blocks);\n-            return this;\n-        }\n-\n-        public Request state(State state) {\n-            this.state = state;\n-            return this;\n-        }\n-\n-        public Request timeout(TimeValue timeout) {\n-            this.timeout = timeout;\n-            return this;\n-        }\n-\n-        public Request masterTimeout(TimeValue masterTimeout) {\n-            this.masterTimeout = masterTimeout;\n-            return this;\n-        }\n-    }\n-\n-    public static class Response {\n-        private final boolean acknowledged;\n-        private final IndexMetaData indexMetaData;\n-\n-        public Response(boolean acknowledged, IndexMetaData indexMetaData) {\n-            this.acknowledged = acknowledged;\n-            this.indexMetaData = indexMetaData;\n-        }\n-\n-        public boolean acknowledged() {\n-            return acknowledged;\n-        }\n-\n-        public IndexMetaData indexMetaData() {\n-            return indexMetaData;\n-        }\n+    private void validate(CreateIndexClusterStateUpdateRequest request, ClusterState state) throws ElasticSearchException {\n+        validateIndexName(request.index(), state);\n     }\n }\ndiff --git a/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\nindex d559b94fe9b..14f2805dc00 100644\n--- a/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\n+++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java\n@@ -28,7 +28,6 @@ import org.elasticsearch.ExceptionsHelper;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n import org.elasticsearch.cluster.ClusterService;\n import org.elasticsearch.cluster.ClusterStateListener;\n-import org.elasticsearch.cluster.action.index.NodeIndexCreatedAction;\n import org.elasticsearch.cluster.action.index.NodeIndexDeletedAction;\n import org.elasticsearch.cluster.action.index.NodeMappingRefreshAction;\n import org.elasticsearch.cluster.action.shard.ShardStateAction;\n@@ -86,7 +85,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n     private final ThreadPool threadPool;\n     private final RecoveryTarget recoveryTarget;\n     private final ShardStateAction shardStateAction;\n-    private final NodeIndexCreatedAction nodeIndexCreatedAction;\n     private final NodeIndexDeletedAction nodeIndexDeletedAction;\n     private final NodeMappingRefreshAction nodeMappingRefreshAction;\n \n@@ -117,7 +115,7 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n     public IndicesClusterStateService(Settings settings, IndicesService indicesService, ClusterService clusterService,\n                                       ThreadPool threadPool, RecoveryTarget recoveryTarget,\n                                       ShardStateAction shardStateAction,\n-                                      NodeIndexCreatedAction nodeIndexCreatedAction, NodeIndexDeletedAction nodeIndexDeletedAction,\n+                                      NodeIndexDeletedAction nodeIndexDeletedAction,\n                                       NodeMappingRefreshAction nodeMappingRefreshAction) {\n         super(settings);\n         this.indicesService = indicesService;\n@@ -125,7 +123,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n         this.threadPool = threadPool;\n         this.recoveryTarget = recoveryTarget;\n         this.shardStateAction = shardStateAction;\n-        this.nodeIndexCreatedAction = nodeIndexCreatedAction;\n         this.nodeIndexDeletedAction = nodeIndexDeletedAction;\n         this.nodeMappingRefreshAction = nodeMappingRefreshAction;\n \n@@ -193,13 +190,6 @@ public class IndicesClusterStateService extends AbstractLifecycleComponent<Indic\n     private void sendIndexLifecycleEvents(final ClusterChangedEvent event) {\n         String localNodeId = event.state().nodes().localNodeId();\n         assert localNodeId != null;\n-        for (String index : event.indicesCreated()) {\n-            try {\n-                nodeIndexCreatedAction.nodeIndexCreated(event.state(), index, localNodeId);\n-            } catch (Throwable e) {\n-                logger.debug(\"failed to send to master index {} created event\", e, index);\n-            }\n-        }\n         for (String index : event.indicesDeleted()) {\n             try {\n                 nodeIndexDeletedAction.nodeIndexDeleted(event.state(), index, localNodeId);\ndiff --git a/src/main/java/org/elasticsearch/rest/action/admin/indices/create/RestCreateIndexAction.java b/src/main/java/org/elasticsearch/rest/action/admin/indices/create/RestCreateIndexAction.java\nindex 90cb97066aa..5f97bf48995 100644\n--- a/src/main/java/org/elasticsearch/rest/action/admin/indices/create/RestCreateIndexAction.java\n+++ b/src/main/java/org/elasticsearch/rest/action/admin/indices/create/RestCreateIndexAction.java\n@@ -19,20 +19,15 @@\n \n package org.elasticsearch.rest.action.admin.indices.create;\n \n-import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;\n import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.rest.*;\n-import org.elasticsearch.rest.action.support.RestXContentBuilder;\n \n import java.io.IOException;\n \n-import static org.elasticsearch.rest.RestStatus.OK;\n-\n /**\n  *\n  */\n@@ -66,29 +61,6 @@ public class RestCreateIndexAction extends BaseRestHandler {\n         createIndexRequest.timeout(request.paramAsTime(\"timeout\", createIndexRequest.timeout()));\n         createIndexRequest.masterNodeTimeout(request.paramAsTime(\"master_timeout\", createIndexRequest.masterNodeTimeout()));\n \n-        client.admin().indices().create(createIndexRequest, new ActionListener<CreateIndexResponse>() {\n-            @Override\n-            public void onResponse(CreateIndexResponse response) {\n-                try {\n-                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n-                    builder.startObject()\n-                            .field(\"ok\", true)\n-                            .field(\"acknowledged\", response.isAcknowledged())\n-                            .endObject();\n-                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n-                } catch (Throwable e) {\n-                    onFailure(e);\n-                }\n-            }\n-\n-            @Override\n-            public void onFailure(Throwable e) {\n-                try {\n-                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n-                } catch (IOException e1) {\n-                    logger.error(\"Failed to send failure response\", e1);\n-                }\n-            }\n-        });\n+        client.admin().indices().create(createIndexRequest, new AcknowledgedRestResponseActionListener<CreateIndexResponse>(request, channel, logger));\n     }\n }\ndiff --git a/src/test/java/org/elasticsearch/cluster/ack/AckTests.java b/src/test/java/org/elasticsearch/cluster/ack/AckTests.java\nindex 3f017a278ea..cb51e4c356b 100644\n--- a/src/test/java/org/elasticsearch/cluster/ack/AckTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/ack/AckTests.java\n@@ -28,6 +28,7 @@ import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResp\n import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;\n import org.elasticsearch.action.admin.indices.alias.IndicesAliasesResponse;\n import org.elasticsearch.action.admin.indices.close.CloseIndexResponse;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n import org.elasticsearch.action.admin.indices.mapping.delete.DeleteMappingResponse;\n import org.elasticsearch.action.admin.indices.mapping.get.GetMappingsResponse;\n import org.elasticsearch.action.admin.indices.mapping.put.PutMappingResponse;\n@@ -469,6 +470,28 @@ public class AckTests extends ElasticsearchIntegrationTest {\n         assertThat(putMappingResponse.isAcknowledged(), equalTo(false));\n     }\n \n+    @Test\n+    public void testCreateIndexAcknowledgement() {\n+        createIndex(\"test\");\n+\n+        for (Client client : clients()) {\n+            assertThat(getLocalClusterState(client).metaData().indices().containsKey(\"test\"), equalTo(true));\n+        }\n+\n+        //let's wait for green, otherwise there can be issues with after test checks (mock directory wrapper etc.)\n+        //but we do want to check that the new index is on all nodes cluster state even before green\n+        ensureGreen();\n+    }\n+\n+    @Test\n+    public void testCreateIndexNoAcknowledgement() {\n+        CreateIndexResponse createIndexResponse = client().admin().indices().prepareCreate(\"test\").setTimeout(\"0s\").get();\n+        assertThat(createIndexResponse.isAcknowledged(), equalTo(false));\n+\n+        //let's wait for green, otherwise there can be issues with after test checks (mock directory wrapper etc.)\n+        ensureGreen();\n+    }\n+\n     private static ClusterState getLocalClusterState(Client client) {\n         return client.admin().cluster().prepareState().setLocal(true).get().getState();\n     }\ndiff --git a/src/test/java/org/elasticsearch/test/hamcrest/ElasticsearchAssertions.java b/src/test/java/org/elasticsearch/test/hamcrest/ElasticsearchAssertions.java\nindex f54bcb82c9d..24023f486ce 100644\n--- a/src/test/java/org/elasticsearch/test/hamcrest/ElasticsearchAssertions.java\n+++ b/src/test/java/org/elasticsearch/test/hamcrest/ElasticsearchAssertions.java\n@@ -26,12 +26,8 @@ import org.elasticsearch.action.ActionFuture;\n import org.elasticsearch.action.ActionRequest;\n import org.elasticsearch.action.ActionRequestBuilder;\n import org.elasticsearch.action.ShardOperationFailedException;\n-import org.elasticsearch.action.admin.indices.create.CreateIndexRequestBuilder;\n-import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequestBuilder;\n import org.elasticsearch.action.admin.indices.delete.DeleteIndexResponse;\n-import org.elasticsearch.action.admin.indices.mapping.put.PutMappingRequestBuilder;\n-import org.elasticsearch.action.admin.indices.mapping.put.PutMappingResponse;\n import org.elasticsearch.action.count.CountResponse;\n import org.elasticsearch.action.percolate.PercolateResponse;\n import org.elasticsearch.action.search.SearchRequest;\n@@ -81,20 +77,11 @@ public class ElasticsearchAssertions {\n         assertAcked(builder.get());\n     }\n \n-    public static void assertAcked(CreateIndexRequestBuilder builder) {\n-        assertAcked(builder.get());\n-    }\n-\n     public static void assertAcked(DeleteIndexResponse response) {\n         assertThat(\"Delete Index failed - not acked\", response.isAcknowledged(), equalTo(true));\n         assertVersionSerializable(response);\n     }\n \n-    public static void assertAcked(CreateIndexResponse response) {\n-        assertThat(\"Create Index failed - not acked\", response.isAcknowledged(), equalTo(true));\n-        assertVersionSerializable(response);\n-    }\n-\n     public static String formatShardStatus(BroadcastOperationResponse response) {\n         String msg = \" Total shards: \" + response.getTotalShards() + \" Successful shards: \" + response.getSuccessfulShards() + \" & \"\n                 + response.getFailedShards() + \" shard failures:\";"
}