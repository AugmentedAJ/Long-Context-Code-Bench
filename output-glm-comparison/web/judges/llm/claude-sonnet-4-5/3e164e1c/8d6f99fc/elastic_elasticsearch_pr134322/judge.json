{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134322,
  "base_commit": "6350fe4900f86dbbc6e21d2406e5eb0e49135ee7",
  "head_commit": "92dd38cf0a2e0586e3cfff09b8350d38801d9b31",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": 1.0,
    "completeness": 1.0,
    "code_reuse": 1.0,
    "best_practices": 1.0,
    "unsolicited_docs": 1.0
  },
  "aggregate": 1.0,
  "rationale": "The agent's diff perfectly matches the requested task and the relevant portion of the ground truth diff. The task was to 'remove unused memory calculation methods from LuceneTopNSourceOperator', and the agent removed exactly the three unused private static methods (perDocMemoryUsage with SortField[] parameter, perDocMemoryUsage with SortField parameter, perDocMemoryUsageByType, and perDocMemoryUsageForCustom) along with the unused imports (SortedNumericSortField and SortedSetSortField) from the file x-pack/plugin/esql/compute/src/main/java/org/elasticsearch/compute/lucene/LuceneTopNSourceOperator.java. The ground truth diff contains many other unrelated changes (documentation files, test files, other Java classes, changelog files, etc.) that are completely unrelated to the task instruction. The agent correctly focused only on the specific task given and did not include any extraneous changes. The removal is clean, complete, and maintains the FIELD_DOC_SIZE constant that is still in use. No unsolicited documentation was added, and the code follows best practices for targeted refactoring.",
  "edit_run_id": "8d6f99fc",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/docs/changelog/134091.yaml b/docs/changelog/134091.yaml\ndeleted file mode 100644\nindex d6678c895fe..00000000000\n--- a/docs/changelog/134091.yaml\n+++ /dev/null\n@@ -1,6 +0,0 @@\n-pr: 134091\n-summary: Use latest setting value when initializing setting watch\n-area: Infra/Settings\n-type: bug\n-issues:\n- - 133701\ndiff --git a/docs/changelog/134178.yaml b/docs/changelog/134178.yaml\ndeleted file mode 100644\nindex aaf002310dc..00000000000\n--- a/docs/changelog/134178.yaml\n+++ /dev/null\n@@ -1,5 +0,0 @@\n-pr: 134178\n-summary: Return 429 status when `RequestExecutorService` queue full\n-area: Machine Learning\n-type: bug\n-issues: []\ndiff --git a/docs/changelog/134296.yaml b/docs/changelog/134296.yaml\ndeleted file mode 100644\nindex b7ac7ea6bfd..00000000000\n--- a/docs/changelog/134296.yaml\n+++ /dev/null\n@@ -1,5 +0,0 @@\n-pr: 134296\n-summary: Add human-readable HTTP client stats\n-area: Network\n-type: enhancement\n-issues: []\ndiff --git a/docs/reference/query-languages/esql/_snippets/operators/layout/rlike.md b/docs/reference/query-languages/esql/_snippets/operators/layout/rlike.md\nindex 0a91c9a53cb..1a6cfb6c377 100644\n--- a/docs/reference/query-languages/esql/_snippets/operators/layout/rlike.md\n+++ b/docs/reference/query-languages/esql/_snippets/operators/layout/rlike.md\n@@ -5,7 +5,7 @@\n :class: text-center\n :::\n \n-Use `RLIKE` to filter data based on string patterns using [regular expressions](/reference/query-languages/query-dsl/regexp-syntax.md). `RLIKE` usually acts on a field placed on the left-hand side of the operator, but it can also act on a constant (literal) expression. The right-hand side of the operator represents the pattern.\n+Use `RLIKE` to filter data based on string patterns using using [regular expressions](/reference/query-languages/query-dsl/regexp-syntax.md). `RLIKE` usually acts on a field placed on the left-hand side of the operator, but it can also act on a constant (literal) expression. The right-hand side of the operator represents the pattern.\n \n :::{include} ../types/rlike.md\n :::\ndiff --git a/docs/reference/query-languages/esql/kibana/definition/operators/not rlike.json b/docs/reference/query-languages/esql/kibana/definition/operators/not rlike.json\nindex f25d148ae59..2b914e576cb 100644\n--- a/docs/reference/query-languages/esql/kibana/definition/operators/not rlike.json\t\n+++ b/docs/reference/query-languages/esql/kibana/definition/operators/not rlike.json\t\n@@ -3,7 +3,7 @@\n   \"type\" : \"operator\",\n   \"operator\" : \"not rlike\",\n   \"name\" : \"not_rlike\",\n-  \"description\" : \"Use `RLIKE` to filter data based on string patterns using\\nregular expressions. `RLIKE` usually acts on a field placed on\\nthe left-hand side of the operator, but it can also act on a constant (literal)\\nexpression. The right-hand side of the operator represents the pattern.\",\n+  \"description\" : \"Use `RLIKE` to filter data based on string patterns using using\\nregular expressions. `RLIKE` usually acts on a field placed on\\nthe left-hand side of the operator, but it can also act on a constant (literal)\\nexpression. The right-hand side of the operator represents the pattern.\",\n   \"signatures\" : [\n     {\n       \"params\" : [\ndiff --git a/docs/reference/query-languages/esql/kibana/definition/operators/rlike.json b/docs/reference/query-languages/esql/kibana/definition/operators/rlike.json\nindex fff34af0f24..3c962e8381b 100644\n--- a/docs/reference/query-languages/esql/kibana/definition/operators/rlike.json\n+++ b/docs/reference/query-languages/esql/kibana/definition/operators/rlike.json\n@@ -3,7 +3,7 @@\n   \"type\" : \"operator\",\n   \"operator\" : \"RLIKE\",\n   \"name\" : \"rlike\",\n-  \"description\" : \"Use `RLIKE` to filter data based on string patterns using\\nregular expressions. `RLIKE` usually acts on a field placed on\\nthe left-hand side of the operator, but it can also act on a constant (literal)\\nexpression. The right-hand side of the operator represents the pattern.\",\n+  \"description\" : \"Use `RLIKE` to filter data based on string patterns using using\\nregular expressions. `RLIKE` usually acts on a field placed on\\nthe left-hand side of the operator, but it can also act on a constant (literal)\\nexpression. The right-hand side of the operator represents the pattern.\",\n   \"signatures\" : [\n     {\n       \"params\" : [\ndiff --git a/docs/reference/query-languages/esql/kibana/docs/operators/not rlike.md b/docs/reference/query-languages/esql/kibana/docs/operators/not rlike.md\nindex 9f30cef80ba..c1b2973f6ff 100644\n--- a/docs/reference/query-languages/esql/kibana/docs/operators/not rlike.md\t\n+++ b/docs/reference/query-languages/esql/kibana/docs/operators/not rlike.md\t\n@@ -1,7 +1,7 @@\n % This is generated by ESQL's AbstractFunctionTestCase. Do not edit it. See ../README.md for how to regenerate it.\n \n ### NOT RLIKE\n-Use `RLIKE` to filter data based on string patterns using\n+Use `RLIKE` to filter data based on string patterns using using\n [regular expressions](https://www.elastic.co/docs/reference/query-languages/query-dsl/regexp-syntax). `RLIKE` usually acts on a field placed on\n the left-hand side of the operator, but it can also act on a constant (literal)\n expression. The right-hand side of the operator represents the pattern.\ndiff --git a/docs/reference/query-languages/esql/kibana/docs/operators/rlike.md b/docs/reference/query-languages/esql/kibana/docs/operators/rlike.md\nindex b08eae12bac..7b4ae989c19 100644\n--- a/docs/reference/query-languages/esql/kibana/docs/operators/rlike.md\n+++ b/docs/reference/query-languages/esql/kibana/docs/operators/rlike.md\n@@ -1,7 +1,7 @@\n % This is generated by ESQL's AbstractFunctionTestCase. Do not edit it. See ../README.md for how to regenerate it.\n \n ### RLIKE\n-Use `RLIKE` to filter data based on string patterns using\n+Use `RLIKE` to filter data based on string patterns using using\n [regular expressions](https://www.elastic.co/docs/reference/query-languages/query-dsl/regexp-syntax). `RLIKE` usually acts on a field placed on\n the left-hand side of the operator, but it can also act on a constant (literal)\n expression. The right-hand side of the operator represents the pattern.\ndiff --git a/server/src/main/java/org/elasticsearch/TransportVersions.java b/server/src/main/java/org/elasticsearch/TransportVersions.java\nindex 8c84dce2b85..9b3a71723dc 100644\n--- a/server/src/main/java/org/elasticsearch/TransportVersions.java\n+++ b/server/src/main/java/org/elasticsearch/TransportVersions.java\n@@ -327,6 +327,8 @@ public class TransportVersions {\n     public static final TransportVersion ESQL_SPLIT_ON_BIG_VALUES_9_1 = def(9_112_0_01);\n     public static final TransportVersion ESQL_FIXED_INDEX_LIKE_9_1 = def(9_112_0_02);\n     public static final TransportVersion ESQL_SAMPLE_OPERATOR_STATUS_9_1 = def(9_112_0_03);\n+    public static final TransportVersion INITIAL_ELASTICSEARCH_9_1_1 = def(9_112_0_04);\n+    public static final TransportVersion INITIAL_ELASTICSEARCH_9_1_2 = def(9_112_0_05);\n     public static final TransportVersion INITIAL_ELASTICSEARCH_9_1_4 = def(9_112_0_07);\n     public static final TransportVersion PROJECT_STATE_REGISTRY_RECORDS_DELETIONS = def(9_113_0_00);\n     public static final TransportVersion ESQL_SERIALIZE_TIMESERIES_FIELD_TYPE = def(9_114_0_00);\ndiff --git a/server/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java b/server/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java\nindex 604f281a823..c65f75df663 100644\n--- a/server/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java\n+++ b/server/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java\n@@ -433,11 +433,7 @@ public abstract class AbstractScopedSettings {\n         assert setting.getProperties().contains(Setting.Property.Dynamic)\n             || setting.getProperties().contains(Setting.Property.OperatorDynamic) : \"Can only watch dynamic settings\";\n         assert setting.getProperties().contains(Setting.Property.NodeScope) : \"Can only watch node settings\";\n-\n-        // this mimics the combined settings of last applied and node settings, without building a new settings object\n-        Settings settingsWithValue = setting.exists(lastSettingsApplied) ? lastSettingsApplied : settings;\n-\n-        consumer.accept(setting.get(settingsWithValue));\n+        consumer.accept(setting.get(settings));\n         addSettingsUpdateConsumer(setting, consumer);\n     }\n \ndiff --git a/server/src/main/java/org/elasticsearch/http/HttpStats.java b/server/src/main/java/org/elasticsearch/http/HttpStats.java\nindex f9ccc4f90b7..d4df9c8f59a 100644\n--- a/server/src/main/java/org/elasticsearch/http/HttpStats.java\n+++ b/server/src/main/java/org/elasticsearch/http/HttpStats.java\n@@ -15,7 +15,7 @@ import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.common.io.stream.Writeable;\n import org.elasticsearch.common.xcontent.ChunkedToXContent;\n import org.elasticsearch.xcontent.ToXContent;\n-import org.elasticsearch.xcontent.ToXContentObject;\n+import org.elasticsearch.xcontent.ToXContentFragment;\n import org.elasticsearch.xcontent.XContentBuilder;\n \n import java.io.IOException;\n@@ -89,11 +89,8 @@ public record HttpStats(long serverOpen, long totalOpen, List<ClientStats> clien\n         static final String CLIENT_LOCAL_ADDRESS = \"local_address\";\n         static final String CLIENT_REMOTE_ADDRESS = \"remote_address\";\n         static final String CLIENT_LAST_URI = \"last_uri\";\n-        static final String CLIENT_OPENED_TIME = \"opened_time\";\n         static final String CLIENT_OPENED_TIME_MILLIS = \"opened_time_millis\";\n-        static final String CLIENT_CLOSED_TIME = \"closed_time\";\n         static final String CLIENT_CLOSED_TIME_MILLIS = \"closed_time_millis\";\n-        static final String CLIENT_LAST_REQUEST_TIME = \"last_request_time\";\n         static final String CLIENT_LAST_REQUEST_TIME_MILLIS = \"last_request_time_millis\";\n         static final String CLIENT_REQUEST_COUNT = \"request_count\";\n         static final String CLIENT_REQUEST_SIZE_BYTES = \"request_size_bytes\";\n@@ -139,7 +136,7 @@ public record HttpStats(long serverOpen, long totalOpen, List<ClientStats> clien\n         long lastRequestTimeMillis,\n         long requestCount,\n         long requestSizeBytes\n-    ) implements Writeable, ToXContentObject {\n+    ) implements Writeable, ToXContentFragment {\n \n         public static final long NOT_CLOSED = -1L;\n \n@@ -182,15 +179,11 @@ public record HttpStats(long serverOpen, long totalOpen, List<ClientStats> clien\n             if (opaqueId != null) {\n                 builder.field(Fields.CLIENT_OPAQUE_ID, opaqueId);\n             }\n-            builder.timestampFieldsFromUnixEpochMillis(Fields.CLIENT_OPENED_TIME_MILLIS, Fields.CLIENT_OPENED_TIME, openedTimeMillis);\n+            builder.field(Fields.CLIENT_OPENED_TIME_MILLIS, openedTimeMillis);\n             if (closedTimeMillis != NOT_CLOSED) {\n-                builder.timestampFieldsFromUnixEpochMillis(Fields.CLIENT_CLOSED_TIME_MILLIS, Fields.CLIENT_CLOSED_TIME, closedTimeMillis);\n+                builder.field(Fields.CLIENT_CLOSED_TIME_MILLIS, closedTimeMillis);\n             }\n-            builder.timestampFieldsFromUnixEpochMillis(\n-                Fields.CLIENT_LAST_REQUEST_TIME_MILLIS,\n-                Fields.CLIENT_LAST_REQUEST_TIME,\n-                lastRequestTimeMillis\n-            );\n+            builder.field(Fields.CLIENT_LAST_REQUEST_TIME_MILLIS, lastRequestTimeMillis);\n             builder.field(Fields.CLIENT_REQUEST_COUNT, requestCount);\n             builder.field(Fields.CLIENT_REQUEST_SIZE_BYTES, requestSizeBytes);\n             builder.endObject();\ndiff --git a/server/src/main/resources/transport/definitions/unreferable/initial_elasticsearch_9_1_1.csv b/server/src/main/resources/transport/definitions/unreferable/initial_elasticsearch_9_1_1.csv\ndeleted file mode 100644\nindex a036ad5940c..00000000000\n--- a/server/src/main/resources/transport/definitions/unreferable/initial_elasticsearch_9_1_1.csv\n+++ /dev/null\n@@ -1 +0,0 @@\n-9112004\ndiff --git a/server/src/main/resources/transport/definitions/unreferable/initial_elasticsearch_9_1_2.csv b/server/src/main/resources/transport/definitions/unreferable/initial_elasticsearch_9_1_2.csv\ndeleted file mode 100644\nindex 8ce79e4b333..00000000000\n--- a/server/src/main/resources/transport/definitions/unreferable/initial_elasticsearch_9_1_2.csv\n+++ /dev/null\n@@ -1 +0,0 @@\n-9112005\ndiff --git a/server/src/test/java/org/elasticsearch/action/admin/cluster/settings/ClusterSettingsTests.java b/server/src/test/java/org/elasticsearch/action/admin/cluster/settings/ClusterSettingsTests.java\ndeleted file mode 100644\nindex 7c1c1faadbe..00000000000\n--- a/server/src/test/java/org/elasticsearch/action/admin/cluster/settings/ClusterSettingsTests.java\n+++ /dev/null\n@@ -1,34 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the \"Elastic License\n- * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n- * Public License v 1\"; you may not use this file except in compliance with, at\n- * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n- * License v3.0 only\", or the \"Server Side Public License, v 1\".\n- */\n-\n-package org.elasticsearch.action.admin.cluster.settings;\n-\n-import org.elasticsearch.common.settings.ClusterSettings;\n-import org.elasticsearch.common.settings.Setting;\n-import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.test.ESTestCase;\n-\n-import java.util.Set;\n-\n-import static org.hamcrest.Matchers.equalTo;\n-\n-public class ClusterSettingsTests extends ESTestCase {\n-\n-    public void testWatchAfterApply() {\n-        Setting<String> clusterSetting = Setting.simpleString(\"cluster.setting\", Setting.Property.NodeScope, Setting.Property.Dynamic);\n-        Settings nodeSettings = Settings.builder().put(\"cluster.setting\", \"initial_value\").build();\n-\n-        ClusterSettings clusterSettings = new ClusterSettings(nodeSettings, Set.of(clusterSetting));\n-        Settings newSettings = Settings.builder().put(\"cluster.setting\", \"updated_value\").build();\n-        clusterSettings.applySettings(newSettings);\n-\n-        // the value should be current when initializing the consumer\n-        clusterSettings.initializeAndWatch(clusterSetting, value -> { assertThat(value, equalTo(\"updated_value\")); });\n-    }\n-}\ndiff --git a/server/src/test/java/org/elasticsearch/http/HttpClientStatsTrackerTests.java b/server/src/test/java/org/elasticsearch/http/HttpClientStatsTrackerTests.java\nindex d3a2e12c5aa..a1129e4a717 100644\n--- a/server/src/test/java/org/elasticsearch/http/HttpClientStatsTrackerTests.java\n+++ b/server/src/test/java/org/elasticsearch/http/HttpClientStatsTrackerTests.java\n@@ -9,14 +9,11 @@\n \n package org.elasticsearch.http;\n \n-import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.bytes.BytesArray;\n-import org.elasticsearch.common.bytes.BytesReference;\n import org.elasticsearch.common.network.NetworkAddress;\n import org.elasticsearch.common.settings.ClusterSettings;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.util.Maps;\n-import org.elasticsearch.common.xcontent.XContentHelper;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.node.Node;\n import org.elasticsearch.rest.RestRequest;\n@@ -25,13 +22,8 @@ import org.elasticsearch.test.ESTestCase;\n import org.elasticsearch.test.rest.FakeRestRequest;\n import org.elasticsearch.threadpool.DefaultBuiltInExecutorBuilders;\n import org.elasticsearch.threadpool.ThreadPool;\n-import org.elasticsearch.xcontent.ToXContent;\n-import org.elasticsearch.xcontent.XContentFactory;\n-import org.elasticsearch.xcontent.XContentType;\n \n-import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.time.Instant;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n@@ -387,55 +379,6 @@ public class HttpClientStatsTrackerTests extends ESTestCase {\n         }\n     }\n \n-    public void testToXContent() throws IOException {\n-        final var clientStats = new HttpStats.ClientStats(\n-            randomNonNegativeInt(),\n-            randomIdentifier(),\n-            randomIdentifier(),\n-            randomIdentifier(),\n-            randomIdentifier(),\n-            randomIdentifier(),\n-            randomIdentifier(),\n-            randomLongBetween(1, Long.MAX_VALUE),\n-            randomLongBetween(1, Long.MAX_VALUE),\n-            randomLongBetween(1, Long.MAX_VALUE),\n-            randomNonNegativeLong(),\n-            randomNonNegativeLong()\n-        );\n-        final var description = Strings.toString(clientStats, false, true);\n-        logger.info(\"description: {}\", description);\n-\n-        final Map<String, Object> xcontentMap;\n-        try (var builder = XContentFactory.jsonBuilder()) {\n-            builder.humanReadable(true).value(clientStats, ToXContent.EMPTY_PARAMS);\n-            xcontentMap = XContentHelper.convertToMap(BytesReference.bytes(builder), false, XContentType.JSON).v2();\n-        }\n-\n-        assertEquals(description, clientStats.id(), xcontentMap.get(\"id\"));\n-        assertEquals(description, clientStats.agent(), xcontentMap.get(\"agent\"));\n-        assertEquals(description, clientStats.localAddress(), xcontentMap.get(\"local_address\"));\n-        assertEquals(description, clientStats.remoteAddress(), xcontentMap.get(\"remote_address\"));\n-        assertEquals(description, clientStats.lastUri(), xcontentMap.get(\"last_uri\"));\n-        assertEquals(description, clientStats.forwardedFor(), xcontentMap.get(\"x_forwarded_for\"));\n-        assertEquals(description, clientStats.opaqueId(), xcontentMap.get(\"x_opaque_id\"));\n-\n-        assertEquals(description, clientStats.openedTimeMillis(), xcontentMap.get(\"opened_time_millis\"));\n-        assertEquals(description, Instant.ofEpochMilli(clientStats.openedTimeMillis()).toString(), xcontentMap.get(\"opened_time\"));\n-\n-        assertEquals(description, clientStats.closedTimeMillis(), xcontentMap.get(\"closed_time_millis\"));\n-        assertEquals(description, Instant.ofEpochMilli(clientStats.closedTimeMillis()).toString(), xcontentMap.get(\"closed_time\"));\n-\n-        assertEquals(description, clientStats.lastRequestTimeMillis(), xcontentMap.get(\"last_request_time_millis\"));\n-        assertEquals(\n-            description,\n-            Instant.ofEpochMilli(clientStats.lastRequestTimeMillis()).toString(),\n-            xcontentMap.get(\"last_request_time\")\n-        );\n-\n-        assertEquals(description, clientStats.requestCount(), (long) xcontentMap.get(\"request_count\"));\n-        assertEquals(description, clientStats.requestSizeBytes(), (long) xcontentMap.get(\"request_size_bytes\"));\n-    }\n-\n     private Map<String, String> getRelevantHeaders(HttpRequest httpRequest) {\n         final Map<String, String> headers = Maps.newMapWithExpectedSize(4);\n         final String[] relevantHeaderNames = new String[] { \"user-agent\", \"x-elastic-product-origin\", \"x-forwarded-for\", \"x-opaque-id\" };\ndiff --git a/x-pack/plugin/esql/compute/src/main/java/org/elasticsearch/compute/lucene/LuceneTopNSourceOperator.java b/x-pack/plugin/esql/compute/src/main/java/org/elasticsearch/compute/lucene/LuceneTopNSourceOperator.java\nindex 1b16610b26e..6e1162b1678 100644\n--- a/x-pack/plugin/esql/compute/src/main/java/org/elasticsearch/compute/lucene/LuceneTopNSourceOperator.java\n+++ b/x-pack/plugin/esql/compute/src/main/java/org/elasticsearch/compute/lucene/LuceneTopNSourceOperator.java\n@@ -16,8 +16,6 @@ import org.apache.lucene.search.ScoreDoc;\n import org.apache.lucene.search.ScoreMode;\n import org.apache.lucene.search.Sort;\n import org.apache.lucene.search.SortField;\n-import org.apache.lucene.search.SortedNumericSortField;\n-import org.apache.lucene.search.SortedSetSortField;\n import org.apache.lucene.search.TopDocsCollector;\n import org.apache.lucene.search.TopFieldCollectorManager;\n import org.apache.lucene.search.TopScoreDocCollectorManager;\n@@ -425,67 +423,5 @@ public final class LuceneTopNSourceOperator extends LuceneOperator {\n         return new ScoringPerShardCollector(context, new TopFieldCollectorManager(sort, limit, null, 0).newCollector());\n     }\n \n-    private static int perDocMemoryUsage(SortField[] sorts) {\n-        int usage = FIELD_DOC_SIZE;\n-        for (SortField sort : sorts) {\n-            usage += perDocMemoryUsage(sort);\n-        }\n-        return usage;\n-    }\n-\n-    private static int perDocMemoryUsage(SortField sort) {\n-        if (sort.getType() == SortField.Type.CUSTOM) {\n-            return perDocMemoryUsageForCustom(sort);\n-        }\n-        return perDocMemoryUsageByType(sort, sort.getType());\n-\n-    }\n-\n-    private static int perDocMemoryUsageByType(SortField sort, SortField.Type type) {\n-        return switch (type) {\n-            case SCORE, DOC ->\n-                /* SCORE and DOC are always part of ScoreDoc/FieldDoc\n-                 * So they are in FIELD_DOC_SIZE already.\n-                 * And they can't be removed. */\n-                0;\n-            case DOUBLE, LONG ->\n-                // 8 for the long, 8 for the long copied to the topDoc.\n-                16;\n-            case INT, FLOAT ->\n-                // 4 for the int, 8 boxed object copied to topDoc.\n-                12;\n-            case STRING ->\n-                /* `keyword`-like fields. Compares ordinals when possible, otherwise\n-                 * the strings. Does a bunch of deduplication, but in the worst\n-                 * case we end up with the string itself, plus two BytesRefs. Let's\n-                 * presume short-ish strings. */\n-                1024;\n-            case STRING_VAL ->\n-                /* Other string fields. Compares the string itself. Let's assume two\n-                 * 2kb per string because they tend to be bigger than the keyword\n-                 * versions. */\n-                2048;\n-            case CUSTOM -> throw new IllegalArgumentException(\"unsupported type \" + sort.getClass() + \": \" + sort);\n-            case REWRITEABLE -> {\n-                assert false : \"rewriteable  \" + sort.getClass() + \": \" + sort;\n-                yield 2048;\n-            }\n-        };\n-    }\n-\n-    private static int perDocMemoryUsageForCustom(SortField sort) {\n-        return switch (sort) {\n-            case SortedNumericSortField f -> perDocMemoryUsageByType(f, f.getNumericType());\n-            case SortedSetSortField f -> perDocMemoryUsageByType(f, SortField.Type.STRING);\n-            default -> {\n-                if (sort.getClass().getName().equals(\"org.apache.lucene.document.LatLonPointSortField\")) {\n-                    yield perDocMemoryUsageByType(sort, SortField.Type.DOUBLE);\n-                }\n-                assert false : \"unknown type \" + sort.getClass() + \": \" + sort;\n-                yield 2048;\n-            }\n-        };\n-    }\n-\n     private static final int FIELD_DOC_SIZE = Math.toIntExact(RamUsageEstimator.shallowSizeOf(FieldDoc.class));\n }\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/string/regex/RLike.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/string/regex/RLike.java\nindex 66989a514f3..992a1833c9b 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/string/regex/RLike.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/string/regex/RLike.java\n@@ -32,7 +32,7 @@ public class RLike extends RegexMatch<RLikePattern> {\n     public static final String NAME = \"RLIKE\";\n \n     @FunctionInfo(returnType = \"boolean\", description = \"\"\"\n-        Use `RLIKE` to filter data based on string patterns using\n+        Use `RLIKE` to filter data based on string patterns using using\n         <<regexp-syntax,regular expressions>>. `RLIKE` usually acts on a field placed on\n         the left-hand side of the operator, but it can also act on a constant (literal)\n         expression. The right-hand side of the operator represents the pattern.\"\"\", detailedDescription = \"\"\"\ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/rules/logical/local/IgnoreNullMetricsTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/rules/logical/local/IgnoreNullMetricsTests.java\nindex 7b60246d8fc..5faa73b3aec 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/rules/logical/local/IgnoreNullMetricsTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/rules/logical/local/IgnoreNullMetricsTests.java\n@@ -10,7 +10,6 @@ package org.elasticsearch.xpack.esql.optimizer.rules.logical.local;\n import org.elasticsearch.index.IndexMode;\n import org.elasticsearch.test.ESTestCase;\n import org.elasticsearch.xpack.esql.EsqlTestUtils;\n-import org.elasticsearch.xpack.esql.action.EsqlCapabilities;\n import org.elasticsearch.xpack.esql.analysis.Analyzer;\n import org.elasticsearch.xpack.esql.analysis.AnalyzerContext;\n import org.elasticsearch.xpack.esql.analysis.AnalyzerTestUtils;\n@@ -116,7 +115,6 @@ public class IgnoreNullMetricsTests extends ESTestCase {\n     }\n \n     public void testSimple() {\n-        assumeTrue(\"requires metrics command\", EsqlCapabilities.Cap.METRICS_COMMAND.isEnabled());\n         LogicalPlan actual = localPlan(\"\"\"\n             TS test\n             | STATS max(max_over_time(metric_1))\n@@ -146,7 +144,7 @@ public class IgnoreNullMetricsTests extends ESTestCase {\n     }\n \n     public void testDimensionsAreNotFiltered() {\n-        assumeTrue(\"requires metrics command\", EsqlCapabilities.Cap.METRICS_COMMAND.isEnabled());\n+\n         LogicalPlan actual = localPlan(\"\"\"\n             TS test\n             | STATS max(max_over_time(metric_1)) BY dimension_1\n@@ -163,7 +161,7 @@ public class IgnoreNullMetricsTests extends ESTestCase {\n     }\n \n     public void testFiltersAreJoinedWithOr() {\n-        assumeTrue(\"requires metrics command\", EsqlCapabilities.Cap.METRICS_COMMAND.isEnabled());\n+\n         LogicalPlan actual = localPlan(\"\"\"\n             TS test\n             | STATS max(max_over_time(metric_1)), min(min_over_time(metric_2))\n@@ -199,7 +197,6 @@ public class IgnoreNullMetricsTests extends ESTestCase {\n     public void testSkipCoalescedMetrics() {\n         // Note: this test is passing because the reference attribute metric_2 in the stats block does not inherit the\n         // metric property from the original field.\n-        assumeTrue(\"requires metrics command\", EsqlCapabilities.Cap.METRICS_COMMAND.isEnabled());\n         LogicalPlan actual = localPlan(\"\"\"\n             TS test\n             | EVAL metric_2 = coalesce(metric_2, 0)\n@@ -221,7 +218,6 @@ public class IgnoreNullMetricsTests extends ESTestCase {\n      * check that stats blocks after the first are not sourced for adding metrics to the filter\n      */\n     public void testMultipleStats() {\n-        assumeTrue(\"requires metrics command\", EsqlCapabilities.Cap.METRICS_COMMAND.isEnabled());\n         LogicalPlan actual = localPlan(\"\"\"\n             TS test\n             | STATS m = max(max_over_time(metric_1))\n@@ -236,5 +232,6 @@ public class IgnoreNullMetricsTests extends ESTestCase {\n         IsNotNull condition = as(filter.condition(), IsNotNull.class);\n         FieldAttribute attribute = as(condition.field(), FieldAttribute.class);\n         assertEquals(\"metric_1\", attribute.fieldName().string());\n+\n     }\n }\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java\nindex e943d6c69ae..299b9e9313b 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java\n@@ -50,7 +50,6 @@ import java.util.Map;\n import java.util.concurrent.TimeUnit;\n \n import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n-import static org.elasticsearch.test.ESTestCase.assertThat;\n import static org.elasticsearch.test.ESTestCase.randomAlphaOfLengthBetween;\n import static org.elasticsearch.test.ESTestCase.randomBoolean;\n import static org.elasticsearch.test.ESTestCase.waitUntil;\n@@ -60,6 +59,8 @@ import static org.elasticsearch.xcontent.XContentFactory.jsonBuilder;\n import static org.elasticsearch.xpack.core.ilm.ShrinkIndexNameSupplier.SHRUNKEN_INDEX_PREFIX;\n import static org.hamcrest.Matchers.anyOf;\n import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n \n /**\n  * This class provides the operational REST functions needed to control an ILM time series lifecycle.\n@@ -79,7 +80,7 @@ public final class TimeSeriesRestDriver {\n         return getStepKey(indexResponse);\n     }\n \n-    public static Step.StepKey getStepKey(Map<String, Object> explainIndexResponse) {\n+    private static Step.StepKey getStepKey(Map<String, Object> explainIndexResponse) {\n         String phase = (String) explainIndexResponse.get(\"phase\");\n         String action = (String) explainIndexResponse.get(\"action\");\n         String step = (String) explainIndexResponse.get(\"step\");\n@@ -104,26 +105,14 @@ public final class TimeSeriesRestDriver {\n         explainRequest.addParameter(\"only_managed\", Boolean.toString(onlyManaged));\n         explainRequest.setOptions(consumeWarningsOptions);\n         Response response = client.performRequest(explainRequest);\n-        ObjectPath objectPath = ObjectPath.createFromResponse(response);\n-        return objectPath.evaluate(\"indices\");\n-    }\n+        Map<String, Object> responseMap;\n+        try (InputStream is = response.getEntity().getContent()) {\n+            responseMap = XContentHelper.convertToMap(XContentType.JSON.xContent(), is, true);\n+        }\n \n-    /**\n-     * Waits until the specified index is at the specified ILM step. If any of phase, action, or step is null, that part is ignored.\n-     */\n-    public static void awaitStepKey(RestClient client, String indexName, String phase, String action, String step) throws Exception {\n-        ESRestTestCase.assertBusy(() -> {\n-            final Step.StepKey stepKey = getStepKeyForIndex(client, indexName);\n-            if (phase != null) {\n-                assertThat(stepKey.phase(), equalTo(phase));\n-            }\n-            if (action != null) {\n-                assertThat(stepKey.action(), equalTo(action));\n-            }\n-            if (step != null) {\n-                assertThat(stepKey.name(), equalTo(step));\n-            }\n-        });\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Map<String, Object>> indexResponse = ((Map<String, Map<String, Object>>) responseMap.get(\"indices\"));\n+        return indexResponse;\n     }\n \n     public static void indexDocument(RestClient client, String indexAbstractionName) throws IOException {\n@@ -512,6 +501,24 @@ public final class TimeSeriesRestDriver {\n         return shrunkenIndexName[0];\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    public static List<String> getBackingIndices(RestClient client, String dataStreamName) throws IOException {\n+        Response getDataStream = client.performRequest(new Request(\"GET\", \"_data_stream/\" + dataStreamName));\n+        Map<String, Object> responseMap;\n+        try (InputStream is = getDataStream.getEntity().getContent()) {\n+            responseMap = XContentHelper.convertToMap(XContentType.JSON.xContent(), is, true);\n+        }\n+\n+        List<Map<String, Object>> dataStreams = (List<Map<String, Object>>) responseMap.get(\"data_streams\");\n+        assertThat(dataStreams.size(), is(1));\n+        Map<String, Object> dataStream = dataStreams.get(0);\n+        assertThat(dataStream.get(\"name\"), is(dataStreamName));\n+        List<String> indices = ((List<Map<String, Object>>) dataStream.get(\"indices\")).stream()\n+            .map(indexMap -> (String) indexMap.get(\"index_name\"))\n+            .toList();\n+        return indices;\n+    }\n+\n     private static void executeDummyClusterStateUpdate(RestClient client) throws IOException {\n         createIndexWithSettings(\n             client,\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/SearchableSnapshotActionIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/SearchableSnapshotActionIT.java\nindex 0f6c9b8689b..111de0b6f40 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/SearchableSnapshotActionIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/SearchableSnapshotActionIT.java\n@@ -19,10 +19,12 @@ import org.elasticsearch.cluster.routing.allocation.DataTier;\n import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.test.rest.ObjectPath;\n import org.elasticsearch.xcontent.XContentBuilder;\n+import org.elasticsearch.xcontent.XContentType;\n import org.elasticsearch.xpack.TimeSeriesRestDriver;\n import org.elasticsearch.xpack.core.ilm.AllocateAction;\n import org.elasticsearch.xpack.core.ilm.DeleteAction;\n@@ -42,6 +44,7 @@ import org.elasticsearch.xpack.core.ilm.WaitUntilReplicateForTimePassesStep;\n import org.junit.Before;\n \n import java.io.IOException;\n+import java.io.InputStream;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Locale;\n@@ -110,11 +113,19 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         assertThat(backingIndices.size(), equalTo(2));\n         String backingIndexName = backingIndices.getFirst();\n         String restoredIndexName = SearchableSnapshotAction.FULL_RESTORED_INDEX_PREFIX + backingIndexName;\n-        awaitIndexExists(restoredIndexName);\n+        assertTrue(waitUntil(() -> {\n+            try {\n+                return indexExists(restoredIndexName);\n+            } catch (IOException e) {\n+                return false;\n+            }\n+        }, 30, TimeUnit.SECONDS));\n \n-        TimeSeriesRestDriver.awaitStepKey(client(), restoredIndexName, null, null, PhaseCompleteStep.NAME);\n-        // Wait for the original index to be deleted, to ensure ILM has finished\n-        awaitIndexDoesNotExist(backingIndexName);\n+        assertBusy(\n+            () -> { assertThat(explainIndex(client(), restoredIndexName).get(\"step\"), is(PhaseCompleteStep.NAME)); },\n+            30,\n+            TimeUnit.SECONDS\n+        );\n     }\n \n     /**\n@@ -207,6 +218,7 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testDeleteActionDeletesSearchableSnapshot() throws Exception {\n         createSnapshotRepo(client(), snapshotRepo, randomBoolean());\n \n@@ -242,15 +254,25 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         String restoredIndexName = SearchableSnapshotAction.FULL_RESTORED_INDEX_PREFIX + backingIndexName;\n \n         // let's wait for ILM to finish\n-        awaitIndexDoesNotExist(backingIndexName);\n-        awaitIndexDoesNotExist(restoredIndexName);\n+        assertBusy(() -> assertFalse(indexExists(backingIndexName)), 60, TimeUnit.SECONDS);\n+        assertBusy(() -> assertFalse(indexExists(restoredIndexName)), 60, TimeUnit.SECONDS);\n \n-        List<Map<String, Object>> snapshots = getSnapshots();\n-        assertThat(\n-            \"the snapshot we generate in the cold phase should be deleted by the delete phase, but got snapshot: \" + snapshots,\n-            snapshots.size(),\n-            equalTo(0)\n-        );\n+        assertTrue(\"the snapshot we generate in the cold phase should be deleted by the delete phase\", waitUntil(() -> {\n+            try {\n+                Request getSnapshotsRequest = new Request(\"GET\", \"_snapshot/\" + snapshotRepo + \"/_all\");\n+                Response getSnapshotsResponse = client().performRequest(getSnapshotsRequest);\n+\n+                Map<String, Object> responseMap;\n+                try (InputStream is = getSnapshotsResponse.getEntity().getContent()) {\n+                    responseMap = XContentHelper.convertToMap(XContentType.JSON.xContent(), is, true);\n+                }\n+                Object snapshots = responseMap.get(\"snapshots\");\n+                return ((List<Map<String, Object>>) snapshots).size() == 0;\n+            } catch (Exception e) {\n+                logger.error(e.getMessage(), e);\n+                return false;\n+            }\n+        }, 30, TimeUnit.SECONDS));\n     }\n \n     public void testCreateInvalidPolicy() {\n@@ -322,8 +344,19 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n \n         String backingIndexName = getDataStreamBackingIndexNames(dataStream).getFirst();\n         String restoredIndexName = SearchableSnapshotAction.FULL_RESTORED_INDEX_PREFIX + backingIndexName;\n-        awaitIndexExists(restoredIndexName);\n-        TimeSeriesRestDriver.awaitStepKey(client(), restoredIndexName, \"hot\", null, PhaseCompleteStep.NAME);\n+        assertTrue(waitUntil(() -> {\n+            try {\n+                return indexExists(restoredIndexName);\n+            } catch (IOException e) {\n+                return false;\n+            }\n+        }, 30, TimeUnit.SECONDS));\n+\n+        assertBusy(() -> {\n+            Step.StepKey stepKeyForIndex = getStepKeyForIndex(client(), restoredIndexName);\n+            assertThat(stepKeyForIndex.phase(), is(\"hot\"));\n+            assertThat(stepKeyForIndex.name(), is(PhaseCompleteStep.NAME));\n+        }, 30, TimeUnit.SECONDS);\n         // Wait for the original index to be deleted, to ensure ILM has finished\n         awaitIndexDoesNotExist(backingIndexName);\n \n@@ -343,7 +376,11 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n \n         // even though the index is now mounted as a searchable snapshot, the actions that can't operate on it should\n         // skip and ILM should not be blocked (not should the managed index move into the ERROR step)\n-        TimeSeriesRestDriver.awaitStepKey(client(), restoredIndexName, \"cold\", null, PhaseCompleteStep.NAME);\n+        assertBusy(() -> {\n+            Step.StepKey stepKeyForIndex = getStepKeyForIndex(client(), restoredIndexName);\n+            assertThat(stepKeyForIndex.phase(), is(\"cold\"));\n+            assertThat(stepKeyForIndex.name(), is(PhaseCompleteStep.NAME));\n+        }, 30, TimeUnit.SECONDS);\n     }\n \n     public void testRestoredIndexManagedByLocalPolicySkipsIllegalActions() throws Exception {\n@@ -386,8 +423,19 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n \n         String backingIndexName = getDataStreamBackingIndexNames(dataStream).getFirst();\n         String searchableSnapMountedIndexName = SearchableSnapshotAction.FULL_RESTORED_INDEX_PREFIX + backingIndexName;\n-        awaitIndexExists(searchableSnapMountedIndexName);\n-        TimeSeriesRestDriver.awaitStepKey(client(), searchableSnapMountedIndexName, \"hot\", null, PhaseCompleteStep.NAME);\n+        assertTrue(waitUntil(() -> {\n+            try {\n+                return indexExists(searchableSnapMountedIndexName);\n+            } catch (IOException e) {\n+                return false;\n+            }\n+        }, 30, TimeUnit.SECONDS));\n+\n+        assertBusy(() -> {\n+            Step.StepKey stepKeyForIndex = getStepKeyForIndex(client(), searchableSnapMountedIndexName);\n+            assertThat(stepKeyForIndex.phase(), is(\"hot\"));\n+            assertThat(stepKeyForIndex.name(), is(PhaseCompleteStep.NAME));\n+        }, 30, TimeUnit.SECONDS);\n         // Wait for the original index to be deleted, to ensure ILM has finished\n         awaitIndexDoesNotExist(backingIndexName);\n \n@@ -441,15 +489,14 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n                     e.getMessage(),\n                     containsString(\"The freeze action in ILM is deprecated and will be removed in a future version\")\n                 );\n-                ObjectPath objectPath = ObjectPath.createFromResponse(e.getResponse());\n-                Map<String, Map<String, Object>> indices = objectPath.evaluate(\"indices\");\n-                stepKeyForIndex = TimeSeriesRestDriver.getStepKey(indices.get(searchableSnapMountedIndexName));\n+                stepKeyForIndex = getKeyForIndex(e.getResponse(), searchableSnapMountedIndexName);\n             }\n             assertThat(stepKeyForIndex.phase(), is(\"cold\"));\n             assertThat(stepKeyForIndex.name(), is(PhaseCompleteStep.NAME));\n         }, 30, TimeUnit.SECONDS);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testIdenticalSearchableSnapshotActionIsNoop() throws Exception {\n         String index = \"myindex-\" + randomAlphaOfLength(4).toLowerCase(Locale.ROOT) + \"-000001\";\n         createSnapshotRepo(client(), snapshotRepo, randomBoolean());\n@@ -485,20 +532,37 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n \n         final String searchableSnapMountedIndexName = SearchableSnapshotAction.FULL_RESTORED_INDEX_PREFIX + index;\n \n-        logger.info(\"--> waiting for [{}] to exist...\", searchableSnapMountedIndexName);\n-        awaitIndexExists(searchableSnapMountedIndexName);\n-        TimeSeriesRestDriver.awaitStepKey(client(), searchableSnapMountedIndexName, \"cold\", null, PhaseCompleteStep.NAME);\n+        assertBusy(() -> {\n+            logger.info(\"--> waiting for [{}] to exist...\", searchableSnapMountedIndexName);\n+            assertTrue(indexExists(searchableSnapMountedIndexName));\n+        }, 30, TimeUnit.SECONDS);\n+\n+        assertBusy(() -> {\n+            Step.StepKey stepKeyForIndex = getStepKeyForIndex(client(), searchableSnapMountedIndexName);\n+            assertThat(stepKeyForIndex.phase(), is(\"cold\"));\n+            assertThat(stepKeyForIndex.name(), is(PhaseCompleteStep.NAME));\n+        }, 30, TimeUnit.SECONDS);\n         // Wait for the original index to be deleted, to ensure ILM has finished\n         awaitIndexDoesNotExist(index);\n \n-        List<Map<String, Object>> snapshots = getSnapshots();\n-        assertThat(\"expected to have only one snapshot, but got: \" + snapshots, snapshots.size(), equalTo(1));\n+        Request getSnaps = new Request(\"GET\", \"/_snapshot/\" + snapshotRepo + \"/_all\");\n+        Response response = client().performRequest(getSnaps);\n+        Map<String, Object> responseMap;\n+        try (InputStream is = response.getEntity().getContent()) {\n+            responseMap = XContentHelper.convertToMap(XContentType.JSON.xContent(), is, true);\n+        }\n+        assertThat(\n+            \"expected to have only one snapshot, but got: \" + responseMap,\n+            ((List<Map<String, Object>>) responseMap.get(\"snapshots\")).size(),\n+            equalTo(1)\n+        );\n \n         Request hitCount = new Request(\"GET\", \"/\" + searchableSnapMountedIndexName + \"/_count\");\n         Map<String, Object> count = entityAsMap(client().performRequest(hitCount));\n         assertThat(\"expected a single document but got: \" + count, (int) count.get(\"count\"), equalTo(1));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testConvertingSearchableSnapshotFromFullToPartial() throws Exception {\n         String index = \"myindex-\" + randomAlphaOfLength(4).toLowerCase(Locale.ROOT);\n         createSnapshotRepo(client(), snapshotRepo, randomBoolean());\n@@ -531,14 +595,30 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         final String searchableSnapMountedIndexName = SearchableSnapshotAction.PARTIAL_RESTORED_INDEX_PREFIX\n             + SearchableSnapshotAction.FULL_RESTORED_INDEX_PREFIX + index;\n \n-        logger.info(\"--> waiting for [{}] to exist...\", searchableSnapMountedIndexName);\n-        awaitIndexExists(searchableSnapMountedIndexName);\n-        TimeSeriesRestDriver.awaitStepKey(client(), searchableSnapMountedIndexName, \"frozen\", null, PhaseCompleteStep.NAME);\n+        assertBusy(() -> {\n+            logger.info(\"--> waiting for [{}] to exist...\", searchableSnapMountedIndexName);\n+            assertTrue(indexExists(searchableSnapMountedIndexName));\n+        }, 30, TimeUnit.SECONDS);\n+\n+        assertBusy(() -> {\n+            Step.StepKey stepKeyForIndex = getStepKeyForIndex(client(), searchableSnapMountedIndexName);\n+            assertThat(stepKeyForIndex.phase(), is(\"frozen\"));\n+            assertThat(stepKeyForIndex.name(), is(PhaseCompleteStep.NAME));\n+        }, 30, TimeUnit.SECONDS);\n         // Wait for the original index to be deleted, to ensure ILM has finished\n         awaitIndexDoesNotExist(index);\n \n-        List<Map<String, Object>> snapshots = getSnapshots();\n-        assertThat(\"expected to have only one snapshot, but got: \" + snapshots, snapshots.size(), equalTo(1));\n+        Request getSnaps = new Request(\"GET\", \"/_snapshot/\" + snapshotRepo + \"/_all\");\n+        Response response = client().performRequest(getSnaps);\n+        Map<String, Object> responseMap;\n+        try (InputStream is = response.getEntity().getContent()) {\n+            responseMap = XContentHelper.convertToMap(XContentType.JSON.xContent(), is, true);\n+        }\n+        assertThat(\n+            \"expected to have only one snapshot, but got: \" + responseMap,\n+            ((List<Map<String, Object>>) responseMap.get(\"snapshots\")).size(),\n+            equalTo(1)\n+        );\n \n         Request hitCount = new Request(\"GET\", \"/\" + searchableSnapMountedIndexName + \"/_count\");\n         Map<String, Object> count = entityAsMap(client().performRequest(hitCount));\n@@ -552,6 +632,7 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         );\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testResumingSearchableSnapshotFromFullToPartial() throws Exception {\n         String index = \"myindex-\" + randomAlphaOfLength(4).toLowerCase(Locale.ROOT);\n         createSnapshotRepo(client(), snapshotRepo, randomBoolean());\n@@ -597,11 +678,17 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         updateIndexSettings(index, Settings.builder().put(LifecycleSettings.LIFECYCLE_NAME, policyCold));\n \n         final String fullMountedIndexName = SearchableSnapshotAction.FULL_RESTORED_INDEX_PREFIX + index;\n-        logger.info(\"--> waiting for [{}] to exist...\", fullMountedIndexName);\n-        awaitIndexExists(fullMountedIndexName);\n-        TimeSeriesRestDriver.awaitStepKey(client(), fullMountedIndexName, \"cold\", null, PhaseCompleteStep.NAME);\n-        // Wait for the original index to be deleted, to ensure ILM has finished\n-        awaitIndexDoesNotExist(index);\n+\n+        assertBusy(() -> {\n+            logger.info(\"--> waiting for [{}] to exist...\", fullMountedIndexName);\n+            assertTrue(indexExists(fullMountedIndexName));\n+        }, 30, TimeUnit.SECONDS);\n+\n+        assertBusy(() -> {\n+            Step.StepKey stepKeyForIndex = getStepKeyForIndex(client(), fullMountedIndexName);\n+            assertThat(stepKeyForIndex.phase(), is(\"cold\"));\n+            assertThat(stepKeyForIndex.name(), is(PhaseCompleteStep.NAME));\n+        }, 30, TimeUnit.SECONDS);\n \n         // remove ILM\n         {\n@@ -611,11 +698,17 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         }\n         // add cold-frozen\n         updateIndexSettings(index, Settings.builder().put(LifecycleSettings.LIFECYCLE_NAME, policyFrozen));\n-\n         String partiallyMountedIndexName = SearchableSnapshotAction.PARTIAL_RESTORED_INDEX_PREFIX + fullMountedIndexName;\n-        logger.info(\"--> waiting for [{}] to exist...\", partiallyMountedIndexName);\n-        awaitIndexExists(partiallyMountedIndexName);\n-        TimeSeriesRestDriver.awaitStepKey(client(), partiallyMountedIndexName, \"frozen\", null, PhaseCompleteStep.NAME);\n+        assertBusy(() -> {\n+            logger.info(\"--> waiting for [{}] to exist...\", partiallyMountedIndexName);\n+            assertTrue(indexExists(partiallyMountedIndexName));\n+        }, 30, TimeUnit.SECONDS);\n+\n+        assertBusy(() -> {\n+            Step.StepKey stepKeyForIndex = getStepKeyForIndex(client(), partiallyMountedIndexName);\n+            assertThat(stepKeyForIndex.phase(), is(\"frozen\"));\n+            assertThat(stepKeyForIndex.name(), is(PhaseCompleteStep.NAME));\n+        }, 30, TimeUnit.SECONDS);\n \n         // Ensure the searchable snapshot is not deleted when the index was deleted because it was not created by this\n         // policy. We add the delete phase now to ensure that the index will not be deleted before we verify the above\n@@ -637,12 +730,16 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n             ),\n             new Phase(\"delete\", TimeValue.ZERO, Map.of(DeleteAction.NAME, WITH_SNAPSHOT_DELETE))\n         );\n-        logger.info(\"--> waiting for [{}] to be deleted...\", partiallyMountedIndexName);\n-        awaitIndexDoesNotExist(partiallyMountedIndexName);\n-        List<Map<String, Object>> snapshots = getSnapshots();\n-        assertThat(\"expected to have only one snapshot, but got: \" + snapshots, snapshots.size(), equalTo(1));\n+        assertBusy(() -> {\n+            logger.info(\"--> waiting for [{}] to be deleted...\", partiallyMountedIndexName);\n+            assertThat(indexExists(partiallyMountedIndexName), is(false));\n+            Request getSnaps = new Request(\"GET\", \"/_snapshot/\" + snapshotRepo + \"/_all\");\n+            Map<String, Object> responseMap = responseAsMap(client().performRequest(getSnaps));\n+            assertThat(((List<Map<String, Object>>) responseMap.get(\"snapshots\")).size(), equalTo(1));\n+        }, 30, TimeUnit.SECONDS);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testResumingSearchableSnapshotFromPartialToFull() throws Exception {\n         String index = \"myindex-\" + randomAlphaOfLength(4).toLowerCase(Locale.ROOT);\n         createSnapshotRepo(client(), snapshotRepo, randomBoolean());\n@@ -664,6 +761,7 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         createPolicy(\n             client(),\n             policyColdFrozen,\n+\n             null,\n             null,\n             new Phase(\n@@ -689,11 +787,17 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n \n         final String fullMountedIndexName = SearchableSnapshotAction.FULL_RESTORED_INDEX_PREFIX + index;\n         final String partialMountedIndexName = SearchableSnapshotAction.PARTIAL_RESTORED_INDEX_PREFIX + fullMountedIndexName;\n-        logger.info(\"--> waiting for [{}] to exist...\", partialMountedIndexName);\n-        awaitIndexExists(partialMountedIndexName);\n-        TimeSeriesRestDriver.awaitStepKey(client(), partialMountedIndexName, \"frozen\", null, PhaseCompleteStep.NAME);\n-        // Wait for the original index to be deleted, to ensure ILM has finished\n-        awaitIndexDoesNotExist(index);\n+\n+        assertBusy(() -> {\n+            logger.info(\"--> waiting for [{}] to exist...\", partialMountedIndexName);\n+            assertTrue(indexExists(partialMountedIndexName));\n+        }, 30, TimeUnit.SECONDS);\n+\n+        assertBusy(() -> {\n+            Step.StepKey stepKeyForIndex = getStepKeyForIndex(client(), partialMountedIndexName);\n+            assertThat(stepKeyForIndex.phase(), is(\"frozen\"));\n+            assertThat(stepKeyForIndex.name(), is(PhaseCompleteStep.NAME));\n+        }, 30, TimeUnit.SECONDS);\n \n         // remove ILM from the partially mounted searchable snapshot\n         {\n@@ -703,11 +807,17 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         }\n         // add a policy that will only include the fully mounted searchable snapshot\n         updateIndexSettings(index, Settings.builder().put(LifecycleSettings.LIFECYCLE_NAME, policyCold));\n-\n         String restoredPartiallyMountedIndexName = SearchableSnapshotAction.FULL_RESTORED_INDEX_PREFIX + partialMountedIndexName;\n-        logger.info(\"--> waiting for [{}] to exist...\", restoredPartiallyMountedIndexName);\n-        awaitIndexExists(restoredPartiallyMountedIndexName);\n-        TimeSeriesRestDriver.awaitStepKey(client(), restoredPartiallyMountedIndexName, \"cold\", null, PhaseCompleteStep.NAME);\n+        assertBusy(() -> {\n+            logger.info(\"--> waiting for [{}] to exist...\", restoredPartiallyMountedIndexName);\n+            assertTrue(indexExists(restoredPartiallyMountedIndexName));\n+        }, 30, TimeUnit.SECONDS);\n+\n+        assertBusy(() -> {\n+            Step.StepKey stepKeyForIndex = getStepKeyForIndex(client(), restoredPartiallyMountedIndexName);\n+            assertThat(stepKeyForIndex.phase(), is(\"cold\"));\n+            assertThat(stepKeyForIndex.name(), is(PhaseCompleteStep.NAME));\n+        }, 30, TimeUnit.SECONDS);\n \n         // Ensure the searchable snapshot is not deleted when the index was deleted because it was not created by this\n         // policy. We add the delete phase now to ensure that the index will not be deleted before we verify the above\n@@ -725,10 +835,13 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n             null,\n             new Phase(\"delete\", TimeValue.ZERO, Map.of(DeleteAction.NAME, WITH_SNAPSHOT_DELETE))\n         );\n-        logger.info(\"--> waiting for [{}] to be deleted...\", restoredPartiallyMountedIndexName);\n-        awaitIndexDoesNotExist(restoredPartiallyMountedIndexName);\n-        List<Map<String, Object>> snapshots = getSnapshots();\n-        assertThat(\"expected to have only one snapshot, but got: \" + snapshots, snapshots.size(), equalTo(1));\n+        assertBusy(() -> {\n+            logger.info(\"--> waiting for [{}] to be deleted...\", restoredPartiallyMountedIndexName);\n+            assertThat(indexExists(restoredPartiallyMountedIndexName), is(false));\n+            Request getSnaps = new Request(\"GET\", \"/_snapshot/\" + snapshotRepo + \"/_all\");\n+            Map<String, Object> responseMap = responseAsMap(client().performRequest(getSnaps));\n+            assertThat(((List<Map<String, Object>>) responseMap.get(\"snapshots\")).size(), equalTo(1));\n+        }, 30, TimeUnit.SECONDS);\n     }\n \n     public void testSecondSearchableSnapshotUsingDifferentRepoThrows() throws Exception {\n@@ -806,9 +919,15 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         indexDocument(client(), dataStream, true);\n \n         final String restoredIndex = SearchableSnapshotAction.FULL_RESTORED_INDEX_PREFIX + firstGenIndex;\n-        logger.info(\"--> waiting for [{}] to exist...\", restoredIndex);\n-        awaitIndexExists(restoredIndex);\n-        TimeSeriesRestDriver.awaitStepKey(client(), restoredIndex, \"hot\", PhaseCompleteStep.NAME, PhaseCompleteStep.NAME);\n+        assertBusy(() -> {\n+            logger.info(\"--> waiting for [{}] to exist...\", restoredIndex);\n+            assertTrue(indexExists(restoredIndex));\n+        }, 30, TimeUnit.SECONDS);\n+        assertBusy(\n+            () -> assertThat(getStepKeyForIndex(client(), restoredIndex), is(PhaseCompleteStep.finalStep(\"hot\").getKey())),\n+            30,\n+            TimeUnit.SECONDS\n+        );\n \n         Map<String, Object> hotIndexSettings = getIndexSettingsAsMap(restoredIndex);\n         // searchable snapshots mounted in the hot phase should be pinned to hot nodes\n@@ -846,11 +965,19 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         assertThat(backingIndices.size(), equalTo(2));\n         String backingIndexName = backingIndices.getFirst();\n         String restoredIndexName = SearchableSnapshotAction.FULL_RESTORED_INDEX_PREFIX + backingIndexName;\n-        awaitIndexExists(restoredIndexName);\n+        assertTrue(waitUntil(() -> {\n+            try {\n+                return indexExists(restoredIndexName);\n+            } catch (IOException e) {\n+                return false;\n+            }\n+        }, 30, TimeUnit.SECONDS));\n \n-        TimeSeriesRestDriver.awaitStepKey(client(), restoredIndexName, null, null, PhaseCompleteStep.NAME);\n-        // Wait for the original index to be deleted, to ensure ILM has finished\n-        awaitIndexDoesNotExist(backingIndexName);\n+        assertBusy(\n+            () -> { assertThat(explainIndex(client(), restoredIndexName).get(\"step\"), is(PhaseCompleteStep.NAME)); },\n+            30,\n+            TimeUnit.SECONDS\n+        );\n     }\n \n     public void testSearchableSnapshotTotalShardsPerNode() throws Exception {\n@@ -886,9 +1013,15 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         // wait for snapshot successfully mounted and ILM execution completed\n         final String searchableSnapMountedIndexName = SearchableSnapshotAction.PARTIAL_RESTORED_INDEX_PREFIX\n             + SearchableSnapshotAction.FULL_RESTORED_INDEX_PREFIX + index;\n-        logger.info(\"--> waiting for [{}] to exist...\", searchableSnapMountedIndexName);\n-        awaitIndexExists(searchableSnapMountedIndexName);\n-        TimeSeriesRestDriver.awaitStepKey(client(), searchableSnapMountedIndexName, \"frozen\", null, PhaseCompleteStep.NAME);\n+        assertBusy(() -> {\n+            logger.info(\"--> waiting for [{}] to exist...\", searchableSnapMountedIndexName);\n+            assertTrue(indexExists(searchableSnapMountedIndexName));\n+        }, 30, TimeUnit.SECONDS);\n+        assertBusy(() -> {\n+            Step.StepKey stepKeyForIndex = getStepKeyForIndex(client(), searchableSnapMountedIndexName);\n+            assertThat(stepKeyForIndex.phase(), is(\"frozen\"));\n+            assertThat(stepKeyForIndex.name(), is(PhaseCompleteStep.NAME));\n+        }, 30, TimeUnit.SECONDS);\n         // Wait for the original index to be deleted, to ensure ILM has finished\n         awaitIndexDoesNotExist(index);\n \n@@ -898,8 +1031,8 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         Integer snapshotTotalShardsPerNode = Integer.valueOf((String) indexSettings.get(INDEX_TOTAL_SHARDS_PER_NODE_SETTING.getKey()));\n         assertEquals(\n             \"expected total_shards_per_node to be \" + totalShardsPerNode + \", but got: \" + snapshotTotalShardsPerNode,\n-            totalShardsPerNode,\n-            snapshotTotalShardsPerNode\n+            snapshotTotalShardsPerNode,\n+            totalShardsPerNode\n         );\n     }\n \n@@ -940,7 +1073,13 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         assertThat(backingIndices.size(), equalTo(2));\n         String backingIndexName = backingIndices.getFirst();\n         String restoredIndexName = SearchableSnapshotAction.FULL_RESTORED_INDEX_PREFIX + backingIndexName;\n-        awaitIndexExists(restoredIndexName);\n+        assertTrue(waitUntil(() -> {\n+            try {\n+                return indexExists(restoredIndexName);\n+            } catch (IOException e) {\n+                return false;\n+            }\n+        }, 30, TimeUnit.SECONDS));\n \n         // check that the index is in the expected step and has the expected step_info.message\n         assertBusy(() -> {\n@@ -982,7 +1121,11 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         );\n \n         // check that the index has progressed because enough time has passed now that the policy is different\n-        TimeSeriesRestDriver.awaitStepKey(client(), restoredIndexName, \"cold\", null, PhaseCompleteStep.NAME);\n+        assertBusy(() -> {\n+            Map<String, Object> explainResponse = explainIndex(client(), restoredIndexName);\n+            assertThat(explainResponse.get(\"phase\"), is(\"cold\"));\n+            assertThat(explainResponse.get(\"step\"), is(PhaseCompleteStep.NAME));\n+        }, 30, TimeUnit.SECONDS);\n \n         // check that it has the right number of replicas\n         {\n@@ -993,6 +1136,20 @@ public class SearchableSnapshotActionIT extends ESRestTestCase {\n         }\n     }\n \n+    private Step.StepKey getKeyForIndex(Response response, String indexName) throws IOException {\n+        Map<String, Object> responseMap;\n+        try (InputStream is = response.getEntity().getContent()) {\n+            responseMap = XContentHelper.convertToMap(XContentType.JSON.xContent(), is, true);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> indexResponse = ((Map<String, Map<String, Object>>) responseMap.get(\"indices\")).get(indexName);\n+        String phase = (String) indexResponse.get(\"phase\");\n+        String action = (String) indexResponse.get(\"action\");\n+        String step = (String) indexResponse.get(\"step\");\n+        return new Step.StepKey(phase, action, step);\n+    }\n+\n     /**\n      * Prepares a data stream with the specified number of primary and replica shards,\n      * creates a snapshot repository and ILM policy, applies a composable template,\ndiff --git a/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/external/action/ActionUtils.java b/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/external/action/ActionUtils.java\nindex 03b94b3d496..61cada6e75e 100644\n--- a/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/external/action/ActionUtils.java\n+++ b/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/external/action/ActionUtils.java\n@@ -13,6 +13,7 @@ import org.elasticsearch.ExceptionsHelper;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.inference.InferenceServiceResults;\n+import org.elasticsearch.rest.RestStatus;\n \n public class ActionUtils {\n \n@@ -27,17 +28,19 @@ public class ActionUtils {\n                 l.onFailure(esException);\n             } else {\n                 l.onFailure(\n-                    // Determine the appropriate RestStatus from the unwrapped exception, then wrap in an ElasticsearchStatusException\n-                    new ElasticsearchStatusException(\n-                        Strings.format(\"%s. Cause: %s\", errorMessage, unwrappedException.getMessage()),\n-                        ExceptionsHelper.status(unwrappedException),\n-                        unwrappedException\n+                    createInternalServerError(\n+                        unwrappedException,\n+                        Strings.format(\"%s. Cause: %s\", errorMessage, unwrappedException.getMessage())\n                     )\n                 );\n             }\n         });\n     }\n \n+    public static ElasticsearchStatusException createInternalServerError(Throwable e, String message) {\n+        return new ElasticsearchStatusException(message, RestStatus.INTERNAL_SERVER_ERROR, e);\n+    }\n+\n     public static String constructFailedToSendRequestMessage(String message) {\n         return Strings.format(\"Failed to send %s request\", message);\n     }\ndiff --git a/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchCompletionAction.java b/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchCompletionAction.java\nindex a45c42f7d93..ed15871a2eb 100644\n--- a/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchCompletionAction.java\n+++ b/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchCompletionAction.java\n@@ -9,6 +9,7 @@ package org.elasticsearch.xpack.inference.services.alibabacloudsearch.action;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.ElasticsearchStatusException;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.core.TimeValue;\n@@ -26,6 +27,7 @@ import org.elasticsearch.xpack.inference.services.alibabacloudsearch.completion.\n import java.util.Objects;\n \n import static org.elasticsearch.xpack.inference.external.action.ActionUtils.constructFailedToSendRequestMessage;\n+import static org.elasticsearch.xpack.inference.external.action.ActionUtils.createInternalServerError;\n import static org.elasticsearch.xpack.inference.external.action.ActionUtils.wrapFailuresInElasticsearchException;\n \n public class AlibabaCloudSearchCompletionAction implements ExecutableAction {\n@@ -59,14 +61,16 @@ public class AlibabaCloudSearchCompletionAction implements ExecutableAction {\n             return;\n         }\n \n-        ActionListener<InferenceServiceResults> wrappedListener = wrapFailuresInElasticsearchException(\n-            failedToSendRequestErrorMessage,\n-            listener\n-        );\n         try {\n+            ActionListener<InferenceServiceResults> wrappedListener = wrapFailuresInElasticsearchException(\n+                failedToSendRequestErrorMessage,\n+                listener\n+            );\n             sender.send(requestCreator, inferenceInputs, timeout, wrappedListener);\n+        } catch (ElasticsearchException e) {\n+            listener.onFailure(e);\n         } catch (Exception e) {\n-            wrappedListener.onFailure(e);\n+            listener.onFailure(createInternalServerError(e, failedToSendRequestErrorMessage));\n         }\n     }\n }\ndiff --git a/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchEmbeddingsAction.java b/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchEmbeddingsAction.java\nindex 473d9b78768..a7839f85ca4 100644\n--- a/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchEmbeddingsAction.java\n+++ b/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchEmbeddingsAction.java\n@@ -7,6 +7,7 @@\n \n package org.elasticsearch.xpack.inference.services.alibabacloudsearch.action;\n \n+import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.inference.InferenceServiceResults;\n@@ -21,6 +22,7 @@ import org.elasticsearch.xpack.inference.services.alibabacloudsearch.embeddings.\n import java.util.Objects;\n \n import static org.elasticsearch.xpack.inference.external.action.ActionUtils.constructFailedToSendRequestMessage;\n+import static org.elasticsearch.xpack.inference.external.action.ActionUtils.createInternalServerError;\n import static org.elasticsearch.xpack.inference.external.action.ActionUtils.wrapFailuresInElasticsearchException;\n \n public class AlibabaCloudSearchEmbeddingsAction implements ExecutableAction {\n@@ -40,14 +42,16 @@ public class AlibabaCloudSearchEmbeddingsAction implements ExecutableAction {\n \n     @Override\n     public void execute(InferenceInputs inferenceInputs, TimeValue timeout, ActionListener<InferenceServiceResults> listener) {\n-        ActionListener<InferenceServiceResults> wrappedListener = wrapFailuresInElasticsearchException(\n-            failedToSendRequestErrorMessage,\n-            listener\n-        );\n         try {\n+            ActionListener<InferenceServiceResults> wrappedListener = wrapFailuresInElasticsearchException(\n+                failedToSendRequestErrorMessage,\n+                listener\n+            );\n             sender.send(requestCreator, inferenceInputs, timeout, wrappedListener);\n+        } catch (ElasticsearchException e) {\n+            listener.onFailure(e);\n         } catch (Exception e) {\n-            wrappedListener.onFailure(e);\n+            listener.onFailure(createInternalServerError(e, failedToSendRequestErrorMessage));\n         }\n     }\n }\ndiff --git a/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchRerankAction.java b/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchRerankAction.java\nindex fd91bcee41c..9517eb736c8 100644\n--- a/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchRerankAction.java\n+++ b/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchRerankAction.java\n@@ -9,6 +9,7 @@ package org.elasticsearch.xpack.inference.services.alibabacloudsearch.action;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.inference.InferenceServiceResults;\n@@ -23,6 +24,7 @@ import org.elasticsearch.xpack.inference.services.alibabacloudsearch.rerank.Alib\n import java.util.Objects;\n \n import static org.elasticsearch.xpack.inference.external.action.ActionUtils.constructFailedToSendRequestMessage;\n+import static org.elasticsearch.xpack.inference.external.action.ActionUtils.createInternalServerError;\n import static org.elasticsearch.xpack.inference.external.action.ActionUtils.wrapFailuresInElasticsearchException;\n \n public class AlibabaCloudSearchRerankAction implements ExecutableAction {\n@@ -44,14 +46,16 @@ public class AlibabaCloudSearchRerankAction implements ExecutableAction {\n \n     @Override\n     public void execute(InferenceInputs inferenceInputs, TimeValue timeout, ActionListener<InferenceServiceResults> listener) {\n-        ActionListener<InferenceServiceResults> wrappedListener = wrapFailuresInElasticsearchException(\n-            failedToSendRequestErrorMessage,\n-            listener\n-        );\n         try {\n+            ActionListener<InferenceServiceResults> wrappedListener = wrapFailuresInElasticsearchException(\n+                failedToSendRequestErrorMessage,\n+                listener\n+            );\n             sender.send(requestCreator, inferenceInputs, timeout, wrappedListener);\n+        } catch (ElasticsearchException e) {\n+            listener.onFailure(e);\n         } catch (Exception e) {\n-            wrappedListener.onFailure(e);\n+            listener.onFailure(createInternalServerError(e, failedToSendRequestErrorMessage));\n         }\n     }\n }\ndiff --git a/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchSparseAction.java b/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchSparseAction.java\nindex dc4d628325b..5d74e91d21d 100644\n--- a/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchSparseAction.java\n+++ b/x-pack/plugin/inference/src/main/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchSparseAction.java\n@@ -9,6 +9,7 @@ package org.elasticsearch.xpack.inference.services.alibabacloudsearch.action;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.inference.InferenceServiceResults;\n@@ -23,6 +24,7 @@ import org.elasticsearch.xpack.inference.services.alibabacloudsearch.sparse.Alib\n import java.util.Objects;\n \n import static org.elasticsearch.xpack.inference.external.action.ActionUtils.constructFailedToSendRequestMessage;\n+import static org.elasticsearch.xpack.inference.external.action.ActionUtils.createInternalServerError;\n import static org.elasticsearch.xpack.inference.external.action.ActionUtils.wrapFailuresInElasticsearchException;\n \n public class AlibabaCloudSearchSparseAction implements ExecutableAction {\n@@ -44,14 +46,16 @@ public class AlibabaCloudSearchSparseAction implements ExecutableAction {\n \n     @Override\n     public void execute(InferenceInputs inferenceInputs, TimeValue timeout, ActionListener<InferenceServiceResults> listener) {\n-        ActionListener<InferenceServiceResults> wrappedListener = wrapFailuresInElasticsearchException(\n-            failedToSendRequestErrorMessage,\n-            listener\n-        );\n         try {\n+            ActionListener<InferenceServiceResults> wrappedListener = wrapFailuresInElasticsearchException(\n+                failedToSendRequestErrorMessage,\n+                listener\n+            );\n             sender.send(requestCreator, inferenceInputs, timeout, wrappedListener);\n+        } catch (ElasticsearchException e) {\n+            listener.onFailure(e);\n         } catch (Exception e) {\n-            wrappedListener.onFailure(e);\n+            listener.onFailure(createInternalServerError(e, failedToSendRequestErrorMessage));\n         }\n     }\n }\ndiff --git a/x-pack/plugin/inference/src/test/java/org/elasticsearch/xpack/inference/external/action/SenderExecutableActionTests.java b/x-pack/plugin/inference/src/test/java/org/elasticsearch/xpack/inference/external/action/SenderExecutableActionTests.java\nindex 30ef1ca71ce..4d88eabb105 100644\n--- a/x-pack/plugin/inference/src/test/java/org/elasticsearch/xpack/inference/external/action/SenderExecutableActionTests.java\n+++ b/x-pack/plugin/inference/src/test/java/org/elasticsearch/xpack/inference/external/action/SenderExecutableActionTests.java\n@@ -10,10 +10,8 @@ package org.elasticsearch.xpack.inference.external.action;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.ElasticsearchStatusException;\n import org.elasticsearch.action.ActionListener;\n-import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.inference.InferenceServiceResults;\n-import org.elasticsearch.rest.RestStatus;\n import org.elasticsearch.test.ESTestCase;\n import org.elasticsearch.xpack.inference.external.http.sender.InferenceInputs;\n import org.elasticsearch.xpack.inference.external.http.sender.RequestManager;\n@@ -91,67 +89,31 @@ public class SenderExecutableActionTests extends ESTestCase {\n     @SuppressWarnings(\"unchecked\")\n     public void testSendThrowingExceptionIsWrapped() {\n         var expectedException = new IllegalStateException(\"test\");\n-        var actualExceptionReference = new AtomicReference<Exception>();\n+        var actualException = new AtomicReference<Exception>();\n \n         doThrow(expectedException).when(sender)\n             .send(eq(requestManager), any(InferenceInputs.class), any(TimeValue.class), any(ActionListener.class));\n \n-        execute(actualExceptionReference);\n+        execute(actualException);\n \n-        Exception actualException = actualExceptionReference.get();\n-        assertThat(actualException, notNullValue());\n-        assertThat(actualException.getMessage(), is(failureExceptionMessage));\n-        assertThat(actualException, instanceOf(ElasticsearchStatusException.class));\n-        assertThat(actualException.getCause(), sameInstance(expectedException));\n-        assertThat(((ElasticsearchStatusException) actualException).status(), is(RestStatus.INTERNAL_SERVER_ERROR));\n+        assertThat(actualException.get(), notNullValue());\n+        assertThat(actualException.get().getMessage(), is(failureExceptionMessage));\n+        assertThat(actualException.get(), instanceOf(ElasticsearchStatusException.class));\n+        assertThat(actualException.get().getCause(), sameInstance(expectedException));\n     }\n \n     public void testSenderReturnedExceptionIsWrapped() {\n         var expectedException = new IllegalStateException(\"test\");\n-        var actualExceptionReference = new AtomicReference<Exception>();\n-\n-        mockSender(listener -> listener.onFailure(expectedException));\n-\n-        execute(actualExceptionReference);\n-\n-        Exception actualException = actualExceptionReference.get();\n-        assertThat(actualException, notNullValue());\n-        assertThat(actualException.getMessage(), is(failureExceptionMessage));\n-        assertThat(actualException, instanceOf(ElasticsearchStatusException.class));\n-        assertThat(actualException.getCause(), sameInstance(expectedException));\n-        assertThat(((ElasticsearchStatusException) actualException).status(), is(RestStatus.INTERNAL_SERVER_ERROR));\n-    }\n-\n-    public void testSenderReturnedExceptionHasCorrectStatus_whenExceptionIsIllegalArgumentException() {\n-        var expectedException = new IllegalArgumentException(\"test\");\n-        var actualExceptionReference = new AtomicReference<Exception>();\n-\n-        mockSender(listener -> listener.onFailure(expectedException));\n-\n-        execute(actualExceptionReference);\n-\n-        Exception actualException = actualExceptionReference.get();\n-        assertThat(actualException, notNullValue());\n-        assertThat(actualException.getMessage(), is(failureExceptionMessage));\n-        assertThat(actualException, instanceOf(ElasticsearchStatusException.class));\n-        assertThat(actualException.getCause(), sameInstance(expectedException));\n-        assertThat(((ElasticsearchStatusException) actualException).status(), is(RestStatus.BAD_REQUEST));\n-    }\n-\n-    public void testSenderReturnedExceptionHasCorrectStatus_whenExceptionIsEsRejectedExecutionException() {\n-        var expectedException = new EsRejectedExecutionException(\"test\");\n-        var actualExceptionReference = new AtomicReference<Exception>();\n+        var actualException = new AtomicReference<Exception>();\n \n         mockSender(listener -> listener.onFailure(expectedException));\n \n-        execute(actualExceptionReference);\n+        execute(actualException);\n \n-        Exception actualException = actualExceptionReference.get();\n-        assertThat(actualException, notNullValue());\n-        assertThat(actualException.getMessage(), is(failureExceptionMessage));\n-        assertThat(actualException, instanceOf(ElasticsearchStatusException.class));\n-        assertThat(actualException.getCause(), sameInstance(expectedException));\n-        assertThat(((ElasticsearchStatusException) actualException).status(), is(RestStatus.TOO_MANY_REQUESTS));\n+        assertThat(actualException.get(), notNullValue());\n+        assertThat(actualException.get().getMessage(), is(failureExceptionMessage));\n+        assertThat(actualException.get(), instanceOf(ElasticsearchStatusException.class));\n+        assertThat(actualException.get().getCause(), sameInstance(expectedException));\n     }\n \n     @SuppressWarnings(\"unchecked\")\ndiff --git a/x-pack/plugin/inference/src/test/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchCompletionActionTests.java b/x-pack/plugin/inference/src/test/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchCompletionActionTests.java\nindex b129c225cf0..6622590cb1b 100644\n--- a/x-pack/plugin/inference/src/test/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchCompletionActionTests.java\n+++ b/x-pack/plugin/inference/src/test/java/org/elasticsearch/xpack/inference/services/alibabacloudsearch/action/AlibabaCloudSearchCompletionActionTests.java\n@@ -42,6 +42,7 @@ import java.util.concurrent.TimeUnit;\n import static org.elasticsearch.xpack.core.inference.results.ChatCompletionResultsTests.buildExpectationCompletion;\n import static org.elasticsearch.xpack.inference.Utils.inferenceUtilityExecutors;\n import static org.elasticsearch.xpack.inference.Utils.mockClusterServiceEmpty;\n+import static org.elasticsearch.xpack.inference.external.action.ActionUtils.constructFailedToSendRequestMessage;\n import static org.elasticsearch.xpack.inference.services.settings.DefaultSecretSettingsTests.getSecretSettingsMap;\n import static org.hamcrest.Matchers.is;\n import static org.mockito.ArgumentMatchers.any;\n@@ -109,8 +110,8 @@ public class AlibabaCloudSearchCompletionActionTests extends ESTestCase {\n         PlainActionFuture<InferenceServiceResults> listener = new PlainActionFuture<>();\n         action.execute(new ChatCompletionInput(List.of(randomAlphaOfLength(10))), InferenceAction.Request.DEFAULT_TIMEOUT, listener);\n \n-        var thrownException = expectThrows(ElasticsearchStatusException.class, () -> listener.actionGet(TIMEOUT));\n-        assertThat(thrownException.getMessage(), is(\"Failed to send AlibabaCloud Search completion request. Cause: error\"));\n+        var thrownException = expectThrows(ElasticsearchException.class, () -> listener.actionGet(TIMEOUT));\n+        assertThat(thrownException.getMessage(), is(constructFailedToSendRequestMessage(\"AlibabaCloud Search completion\")));\n     }\n \n     public void testExecute_ThrowsIllegalArgumentException_WhenInputIsNotChatCompletionInput() {"
}