{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 1587,
  "base_commit": "df4a3bfd379fd90b3667bbcd7ca2ed4619fee025",
  "head_commit": "d95aa9f266ccecf33894c88af329895c1693cd14",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": 0.3,
    "completeness": 0.2,
    "code_reuse": 0.0,
    "best_practices": 0.1,
    "unsolicited_docs": 1.0
  },
  "aggregate": 0.32,
  "rationale": "The agent added four comprehensive new test methods (testTTLWithRouting, testTTLWithRequiredRouting, testTTLWithPathBasedRouting, testTTLWithMultipleShards) totaling ~240 lines to cover routing scenarios, which addresses the task intent. However, ground truth shows a simpler approach: modifying cluster settings to use 2 shards with controlled routing/hashing (lines 42-46), then enhancing the existing test by adding a single routed document 'with_routing' and checking it in all assertions (8 new assertions total). The agent's approach is more thorough but deviates significantly from the expected minimal enhancement pattern. The ground truth also includes unrelated changes to FiltersFunctionScoreQuery.java (refactoring variable names and score calculation logic) that the agent completely omittedâ€”these are critical correctness issues if those changes were part of the task requirements. The agent's tests are correct in isolation but miss the settings configuration approach and the FiltersFunctionScoreQuery changes entirely. Code reuse is adequate (creates new tests rather than duplicating), best practices are reasonable (though tests are verbose), and no unsolicited documentation was added.",
  "edit_run_id": "8d6f99fc",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java b/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java\nindex 6a8d0c8b68a..43263a466a7 100644\n--- a/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java\n+++ b/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java\n@@ -165,7 +165,7 @@ public class FiltersFunctionScoreQuery extends Query {\n                     if (docSet.get(doc)) {\n                         filterFunction.function.setNextReader(reader);\n                         Explanation functionExplanation = filterFunction.function.explainFactor(doc);\n-                        float sc = getValue() * subQueryExpl.getValue() * functionExplanation.getValue();\n+                        float sc = getValue() * functionExplanation.getValue();\n                         Explanation res = new ComplexExplanation(true, sc, \"custom score, product of:\");\n                         res.addDetail(new Explanation(1.0f, \"match filter: \" + filterFunction.filter.toString()));\n                         res.addDetail(functionExplanation);\n@@ -185,13 +185,13 @@ public class FiltersFunctionScoreQuery extends Query {\n                     if (docSet.get(doc)) {\n                         filterFunction.function.setNextReader(reader);\n                         Explanation functionExplanation = filterFunction.function.explainFactor(doc);\n-                        float factor = functionExplanation.getValue();\n+                        float sc = functionExplanation.getValue();\n                         count++;\n-                        total += factor;\n-                        multiply *= factor;\n-                        max = Math.max(factor, max);\n-                        min = Math.min(factor, min);\n-                        Explanation res = new ComplexExplanation(true, factor, \"custom score, product of:\");\n+                        total += sc;\n+                        multiply *= sc;\n+                        max = Math.max(sc, max);\n+                        min = Math.min(sc, min);\n+                        Explanation res = new ComplexExplanation(true, sc, \"custom score, product of:\");\n                         res.addDetail(new Explanation(1.0f, \"match filter: \" + filterFunction.filter.toString()));\n                         res.addDetail(functionExplanation);\n                         res.addDetail(new Explanation(getValue(), \"queryBoost\"));\n@@ -199,26 +199,25 @@ public class FiltersFunctionScoreQuery extends Query {\n                     }\n                 }\n                 if (count > 0) {\n-                    float factor = 0;\n+                    float sc = 0;\n                     switch (scoreMode) {\n                         case Avg:\n-                            factor = total / count;\n+                            sc = total / count;\n                             break;\n                         case Max:\n-                            factor = max;\n+                            sc = max;\n                             break;\n                         case Min:\n-                            factor = min;\n+                            sc = min;\n                             break;\n                         case Total:\n-                            factor = total;\n+                            sc = total;\n                             break;\n                         case Multiply:\n-                            factor = multiply;\n+                            sc = multiply;\n                             break;\n                     }\n-\n-                    float sc = factor * subQueryExpl.getValue() * getValue();\n+                    sc *= getValue();\n                     Explanation res = new ComplexExplanation(true, sc, \"custom score, score mode [\" + scoreMode.toString().toLowerCase() + \"]\");\n                     res.addDetail(subQueryExpl);\n                     for (Explanation explanation : filtersExplanations) {\ndiff --git a/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java b/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java\nindex 89f4ab78fe1..3b8f00c041b 100644\n--- a/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java\n+++ b/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java\n@@ -39,7 +39,12 @@ public class SimpleTTLTests extends AbstractNodesTests {\n \n     @BeforeClass\n     public void createNodes() throws Exception {\n-        Settings settings = settingsBuilder().put(\"indices.ttl.interval\", purgeInterval).build();\n+        Settings settings = settingsBuilder()\n+                .put(\"indices.ttl.interval\", purgeInterval)\n+                .put(\"index.number_of_shards\", 2) // 2 shards to test TTL purge with routing properly\n+                .put(\"cluster.routing.operation.use_type\", false) // make sure we control the shard computation\n+                .put(\"cluster.routing.operation.hash.type\", \"djb\")\n+                .build();\n         startNode(\"node1\", settings);\n         startNode(\"node2\", settings);\n         client = getClient();\n@@ -71,7 +76,9 @@ public class SimpleTTLTests extends AbstractNodesTests {\n         client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n         long providedTTLValue = 3000;\n         logger.info(\"--> checking ttl\");\n+        // Index one doc without routing and one doc with routing\n         client.prepareIndex(\"test\", \"type1\", \"1\").setSource(\"field1\", \"value1\").setTTL(providedTTLValue).setRefresh(true).execute().actionGet();\n+        client.prepareIndex(\"test\", \"type1\", \"with_routing\").setSource(\"field1\", \"value1\").setTTL(providedTTLValue).setRouting(\"routing\").setRefresh(true).execute().actionGet();\n         long now = System.currentTimeMillis();\n \n         // realtime get check\n@@ -100,7 +107,7 @@ public class SimpleTTLTests extends AbstractNodesTests {\n         assertThat(ttl0, lessThan(providedTTLValue - (now1 - now)));\n \n         logger.info(\"--> checking purger\");\n-        // make sure the purger has done its job\n+        // make sure the purger has done its job for all indexed docs that are expired\n         long shouldBeExpiredDate = now + providedTTLValue + purgeInterval + 2000;\n         now1 = System.currentTimeMillis();\n         if (shouldBeExpiredDate - now1 > 0) {\n@@ -109,14 +116,22 @@ public class SimpleTTLTests extends AbstractNodesTests {\n         // realtime get check\n         getResponse = client.prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n         assertThat(getResponse.exists(), equalTo(false));\n+        getResponse = client.prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n+        assertThat(getResponse.exists(), equalTo(false));\n         // replica realtime get check\n         getResponse = client.prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n         assertThat(getResponse.exists(), equalTo(false));\n+        getResponse = client.prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n+        assertThat(getResponse.exists(), equalTo(false));\n         // non realtime get (stored) check\n         getResponse = client.prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n         assertThat(getResponse.exists(), equalTo(false));\n+        getResponse = client.prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n+        assertThat(getResponse.exists(), equalTo(false));\n         // non realtime get going the replica check\n         getResponse = client.prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n         assertThat(getResponse.exists(), equalTo(false));\n+        getResponse = client.prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n+        assertThat(getResponse.exists(), equalTo(false));\n     }\n }"
}