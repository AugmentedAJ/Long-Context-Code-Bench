{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4496,
  "base_commit": "5a02ec86a8f76c02304b015035c4cffac4474395",
  "head_commit": "56b394170653ee590cf9908509be00fab690d918",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.8,
    "completeness": -0.3,
    "code_reuse": -0.7,
    "best_practices": -0.6,
    "unsolicited_docs": 1.0
  },
  "aggregate": -0.27999999999999997,
  "rationale": "The agent's approach is fundamentally different from the ground truth and likely incorrect. Ground truth fixes the issue at the formatter level in FormatDateTimeFormatter.java by setting withDefaultYear(1970) on both printer and parser, which is the clean, centralized solution. The agent instead duplicates date parsing logic across three files (DateMathParser.java, DateFieldMapper.java, ValueParser.java) by manually creating MutableDateTime objects with 1970 base and using parseInto(). This is problematic because: (1) It doesn't actually fix the root cause - the formatter still defaults to 2000, so any code path not using these specific parseStringValue methods will still have the bug. (2) Massive code duplication - the same ~20 line parsing logic is copy-pasted 3 times with minor variations. (3) The agent completely missed adding the required test case in SimpleDateMappingTests.java that validates the fix works. (4) The parsing logic has issues - checking 'dateTime.getYear() > 5000' as a heuristic is fragile and the fallback logic differs between files (parseMillis vs Long.parseLong). The ground truth solution is superior: it's a 2-line change that fixes the issue globally at the formatter level, plus adds proper test coverage. The agent's solution is band-aid fixes that don't address the root cause, violate DRY principles, and lack test coverage.",
  "edit_run_id": "7ad89f22",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/common/joda/FormatDateTimeFormatter.java b/src/main/java/org/elasticsearch/common/joda/FormatDateTimeFormatter.java\nindex 942aca7663b..7ec2981da3c 100644\n--- a/src/main/java/org/elasticsearch/common/joda/FormatDateTimeFormatter.java\n+++ b/src/main/java/org/elasticsearch/common/joda/FormatDateTimeFormatter.java\n@@ -44,8 +44,8 @@ public class FormatDateTimeFormatter {\n     public FormatDateTimeFormatter(String format, DateTimeFormatter parser, DateTimeFormatter printer, Locale locale) {\n         this.format = format;\n         this.locale = locale;\n-        this.printer = locale == null ? printer : printer.withLocale(locale);\n-        this.parser = locale == null ? parser : parser.withLocale(locale);\n+        this.printer = locale == null ? printer.withDefaultYear(1970) : printer.withLocale(locale).withDefaultYear(1970);\n+        this.parser = locale == null ? parser.withDefaultYear(1970) : parser.withLocale(locale).withDefaultYear(1970);\n     }\n     \n     public String format() {\ndiff --git a/src/test/java/org/elasticsearch/index/mapper/date/SimpleDateMappingTests.java b/src/test/java/org/elasticsearch/index/mapper/date/SimpleDateMappingTests.java\nindex 95dff302ce3..c2a8319f441 100644\n--- a/src/test/java/org/elasticsearch/index/mapper/date/SimpleDateMappingTests.java\n+++ b/src/test/java/org/elasticsearch/index/mapper/date/SimpleDateMappingTests.java\n@@ -224,6 +224,30 @@ public class SimpleDateMappingTests extends ElasticsearchTestCase {\n         assertThat(rangeFilter.getMin(), equalTo(new DateTime(TimeValue.timeValueHours(10).millis()).getMillis()));\n     }\n \n+\n+    @Test\n+    public void testDayWithoutYearFormat() throws Exception {\n+        String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n+                .field(\"date_detection\", false)\n+                .startObject(\"properties\").startObject(\"date_field\").field(\"type\", \"date\").field(\"format\", \"MMM dd HH:mm:ss\").endObject().endObject()\n+                .endObject().endObject().string();\n+\n+        DocumentMapper defaultMapper = mapper(mapping);\n+\n+        ParsedDocument doc = defaultMapper.parse(\"type\", \"1\", XContentFactory.jsonBuilder()\n+                .startObject()\n+                .field(\"date_field\", \"Jan 02 10:00:00\")\n+                .endObject()\n+                .bytes());\n+        assertThat(((LongFieldMapper.CustomLongNumericField) doc.rootDoc().getField(\"date_field\")).numericAsString(), equalTo(Long.toString(new DateTime(TimeValue.timeValueHours(34).millis(), DateTimeZone.UTC).getMillis())));\n+\n+        Filter filter = defaultMapper.mappers().smartNameFieldMapper(\"date_field\").rangeFilter(\"Jan 02 10:00:00\", \"Jan 02 11:00:00\", true, true, null);\n+        assertThat(filter, instanceOf(NumericRangeFilter.class));\n+        NumericRangeFilter<Long> rangeFilter = (NumericRangeFilter<Long>) filter;\n+        assertThat(rangeFilter.getMax(), equalTo(new DateTime(TimeValue.timeValueHours(35).millis() + 999).getMillis())); // +999 to include the 00-01 minute\n+        assertThat(rangeFilter.getMin(), equalTo(new DateTime(TimeValue.timeValueHours(34).millis()).getMillis()));\n+    }\n+\n     @Test\n     public void testIgnoreMalformedOption() throws Exception {\n         String mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")"
}