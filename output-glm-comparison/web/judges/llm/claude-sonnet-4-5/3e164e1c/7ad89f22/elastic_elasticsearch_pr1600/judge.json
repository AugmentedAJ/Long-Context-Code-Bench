{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 1600,
  "base_commit": "ed8a46ce09ccf43adec55af91a72fc9c5dc1ec05",
  "head_commit": "682176497f9f454943d2373dc24501ad37b8dbb0",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.6,
    "completeness": -0.5,
    "code_reuse": 0.0,
    "best_practices": -0.3,
    "unsolicited_docs": 1.0
  },
  "aggregate": -0.08000000000000003,
  "rationale": "The agent's implementation has several critical issues compared to the ground truth: (1) It fails to import TimeValue, which is needed for parsing TTL values from strings; (2) It doesn't extract timestamp/TTL from the script context (ctx.get), only from getResult fields, missing the script-provided values entirely; (3) It doesn't implement TTL decay logic (subtracting elapsed time) which is essential for correctness; (4) It doesn't track getDate for TTL approximation; (5) It keeps both TimestampFieldMapper and TTLFieldMapper imports instead of replacing the former with the latter as ground truth does; (6) The conditional setting of timestamp/ttl on indexRequest differs from ground truth's inline chaining approach. The agent adds TTLFieldMapper.NAME to the get() call alongside TimestampFieldMapper.NAME instead of replacing it, which changes behavior. Most critically, the lack of ctx.get() extraction means script-provided timestamp/TTL values are ignored, and missing TTL decay logic will cause incorrect TTL values over time.",
  "edit_run_id": "7ad89f22",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\nindex 5a296cdf925..ae9eea79b9f 100644\n--- a/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\n+++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java\n@@ -43,6 +43,7 @@ import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.common.collect.Tuple;\n import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.xcontent.XContentHelper;\n import org.elasticsearch.common.xcontent.XContentType;\n import org.elasticsearch.index.engine.DocumentMissingException;\n@@ -52,7 +53,7 @@ import org.elasticsearch.index.get.GetResult;\n import org.elasticsearch.index.mapper.internal.ParentFieldMapper;\n import org.elasticsearch.index.mapper.internal.RoutingFieldMapper;\n import org.elasticsearch.index.mapper.internal.SourceFieldMapper;\n-import org.elasticsearch.index.mapper.internal.TimestampFieldMapper;\n+import org.elasticsearch.index.mapper.internal.TTLFieldMapper;\n import org.elasticsearch.index.service.IndexService;\n import org.elasticsearch.index.shard.IllegalIndexShardStateException;\n import org.elasticsearch.index.shard.ShardId;\n@@ -152,8 +153,9 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         IndexService indexService = indicesService.indexServiceSafe(request.index());\n         IndexShard indexShard = indexService.shardSafe(request.shardId());\n \n+        long getDate = System.currentTimeMillis();\n         GetResult getResult = indexShard.getService().get(request.type(), request.id(),\n-                new String[]{SourceFieldMapper.NAME, RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TimestampFieldMapper.NAME}, true);\n+                new String[]{SourceFieldMapper.NAME, RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TTLFieldMapper.NAME}, true);\n \n         // no doc, what to do, what to do...\n         if (!getResult.exists()) {\n@@ -183,12 +185,28 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         }\n \n         String operation = (String) ctx.get(\"op\");\n+        String timestamp = (String) ctx.get(\"_timestamp\");\n+        Long ttl = null;\n+        Object fetchedTTL = ctx.get(\"_ttl\");\n+        if (fetchedTTL != null) {\n+            if (fetchedTTL instanceof Number) {\n+                ttl = ((Number) fetchedTTL).longValue();\n+            } else {\n+                ttl = TimeValue.parseTimeValue((String) fetchedTTL, null).millis();\n+            }\n+        }\n         source = (Map<String, Object>) ctx.get(\"_source\");\n \n         // apply script to update the source\n         String routing = getResult.fields().containsKey(RoutingFieldMapper.NAME) ? getResult.field(RoutingFieldMapper.NAME).value().toString() : null;\n         String parent = getResult.fields().containsKey(ParentFieldMapper.NAME) ? getResult.field(ParentFieldMapper.NAME).value().toString() : null;\n-        // TODO ttl/timestamp\n+        // No TTL has been given in the update script so we keep previous TTL value if there is one\n+        if (ttl == null) {\n+            ttl = getResult.fields().containsKey(TTLFieldMapper.NAME) ? (Long) getResult.field(TTLFieldMapper.NAME).value() : null;\n+            if (ttl != null) {\n+                ttl = ttl - (System.currentTimeMillis() - getDate); // It is an approximation of exact TTL value, could be improved\n+            }\n+        }\n \n         // TODO percolate?\n \n@@ -197,7 +215,8 @@ public class TransportUpdateAction extends TransportInstanceSingleOperationActio\n         if (operation == null || \"index\".equals(operation)) {\n             IndexRequest indexRequest = Requests.indexRequest(request.index()).type(request.type()).id(request.id()).routing(routing).parent(parent)\n                     .source(source, sourceAndContent.v1())\n-                    .version(getResult.version()).replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel());\n+                    .version(getResult.version()).replicationType(request.replicationType()).consistencyLevel(request.consistencyLevel())\n+                    .timestamp(timestamp).ttl(ttl);\n             indexRequest.operationThreaded(false);\n             indexAction.execute(indexRequest, new ActionListener<IndexResponse>() {\n                 @Override"
}