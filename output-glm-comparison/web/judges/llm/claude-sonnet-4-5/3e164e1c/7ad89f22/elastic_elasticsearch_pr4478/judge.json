{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4478,
  "base_commit": "2b6214cff72423fc5c948c7b4c39027c93494400",
  "head_commit": "a4f97bed9d3a299f1553192464ecfba17a75cfb9",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.9,
    "completeness": -0.95,
    "code_reuse": -0.8,
    "best_practices": -0.5,
    "unsolicited_docs": 0.0
  },
  "aggregate": -0.6300000000000001,
  "rationale": "The agent completely misunderstood the optimization task. The ground truth implements a sophisticated early termination strategy with major architectural changes: (1) adds hashCode caching in MutableShardRouting, (2) creates a drain() method in UnassignedShards, (3) refactors the initialization loop to use sorted arrays with primary/replica separation, (4) adds canAllocate methods to AllocationDecider/AllocationDeciders for node-level decisions, (5) uses IdentityHashSet to track available nodes and removes exhausted nodes from consideration, and (6) removes unnecessary constructors from AllocationService. The agent instead added only trivial early-termination checks (primary active check for replicas, shard containment check) directly in the allocation loop, missing all the core algorithmic improvements. The agent's changes do not address the fundamental inefficiency of repeatedly attempting to allocate replicas when their primaries are not active across multiple rounds, nor do they implement the array-based sorting and filtering approach that enables efficient batch processing. The agent also added unsolicited verbose comments explaining obvious logic. Critical missing components: hashCode optimization, drain method, array-based allocation with comparator, node-level allocation deciders, IdentityHashSet for node tracking, and test infrastructure changes. The agent's solution would provide minimal performance improvement compared to the ground truth's comprehensive optimization.",
  "edit_run_id": "7ad89f22",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/cluster/routing/MutableShardRouting.java b/src/main/java/org/elasticsearch/cluster/routing/MutableShardRouting.java\nindex c3d4bca0f4e..a80672b67bb 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/MutableShardRouting.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/MutableShardRouting.java\n@@ -147,5 +147,14 @@ public class MutableShardRouting extends ImmutableShardRouting {\n         primary = false;\n     }\n \n+    private long hashVersion = version-1;\n+    private int hashCode = 0;\n+\n+    @Override\n+    public int hashCode() {\n+        hashCode = (hashVersion != version ? super.hashCode() : hashCode);\n+        hashVersion = version;\n+        return hashCode;\n+    }\n }\n \ndiff --git a/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java b/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java\nindex 148027aee91..837a9efa6ce 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java\n@@ -584,6 +584,14 @@ public class RoutingNodes implements Iterable<RoutingNode> {\n         public void copyAll(Collection<MutableShardRouting> others) {\n             others.addAll(unassigned);\n         }\n+\n+        public MutableShardRouting[] drain() {\n+            MutableShardRouting[] mutableShardRoutings = unassigned.toArray(new MutableShardRouting[unassigned.size()]);\n+            unassigned.clear();\n+            primaries = 0;\n+            transactionId++;\n+            return mutableShardRoutings;\n+        }\n     }\n \n \ndiff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java\nindex 5f20e86ba4b..5a765b297ec 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java\n@@ -34,9 +34,7 @@ import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n import org.elasticsearch.common.component.AbstractComponent;\n import org.elasticsearch.common.inject.Inject;\n-import org.elasticsearch.common.settings.ImmutableSettings;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.node.settings.NodeSettingsService;\n \n import java.util.ArrayList;\n import java.util.Iterator;\n@@ -57,16 +55,6 @@ public class AllocationService extends AbstractComponent {\n     private final ClusterInfoService clusterInfoService;\n     private final ShardsAllocators shardsAllocators;\n \n-    public AllocationService() {\n-        this(ImmutableSettings.Builder.EMPTY_SETTINGS);\n-    }\n-\n-    public AllocationService(Settings settings) {\n-        this(settings,\n-                new AllocationDeciders(settings, new NodeSettingsService(ImmutableSettings.Builder.EMPTY_SETTINGS)),\n-                new ShardsAllocators(settings), ClusterInfoService.EMPTY);\n-    }\n-\n     @Inject\n     public AllocationService(Settings settings, AllocationDeciders allocationDeciders, ShardsAllocators shardsAllocators, ClusterInfoService clusterInfoService) {\n         super(settings);\ndiff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java\nindex 2e67160d859..c2bb966ced7 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java\n@@ -20,6 +20,7 @@\n package org.elasticsearch.cluster.routing.allocation.allocator;\n \n import com.google.common.base.Predicate;\n+import org.apache.lucene.util.ArrayUtil;\n import org.apache.lucene.util.IntroSorter;\n import org.elasticsearch.ElasticSearchIllegalArgumentException;\n import org.elasticsearch.cluster.metadata.MetaData;\n@@ -30,6 +31,7 @@ import org.elasticsearch.cluster.routing.allocation.StartedRerouteAllocation;\n import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n import org.elasticsearch.cluster.routing.allocation.decider.Decision.Type;\n+import org.elasticsearch.common.collect.IdentityHashSet;\n import org.elasticsearch.common.component.AbstractComponent;\n import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.logging.ESLogger;\n@@ -367,80 +369,82 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n             }\n             final RoutingNodes.UnassignedShards unassigned = routingNodes.unassigned().transactionBegin();\n             boolean changed = initialize(routingNodes, unassigned);\n-            NodeSorter sorter = newNodeSorter();\n-            if (nodes.size() > 1) { /* skip if we only have one node */\n-                for (String index : buildWeightOrderedIndidces(Operation.BALANCE, sorter)) {\n-                    sorter.reset(Operation.BALANCE, index);\n-                    final float[] weights = sorter.weights;\n-                    final ModelNode[] modelNodes = sorter.modelNodes;\n-                    int lowIdx = 0;\n-                    int highIdx = weights.length - 1;\n-                    while (true) {\n-                        final ModelNode minNode = modelNodes[lowIdx];\n-                        final ModelNode maxNode = modelNodes[highIdx];\n-                        advance_range: \n-                        if (maxNode.numShards(index) > 0) {\n-                            float delta = weights[highIdx] - weights[lowIdx];\n-                            delta = delta <= threshold ? delta : sorter.weight(Operation.THRESHOLD_CHECK, maxNode) - sorter.weight(Operation.THRESHOLD_CHECK, minNode);\n-                            if (delta <= threshold) {\n-                                if (lowIdx > 0 && highIdx-1 > 0 // is there a chance for a higher delta? \n-                                    && (weights[highIdx-1] - weights[0] > threshold) // check if we need to break at all\n-                                    ) {\n-                                    /* This is a special case if allocations from the \"heaviest\" to the \"lighter\" nodes is not possible \n-                                     * due to some allocation decider restrictions like zone awareness. if one zone has for instance \n-                                     * less nodes than another zone. so one zone is horribly overloaded from a balanced perspective but we\n-                                     * can't move to the \"lighter\" shards since otherwise the zone would go over capacity.\n-                                     * \n-                                     * This break jumps straight to the condition below were we start moving from the high index towards \n-                                     * the low index to shrink the window we are considering for balance from the other direction. \n-                                     * (check shrinking the window from MAX to MIN)\n-                                     * See #3580\n-                                     */\n-                                    break advance_range;\n+            if (!changed) {\n+                NodeSorter sorter = newNodeSorter();\n+                if (nodes.size() > 1) { /* skip if we only have one node */\n+                    for (String index : buildWeightOrderedIndidces(Operation.BALANCE, sorter)) {\n+                        sorter.reset(Operation.BALANCE, index);\n+                        final float[] weights = sorter.weights;\n+                        final ModelNode[] modelNodes = sorter.modelNodes;\n+                        int lowIdx = 0;\n+                        int highIdx = weights.length - 1;\n+                        while (true) {\n+                            final ModelNode minNode = modelNodes[lowIdx];\n+                            final ModelNode maxNode = modelNodes[highIdx];\n+                            advance_range:\n+                            if (maxNode.numShards(index) > 0) {\n+                                float delta = weights[highIdx] - weights[lowIdx];\n+                                delta = delta <= threshold ? delta : sorter.weight(Operation.THRESHOLD_CHECK, maxNode) - sorter.weight(Operation.THRESHOLD_CHECK, minNode);\n+                                if (delta <= threshold) {\n+                                    if (lowIdx > 0 && highIdx-1 > 0 // is there a chance for a higher delta?\n+                                        && (weights[highIdx-1] - weights[0] > threshold) // check if we need to break at all\n+                                        ) {\n+                                        /* This is a special case if allocations from the \"heaviest\" to the \"lighter\" nodes is not possible\n+                                         * due to some allocation decider restrictions like zone awareness. if one zone has for instance\n+                                         * less nodes than another zone. so one zone is horribly overloaded from a balanced perspective but we\n+                                         * can't move to the \"lighter\" shards since otherwise the zone would go over capacity.\n+                                         *\n+                                         * This break jumps straight to the condition below were we start moving from the high index towards\n+                                         * the low index to shrink the window we are considering for balance from the other direction.\n+                                         * (check shrinking the window from MAX to MIN)\n+                                         * See #3580\n+                                         */\n+                                        break advance_range;\n+                                    }\n+                                    if (logger.isTraceEnabled()) {\n+                                        logger.trace(\"Stop balancing index [{}]  min_node [{}] weight: [{}]  max_node [{}] weight: [{}]  delta: [{}]\",\n+                                                index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);\n+                                    }\n+                                    break;\n                                 }\n                                 if (logger.isTraceEnabled()) {\n-                                    logger.trace(\"Stop balancing index [{}]  min_node [{}] weight: [{}]  max_node [{}] weight: [{}]  delta: [{}]\",\n-                                            index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);\n+                                    logger.trace(\"Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]\",\n+                                            maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);\n+                                }\n+                                /* pass the delta to the replication function to prevent relocations that only swap the weights of the two nodes.\n+                                 * a relocation must bring us closer to the balance if we only achive the same delta the relocation is useless */\n+                                if (tryRelocateShard(Operation.BALANCE, minNode, maxNode, index, delta)) {\n+                                    /*\n+                                     * TODO we could be a bit smarter here, we don't need to fully sort necessarily\n+                                     * we could just find the place to insert linearly but the win might be minor\n+                                     * compared to the added complexity\n+                                     */\n+                                    weights[lowIdx] = sorter.weight(Operation.BALANCE, modelNodes[lowIdx]);\n+                                    weights[highIdx] = sorter.weight(Operation.BALANCE, modelNodes[highIdx]);\n+                                    sorter.sort(0, weights.length);\n+                                    lowIdx = 0;\n+                                    highIdx = weights.length - 1;\n+                                    changed = true;\n+                                    continue;\n                                 }\n-                                break;\n-                            }\n-                            if (logger.isTraceEnabled()) {\n-                                logger.trace(\"Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]\",\n-                                        maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);\n                             }\n-                            /* pass the delta to the replication function to prevent relocations that only swap the weights of the two nodes.\n-                             * a relocation must bring us closer to the balance if we only achive the same delta the relocation is useless */\n-                            if (tryRelocateShard(Operation.BALANCE, minNode, maxNode, index, delta)) {\n-                                /*\n-                                 * TODO we could be a bit smarter here, we don't need to fully sort necessarily\n-                                 * we could just find the place to insert linearly but the win might be minor\n-                                 * compared to the added complexity\n-                                 */\n-                                weights[lowIdx] = sorter.weight(Operation.BALANCE, modelNodes[lowIdx]);\n-                                weights[highIdx] = sorter.weight(Operation.BALANCE, modelNodes[highIdx]);\n-                                sorter.sort(0, weights.length);\n+                            if (lowIdx < highIdx - 1) {\n+                                /* Shrinking the window from MIN to MAX\n+                                 * we can't move from any shard from the min node lets move on to the next node\n+                                 * and see if the threshold still holds. We either don't have any shard of this\n+                                 * index on this node of allocation deciders prevent any relocation.*/\n+                                lowIdx++;\n+                            } else if (lowIdx > 0) {\n+                                /* Shrinking the window from MAX to MIN\n+                                 * now we go max to min since obviously we can't move anything to the max node\n+                                 * lets pick the next highest */\n                                 lowIdx = 0;\n-                                highIdx = weights.length - 1;\n-                                changed = true;\n-                                continue;\n+                                highIdx--;\n+                            } else {\n+                                /* we are done here, we either can't relocate anymore or we are balanced */\n+                                break;\n                             }\n                         }\n-                        if (lowIdx < highIdx - 1) { \n-                            /* Shrinking the window from MIN to MAX\n-                             * we can't move from any shard from the min node lets move on to the next node\n-                             * and see if the threshold still holds. We either don't have any shard of this\n-                             * index on this node of allocation deciders prevent any relocation.*/\n-                            lowIdx++;\n-                        } else if (lowIdx > 0) {\n-                            /* Shrinking the window from MAX to MIN\n-                             * now we go max to min since obviously we can't move anything to the max node \n-                             * lets pick the next highest */\n-                            lowIdx = 0;\n-                            highIdx--;\n-                        } else {\n-                            /* we are done here, we either can't relocate anymore or we are balanced */\n-                            break;\n-                        }\n                     }\n                 }\n             }\n@@ -521,38 +525,39 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n             }\n             final RoutingNodes.UnassignedShards unassigned = routingNodes.unassigned().transactionBegin();\n             boolean changed = initialize(routingNodes, unassigned);\n-\n-            final ModelNode sourceNode = nodes.get(node.nodeId());\n-            assert sourceNode != null;\n-            final NodeSorter sorter = newNodeSorter();\n-            sorter.reset(Operation.MOVE, shard.getIndex());\n-            final ModelNode[] nodes = sorter.modelNodes;\n-            assert sourceNode.containsShard(shard);\n-            /*\n-             * the sorter holds the minimum weight node first for the shards index.\n-             * We now walk through the nodes until we find a node to allocate the shard.\n-             * This is not guaranteed to be balanced after this operation we still try best effort to \n-             * allocate on the minimal eligible node.\n-             */\n-           \n-            for (ModelNode currentNode : nodes) {\n-                if (currentNode.getNodeId().equals(node.nodeId())) {\n-                    continue;\n-                }\n-                RoutingNode target = routingNodes.node(currentNode.getNodeId());\n-                Decision decision = allocation.deciders().canAllocate(shard, target, allocation);\n-                if (decision.type() == Type.YES) { // TODO maybe we can respect throttling here too?\n-                    sourceNode.removeShard(shard);\n-                    final MutableShardRouting initializingShard = new MutableShardRouting(shard.index(), shard.id(), currentNode.getNodeId(),\n-                            shard.currentNodeId(), shard.restoreSource(), shard.primary(), INITIALIZING, shard.version() + 1);\n-                    currentNode.addShard(initializingShard, decision);\n-                    routingNodes.assign(initializingShard, target.nodeId());\n-                    routingNodes.relocate(shard, target.nodeId()); // set the node to relocate after we added the initializing shard\n-                    if (logger.isTraceEnabled()) {\n-                        logger.trace(\"Moved shard [{}] to node [{}]\", shard, currentNode.getNodeId());\n+            if (!changed) {\n+                final ModelNode sourceNode = nodes.get(node.nodeId());\n+                assert sourceNode != null;\n+                final NodeSorter sorter = newNodeSorter();\n+                sorter.reset(Operation.MOVE, shard.getIndex());\n+                final ModelNode[] nodes = sorter.modelNodes;\n+                assert sourceNode.containsShard(shard);\n+                /*\n+                 * the sorter holds the minimum weight node first for the shards index.\n+                 * We now walk through the nodes until we find a node to allocate the shard.\n+                 * This is not guaranteed to be balanced after this operation we still try best effort to\n+                 * allocate on the minimal eligible node.\n+                 */\n+\n+                for (ModelNode currentNode : nodes) {\n+                    if (currentNode.getNodeId().equals(node.nodeId())) {\n+                        continue;\n+                    }\n+                    RoutingNode target = routingNodes.node(currentNode.getNodeId());\n+                    Decision decision = allocation.deciders().canAllocate(shard, target, allocation);\n+                    if (decision.type() == Type.YES) { // TODO maybe we can respect throttling here too?\n+                        sourceNode.removeShard(shard);\n+                        final MutableShardRouting initializingShard = new MutableShardRouting(shard.index(), shard.id(), currentNode.getNodeId(),\n+                                shard.currentNodeId(), shard.restoreSource(), shard.primary(), INITIALIZING, shard.version() + 1);\n+                        currentNode.addShard(initializingShard, decision);\n+                        routingNodes.assign(initializingShard, target.nodeId());\n+                        routingNodes.relocate(shard, target.nodeId()); // set the node to relocate after we added the initializing shard\n+                        if (logger.isTraceEnabled()) {\n+                            logger.trace(\"Moved shard [{}] to node [{}]\", shard, currentNode.getNodeId());\n+                        }\n+                        changed = true;\n+                        break;\n                     }\n-                    changed = true;\n-                    break;\n                 }\n             }\n             routingNodes.unassigned().transactionEnd(unassigned);\n@@ -603,40 +608,57 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n              * use the sorter to save some iterations. \n              */\n             final AllocationDeciders deciders = allocation.deciders();\n-            final Set<MutableShardRouting> currentRound = new TreeSet<MutableShardRouting>(new Comparator<MutableShardRouting>() {\n+            final Comparator<MutableShardRouting> comparator = new Comparator<MutableShardRouting>() {\n                 @Override\n                 public int compare(MutableShardRouting o1,\n                                    MutableShardRouting o2) {\n+                    if (o1.primary() ^ o2.primary()) {\n+                        return o1.primary() ? -1 : o2.primary() ? 1 : 0;\n+                    }\n                     final int indexCmp;\n                     if ((indexCmp = o1.index().compareTo(o2.index())) == 0) {\n-                        if (o1.getId() - o2.getId() == 0) {\n-                            return o1.primary() ? -1 : o2.primary() ? 1 : 0;\n-                        }\n                         return o1.getId() - o2.getId();\n-\n                     }\n                     return indexCmp;\n                 }\n-            });\n+            };\n+            /*\n+             * we use 2 arrays and move replicas to the second array once we allocated an identical\n+             * replica in the current iteration to make sure all indices get allocated in the same manner.\n+             * The arrays are sorted by primaries first and then by index and shard ID so a 2 indices with 2 replica and 1 shard would look like:\n+             * [(0,P,IDX1), (0,P,IDX2), (0,R,IDX1), (0,R,IDX1), (0,R,IDX2), (0,R,IDX2)]\n+             * if we allocate for instance (0, R, IDX1) we move the second replica to the secondary array and proceed with\n+             * the next replica. If we could not find a node to allocate (0,R,IDX1) we move all it's replicas to ingoreUnassigned.\n+             */\n+            MutableShardRouting[] primary = unassigned.drain();\n+            MutableShardRouting[] secondary = new MutableShardRouting[primary.length];\n+            int secondaryLength = 0;\n+            int primaryLength = primary.length;\n+            ArrayUtil.timSort(primary, comparator);\n+            final Set<ModelNode> values = new IdentityHashSet<ModelNode>(nodes.values());\n             do {\n-                Iterator<MutableShardRouting> iterator = unassigned.iterator();\n-                while (iterator.hasNext()) {\n-                    /* we treat every index equally here once chunk a time such that we fill up\n-                     * nodes with all indices at the same time. Only on shard of a shard a time.\n-                \t * Although there might be a primary and a shard of a shard in the set but\n-                \t * primaries will be started first.*/\n-                    if (currentRound.add(iterator.next())) {\n-                        iterator.remove();\n+                for (int i = 0; i < primaryLength; i++) {\n+                    MutableShardRouting shard = primary[i];\n+                    if (!shard.primary()) {\n+                        boolean drop = deciders.canAllocate(shard, allocation).type() == Type.NO;\n+                        if (drop) {\n+                            ignoredUnassigned.add(shard);\n+                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {\n+                                ignoredUnassigned.add(primary[++i]);\n+                            }\n+                            continue;\n+                        } else {\n+                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {\n+                                secondary[secondaryLength++] = primary[++i];\n+                            }\n+                        }\n                     }\n-                }\n-                boolean iterationChanged = false;\n-                for (MutableShardRouting shard : currentRound) {\n-                    assert !shard.assignedToNode();\n+                    assert !shard.assignedToNode() : shard;\n                     /* find an node with minimal weight we can allocate on*/\n                     float minWeight = Float.POSITIVE_INFINITY;\n                     ModelNode minNode = null;\n                     Decision decision = null;\n-                    for (ModelNode node : nodes.values()) {\n+                    for (ModelNode node : values) {\n                         /*\n                          * The shard we add is removed below to simulate the\n \t                     * addition for weight calculation we use Decision.ALWAYS to\n@@ -696,7 +718,6 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n                     }\n                     assert decision != null && minNode != null || decision == null && minNode == null;\n                     if (minNode != null) {\n-                        iterationChanged = true;\n                         minNode.addShard(shard, decision);\n                         if (decision.type() == Type.YES) {\n                             if (logger.isTraceEnabled()) {\n@@ -705,6 +726,14 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n                             routingNodes.assign(shard, routingNodes.node(minNode.getNodeId()).nodeId());\n                             changed = true;\n                             continue; // don't add to ignoreUnassigned\n+                        } else {\n+                            final RoutingNode node = routingNodes.node(minNode.getNodeId());\n+                            if (deciders.canAllocate(node, allocation).type() != Type.YES) {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\"Can not allocate on node [{}] remove from round decisin [{}]\", node, decision.type());\n+                                }\n+                                values.remove(minNode);\n+                            }\n                         }\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No eligable node found to assign shard [{}] decision [{}]\", shard, decision.type());\n@@ -713,14 +742,18 @@ public class BalancedShardsAllocator extends AbstractComponent implements Shards\n                         logger.trace(\"No Node found to assign shard [{}]\", shard);\n                     }\n                     ignoredUnassigned.add(shard);\n+                    if (!shard.primary()) { // we could not allocate it and we are a replica - check if we can ignore the other replicas\n+                        while(secondaryLength > 0 && comparator.compare(shard, secondary[secondaryLength-1]) == 0) {\n+                            ignoredUnassigned.add(secondary[--secondaryLength]);\n+                        }\n+                    }\n                 }\n-                if (!iterationChanged && !unassigned.isEmpty()) {\n-                    unassigned.copyAll(ignoredUnassigned);\n-                    unassigned.clear();\n-                    return changed;\n-                }\n-                currentRound.clear();\n-            } while (!unassigned.isEmpty());\n+                primaryLength = secondaryLength;\n+                MutableShardRouting[] tmp = primary;\n+                primary = secondary;\n+                secondary = tmp;\n+                secondaryLength = 0;\n+            } while (primaryLength > 0);\n             // clear everything we have either added it or moved to ingoreUnassigned\n             return changed;\n         }\ndiff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java\nindex 2209e9d04dd..b2247e9de4a 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java\n@@ -64,4 +64,20 @@ public abstract class AllocationDecider extends AbstractComponent {\n     public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n         return Decision.ALWAYS;\n     }\n+\n+    /**\n+     * Returns a {@link Decision} whether the given shard routing can be allocated at all at this state of the\n+     * {@link RoutingAllocation}. The default is {@link Decision#ALWAYS}.\n+     */\n+    public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {\n+        return Decision.ALWAYS;\n+    }\n+\n+    /**\n+     * Returns a {@link Decision} whether the given node can allow any allocation at all at this state of the\n+     * {@link RoutingAllocation}. The default is {@link Decision#ALWAYS}.\n+     */\n+    public Decision canAllocate(RoutingNode node, RoutingAllocation allocation) {\n+        return Decision.ALWAYS;\n+    }\n }\ndiff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java\nindex bc09e4222af..91c0889027d 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java\n@@ -19,13 +19,11 @@\n \n package org.elasticsearch.cluster.routing.allocation.decider;\n \n-import com.google.common.collect.ImmutableSet;\n import org.elasticsearch.cluster.routing.RoutingNode;\n import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n import org.elasticsearch.common.inject.Inject;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.node.settings.NodeSettingsService;\n \n import java.util.Set;\n \n@@ -37,59 +35,14 @@ public class AllocationDeciders extends AllocationDecider {\n \n     private final AllocationDecider[] allocations;\n \n-    /**\n-     * Create a new {@link AllocationDeciders} instance. The different deciders\n-     * should be added in order, as looping over them will stop when the first \n-     * return a {@link Decision#THROTTLE} or {@link Decision#NO}. For performance\n-     * reasons, those more likely to return either of these, and those with\n-     * cheap execution should be executed first.\n-     *\n-     * Performance characteristics:\n-     * {@link ConcurrentRebalanceAllocationDecider} numerical comparison of a counter in {@link org.elasticsearch.cluster.routing.RoutingNodes},\n-     * constant performance, likely to be triggered.\n-     * {@link DisableAllocationDecider} lookup of setting. Constant performance, not as\n-     * likely to be triggered.\n-     * {@link ClusterRebalanceAllocationDecider} checks for unassigned primaries, inactive primaries and\n-     * a rebalance already happening in replica set. \n-     * {@link DiskThresholdDecider} one numerical comparison per node in cluster.\n-     * {@link SnapshotInProgressAllocationDecider} status lookup, unlikely.\n-     * {@link FilterAllocationDecider} checks all allocation include/exclude filters in the cluster against the \n-     * node's attributes.\n-     * {@link RebalanceOnlyWhenActiveAllocationDecider} checks if all shards are active.\n-     * {@link ReplicaAfterPrimaryActiveAllocationDecider} finds primary in replica set, checks whether it\n-     * is started.\n-     * {@link ShardsLimitAllocationDecider} loops over shards allocated on a node, filters out non-relocating\n-     * shards of the same index to do a count comparison.\n-     * {@link AwarenessAllocationDecider} loops over all shards in cluster.\n-     * {@link SameShardAllocationDecider} loops over shards on node.\n-     * {@link ThrottlingAllocationDecider} checks primaries initializing (looping over shards on node) for a primary\n-     * to be allocated, for replicas loops over all shards on node.\n-     *\n-     * @param settings            settings to use\n-     * @param nodeSettingsService per-node settings to use\n-     */\n-    public AllocationDeciders(Settings settings, NodeSettingsService nodeSettingsService) {\n-        this(settings, ImmutableSet.<AllocationDecider>builder()\n-                .add(new ConcurrentRebalanceAllocationDecider(settings, nodeSettingsService))\n-                .add(new DisableAllocationDecider(settings, nodeSettingsService))\n-                .add(new ClusterRebalanceAllocationDecider(settings))\n-                .add(new DiskThresholdDecider(settings, nodeSettingsService))\n-                .add(new SnapshotInProgressAllocationDecider(settings))\n-                .add(new FilterAllocationDecider(settings, nodeSettingsService))\n-                .add(new RebalanceOnlyWhenActiveAllocationDecider(settings))\n-                .add(new ReplicaAfterPrimaryActiveAllocationDecider(settings))\n-                .add(new ShardsLimitAllocationDecider(settings))\n-                .add(new AwarenessAllocationDecider(settings, nodeSettingsService))\n-                .add(new SameShardAllocationDecider(settings))\n-                .add(new ThrottlingAllocationDecider(settings, nodeSettingsService))\n-                .build()\n-        );\n+    public AllocationDeciders(Settings settings, AllocationDecider[] allocations) {\n+        super(settings);\n+        this.allocations = allocations;\n     }\n \n     @Inject\n     public AllocationDeciders(Settings settings, Set<AllocationDecider> allocations) {\n-        super(settings);\n-        this.allocations = allocations.toArray(new AllocationDecider[allocations.size()]);\n+        this(settings, allocations.toArray(new AllocationDecider[allocations.size()]));\n     }\n \n     @Override\n@@ -153,4 +106,32 @@ public class AllocationDeciders extends AllocationDecider {\n         }\n         return ret;\n     }\n+\n+    public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {\n+        Decision.Multi ret = new Decision.Multi();\n+        for (AllocationDecider allocationDecider : allocations) {\n+            Decision decision = allocationDecider.canAllocate(shardRouting, allocation);\n+            // short track if a NO is returned.\n+            if (decision == Decision.NO) {\n+                return decision;\n+            } else if (decision != Decision.ALWAYS) {\n+                ret.add(decision);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    public Decision canAllocate(RoutingNode node, RoutingAllocation allocation) {\n+        Decision.Multi ret = new Decision.Multi();\n+        for (AllocationDecider allocationDecider : allocations) {\n+            Decision decision = allocationDecider.canAllocate(node, allocation);\n+            // short track if a NO is returned.\n+            if (decision == Decision.NO) {\n+                return decision;\n+            } else if (decision != Decision.ALWAYS) {\n+                ret.add(decision);\n+            }\n+        }\n+        return ret;\n+    }\n }\ndiff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecidersModule.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecidersModule.java\nindex 999a7392b06..a07198e675a 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecidersModule.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecidersModule.java\n@@ -19,6 +19,7 @@\n \n package org.elasticsearch.cluster.routing.allocation.decider;\n \n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import org.elasticsearch.common.inject.AbstractModule;\n import org.elasticsearch.common.inject.multibindings.Multibinder;\n@@ -51,22 +52,27 @@ public class AllocationDecidersModule extends AbstractModule {\n     @Override\n     protected void configure() {\n         Multibinder<AllocationDecider> allocationMultibinder = Multibinder.newSetBinder(binder(), AllocationDecider.class);\n-        allocationMultibinder.addBinding().to(SameShardAllocationDecider.class);\n-        allocationMultibinder.addBinding().to(FilterAllocationDecider.class);\n-        allocationMultibinder.addBinding().to(ReplicaAfterPrimaryActiveAllocationDecider.class);\n-        allocationMultibinder.addBinding().to(ThrottlingAllocationDecider.class);\n-        allocationMultibinder.addBinding().to(RebalanceOnlyWhenActiveAllocationDecider.class);\n-        allocationMultibinder.addBinding().to(ClusterRebalanceAllocationDecider.class);\n-        allocationMultibinder.addBinding().to(ConcurrentRebalanceAllocationDecider.class);\n-        allocationMultibinder.addBinding().to(DisableAllocationDecider.class);\n-        allocationMultibinder.addBinding().to(AwarenessAllocationDecider.class);\n-        allocationMultibinder.addBinding().to(ShardsLimitAllocationDecider.class);\n-        allocationMultibinder.addBinding().to(DiskThresholdDecider.class);\n-        allocationMultibinder.addBinding().to(SnapshotInProgressAllocationDecider.class);\n+        for (Class<? extends AllocationDecider> deciderClass : DEFAULT_ALLOCATION_DECIDERS) {\n+            allocationMultibinder.addBinding().to(deciderClass);\n+        }\n         for (Class<? extends AllocationDecider> allocation : allocations) {\n             allocationMultibinder.addBinding().to(allocation);\n         }\n \n         bind(AllocationDeciders.class).asEagerSingleton();\n     }\n+\n+    public static final ImmutableSet<Class<? extends AllocationDecider>> DEFAULT_ALLOCATION_DECIDERS = ImmutableSet.<Class<? extends AllocationDecider>>builder().\n+            add(SameShardAllocationDecider.class).\n+            add(FilterAllocationDecider.class).\n+            add(ReplicaAfterPrimaryActiveAllocationDecider.class).\n+            add(ThrottlingAllocationDecider.class).\n+            add(RebalanceOnlyWhenActiveAllocationDecider.class).\n+            add(ClusterRebalanceAllocationDecider.class).\n+            add(ConcurrentRebalanceAllocationDecider.class).\n+            add(DisableAllocationDecider.class).\n+            add(AwarenessAllocationDecider.class).\n+            add(ShardsLimitAllocationDecider.class).\n+            add(DiskThresholdDecider.class).\n+            add(SnapshotInProgressAllocationDecider.class).build();\n }\ndiff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java\nindex 5bcd0d67fd4..7b7b0c9805e 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java\n@@ -110,7 +110,7 @@ public class DiskThresholdDecider extends AllocationDecider {\n     }\n \n     @Inject\n-    protected DiskThresholdDecider(Settings settings, NodeSettingsService nodeSettingsService) {\n+    public DiskThresholdDecider(Settings settings, NodeSettingsService nodeSettingsService) {\n         super(settings);\n         String lowWatermark = settings.get(CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK, \"0.7\");\n         String highWatermark = settings.get(CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK, \"0.85\");\ndiff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ReplicaAfterPrimaryActiveAllocationDecider.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ReplicaAfterPrimaryActiveAllocationDecider.java\nindex dd18e951ae6..f2cfd6f2abc 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ReplicaAfterPrimaryActiveAllocationDecider.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ReplicaAfterPrimaryActiveAllocationDecider.java\n@@ -38,6 +38,10 @@ public class ReplicaAfterPrimaryActiveAllocationDecider extends AllocationDecide\n \n     @Override\n     public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n+        return canAllocate(shardRouting, allocation);\n+    }\n+\n+    public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {\n         if (shardRouting.primary()) {\n             return Decision.YES;\n         }\ndiff --git a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java\nindex 6f051462d90..c9987668072 100644\n--- a/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java\n+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java\n@@ -77,7 +77,7 @@ public class ThrottlingAllocationDecider extends AllocationDecider {\n                 // primary is unassigned, means we are going to do recovery from gateway\n                 // count *just the primary* currently doing recovery on the node and check against concurrent_recoveries\n                 int primariesInRecovery = 0;\n-                for (MutableShardRouting shard : node) {;\n+                for (MutableShardRouting shard : node) {\n                     // when a primary shard is INITIALIZING, it can be because of *initial recovery* or *relocation from another node*\n                     // we only count initial recoveries here, so we need to make sure that relocating node is null\n                     if (shard.state() == ShardRoutingState.INITIALIZING && shard.primary() && shard.relocatingNodeId() == null) {\n@@ -95,13 +95,16 @@ public class ThrottlingAllocationDecider extends AllocationDecider {\n         // either primary or replica doing recovery (from peer shard)\n \n         // count the number of recoveries on the node, its for both target (INITIALIZING) and source (RELOCATING)\n+        return canAllocate(node, allocation);\n+    }\n+\n+    public Decision canAllocate(RoutingNode node, RoutingAllocation allocation) {\n         int currentRecoveries = 0;\n         for (MutableShardRouting shard : node) {\n             if (shard.state() == ShardRoutingState.INITIALIZING || shard.state() == ShardRoutingState.RELOCATING) {\n                 currentRecoveries++;\n             }\n         }\n-\n         if (currentRecoveries >= concurrentRecoveries) {\n             return Decision.THROTTLE;\n         } else {\ndiff --git a/src/test/java/org/elasticsearch/benchmark/cluster/ClusterAllocationRerouteBenchmark.java b/src/test/java/org/elasticsearch/benchmark/cluster/ClusterAllocationRerouteBenchmark.java\nindex 8be139412c7..f97479608f2 100644\n--- a/src/test/java/org/elasticsearch/benchmark/cluster/ClusterAllocationRerouteBenchmark.java\n+++ b/src/test/java/org/elasticsearch/benchmark/cluster/ClusterAllocationRerouteBenchmark.java\n@@ -28,25 +28,27 @@ import org.elasticsearch.cluster.routing.allocation.AllocationService;\n import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n+import org.elasticsearch.common.settings.ImmutableSettings;\n import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n+\n+import java.util.Random;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;\n import static org.elasticsearch.cluster.routing.allocation.RoutingAllocationTests.newNode;\n-import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;\n \n public class ClusterAllocationRerouteBenchmark {\n \n     private static final ESLogger logger = Loggers.getLogger(ClusterAllocationRerouteBenchmark.class);\n \n     public static void main(String[] args) {\n-        final int numberOfRuns = 10;\n+        final int numberOfRuns = 1;\n         final int numIndices = 5 * 365; // five years\n         final int numShards = 6;\n         final int numReplicas = 2;\n         final int numberOfNodes = 30;\n         final int numberOfTags = 2;\n-\n-        AllocationService strategy = new AllocationService(settingsBuilder().build());\n+        AllocationService strategy = ElasticsearchAllocationTestCase.createAllocationService(ImmutableSettings.EMPTY, new Random(1));\n \n         MetaData.Builder mb = MetaData.builder();\n         for (int i = 1; i <= numIndices; i++) {\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/AddIncrementallyTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/AddIncrementallyTests.java\nindex d847505eeb5..3e9bf274fff 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/AddIncrementallyTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/AddIncrementallyTests.java\n@@ -13,7 +13,7 @@ import org.elasticsearch.cluster.routing.allocation.decider.ClusterRebalanceAllo\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n import org.elasticsearch.common.settings.ImmutableSettings;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.hamcrest.Matcher;\n import org.hamcrest.Matchers;\n import org.junit.Test;\n@@ -23,14 +23,14 @@ import static org.elasticsearch.cluster.routing.ShardRoutingState.STARTED;\n import static org.elasticsearch.cluster.routing.allocation.RoutingAllocationTests.newNode;\n import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;\n \n-public class AddIncrementallyTests extends ElasticsearchTestCase {\n+public class AddIncrementallyTests extends ElasticsearchAllocationTestCase {\n     private final ESLogger logger = Loggers.getLogger(AddIncrementallyTests.class);\n \n     @Test\n     public void testAddNodesAndIndices() {\n         ImmutableSettings.Builder settings = settingsBuilder();\n         settings.put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString());\n-        AllocationService service = new AllocationService(settings.build());\n+        AllocationService service = createAllocationService(settings.build());\n \n         ClusterState clusterState = initCluster(service, 1, 3, 3, 1);\n         assertThat(clusterState.routingNodes().node(\"node0\").shardsWithState(STARTED).size(), Matchers.equalTo(9));\n@@ -75,7 +75,7 @@ public class AddIncrementallyTests extends ElasticsearchTestCase {\n         ImmutableSettings.Builder settings = settingsBuilder();\n         settings.put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString())\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 2);\n-        AllocationService service = new AllocationService(settings.build());\n+        AllocationService service = createAllocationService(settings.build());\n \n         ClusterState clusterState = initCluster(service, 1, 3, 3, 1);\n         assertThat(clusterState.routingNodes().node(\"node0\").shardsWithState(STARTED).size(), Matchers.equalTo(9));\n@@ -146,7 +146,7 @@ public class AddIncrementallyTests extends ElasticsearchTestCase {\n         settings.put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString())\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 100)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 100);\n-        AllocationService service = new AllocationService(settings.build());\n+        AllocationService service = createAllocationService(settings.build());\n \n         ClusterState clusterState = initCluster(service, 1, 3, 3, 1);\n         assertThat(clusterState.routingNodes().node(\"node0\").shardsWithState(STARTED).size(), Matchers.equalTo(9));\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/AllocatePostApiFlagTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/AllocatePostApiFlagTests.java\nindex fddd2884072..df7f0999299 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/AllocatePostApiFlagTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/AllocatePostApiFlagTests.java\n@@ -26,7 +26,7 @@ import org.elasticsearch.cluster.node.DiscoveryNodes;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;\n@@ -36,13 +36,13 @@ import static org.hamcrest.Matchers.equalTo;\n \n /**\n  */\n-public class AllocatePostApiFlagTests extends ElasticsearchTestCase {\n+public class AllocatePostApiFlagTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(AllocatePostApiFlagTests.class);\n \n     @Test\n     public void simpleFlagTests() {\n-        AllocationService allocation = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n+        AllocationService allocation = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n \n         logger.info(\"creating an index with 1 shard, no replica\");\n         MetaData metaData = MetaData.builder()\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/AllocationCommandsTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/AllocationCommandsTests.java\nindex bb8b0da5d15..643622384ec 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/AllocationCommandsTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/AllocationCommandsTests.java\n@@ -39,7 +39,7 @@ import org.elasticsearch.common.xcontent.XContentFactory;\n import org.elasticsearch.common.xcontent.XContentParser;\n import org.elasticsearch.common.xcontent.XContentType;\n import org.elasticsearch.index.shard.ShardId;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;\n@@ -51,13 +51,13 @@ import static org.hamcrest.Matchers.equalTo;\n \n /**\n  */\n-public class AllocationCommandsTests extends ElasticsearchTestCase {\n+public class AllocationCommandsTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(AllocationCommandsTests.class);\n \n     @Test\n     public void moveShardCommand() {\n-        AllocationService allocation = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n+        AllocationService allocation = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n \n         logger.info(\"creating an index with 1 shard, no replica\");\n         MetaData metaData = MetaData.builder()\n@@ -101,7 +101,7 @@ public class AllocationCommandsTests extends ElasticsearchTestCase {\n \n     @Test\n     public void allocateCommand() {\n-        AllocationService allocation = new AllocationService(settingsBuilder()\n+        AllocationService allocation = createAllocationService(settingsBuilder()\n                 .put(DisableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_DISABLE_NEW_ALLOCATION, true)\n                 .put(DisableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_DISABLE_ALLOCATION, true)\n                 .build());\n@@ -182,7 +182,7 @@ public class AllocationCommandsTests extends ElasticsearchTestCase {\n \n     @Test\n     public void cancelCommand() {\n-        AllocationService allocation = new AllocationService(settingsBuilder()\n+        AllocationService allocation = createAllocationService(settingsBuilder()\n                 .put(DisableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_DISABLE_NEW_ALLOCATION, true)\n                 .put(DisableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_DISABLE_ALLOCATION, true)\n                 .build());\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/AwarenessAllocationTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/AwarenessAllocationTests.java\nindex 953d7d0b245..9785ae94936 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/AwarenessAllocationTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/AwarenessAllocationTests.java\n@@ -29,7 +29,7 @@ import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.cluster.routing.ShardRoutingState;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n@@ -39,13 +39,13 @@ import static org.hamcrest.Matchers.*;\n \n /**\n  */\n-public class AwarenessAllocationTests extends ElasticsearchTestCase {\n+public class AwarenessAllocationTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(AwarenessAllocationTests.class);\n \n     @Test\n     public void moveShardOnceNewNodeWithAttributeAdded1() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .put(\"cluster.routing.allocation.awareness.attributes\", \"rack_id\")\n@@ -114,7 +114,7 @@ public class AwarenessAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void moveShardOnceNewNodeWithAttributeAdded2() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .put(\"cluster.routing.allocation.awareness.attributes\", \"rack_id\")\n@@ -184,7 +184,7 @@ public class AwarenessAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void moveShardOnceNewNodeWithAttributeAdded3() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n@@ -285,7 +285,7 @@ public class AwarenessAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void moveShardOnceNewNodeWithAttributeAdded4() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n@@ -381,7 +381,7 @@ public class AwarenessAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void moveShardOnceNewNodeWithAttributeAdded5() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .put(\"cluster.routing.allocation.awareness.attributes\", \"rack_id\")\n@@ -460,7 +460,7 @@ public class AwarenessAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void moveShardOnceNewNodeWithAttributeAdded6() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .put(\"cluster.routing.allocation.awareness.attributes\", \"rack_id\")\n@@ -541,7 +541,7 @@ public class AwarenessAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void fullAwareness1() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .put(\"cluster.routing.allocation.awareness.force.rack_id.values\", \"1,2\")\n@@ -609,7 +609,7 @@ public class AwarenessAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void fullAwareness2() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .put(\"cluster.routing.allocation.awareness.force.rack_id.values\", \"1,2\")\n@@ -678,7 +678,7 @@ public class AwarenessAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void fullAwareness3() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n@@ -763,7 +763,7 @@ public class AwarenessAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testUnbalancedZones() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.awareness.force.zone.values\", \"a,b\")\n                 .put(\"cluster.routing.allocation.awareness.attributes\", \"zone\")\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 10)\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/BalanceConfigurationTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/BalanceConfigurationTests.java\nindex c7f1e0a0e7c..97b3f75be33 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/BalanceConfigurationTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/BalanceConfigurationTests.java\n@@ -30,14 +30,13 @@ import org.elasticsearch.cluster.routing.*;\n import org.elasticsearch.cluster.routing.allocation.allocator.BalancedShardsAllocator;\n import org.elasticsearch.cluster.routing.allocation.allocator.ShardsAllocator;\n import org.elasticsearch.cluster.routing.allocation.allocator.ShardsAllocators;\n-import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n import org.elasticsearch.cluster.routing.allocation.decider.ClusterRebalanceAllocationDecider;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n import org.elasticsearch.common.settings.ImmutableSettings;\n import org.elasticsearch.gateway.none.NoneGatewayAllocator;\n import org.elasticsearch.node.settings.NodeSettingsService;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.hamcrest.Matchers;\n import org.junit.Test;\n \n@@ -46,7 +45,7 @@ import static org.elasticsearch.cluster.routing.ShardRoutingState.STARTED;\n import static org.elasticsearch.cluster.routing.allocation.RoutingAllocationTests.newNode;\n import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;\n \n-public class BalanceConfigurationTests extends ElasticsearchTestCase {\n+public class BalanceConfigurationTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(BalanceConfigurationTests.class);\n     // TODO maybe we can randomize these numbers somehow\n@@ -70,7 +69,7 @@ public class BalanceConfigurationTests extends ElasticsearchTestCase {\n         settings.put(BalancedShardsAllocator.SETTING_PRIMARY_BALANCE_FACTOR, primaryBalance);\n         settings.put(BalancedShardsAllocator.SETTING_THRESHOLD, balanceTreshold);\n \n-        AllocationService strategy = new AllocationService(settings.build());\n+        AllocationService strategy = createAllocationService(settings.build());\n \n         ClusterState clusterState = initCluster(strategy);\n         assertIndexBalance(logger, clusterState.getRoutingNodes(), numberOfNodes, numberOfIndices, numberOfReplicas, numberOfShards, balanceTreshold);\n@@ -98,7 +97,7 @@ public class BalanceConfigurationTests extends ElasticsearchTestCase {\n         settings.put(BalancedShardsAllocator.SETTING_PRIMARY_BALANCE_FACTOR, primaryBalance);\n         settings.put(BalancedShardsAllocator.SETTING_THRESHOLD, balanceTreshold);\n \n-        AllocationService strategy = new AllocationService(settings.build());\n+        AllocationService strategy = createAllocationService(settings.build());\n \n         ClusterState clusterState = initCluster(strategy);\n         assertReplicaBalance(logger, clusterState.getRoutingNodes(), numberOfNodes, numberOfIndices, numberOfReplicas, numberOfShards, balanceTreshold);\n@@ -126,7 +125,7 @@ public class BalanceConfigurationTests extends ElasticsearchTestCase {\n         settings.put(BalancedShardsAllocator.SETTING_PRIMARY_BALANCE_FACTOR, primaryBalance);\n         settings.put(BalancedShardsAllocator.SETTING_THRESHOLD, balanceTreshold);\n \n-        AllocationService strategy = new AllocationService(settings.build());\n+        AllocationService strategy = createAllocationService(settings.build());\n \n         ClusterState clusterstate = initCluster(strategy);\n         assertPrimaryBalance(logger, clusterstate.getRoutingNodes(), numberOfNodes, numberOfIndices, numberOfReplicas, numberOfShards, balanceTreshold);\n@@ -352,10 +351,9 @@ public class BalanceConfigurationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testNoRebalanceOnPrimaryOverload() {\n-\n         ImmutableSettings.Builder settings = settingsBuilder();\n-        AllocationService strategy = new AllocationService(settings.build(), new AllocationDeciders(settings.build(),\n-                new NodeSettingsService(ImmutableSettings.Builder.EMPTY_SETTINGS)), new ShardsAllocators(settings.build(),\n+        AllocationService strategy = new AllocationService(settings.build(), randomAllocationDeciders(settings.build(),\n+                new NodeSettingsService(ImmutableSettings.Builder.EMPTY_SETTINGS), getRandom()), new ShardsAllocators(settings.build(),\n                 new NoneGatewayAllocator(), new ShardsAllocator() {\n \n             @Override\n@@ -472,7 +470,7 @@ public class BalanceConfigurationTests extends ElasticsearchTestCase {\n                 assertThat(mutableShardRouting.state(), Matchers.equalTo(ShardRoutingState.INITIALIZING));\n             }\n         }\n-        strategy = new AllocationService(settings.build());\n+        strategy = createAllocationService(settings.build());\n \n         logger.info(\"use the new allocator and check if it moves shards\");\n         routingNodes = clusterState.routingNodes();\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/ClusterRebalanceRoutingTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/ClusterRebalanceRoutingTests.java\nindex 4a7ce42b238..03f4907d7cf 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/ClusterRebalanceRoutingTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/ClusterRebalanceRoutingTests.java\n@@ -28,7 +28,7 @@ import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.cluster.routing.allocation.decider.ClusterRebalanceAllocationDecider;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n@@ -36,13 +36,13 @@ import static org.elasticsearch.cluster.routing.allocation.RoutingAllocationTest\n import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;\n import static org.hamcrest.Matchers.equalTo;\n \n-public class ClusterRebalanceRoutingTests extends ElasticsearchTestCase {\n+public class ClusterRebalanceRoutingTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(ClusterRebalanceRoutingTests.class);\n \n     @Test\n     public void testAlways() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build());\n \n         MetaData metaData = MetaData.builder()\n                 .put(IndexMetaData.builder(\"test1\").numberOfShards(1).numberOfReplicas(1))\n@@ -128,7 +128,7 @@ public class ClusterRebalanceRoutingTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testClusterPrimariesActive1() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE.toString()).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE.toString()).build());\n \n         MetaData metaData = MetaData.builder()\n                 .put(IndexMetaData.builder(\"test1\").numberOfShards(1).numberOfReplicas(1))\n@@ -232,7 +232,7 @@ public class ClusterRebalanceRoutingTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testClusterPrimariesActive2() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE.toString()).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE.toString()).build());\n \n         MetaData metaData = MetaData.builder()\n                 .put(IndexMetaData.builder(\"test1\").numberOfShards(1).numberOfReplicas(1))\n@@ -316,7 +316,7 @@ public class ClusterRebalanceRoutingTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testClusterAllActive1() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.INDICES_ALL_ACTIVE.toString()).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.INDICES_ALL_ACTIVE.toString()).build());\n \n         MetaData metaData = MetaData.builder()\n                 .put(IndexMetaData.builder(\"test1\").numberOfShards(1).numberOfReplicas(1))\n@@ -439,7 +439,7 @@ public class ClusterRebalanceRoutingTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testClusterAllActive2() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.INDICES_ALL_ACTIVE.toString()).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.INDICES_ALL_ACTIVE.toString()).build());\n \n         MetaData metaData = MetaData.builder()\n                 .put(IndexMetaData.builder(\"test1\").numberOfShards(1).numberOfReplicas(1))\n@@ -523,7 +523,7 @@ public class ClusterRebalanceRoutingTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testClusterAllActive3() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.INDICES_ALL_ACTIVE.toString()).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.INDICES_ALL_ACTIVE.toString()).build());\n \n         MetaData metaData = MetaData.builder()\n                 .put(IndexMetaData.builder(\"test1\").numberOfShards(1).numberOfReplicas(1))\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/ConcurrentRebalanceRoutingTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/ConcurrentRebalanceRoutingTests.java\nindex 3eb108ba015..1afa702c1cd 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/ConcurrentRebalanceRoutingTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/ConcurrentRebalanceRoutingTests.java\n@@ -27,7 +27,7 @@ import org.elasticsearch.cluster.routing.RoutingNodes;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n@@ -36,13 +36,13 @@ import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilde\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.nullValue;\n \n-public class ConcurrentRebalanceRoutingTests extends ElasticsearchTestCase {\n+public class ConcurrentRebalanceRoutingTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(ConcurrentRebalanceRoutingTests.class);\n \n     @Test\n     public void testClusterConcurrentRebalance() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", 3)\n                 .build());\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/DeadNodesAllocationTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/DeadNodesAllocationTests.java\nindex 0aafbf3145e..4410382be05 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/DeadNodesAllocationTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/DeadNodesAllocationTests.java\n@@ -28,7 +28,7 @@ import org.elasticsearch.cluster.routing.allocation.command.AllocationCommands;\n import org.elasticsearch.cluster.routing.allocation.command.MoveAllocationCommand;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n@@ -38,13 +38,13 @@ import static org.hamcrest.Matchers.equalTo;\n \n /**\n  */\n-public class DeadNodesAllocationTests extends ElasticsearchTestCase {\n+public class DeadNodesAllocationTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(DeadNodesAllocationTests.class);\n \n     @Test\n     public void simpleDeadNodeOnStartedPrimaryShard() {\n-        AllocationService allocation = new AllocationService(settingsBuilder()\n+        AllocationService allocation = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .build());\n@@ -96,7 +96,7 @@ public class DeadNodesAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void deadNodeWhileRelocatingOnToNode() {\n-        AllocationService allocation = new AllocationService(settingsBuilder()\n+        AllocationService allocation = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .build());\n@@ -171,7 +171,7 @@ public class DeadNodesAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void deadNodeWhileRelocatingOnFromNode() {\n-        AllocationService allocation = new AllocationService(settingsBuilder()\n+        AllocationService allocation = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .build());\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/DisableAllocationTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/DisableAllocationTests.java\nindex 2c6c0d25853..a3121bc9941 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/DisableAllocationTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/DisableAllocationTests.java\n@@ -28,7 +28,7 @@ import org.elasticsearch.cluster.routing.allocation.decider.DisableAllocationDec\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n import org.elasticsearch.common.settings.ImmutableSettings;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;\n@@ -39,13 +39,13 @@ import static org.hamcrest.Matchers.equalTo;\n \n /**\n  */\n-public class DisableAllocationTests extends ElasticsearchTestCase {\n+public class DisableAllocationTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(DisableAllocationTests.class);\n \n     @Test\n     public void testClusterDisableAllocation() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(DisableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_DISABLE_NEW_ALLOCATION, true)\n                 .put(DisableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_DISABLE_ALLOCATION, true)\n                 .build());\n@@ -75,7 +75,7 @@ public class DisableAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testClusterDisableReplicaAllocation() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.disable_replica_allocation\", true)\n                 .build());\n \n@@ -109,7 +109,7 @@ public class DisableAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testIndexDisableAllocation() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .build());\n \n         MetaData metaData = MetaData.builder()\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/ElectReplicaAsPrimaryDuringRelocationTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/ElectReplicaAsPrimaryDuringRelocationTests.java\nindex c82f7efbfa6..1a0c27de5e5 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/ElectReplicaAsPrimaryDuringRelocationTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/ElectReplicaAsPrimaryDuringRelocationTests.java\n@@ -28,7 +28,7 @@ import org.elasticsearch.cluster.routing.RoutingNodes;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;\n@@ -40,13 +40,13 @@ import static org.hamcrest.Matchers.equalTo;\n /**\n  *\n  */\n-public class ElectReplicaAsPrimaryDuringRelocationTests extends ElasticsearchTestCase {\n+public class ElectReplicaAsPrimaryDuringRelocationTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(ElectReplicaAsPrimaryDuringRelocationTests.class);\n \n     @Test\n     public void testElectReplicaAsPrimaryDuringRelocation() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n \n         logger.info(\"Building initial routing table\");\n \ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/FailedNodeRoutingTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/FailedNodeRoutingTests.java\nindex cc265db2255..b92bb7ead60 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/FailedNodeRoutingTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/FailedNodeRoutingTests.java\n@@ -29,7 +29,7 @@ import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.cluster.routing.allocation.decider.ClusterRebalanceAllocationDecider;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;\n@@ -38,13 +38,13 @@ import static org.elasticsearch.cluster.routing.allocation.RoutingAllocationTest\n import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;\n import static org.hamcrest.Matchers.equalTo;\n \n-public class FailedNodeRoutingTests extends ElasticsearchTestCase {\n+public class FailedNodeRoutingTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(FailedNodeRoutingTests.class);\n \n     @Test\n     public void simpleFailedNodeTest() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build());\n \n         MetaData metaData = MetaData.builder()\n                 .put(IndexMetaData.builder(\"test1\").numberOfShards(1).numberOfReplicas(1))\n@@ -104,7 +104,7 @@ public class FailedNodeRoutingTests extends ElasticsearchTestCase {\n \n     @Test\n     public void simpleFailedNodeTestNoReassign() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build());\n \n         MetaData metaData = MetaData.builder()\n                 .put(IndexMetaData.builder(\"test1\").numberOfShards(1).numberOfReplicas(1))\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/FailedShardsRoutingTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/FailedShardsRoutingTests.java\nindex 639a974e8e1..1295dc68501 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/FailedShardsRoutingTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/FailedShardsRoutingTests.java\n@@ -31,7 +31,7 @@ import org.elasticsearch.cluster.routing.allocation.command.AllocationCommands;\n import org.elasticsearch.cluster.routing.allocation.command.MoveAllocationCommand;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n@@ -42,13 +42,13 @@ import static org.hamcrest.Matchers.*;\n /**\n  *\n  */\n-public class FailedShardsRoutingTests extends ElasticsearchTestCase {\n+public class FailedShardsRoutingTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(FailedShardsRoutingTests.class);\n \n     @Test\n     public void testFailedShardPrimaryRelocatingToAndFrom() {\n-        AllocationService allocation = new AllocationService(settingsBuilder()\n+        AllocationService allocation = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .build());\n@@ -137,7 +137,7 @@ public class FailedShardsRoutingTests extends ElasticsearchTestCase {\n \n     @Test\n     public void failPrimaryStartedCheckReplicaElected() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .build());\n@@ -219,7 +219,7 @@ public class FailedShardsRoutingTests extends ElasticsearchTestCase {\n \n     @Test\n     public void firstAllocationFailureSingleNode() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .build());\n@@ -276,7 +276,7 @@ public class FailedShardsRoutingTests extends ElasticsearchTestCase {\n \n     @Test\n     public void firstAllocationFailureTwoNodes() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .build());\n@@ -298,6 +298,7 @@ public class FailedShardsRoutingTests extends ElasticsearchTestCase {\n         RoutingTable prevRoutingTable = routingTable;\n         routingTable = strategy.reroute(clusterState).routingTable();\n         clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n+        final String nodeHoldingPrimary = routingTable.index(\"test\").shard(0).primaryShard().currentNodeId();\n \n         assertThat(prevRoutingTable != routingTable, equalTo(true));\n         assertThat(routingTable.index(\"test\").shards().size(), equalTo(1));\n@@ -305,14 +306,14 @@ public class FailedShardsRoutingTests extends ElasticsearchTestCase {\n             assertThat(routingTable.index(\"test\").shard(i).size(), equalTo(2));\n             assertThat(routingTable.index(\"test\").shard(i).shards().size(), equalTo(2));\n             assertThat(routingTable.index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n-            assertThat(routingTable.index(\"test\").shard(i).primaryShard().currentNodeId(), equalTo(\"node1\"));\n+            assertThat(routingTable.index(\"test\").shard(i).primaryShard().currentNodeId(), equalTo(nodeHoldingPrimary));\n             assertThat(routingTable.index(\"test\").shard(i).replicaShards().size(), equalTo(1));\n             assertThat(routingTable.index(\"test\").shard(i).replicaShards().get(0).state(), equalTo(UNASSIGNED));\n         }\n \n         logger.info(\"fail the first shard, will start INITIALIZING on the second node\");\n         prevRoutingTable = routingTable;\n-        routingTable = strategy.applyFailedShard(clusterState, new ImmutableShardRouting(\"test\", 0, \"node1\", true, INITIALIZING, 0)).routingTable();\n+        routingTable = strategy.applyFailedShard(clusterState, new ImmutableShardRouting(\"test\", 0, nodeHoldingPrimary, true, INITIALIZING, 0)).routingTable();\n         clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n         RoutingNodes routingNodes = clusterState.routingNodes();\n \n@@ -322,18 +323,18 @@ public class FailedShardsRoutingTests extends ElasticsearchTestCase {\n             assertThat(routingTable.index(\"test\").shard(i).size(), equalTo(2));\n             assertThat(routingTable.index(\"test\").shard(i).shards().size(), equalTo(2));\n             assertThat(routingTable.index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n-            assertThat(routingTable.index(\"test\").shard(i).primaryShard().currentNodeId(), equalTo(\"node2\"));\n+            assertThat(routingTable.index(\"test\").shard(i).primaryShard().currentNodeId(), not(equalTo(nodeHoldingPrimary)));\n             assertThat(routingTable.index(\"test\").shard(i).replicaShards().size(), equalTo(1));\n             assertThat(routingTable.index(\"test\").shard(i).replicaShards().get(0).state(), equalTo(UNASSIGNED));\n         }\n \n         logger.info(\"fail the shard again, see that nothing happens\");\n-        assertThat(strategy.applyFailedShard(clusterState, new ImmutableShardRouting(\"test\", 0, \"node1\", true, INITIALIZING, 0)).changed(), equalTo(false));\n+        assertThat(strategy.applyFailedShard(clusterState, new ImmutableShardRouting(\"test\", 0, nodeHoldingPrimary, true, INITIALIZING, 0)).changed(), equalTo(false));\n     }\n \n     @Test\n     public void rebalanceFailure() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .build());\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/FilterRoutingTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/FilterRoutingTests.java\nindex b2229354d3b..0989b2b09f3 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/FilterRoutingTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/FilterRoutingTests.java\n@@ -29,7 +29,7 @@ import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.cluster.routing.ShardRoutingState;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.hamcrest.Matchers;\n import org.junit.Test;\n \n@@ -42,13 +42,13 @@ import static org.hamcrest.Matchers.equalTo;\n \n /**\n  */\n-public class FilterRoutingTests extends ElasticsearchTestCase {\n+public class FilterRoutingTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(FilterRoutingTests.class);\n \n     @Test\n     public void testClusterFilters() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.include.tag1\", \"value1,value2\")\n                 .put(\"cluster.routing.allocation.exclude.tag1\", \"value3,value4\")\n                 .build());\n@@ -94,7 +94,7 @@ public class FilterRoutingTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testIndexFilters() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .build());\n \n         logger.info(\"Building initial routing table\");\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/IndexBalanceTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/IndexBalanceTests.java\nindex d3aa86266cd..dacc28f33a4 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/IndexBalanceTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/IndexBalanceTests.java\n@@ -28,7 +28,7 @@ import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n import org.elasticsearch.common.settings.ImmutableSettings;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n@@ -40,13 +40,13 @@ import static org.hamcrest.Matchers.nullValue;\n /**\n  *\n  */\n-public class IndexBalanceTests extends ElasticsearchTestCase {\n+public class IndexBalanceTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(IndexBalanceTests.class);\n \n     @Test\n     public void testBalanceAllNodesStarted() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n@@ -177,7 +177,7 @@ public class IndexBalanceTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testBalanceIncrementallyStartNodes() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n@@ -340,7 +340,7 @@ public class IndexBalanceTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testBalanceAllNodesStartedAddIndex() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/PreferLocalPrimariesToRelocatingPrimariesTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/PreferLocalPrimariesToRelocatingPrimariesTests.java\nindex 206fa7bdeae..82fc1e58a06 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/PreferLocalPrimariesToRelocatingPrimariesTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/PreferLocalPrimariesToRelocatingPrimariesTests.java\n@@ -25,7 +25,7 @@ import org.elasticsearch.cluster.metadata.MetaData;\n import org.elasticsearch.cluster.node.DiscoveryNodes;\n import org.elasticsearch.cluster.routing.MutableShardRouting;\n import org.elasticsearch.cluster.routing.RoutingTable;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n@@ -36,7 +36,7 @@ import static org.hamcrest.Matchers.equalTo;\n \n /**\n  */\n-public class PreferLocalPrimariesToRelocatingPrimariesTests extends ElasticsearchTestCase {\n+public class PreferLocalPrimariesToRelocatingPrimariesTests extends ElasticsearchAllocationTestCase {\n     @Test\n     public void testPreferLocalPrimaryAllocationOverFiltered() {\n         int concurrentRecoveries = randomIntBetween(1, 10);\n@@ -45,7 +45,7 @@ public class PreferLocalPrimariesToRelocatingPrimariesTests extends Elasticsearc\n         int totalNumberOfShards = numberOfShards * 2;\n \n         logger.info(\"create an allocation with [{}] initial primary recoveries and [{}] concurrent recoveries\", primaryRecoveries, concurrentRecoveries);\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", concurrentRecoveries)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", primaryRecoveries)\n                 .build());\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/PreferPrimaryAllocationTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/PreferPrimaryAllocationTests.java\nindex 36a20bc3f0f..87be5458997 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/PreferPrimaryAllocationTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/PreferPrimaryAllocationTests.java\n@@ -26,7 +26,7 @@ import org.elasticsearch.cluster.node.DiscoveryNodes;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;\n@@ -36,14 +36,14 @@ import static org.hamcrest.Matchers.equalTo;\n \n /**\n  */\n-public class PreferPrimaryAllocationTests extends ElasticsearchTestCase {\n+public class PreferPrimaryAllocationTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(PreferPrimaryAllocationTests.class);\n \n     @Test\n     public void testPreferPrimaryAllocationOverReplicas() {\n         logger.info(\"create an allocation with 1 initial recoveries\");\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 1)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 1)\n                 .build());\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/PrimaryElectionRoutingTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/PrimaryElectionRoutingTests.java\nindex e10a44c1818..edf53c2a763 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/PrimaryElectionRoutingTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/PrimaryElectionRoutingTests.java\n@@ -27,7 +27,7 @@ import org.elasticsearch.cluster.routing.RoutingNodes;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;\n@@ -40,13 +40,13 @@ import static org.hamcrest.Matchers.nullValue;\n /**\n  *\n  */\n-public class PrimaryElectionRoutingTests extends ElasticsearchTestCase {\n+public class PrimaryElectionRoutingTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(PrimaryElectionRoutingTests.class);\n \n     @Test\n     public void testBackupElectionToPrimaryWhenPrimaryCanBeAllocatedToAnotherNode() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n \n         logger.info(\"Building initial routing table\");\n \n@@ -97,7 +97,7 @@ public class PrimaryElectionRoutingTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testRemovingInitializingReplicasIfPrimariesFails() {\n-        AllocationService allocation = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n+        AllocationService allocation = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n \n         logger.info(\"Building initial routing table\");\n \ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/PrimaryNotRelocatedWhileBeingRecoveredTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/PrimaryNotRelocatedWhileBeingRecoveredTests.java\nindex bbb83e78750..ad5d5a247ec 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/PrimaryNotRelocatedWhileBeingRecoveredTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/PrimaryNotRelocatedWhileBeingRecoveredTests.java\n@@ -27,7 +27,7 @@ import org.elasticsearch.cluster.routing.RoutingNodes;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;\n@@ -39,14 +39,14 @@ import static org.hamcrest.Matchers.equalTo;\n /**\n  *\n  */\n-public class PrimaryNotRelocatedWhileBeingRecoveredTests extends ElasticsearchTestCase {\n+public class PrimaryNotRelocatedWhileBeingRecoveredTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(PrimaryNotRelocatedWhileBeingRecoveredTests.class);\n \n \n     @Test\n     public void testPrimaryNotRelocatedWhileBeingRecoveredFrom() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 10)\n                 .build());\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/RandomAllocationDeciderTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/RandomAllocationDeciderTests.java\nindex ed65dc11c92..1deb7433633 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/RandomAllocationDeciderTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/RandomAllocationDeciderTests.java\n@@ -35,7 +35,7 @@ import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n import org.elasticsearch.cluster.routing.allocation.decider.SameShardAllocationDecider;\n import org.elasticsearch.common.settings.ImmutableSettings;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.hamcrest.Matchers;\n import org.junit.Test;\n \n@@ -48,7 +48,7 @@ import static org.elasticsearch.cluster.routing.allocation.RoutingAllocationTest\n import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;\n import static org.hamcrest.Matchers.equalTo;\n \n-public class RandomAllocationDeciderTests extends ElasticsearchTestCase {\n+public class RandomAllocationDeciderTests extends ElasticsearchAllocationTestCase {\n \n     /* This test will make random allocation decision on a growing and shrinking\n      * cluster leading to a random distribution of the shards. After a certain\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/RebalanceAfterActiveTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/RebalanceAfterActiveTests.java\nindex 9021fb6abcb..a58353f2158 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/RebalanceAfterActiveTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/RebalanceAfterActiveTests.java\n@@ -28,7 +28,7 @@ import org.elasticsearch.cluster.routing.RoutingNodes;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n@@ -40,13 +40,13 @@ import static org.hamcrest.Matchers.nullValue;\n /**\n  *\n  */\n-public class RebalanceAfterActiveTests extends ElasticsearchTestCase {\n+public class RebalanceAfterActiveTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(RebalanceAfterActiveTests.class);\n \n     @Test\n     public void testRebalanceOnlyAfterAllShardsAreActive() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/ReplicaAllocatedAfterPrimaryTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/ReplicaAllocatedAfterPrimaryTests.java\nindex ed6d3755b8f..f6e40fe3148 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/ReplicaAllocatedAfterPrimaryTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/ReplicaAllocatedAfterPrimaryTests.java\n@@ -27,25 +27,26 @@ import org.elasticsearch.cluster.routing.RoutingNodes;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n import static org.elasticsearch.cluster.routing.allocation.RoutingAllocationTests.newNode;\n import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;\n import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.not;\n import static org.hamcrest.Matchers.nullValue;\n \n /**\n  *\n  */\n-public class ReplicaAllocatedAfterPrimaryTests extends ElasticsearchTestCase {\n+public class ReplicaAllocatedAfterPrimaryTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(ReplicaAllocatedAfterPrimaryTests.class);\n \n     @Test\n     public void testBackupIsAllocatedAfterPrimary() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n \n         logger.info(\"Building initial routing table\");\n \n@@ -73,13 +74,15 @@ public class ReplicaAllocatedAfterPrimaryTests extends ElasticsearchTestCase {\n         RoutingTable prevRoutingTable = routingTable;\n         routingTable = strategy.reroute(clusterState).routingTable();\n         clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n+        final String nodeHoldingPrimary = routingTable.index(\"test\").shard(0).primaryShard().currentNodeId();\n+\n \n         assertThat(prevRoutingTable != routingTable, equalTo(true));\n         assertThat(routingTable.index(\"test\").shards().size(), equalTo(1));\n         assertThat(routingTable.index(\"test\").shard(0).size(), equalTo(2));\n         assertThat(routingTable.index(\"test\").shard(0).shards().size(), equalTo(2));\n         assertThat(routingTable.index(\"test\").shard(0).primaryShard().state(), equalTo(INITIALIZING));\n-        assertThat(routingTable.index(\"test\").shard(0).primaryShard().currentNodeId(), equalTo(\"node1\"));\n+        assertThat(routingTable.index(\"test\").shard(0).primaryShard().currentNodeId(), equalTo(nodeHoldingPrimary));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().size(), equalTo(1));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).state(), equalTo(UNASSIGNED));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId(), nullValue());\n@@ -87,18 +90,19 @@ public class ReplicaAllocatedAfterPrimaryTests extends ElasticsearchTestCase {\n         logger.info(\"Start all the primary shards\");\n         RoutingNodes routingNodes = clusterState.routingNodes();\n         prevRoutingTable = routingTable;\n-        routingTable = strategy.applyStartedShards(clusterState, routingNodes.node(\"node1\").shardsWithState(INITIALIZING)).routingTable();\n+        routingTable = strategy.applyStartedShards(clusterState, routingNodes.node(nodeHoldingPrimary).shardsWithState(INITIALIZING)).routingTable();\n         clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n-\n+        final String nodeHoldingReplica = routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId();\n+        assertThat(nodeHoldingPrimary, not(equalTo(nodeHoldingReplica)));\n         assertThat(prevRoutingTable != routingTable, equalTo(true));\n         assertThat(routingTable.index(\"test\").shards().size(), equalTo(1));\n         assertThat(routingTable.index(\"test\").shard(0).size(), equalTo(2));\n         assertThat(routingTable.index(\"test\").shard(0).shards().size(), equalTo(2));\n         assertThat(routingTable.index(\"test\").shard(0).primaryShard().state(), equalTo(STARTED));\n-        assertThat(routingTable.index(\"test\").shard(0).primaryShard().currentNodeId(), equalTo(\"node1\"));\n+        assertThat(routingTable.index(\"test\").shard(0).primaryShard().currentNodeId(), equalTo(nodeHoldingPrimary));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().size(), equalTo(1));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).state(), equalTo(INITIALIZING));\n-        assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId(), equalTo(\"node2\"));\n+        assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId(), equalTo(nodeHoldingReplica));\n \n     }\n }\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocationTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocationTests.java\nindex f972a39dc95..dd9cbc1d3b5 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocationTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocationTests.java\n@@ -26,7 +26,7 @@ import org.elasticsearch.cluster.routing.MutableShardRouting;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.transport.DummyTransportAddress;\n import org.elasticsearch.common.transport.TransportAddress;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Ignore;\n \n import java.util.List;\n@@ -36,7 +36,7 @@ import static com.google.common.collect.Lists.newArrayList;\n import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;\n \n @Ignore(\"Not a test\")\n-public class RoutingAllocationTests extends ElasticsearchTestCase {\n+public class RoutingAllocationTests extends ElasticsearchAllocationTestCase {\n \n     public static DiscoveryNode newNode(String nodeId) {\n         return new DiscoveryNode(nodeId, DummyTransportAddress.INSTANCE, Version.CURRENT);\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/RoutingNodesIntegrityTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/RoutingNodesIntegrityTests.java\nindex 40c7af27447..9a619f15e0a 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/RoutingNodesIntegrityTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/RoutingNodesIntegrityTests.java\n@@ -29,7 +29,7 @@ import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n import org.elasticsearch.common.settings.ImmutableSettings;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;\n@@ -41,13 +41,13 @@ import static org.hamcrest.Matchers.equalTo;\n /**\n  *\n  */\n-public class RoutingNodesIntegrityTests extends ElasticsearchTestCase {\n+public class RoutingNodesIntegrityTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(IndexBalanceTests.class);\n \n     @Test\n     public void testBalanceAllNodesStarted() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n@@ -120,7 +120,7 @@ public class RoutingNodesIntegrityTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testBalanceIncrementallyStartNodes() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n@@ -213,7 +213,7 @@ public class RoutingNodesIntegrityTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testBalanceAllNodesStartedAddIndex() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 1)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 3)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/SameShardRoutingTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/SameShardRoutingTests.java\nindex e477cc4cded..8fce31ed215 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/SameShardRoutingTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/SameShardRoutingTests.java\n@@ -11,7 +11,7 @@ import org.elasticsearch.cluster.routing.allocation.decider.SameShardAllocationD\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n import org.elasticsearch.common.transport.InetSocketTransportAddress;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.elasticsearch.test.junit.annotations.TestLogging;\n import org.junit.Test;\n \n@@ -23,14 +23,14 @@ import static org.hamcrest.Matchers.equalTo;\n \n /**\n  */\n-public class SameShardRoutingTests extends ElasticsearchTestCase {\n+public class SameShardRoutingTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(SameShardRoutingTests.class);\n \n     @Test\n     @TestLogging(\"cluster.routing.allocation:TRACE\")\n     public void sameHost() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(SameShardAllocationDecider.SAME_HOST_SETTING, true).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(SameShardAllocationDecider.SAME_HOST_SETTING, true).build());\n \n         MetaData metaData = MetaData.builder()\n                 .put(IndexMetaData.builder(\"test\").numberOfShards(2).numberOfReplicas(1))\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/ShardVersioningTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/ShardVersioningTests.java\nindex ba673dfbee9..52b77893175 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/ShardVersioningTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/ShardVersioningTests.java\n@@ -28,7 +28,7 @@ import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.cluster.routing.allocation.decider.ClusterRebalanceAllocationDecider;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n@@ -36,13 +36,13 @@ import static org.elasticsearch.cluster.routing.allocation.RoutingAllocationTest\n import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;\n import static org.hamcrest.Matchers.equalTo;\n \n-public class ShardVersioningTests extends ElasticsearchTestCase {\n+public class ShardVersioningTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(ShardVersioningTests.class);\n \n     @Test\n     public void simple() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.allow_rebalance\", ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build());\n \n         MetaData metaData = MetaData.builder()\n                 .put(IndexMetaData.builder(\"test1\").numberOfShards(1).numberOfReplicas(1))\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/ShardsLimitAllocationTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/ShardsLimitAllocationTests.java\nindex 597f76106c2..fb4770c9d9e 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/ShardsLimitAllocationTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/ShardsLimitAllocationTests.java\n@@ -31,7 +31,7 @@ import org.elasticsearch.cluster.routing.allocation.decider.ShardsLimitAllocatio\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n import org.elasticsearch.common.settings.ImmutableSettings;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n@@ -42,13 +42,13 @@ import static org.hamcrest.Matchers.equalTo;\n \n /**\n  */\n-public class ShardsLimitAllocationTests extends ElasticsearchTestCase {\n+public class ShardsLimitAllocationTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(ShardsLimitAllocationTests.class);\n \n     @Test\n     public void indexLevelShardsLimitAllocate() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n \n         logger.info(\"Building initial routing table\");\n \n@@ -91,7 +91,7 @@ public class ShardsLimitAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void indexLevelShardsLimitRemain() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/SingleShardNoReplicasRoutingTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/SingleShardNoReplicasRoutingTests.java\nindex 4855df45553..5da6d06b652 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/SingleShardNoReplicasRoutingTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/SingleShardNoReplicasRoutingTests.java\n@@ -27,7 +27,7 @@ import org.elasticsearch.cluster.node.DiscoveryNodes;\n import org.elasticsearch.cluster.routing.*;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import java.util.List;\n@@ -44,13 +44,13 @@ import static org.hamcrest.Matchers.*;\n /**\n  *\n  */\n-public class SingleShardNoReplicasRoutingTests extends ElasticsearchTestCase {\n+public class SingleShardNoReplicasRoutingTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(SingleShardNoReplicasRoutingTests.class);\n \n     @Test\n     public void testSingleIndexStartedShard() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n \n         logger.info(\"Building initial routing table\");\n \n@@ -152,7 +152,7 @@ public class SingleShardNoReplicasRoutingTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testSingleIndexShardFailed() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n \n         logger.info(\"Building initial routing table\");\n \n@@ -202,7 +202,7 @@ public class SingleShardNoReplicasRoutingTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testMultiIndexEvenDistribution() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\n@@ -315,7 +315,7 @@ public class SingleShardNoReplicasRoutingTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testMultiIndexUnevenNodes() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .put(\"cluster.routing.allocation.cluster_concurrent_rebalance\", -1)\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/SingleShardOneReplicaRoutingTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/SingleShardOneReplicaRoutingTests.java\nindex 1eb5ec56424..bc9162058c2 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/SingleShardOneReplicaRoutingTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/SingleShardOneReplicaRoutingTests.java\n@@ -27,7 +27,7 @@ import org.elasticsearch.cluster.routing.RoutingNodes;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n@@ -39,13 +39,13 @@ import static org.hamcrest.Matchers.nullValue;\n /**\n  *\n  */\n-public class SingleShardOneReplicaRoutingTests extends ElasticsearchTestCase {\n+public class SingleShardOneReplicaRoutingTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(SingleShardOneReplicaRoutingTests.class);\n \n     @Test\n     public void testSingleIndexFirstStartPrimaryThenBackups() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n \n         logger.info(\"Building initial routing table\");\n \ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/TenShardsOneReplicaRoutingTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/TenShardsOneReplicaRoutingTests.java\nindex 0e61d336586..b1ec6e0a154 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/TenShardsOneReplicaRoutingTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/TenShardsOneReplicaRoutingTests.java\n@@ -27,7 +27,7 @@ import org.elasticsearch.cluster.routing.RoutingNodes;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n@@ -38,13 +38,13 @@ import static org.hamcrest.Matchers.*;\n /**\n  *\n  */\n-public class TenShardsOneReplicaRoutingTests extends ElasticsearchTestCase {\n+public class TenShardsOneReplicaRoutingTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(TenShardsOneReplicaRoutingTests.class);\n \n     @Test\n     public void testSingleIndexFirstStartPrimaryThenBackups() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/ThrottlingAllocationTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/ThrottlingAllocationTests.java\nindex da89e111da4..38adb3a786f 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/ThrottlingAllocationTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/ThrottlingAllocationTests.java\n@@ -26,7 +26,7 @@ import org.elasticsearch.cluster.node.DiscoveryNodes;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n@@ -37,13 +37,13 @@ import static org.hamcrest.Matchers.equalTo;\n /**\n  *\n  */\n-public class ThrottlingAllocationTests extends ElasticsearchTestCase {\n+public class ThrottlingAllocationTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(ThrottlingAllocationTests.class);\n \n     @Test\n     public void testPrimaryRecoveryThrottling() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.node_concurrent_recoveries\", 3)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 3)\n                 .build());\n@@ -104,7 +104,7 @@ public class ThrottlingAllocationTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testReplicaAndPrimaryRecoveryThrottling() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 3)\n                 .put(\"cluster.routing.allocation.node_initial_primaries_recoveries\", 3)\n                 .build());\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/UpdateNumberOfReplicasTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/UpdateNumberOfReplicasTests.java\nindex 8ba7edbe560..00482dfcc8a 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/UpdateNumberOfReplicasTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/UpdateNumberOfReplicasTests.java\n@@ -8,7 +8,7 @@ import org.elasticsearch.cluster.routing.RoutingNodes;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.*;\n@@ -19,13 +19,13 @@ import static org.hamcrest.Matchers.*;\n /**\n  *\n  */\n-public class UpdateNumberOfReplicasTests extends ElasticsearchTestCase {\n+public class UpdateNumberOfReplicasTests extends ElasticsearchAllocationTestCase {\n \n     private final ESLogger logger = Loggers.getLogger(UpdateNumberOfReplicasTests.class);\n \n     @Test\n     public void testUpdateNumberOfReplicas() {\n-        AllocationService strategy = new AllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n+        AllocationService strategy = createAllocationService(settingsBuilder().put(\"cluster.routing.allocation.concurrent_recoveries\", 10).build());\n \n         logger.info(\"Building initial routing table\");\n \n@@ -58,7 +58,7 @@ public class UpdateNumberOfReplicasTests extends ElasticsearchTestCase {\n         logger.info(\"Start all the primary shards\");\n         RoutingNodes routingNodes = clusterState.routingNodes();\n         prevRoutingTable = routingTable;\n-        routingTable = strategy.applyStartedShards(clusterState, routingNodes.node(\"node1\").shardsWithState(INITIALIZING)).routingTable();\n+        routingTable = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(INITIALIZING)).routingTable();\n         clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n \n         logger.info(\"Start all the replica shards\");\n@@ -66,16 +66,19 @@ public class UpdateNumberOfReplicasTests extends ElasticsearchTestCase {\n         prevRoutingTable = routingTable;\n         routingTable = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(INITIALIZING)).routingTable();\n         clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n-\n+        final String nodeHoldingPrimary = routingTable.index(\"test\").shard(0).primaryShard().currentNodeId();\n+        final String nodeHoldingReplica = routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId();\n+        assertThat(nodeHoldingPrimary, not(equalTo(nodeHoldingReplica)));\n         assertThat(prevRoutingTable != routingTable, equalTo(true));\n         assertThat(routingTable.index(\"test\").shards().size(), equalTo(1));\n         assertThat(routingTable.index(\"test\").shard(0).size(), equalTo(2));\n         assertThat(routingTable.index(\"test\").shard(0).shards().size(), equalTo(2));\n         assertThat(routingTable.index(\"test\").shard(0).primaryShard().state(), equalTo(STARTED));\n-        assertThat(routingTable.index(\"test\").shard(0).primaryShard().currentNodeId(), equalTo(\"node1\"));\n+        assertThat(routingTable.index(\"test\").shard(0).primaryShard().currentNodeId(), equalTo(nodeHoldingPrimary));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().size(), equalTo(1));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).state(), equalTo(STARTED));\n-        assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId(), equalTo(\"node2\"));\n+        assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId(), equalTo(nodeHoldingReplica));\n+\n \n         logger.info(\"add another replica\");\n         routingNodes = clusterState.routingNodes();\n@@ -90,10 +93,10 @@ public class UpdateNumberOfReplicasTests extends ElasticsearchTestCase {\n         assertThat(routingTable.index(\"test\").shards().size(), equalTo(1));\n         assertThat(routingTable.index(\"test\").shard(0).size(), equalTo(3));\n         assertThat(routingTable.index(\"test\").shard(0).primaryShard().state(), equalTo(STARTED));\n-        assertThat(routingTable.index(\"test\").shard(0).primaryShard().currentNodeId(), equalTo(\"node1\"));\n+        assertThat(routingTable.index(\"test\").shard(0).primaryShard().currentNodeId(), equalTo(nodeHoldingPrimary));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().size(), equalTo(2));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).state(), equalTo(STARTED));\n-        assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId(), equalTo(\"node2\"));\n+        assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId(), equalTo(nodeHoldingReplica));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(1).state(), equalTo(UNASSIGNED));\n \n         logger.info(\"Add another node and start the added replica\");\n@@ -106,10 +109,10 @@ public class UpdateNumberOfReplicasTests extends ElasticsearchTestCase {\n         assertThat(routingTable.index(\"test\").shards().size(), equalTo(1));\n         assertThat(routingTable.index(\"test\").shard(0).size(), equalTo(3));\n         assertThat(routingTable.index(\"test\").shard(0).primaryShard().state(), equalTo(STARTED));\n-        assertThat(routingTable.index(\"test\").shard(0).primaryShard().currentNodeId(), equalTo(\"node1\"));\n+        assertThat(routingTable.index(\"test\").shard(0).primaryShard().currentNodeId(), equalTo(nodeHoldingPrimary));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().size(), equalTo(2));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).state(), equalTo(STARTED));\n-        assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId(), equalTo(\"node2\"));\n+        assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId(), equalTo(nodeHoldingReplica));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(1).state(), equalTo(INITIALIZING));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(1).currentNodeId(), equalTo(\"node3\"));\n \n@@ -122,10 +125,10 @@ public class UpdateNumberOfReplicasTests extends ElasticsearchTestCase {\n         assertThat(routingTable.index(\"test\").shards().size(), equalTo(1));\n         assertThat(routingTable.index(\"test\").shard(0).size(), equalTo(3));\n         assertThat(routingTable.index(\"test\").shard(0).primaryShard().state(), equalTo(STARTED));\n-        assertThat(routingTable.index(\"test\").shard(0).primaryShard().currentNodeId(), equalTo(\"node1\"));\n+        assertThat(routingTable.index(\"test\").shard(0).primaryShard().currentNodeId(), equalTo(nodeHoldingPrimary));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().size(), equalTo(2));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).state(), equalTo(STARTED));\n-        assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId(), equalTo(\"node2\"));\n+        assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId(), equalTo(nodeHoldingReplica));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(1).state(), equalTo(STARTED));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(1).currentNodeId(), equalTo(\"node3\"));\n \n@@ -142,10 +145,10 @@ public class UpdateNumberOfReplicasTests extends ElasticsearchTestCase {\n         assertThat(routingTable.index(\"test\").shards().size(), equalTo(1));\n         assertThat(routingTable.index(\"test\").shard(0).size(), equalTo(2));\n         assertThat(routingTable.index(\"test\").shard(0).primaryShard().state(), equalTo(STARTED));\n-        assertThat(routingTable.index(\"test\").shard(0).primaryShard().currentNodeId(), equalTo(\"node1\"));\n+        assertThat(routingTable.index(\"test\").shard(0).primaryShard().currentNodeId(), equalTo(nodeHoldingPrimary));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().size(), equalTo(1));\n         assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).state(), equalTo(STARTED));\n-        assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId(), anyOf(equalTo(\"node2\"), equalTo(\"node3\")));\n+        assertThat(routingTable.index(\"test\").shard(0).replicaShards().get(0).currentNodeId(), anyOf(equalTo(nodeHoldingReplica), equalTo(\"node3\")));\n \n         logger.info(\"do a reroute, should remain the same\");\n         prevRoutingTable = routingTable;\ndiff --git a/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderTests.java b/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderTests.java\nindex 50b3677dd79..05071bda4f8 100644\n--- a/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderTests.java\n@@ -33,7 +33,7 @@ import org.elasticsearch.cluster.routing.allocation.AllocationService;\n import org.elasticsearch.cluster.routing.allocation.allocator.ShardsAllocators;\n import org.elasticsearch.common.settings.ImmutableSettings;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import java.util.Arrays;\n@@ -46,7 +46,7 @@ import static org.elasticsearch.cluster.routing.allocation.RoutingAllocationTest\n import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;\n import static org.hamcrest.Matchers.equalTo;\n \n-public class DiskThresholdDeciderTests extends ElasticsearchTestCase {\n+public class DiskThresholdDeciderTests extends ElasticsearchAllocationTestCase {\n \n     @Test\n     public void diskThresholdTest() {\ndiff --git a/src/test/java/org/elasticsearch/cluster/serialization/ClusterSerializationTests.java b/src/test/java/org/elasticsearch/cluster/serialization/ClusterSerializationTests.java\nindex 9e9fde6d683..abda107860b 100644\n--- a/src/test/java/org/elasticsearch/cluster/serialization/ClusterSerializationTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/serialization/ClusterSerializationTests.java\n@@ -30,7 +30,7 @@ import org.elasticsearch.cluster.routing.allocation.AllocationService;\n import org.elasticsearch.common.io.stream.BytesStreamInput;\n import org.elasticsearch.common.io.stream.BytesStreamOutput;\n import org.elasticsearch.common.transport.DummyTransportAddress;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.hamcrest.Matchers.equalTo;\n@@ -38,7 +38,7 @@ import static org.hamcrest.Matchers.equalTo;\n /**\n  *\n  */\n-public class ClusterSerializationTests extends ElasticsearchTestCase {\n+public class ClusterSerializationTests extends ElasticsearchAllocationTestCase {\n \n     @Test\n     public void testClusterStateSerialization() throws Exception {\n@@ -54,7 +54,7 @@ public class ClusterSerializationTests extends ElasticsearchTestCase {\n \n         ClusterState clusterState = ClusterState.builder().nodes(nodes).metaData(metaData).routingTable(routingTable).build();\n \n-        AllocationService strategy = new AllocationService();\n+        AllocationService strategy = createAllocationService();\n         clusterState = ClusterState.builder(clusterState).routingTable(strategy.reroute(clusterState).routingTable()).build();\n \n         ClusterState serializedClusterState = ClusterState.Builder.fromBytes(ClusterState.Builder.toBytes(clusterState), newNode(\"node1\"));\n@@ -77,7 +77,7 @@ public class ClusterSerializationTests extends ElasticsearchTestCase {\n \n         ClusterState clusterState = ClusterState.builder().nodes(nodes).metaData(metaData).routingTable(routingTable).build();\n \n-        AllocationService strategy = new AllocationService();\n+        AllocationService strategy = createAllocationService();\n         RoutingTable source = strategy.reroute(clusterState).routingTable();\n \n         BytesStreamOutput outStream = new BytesStreamOutput();\ndiff --git a/src/test/java/org/elasticsearch/cluster/serialization/ClusterStateToStringTests.java b/src/test/java/org/elasticsearch/cluster/serialization/ClusterStateToStringTests.java\nindex fc33d6f48cf..0d04a7a27bd 100644\n--- a/src/test/java/org/elasticsearch/cluster/serialization/ClusterStateToStringTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/serialization/ClusterStateToStringTests.java\n@@ -10,7 +10,7 @@ import org.elasticsearch.cluster.node.DiscoveryNodes;\n import org.elasticsearch.cluster.routing.RoutingTable;\n import org.elasticsearch.cluster.routing.allocation.AllocationService;\n import org.elasticsearch.common.transport.DummyTransportAddress;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.hamcrest.Matchers.containsString;\n@@ -18,7 +18,7 @@ import static org.hamcrest.Matchers.containsString;\n /**\n  *\n  */\n-public class ClusterStateToStringTests extends ElasticsearchTestCase {\n+public class ClusterStateToStringTests extends ElasticsearchAllocationTestCase {\n     @Test\n     public void testClusterStateSerialization() throws Exception {\n         MetaData metaData = MetaData.builder()\n@@ -34,7 +34,7 @@ public class ClusterStateToStringTests extends ElasticsearchTestCase {\n \n         ClusterState clusterState = ClusterState.builder().nodes(nodes).metaData(metaData).routingTable(routingTable).build();\n \n-        AllocationService strategy = new AllocationService();\n+        AllocationService strategy = createAllocationService();\n         clusterState = ClusterState.builder(clusterState).routingTable(strategy.reroute(clusterState).routingTable()).build();\n \n         String clusterStateString = clusterState.toString();\ndiff --git a/src/test/java/org/elasticsearch/cluster/structure/RoutingIteratorTests.java b/src/test/java/org/elasticsearch/cluster/structure/RoutingIteratorTests.java\nindex a0721e4f86d..f504dc5f4a4 100644\n--- a/src/test/java/org/elasticsearch/cluster/structure/RoutingIteratorTests.java\n+++ b/src/test/java/org/elasticsearch/cluster/structure/RoutingIteratorTests.java\n@@ -32,7 +32,7 @@ import org.elasticsearch.cluster.routing.operation.hash.djb.DjbHashFunction;\n import org.elasticsearch.cluster.routing.operation.plain.PlainOperationRouting;\n import org.elasticsearch.common.settings.ImmutableSettings;\n import org.elasticsearch.index.shard.ShardId;\n-import org.elasticsearch.test.ElasticsearchTestCase;\n+import org.elasticsearch.test.ElasticsearchAllocationTestCase;\n import org.junit.Test;\n \n import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;\n@@ -40,7 +40,7 @@ import static org.elasticsearch.cluster.routing.allocation.RoutingAllocationTest\n import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;\n import static org.hamcrest.Matchers.*;\n \n-public class RoutingIteratorTests extends ElasticsearchTestCase {\n+public class RoutingIteratorTests extends ElasticsearchAllocationTestCase {\n \n     @Test\n     public void testEmptyIterator() {\n@@ -248,7 +248,7 @@ public class RoutingIteratorTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testAttributePreferenceRouting() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .put(\"cluster.routing.allocation.allow_rebalance\", \"always\")\n                 .put(\"cluster.routing.allocation.awareness.attributes\", \"rack_id,zone\")\n@@ -299,7 +299,7 @@ public class RoutingIteratorTests extends ElasticsearchTestCase {\n \n     @Test\n     public void testShardsAndPreferNodeRouting() {\n-        AllocationService strategy = new AllocationService(settingsBuilder()\n+        AllocationService strategy = createAllocationService(settingsBuilder()\n                 .put(\"cluster.routing.allocation.concurrent_recoveries\", 10)\n                 .build());\n \ndiff --git a/src/test/java/org/elasticsearch/test/ElasticsearchAllocationTestCase.java b/src/test/java/org/elasticsearch/test/ElasticsearchAllocationTestCase.java\nnew file mode 100644\nindex 00000000000..57c0f56770d\n--- /dev/null\n+++ b/src/test/java/org/elasticsearch/test/ElasticsearchAllocationTestCase.java\n@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to ElasticSearch and Shay Banon under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. ElasticSearch licenses this\n+ * file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.test;\n+\n+import com.google.common.collect.ImmutableSet;\n+import org.elasticsearch.cluster.ClusterInfoService;\n+import org.elasticsearch.cluster.routing.allocation.AllocationService;\n+import org.elasticsearch.cluster.routing.allocation.allocator.ShardsAllocators;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecidersModule;\n+import org.elasticsearch.common.settings.ImmutableSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.node.settings.NodeSettingsService;\n+\n+import java.lang.reflect.Constructor;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Random;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+/**\n+ */\n+public class ElasticsearchAllocationTestCase extends ElasticsearchTestCase {\n+\n+    public static AllocationService createAllocationService() {\n+        return createAllocationService(ImmutableSettings.Builder.EMPTY_SETTINGS);\n+    }\n+\n+    public static AllocationService createAllocationService(Settings settings) {\n+        return createAllocationService(settings, getRandom())    ;\n+    }\n+\n+    public static AllocationService createAllocationService(Settings settings, Random random) {\n+        return new AllocationService(settings,\n+                randomAllocationDeciders(settings, new NodeSettingsService(ImmutableSettings.Builder.EMPTY_SETTINGS), random),\n+                new ShardsAllocators(settings), ClusterInfoService.EMPTY);\n+    }\n+\n+    public static AllocationDeciders randomAllocationDeciders(Settings settings, NodeSettingsService nodeSettingsService, Random random) {\n+        final ImmutableSet<Class<? extends AllocationDecider>> defaultAllocationDeciders = AllocationDecidersModule.DEFAULT_ALLOCATION_DECIDERS;\n+        final List<AllocationDecider> list = new ArrayList<AllocationDecider>();\n+        for (Class<? extends AllocationDecider> deciderClass : defaultAllocationDeciders) {\n+            try {\n+                try {\n+                    Constructor<? extends AllocationDecider> constructor = deciderClass.getConstructor(Settings.class, NodeSettingsService.class);\n+                    list.add(constructor.newInstance(settings, nodeSettingsService));\n+                } catch (NoSuchMethodException e) {\n+                    Constructor<? extends AllocationDecider> constructor = null;\n+                    constructor = deciderClass.getConstructor(Settings.class);\n+                    list.add(constructor.newInstance(settings));\n+                }\n+            } catch (Exception ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        }\n+        assertThat(list.size(), equalTo(defaultAllocationDeciders.size()));\n+        for (AllocationDecider d : list) {\n+            assertThat(defaultAllocationDeciders.contains(d.getClass()), is(true));\n+        }\n+        Collections.shuffle(list, random);\n+        return new AllocationDeciders(settings, list.toArray(new AllocationDecider[0]));\n+\n+    }\n+}\ndiff --git a/src/test/java/org/elasticsearch/test/ElasticsearchTestCase.java b/src/test/java/org/elasticsearch/test/ElasticsearchTestCase.java\nindex 38ad8f9a560..1d0df441ad9 100644\n--- a/src/test/java/org/elasticsearch/test/ElasticsearchTestCase.java\n+++ b/src/test/java/org/elasticsearch/test/ElasticsearchTestCase.java\n@@ -18,8 +18,11 @@\n  */\n package org.elasticsearch.test;\n \n-import com.carrotsearch.randomizedtesting.annotations.*;\n+import com.carrotsearch.randomizedtesting.annotations.Listeners;\n+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakFilters;\n+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakScope;\n import com.carrotsearch.randomizedtesting.annotations.ThreadLeakScope.Scope;\n+import com.carrotsearch.randomizedtesting.annotations.TimeoutSuite;\n import com.google.common.base.Predicate;\n import com.google.common.collect.ImmutableList;\n import org.apache.lucene.store.MockDirectoryWrapper;\n@@ -31,8 +34,8 @@ import org.elasticsearch.common.logging.ESLogger;\n import org.elasticsearch.common.logging.Loggers;\n import org.elasticsearch.common.util.concurrent.EsAbortPolicy;\n import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n-import org.elasticsearch.test.junit.listeners.LoggingListener;\n import org.elasticsearch.test.engine.MockRobinEngine;\n+import org.elasticsearch.test.junit.listeners.LoggingListener;\n import org.elasticsearch.test.store.MockDirectoryHelper;\n import org.junit.AfterClass;\n import org.junit.BeforeClass;\n@@ -57,15 +60,15 @@ import java.util.concurrent.TimeUnit;\n public abstract class ElasticsearchTestCase extends AbstractRandomizedTest {\n \n     private static Thread.UncaughtExceptionHandler defaultHandler;\n-    \n+\n     protected final ESLogger logger = Loggers.getLogger(getClass());\n \n     public static final String CHILD_VM_ID = System.getProperty(\"junit4.childvm.id\", \"\" + System.currentTimeMillis());\n-    \n+\n     public static boolean awaitBusy(Predicate<?> breakPredicate) throws InterruptedException {\n         return awaitBusy(breakPredicate, 10, TimeUnit.SECONDS);\n     }\n-    \n+\n     public static boolean awaitBusy(Predicate<?> breakPredicate, long maxWaitTime, TimeUnit unit) throws InterruptedException {\n         long maxTimeInMillis = TimeUnit.MILLISECONDS.convert(maxWaitTime, unit);\n         long iterations = Math.max(Math.round(Math.log10(maxTimeInMillis) / Math.log10(2)), 1);\n@@ -83,9 +86,9 @@ public abstract class ElasticsearchTestCase extends AbstractRandomizedTest {\n         Thread.sleep(Math.max(timeInMillis, 0));\n         return breakPredicate.apply(null);\n     }\n-    \n-    private static final String[] numericTypes = new String[] {\"byte\", \"short\", \"integer\", \"long\"};\n-    \n+\n+    private static final String[] numericTypes = new String[]{\"byte\", \"short\", \"integer\", \"long\"};\n+\n     public static String randomNumericType(Random random) {\n         return numericTypes[random.nextInt(numericTypes.length)];\n     }\n@@ -101,7 +104,7 @@ public abstract class ElasticsearchTestCase extends AbstractRandomizedTest {\n         URI uri = URI.create(getClass().getResource(relativePath).toString());\n         return new File(uri);\n     }\n-    \n+\n     public static void ensureAllFilesClosed() throws IOException {\n         try {\n             for (MockDirectoryHelper.ElasticsearchMockDirectoryWrapper w : MockDirectoryHelper.wrappers) {\n@@ -113,7 +116,7 @@ public abstract class ElasticsearchTestCase extends AbstractRandomizedTest {\n             forceClearMockWrappers();\n         }\n     }\n-    \n+\n     public static void ensureAllSearchersClosed() {\n         /* in some cases we finish a test faster than the freeContext calls make it to the\n          * shards. Let's wait for some time if there are still searchers. If the are really \n@@ -144,11 +147,11 @@ public abstract class ElasticsearchTestCase extends AbstractRandomizedTest {\n             MockRobinEngine.INFLIGHT_ENGINE_SEARCHERS.clear();\n         }\n     }\n-    \n+\n     public static void forceClearMockWrappers() {\n         MockDirectoryHelper.wrappers.clear();\n     }\n-    \n+\n     public static boolean hasUnclosedWrapper() {\n         for (MockDirectoryWrapper w : MockDirectoryHelper.wrappers) {\n             if (w.isOpen()) {\n@@ -166,7 +169,7 @@ public abstract class ElasticsearchTestCase extends AbstractRandomizedTest {\n                 ensureAllFilesClosed();\n             }\n         });\n-        \n+\n         closeAfterSuite(new Closeable() {\n             @Override\n             public void close() throws IOException {\n@@ -179,15 +182,15 @@ public abstract class ElasticsearchTestCase extends AbstractRandomizedTest {\n \n     @AfterClass\n     public static void resetUncaughtExceptionHandler() {\n-       Thread.setDefaultUncaughtExceptionHandler(defaultHandler);\n+        Thread.setDefaultUncaughtExceptionHandler(defaultHandler);\n     }\n \n     public static boolean maybeDocValues() {\n         return LuceneTestCase.defaultCodecSupportsSortedSet() && randomBoolean();\n     }\n-    \n+\n     private static final List<Version> SORTED_VERSIONS;\n-    \n+\n     static {\n         Field[] declaredFields = Version.class.getDeclaredFields();\n         Set<Integer> ids = new HashSet<Integer>();\n@@ -213,17 +216,17 @@ public abstract class ElasticsearchTestCase extends AbstractRandomizedTest {\n         }\n         SORTED_VERSIONS = version.build();\n     }\n-    \n+\n     public static Version getPreviousVersion() {\n         Version version = SORTED_VERSIONS.get(1);\n         assert version.before(Version.CURRENT);\n         return version;\n     }\n-    \n+\n     public static Version randomVersion() {\n         return randomVersion(getRandom());\n     }\n-    \n+\n     public static Version randomVersion(Random random) {\n         return SORTED_VERSIONS.get(random.nextInt(SORTED_VERSIONS.size()));\n     }\n@@ -246,7 +249,7 @@ public abstract class ElasticsearchTestCase extends AbstractRandomizedTest {\n                 }\n             } else if (e instanceof OutOfMemoryError) {\n                 if (e.getMessage().contains(\"unable to create new native thread\")) {\n-                   printStackDump(logger);\n+                    printStackDump(logger);\n                 }\n             }\n             parent.uncaughtException(t, e);\n@@ -263,11 +266,11 @@ public abstract class ElasticsearchTestCase extends AbstractRandomizedTest {\n     /**\n      * Dump threads and their current stack trace.\n      */\n-    private static String formatThreadStacks(Map<Thread,StackTraceElement[]> threads) {\n+    private static String formatThreadStacks(Map<Thread, StackTraceElement[]> threads) {\n         StringBuilder message = new StringBuilder();\n         int cnt = 1;\n         final Formatter f = new Formatter(message, Locale.ENGLISH);\n-        for (Map.Entry<Thread,StackTraceElement[]> e : threads.entrySet()) {\n+        for (Map.Entry<Thread, StackTraceElement[]> e : threads.entrySet()) {\n             if (e.getKey().isAlive())\n                 f.format(Locale.ENGLISH, \"\\n  %2d) %s\", cnt++, threadName(e.getKey())).flush();\n             if (e.getValue().length == 0) {"
}