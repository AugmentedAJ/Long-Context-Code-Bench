{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 4212,
  "base_commit": "22852d8040df7c789e0cdbb32d33ef1e5cc76435",
  "head_commit": "4ffd8a663c44f8ddd3a54ced2aa745a3665056b7",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.6,
    "completeness": -0.8,
    "code_reuse": -0.7,
    "best_practices": -0.4,
    "unsolicited_docs": 0.0
  },
  "aggregate": -0.4999999999999999,
  "rationale": "The agent's implementation is significantly incomplete and architecturally different from ground truth. Ground truth creates static helper methods `isRepositoryInUse()` in both SnapshotsService and RestoreService, then calls them from RepositoriesService via `ensureRepositoryNotInUse()` which throws ElasticSearchIllegalStateException. Agent instead creates a single private instance method in RepositoriesService and introduces a new custom exception type RepositoryInUseException (not present in ground truth). This breaks the expected separation of concerns. Critical omissions: (1) No static helper methods added to SnapshotsService or RestoreService - these are core to the ground truth design; (2) Missing null-safety check around newMetaData in applyClusterState (lines 268-285 in ground truth); (3) Missing test file deleteRepositoryWhileSnapshottingTest() in SharedClusterSnapshotRestoreTests; (4) Missing minor code cleanups (import removals, return statement simplification, null instead of primary.currentNodeId(), javadoc fix); (5) Missing file rename MockRamDirecorySerivce -> MockRamDirectoryService. The agent only implements validation in RepositoriesService without the broader architectural changes. Code reuse is poor because it duplicates the isRepositoryInUse logic inline rather than leveraging the service layer design. Best practices violated by creating a custom exception type not in the codebase and not following the established pattern. No unsolicited documentation detected.",
  "edit_run_id": "7ad89f22",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/repositories/RepositoriesService.java b/src/main/java/org/elasticsearch/repositories/RepositoriesService.java\nindex 0f9d59d89c3..9b649fb02fe 100644\n--- a/src/main/java/org/elasticsearch/repositories/RepositoriesService.java\n+++ b/src/main/java/org/elasticsearch/repositories/RepositoriesService.java\n@@ -20,6 +20,7 @@\n package org.elasticsearch.repositories;\n \n import com.google.common.collect.ImmutableMap;\n+import org.elasticsearch.ElasticSearchIllegalStateException;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.*;\n import org.elasticsearch.cluster.ack.ClusterStateUpdateRequest;\n@@ -38,6 +39,8 @@ import org.elasticsearch.common.regex.Regex;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.index.snapshots.IndexShardRepository;\n+import org.elasticsearch.snapshots.RestoreService;\n+import org.elasticsearch.snapshots.SnapshotsService;\n \n import java.util.ArrayList;\n import java.util.List;\n@@ -87,6 +90,7 @@ public class RepositoriesService extends AbstractComponent implements ClusterSta\n         clusterService.submitStateUpdateTask(request.cause, new AckedClusterStateUpdateTask() {\n             @Override\n             public ClusterState execute(ClusterState currentState) {\n+                ensureRepositoryNotInUse(currentState, request.name);\n                 // Trying to create the new repository on master to make sure it works\n                 if (!registerRepository(newRepositoryMetaData)) {\n                     // The new repository has the same settings as the old one - ignore\n@@ -172,6 +176,7 @@ public class RepositoriesService extends AbstractComponent implements ClusterSta\n         clusterService.submitStateUpdateTask(request.cause, new AckedClusterStateUpdateTask() {\n             @Override\n             public ClusterState execute(ClusterState currentState) {\n+                ensureRepositoryNotInUse(currentState, request.name);\n                 MetaData metaData = currentState.metaData();\n                 MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData());\n                 RepositoriesMetaData repositories = metaData.custom(RepositoriesMetaData.TYPE);\n@@ -260,22 +265,23 @@ public class RepositoriesService extends AbstractComponent implements ClusterSta\n             }\n \n             ImmutableMap.Builder<String, RepositoryHolder> builder = ImmutableMap.builder();\n-            // Now go through all repositories and update existing or create missing\n-            for (RepositoryMetaData repositoryMetaData : newMetaData.repositories()) {\n-                RepositoryHolder holder = survivors.get(repositoryMetaData.name());\n-                if (holder != null) {\n-                    // Found previous version of this repository\n-                    if (!holder.type.equals(repositoryMetaData.type()) || !holder.settings.equals(repositoryMetaData.settings())) {\n-                        // Previous version is different from the version in settings\n-                        closeRepository(repositoryMetaData.name(), holder);\n+            if (newMetaData != null) {\n+                // Now go through all repositories and update existing or create missing\n+                for (RepositoryMetaData repositoryMetaData : newMetaData.repositories()) {\n+                    RepositoryHolder holder = survivors.get(repositoryMetaData.name());\n+                    if (holder != null) {\n+                        // Found previous version of this repository\n+                        if (!holder.type.equals(repositoryMetaData.type()) || !holder.settings.equals(repositoryMetaData.settings())) {\n+                            // Previous version is different from the version in settings\n+                            closeRepository(repositoryMetaData.name(), holder);\n+                            holder = createRepositoryHolder(repositoryMetaData);\n+                        }\n+                    } else {\n                         holder = createRepositoryHolder(repositoryMetaData);\n-                        //TODO: Error handling and proper Injector cleanup\n                     }\n-                } else {\n-                    holder = createRepositoryHolder(repositoryMetaData);\n-                }\n-                if (holder != null) {\n-                    builder.put(repositoryMetaData.name(), holder);\n+                    if (holder != null) {\n+                        builder.put(repositoryMetaData.name(), holder);\n+                    }\n                 }\n             }\n             repositories = builder.build();\n@@ -389,6 +395,12 @@ public class RepositoriesService extends AbstractComponent implements ClusterSta\n         }\n     }\n \n+    private void ensureRepositoryNotInUse(ClusterState clusterState, String repository) {\n+        if (SnapshotsService.isRepositoryInUse(clusterState, repository) || RestoreService.isRepositoryInUse(clusterState, repository)) {\n+            throw new ElasticSearchIllegalStateException(\"trying to modify or unregister repository that is currently used \");\n+        }\n+    }\n+\n     /**\n      * Internal data structure for holding repository with its configuration information and injector\n      */\ndiff --git a/src/main/java/org/elasticsearch/snapshots/RestoreService.java b/src/main/java/org/elasticsearch/snapshots/RestoreService.java\nindex 55d4dc90a76..89047881192 100644\n--- a/src/main/java/org/elasticsearch/snapshots/RestoreService.java\n+++ b/src/main/java/org/elasticsearch/snapshots/RestoreService.java\n@@ -423,6 +423,24 @@ public class RestoreService extends AbstractComponent implements ClusterStateLis\n         }\n     }\n \n+    /**\n+     * Checks if a repository is currently in use by one of the snapshots\n+     * @param clusterState cluster state\n+     * @param repository repository id\n+     * @return true if repository is currently in use by one of the running snapshots\n+     */\n+    public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {\n+        MetaData metaData = clusterState.metaData();\n+        RestoreMetaData snapshots = metaData.custom(RestoreMetaData.TYPE);\n+        if (snapshots != null) {\n+            for(RestoreMetaData.Entry snapshot : snapshots.entries()) {\n+                if(repository.equals(snapshot.snapshotId().getRepository())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n \n     /**\n      * Restore snapshot request\ndiff --git a/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java b/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\nindex 7835ba6be26..81f0bbe7eb7 100644\n--- a/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\n+++ b/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\n@@ -292,8 +292,7 @@ public class SnapshotsService extends AbstractComponent implements ClusterStateL\n                         }\n                     }\n                     mdBuilder.putCustom(SnapshotMetaData.TYPE, new SnapshotMetaData(entries.build()));\n-                    ClusterState newState = ClusterState.builder(currentState).metaData(mdBuilder).build();\n-                    return newState;\n+                    return ClusterState.builder(currentState).metaData(mdBuilder).build();\n                 }\n \n                 @Override\n@@ -840,6 +839,25 @@ public class SnapshotsService extends AbstractComponent implements ClusterStateL\n         });\n     }\n \n+    /**\n+     * Checks if a repository is currently in use by one of the snapshots\n+     * @param clusterState cluster state\n+     * @param repository repository id\n+     * @return true if repository is currently in use by one of the running snapshots\n+     */\n+    public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {\n+        MetaData metaData = clusterState.metaData();\n+        SnapshotMetaData snapshots = metaData.custom(SnapshotMetaData.TYPE);\n+        if (snapshots != null) {\n+            for(SnapshotMetaData.Entry snapshot : snapshots.entries()) {\n+                if(repository.equals(snapshot.snapshotId().getRepository())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Deletes snapshot from repository\n      *\n@@ -883,7 +901,7 @@ public class SnapshotsService extends AbstractComponent implements ClusterStateL\n                 ShardRouting primary = indexRoutingTable.shard(i).primaryShard();\n                 if (primary == null || !primary.assignedToNode()) {\n                     //TODO: Should we bailout completely or just mark this shard as failed?\n-                    builder.put(shardId, new SnapshotMetaData.ShardSnapshotStatus(primary.currentNodeId(), State.FAILED, \"primary shard is not allocated\"));\n+                    builder.put(shardId, new SnapshotMetaData.ShardSnapshotStatus(null, State.FAILED, \"primary shard is not allocated\"));\n                 } else if (!primary.started()) {\n                     builder.put(shardId, new SnapshotMetaData.ShardSnapshotStatus(primary.currentNodeId(), State.FAILED, \"primary shard hasn't been started yet\"));\n                 } else {\n@@ -941,8 +959,6 @@ public class SnapshotsService extends AbstractComponent implements ClusterStateL\n \n         /**\n          * Called if delete operation failed\n-         *\n-         * @param t\n          */\n         void onFailure(Throwable t);\n     }\ndiff --git a/src/test/java/org/elasticsearch/snapshots/DedicatedClusterSnapshotRestoreTests.java b/src/test/java/org/elasticsearch/snapshots/DedicatedClusterSnapshotRestoreTests.java\nindex 7f3445c0f41..3503fec95ff 100644\n--- a/src/test/java/org/elasticsearch/snapshots/DedicatedClusterSnapshotRestoreTests.java\n+++ b/src/test/java/org/elasticsearch/snapshots/DedicatedClusterSnapshotRestoreTests.java\n@@ -20,7 +20,6 @@\n package org.elasticsearch.snapshots;\n \n import com.carrotsearch.randomizedtesting.LifecycleScope;\n-import org.apache.lucene.util.LuceneTestCase;\n import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryResponse;\n import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n import org.elasticsearch.client.Client;\ndiff --git a/src/test/java/org/elasticsearch/snapshots/SharedClusterSnapshotRestoreTests.java b/src/test/java/org/elasticsearch/snapshots/SharedClusterSnapshotRestoreTests.java\nindex 2d6040dc71f..b1cf306e3c3 100644\n--- a/src/test/java/org/elasticsearch/snapshots/SharedClusterSnapshotRestoreTests.java\n+++ b/src/test/java/org/elasticsearch/snapshots/SharedClusterSnapshotRestoreTests.java\n@@ -21,7 +21,6 @@ package org.elasticsearch.snapshots;\n \n import com.carrotsearch.randomizedtesting.LifecycleScope;\n import com.google.common.collect.ImmutableList;\n-import org.apache.lucene.util.LuceneTestCase;\n import org.elasticsearch.ExceptionsHelper;\n import org.elasticsearch.action.ListenableActionFuture;\n import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryResponse;\n@@ -729,6 +728,95 @@ public class SharedClusterSnapshotRestoreTests extends AbstractSnapshotTests {\n         assertThat(client.prepareCount(\"test-idx\").get().getCount(), equalTo(100L));\n     }\n \n+    @Test\n+    @TestLogging(\"cluster.routing.allocation.decider:TRACE\")\n+    public void deleteRepositoryWhileSnapshottingTest() throws Exception {\n+        Client client = client();\n+        File repositoryLocation = newTempDir(LifecycleScope.TEST);\n+        logger.info(\"-->  creating repository\");\n+        PutRepositoryResponse putRepositoryResponse = client.admin().cluster().preparePutRepository(\"test-repo\")\n+                .setType(MockRepositoryModule.class.getCanonicalName()).setSettings(\n+                        ImmutableSettings.settingsBuilder()\n+                                .put(\"location\", repositoryLocation)\n+                                .put(\"random\", randomAsciiOfLength(10))\n+                                .put(\"wait_after_unblock\", 200)\n+                ).get();\n+        assertThat(putRepositoryResponse.isAcknowledged(), equalTo(true));\n+\n+        // Create index on 2 nodes and make sure each node has a primary by setting no replicas\n+        assertAcked(prepareCreate(\"test-idx\", 2, ImmutableSettings.builder().put(\"number_of_replicas\", 0)));\n+\n+        logger.info(\"--> indexing some data\");\n+        for (int i = 0; i < 100; i++) {\n+            index(\"test-idx\", \"doc\", Integer.toString(i), \"foo\", \"bar\" + i);\n+        }\n+        refresh();\n+        assertThat(client.prepareCount(\"test-idx\").get().getCount(), equalTo(100L));\n+\n+        // Pick one node and block it\n+        String blockedNode = blockNodeWithIndex(\"test-idx\");\n+\n+        logger.info(\"--> snapshot\");\n+        client.admin().cluster().prepareCreateSnapshot(\"test-repo\", \"test-snap\").setWaitForCompletion(false).setIndices(\"test-idx\").get();\n+\n+        logger.info(\"--> waiting for block to kick in\");\n+        waitForBlock(blockedNode, \"test-repo\", TimeValue.timeValueSeconds(60));\n+\n+        logger.info(\"--> execution was blocked on node [{}], trying to delete repository\", blockedNode);\n+\n+        try {\n+            client.admin().cluster().prepareDeleteRepository(\"test-repo\").execute().get();\n+            fail(\"shouldn't be able to delete in-use repository\");\n+        } catch (Exception ex) {\n+            logger.info(\"--> in-use repository deletion failed\");\n+        }\n+\n+        logger.info(\"--> trying to move repository to another location\");\n+        try {\n+            client.admin().cluster().preparePutRepository(\"test-repo\")\n+                    .setType(\"fs\").setSettings(ImmutableSettings.settingsBuilder().put(\"location\", new File(repositoryLocation, \"test\"))\n+            ).get();\n+            fail(\"shouldn't be able to replace in-use repository\");\n+        } catch (Exception ex) {\n+            logger.info(\"--> in-use repository replacement failed\");\n+        }\n+\n+        logger.info(\"--> trying to create a repository with different name\");\n+        putRepositoryResponse = client.admin().cluster().preparePutRepository(\"test-repo-2\")\n+                .setType(\"fs\").setSettings(ImmutableSettings.settingsBuilder().put(\"location\", new File(repositoryLocation, \"test\"))\n+        ).get();\n+        assertThat(putRepositoryResponse.isAcknowledged(), equalTo(true));\n+\n+        logger.info(\"--> unblocking blocked node\");\n+        unblockNode(blockedNode);\n+        logger.info(\"--> waiting for completion\");\n+        SnapshotInfo snapshotInfo = waitForCompletion(\"test-repo\", \"test-snap\", TimeValue.timeValueSeconds(600));\n+        logger.info(\"Number of failed shards [{}]\", snapshotInfo.shardFailures().size());\n+        logger.info(\"--> done\");\n+\n+        ImmutableList<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots(\"test-repo\").setSnapshots(\"test-snap\").get().getSnapshots();\n+\n+        assertThat(snapshotInfos.size(), equalTo(1));\n+        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS));\n+        assertThat(snapshotInfos.get(0).shardFailures().size(), equalTo(0));\n+\n+        logger.info(\"--> delete index\");\n+        wipeIndices(\"test-idx\");\n+\n+        logger.info(\"--> replace mock repository with real one at the same location\");\n+        putRepositoryResponse = client.admin().cluster().preparePutRepository(\"test-repo\")\n+                .setType(\"fs\").setSettings(ImmutableSettings.settingsBuilder().put(\"location\", repositoryLocation)\n+                ).get();\n+        assertThat(putRepositoryResponse.isAcknowledged(), equalTo(true));\n+\n+        logger.info(\"--> restore index\");\n+        RestoreSnapshotResponse restoreSnapshotResponse = client.admin().cluster().prepareRestoreSnapshot(\"test-repo\", \"test-snap\").setWaitForCompletion(true).execute().actionGet();\n+        assertThat(restoreSnapshotResponse.getRestoreInfo().totalShards(), greaterThan(0));\n+\n+        ensureGreen();\n+        assertThat(client.prepareCount(\"test-idx\").get().getCount(), equalTo(100L));\n+    }\n+\n     @Test\n     public void urlRepositoryTest() throws Exception {\n         Client client = client();\ndiff --git a/src/test/java/org/elasticsearch/test/store/MockRamDirecorySerivce.java b/src/test/java/org/elasticsearch/test/store/MockRamDirectoryService.java\nsimilarity index 90%\nrename from src/test/java/org/elasticsearch/test/store/MockRamDirecorySerivce.java\nrename to src/test/java/org/elasticsearch/test/store/MockRamDirectoryService.java\nindex b000df98253..7de87765caa 100644\n--- a/src/test/java/org/elasticsearch/test/store/MockRamDirecorySerivce.java\n+++ b/src/test/java/org/elasticsearch/test/store/MockRamDirectoryService.java\n@@ -29,13 +29,13 @@ import org.elasticsearch.index.store.DirectoryService;\n \n import java.io.IOException;\n \n-public class MockRamDirecorySerivce extends AbstractIndexShardComponent implements DirectoryService {\n+public class MockRamDirectoryService extends AbstractIndexShardComponent implements DirectoryService {\n \n     private final MockDirectoryHelper helper;\n     private final DirectoryService delegateService;\n \n     @Inject\n-    public MockRamDirecorySerivce(ShardId shardId, Settings indexSettings, ByteBufferCache byteBufferCache) {\n+    public MockRamDirectoryService(ShardId shardId, Settings indexSettings, ByteBufferCache byteBufferCache) {\n         super(shardId, indexSettings);\n         helper = new MockDirectoryHelper(shardId, indexSettings, logger);\n         delegateService = helper.randomRamDirecoryService(byteBufferCache);\ndiff --git a/src/test/java/org/elasticsearch/test/store/MockRamIndexStore.java b/src/test/java/org/elasticsearch/test/store/MockRamIndexStore.java\nindex 3c653c36806..212451a56f3 100644\n--- a/src/test/java/org/elasticsearch/test/store/MockRamIndexStore.java\n+++ b/src/test/java/org/elasticsearch/test/store/MockRamIndexStore.java\n@@ -45,7 +45,7 @@ public class MockRamIndexStore extends AbstractIndexStore{\n \n     @Override\n     public Class<? extends DirectoryService> shardDirectory() {\n-        return MockRamDirecorySerivce.class;\n+        return MockRamDirectoryService.class;\n     }\n \n     @Override"
}