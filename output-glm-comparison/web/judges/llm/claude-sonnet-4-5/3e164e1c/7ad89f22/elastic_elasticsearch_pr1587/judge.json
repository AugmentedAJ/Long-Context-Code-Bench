{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 1587,
  "base_commit": "df4a3bfd379fd90b3667bbcd7ca2ed4619fee025",
  "head_commit": "d95aa9f266ccecf33894c88af329895c1693cd14",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.3,
    "completeness": -0.4,
    "code_reuse": -0.2,
    "best_practices": 0.0,
    "unsolicited_docs": 1.0
  },
  "aggregate": 0.020000000000000018,
  "rationale": "The agent added three new comprehensive test methods for TTL with routing but completely missed the core requirements shown in ground truth: (1) configuring cluster settings (index.number_of_shards=2, cluster.routing.operation settings) in the @BeforeClass setup, and (2) enhancing the existing testSimpleTTL() method to test both routed and non-routed documents together. The ground truth also includes unrelated but necessary bug fixes in FiltersFunctionScoreQuery.java that the agent didn't implement. While the agent's new tests do verify TTL+routing functionality across multiple scenarios, they don't match the task's intent of 'enhancing ttl tests' by modifying the existing test structure. The approach creates separate tests instead of improving the current test to cover routing scenarios alongside basic TTL, missing the distributed shard testing configuration that ground truth establishes globally. Code quality is acceptable but the solution direction is wrong.",
  "edit_run_id": "7ad89f22",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java b/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java\nindex 6a8d0c8b68a..43263a466a7 100644\n--- a/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java\n+++ b/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java\n@@ -165,7 +165,7 @@ public class FiltersFunctionScoreQuery extends Query {\n                     if (docSet.get(doc)) {\n                         filterFunction.function.setNextReader(reader);\n                         Explanation functionExplanation = filterFunction.function.explainFactor(doc);\n-                        float sc = getValue() * subQueryExpl.getValue() * functionExplanation.getValue();\n+                        float sc = getValue() * functionExplanation.getValue();\n                         Explanation res = new ComplexExplanation(true, sc, \"custom score, product of:\");\n                         res.addDetail(new Explanation(1.0f, \"match filter: \" + filterFunction.filter.toString()));\n                         res.addDetail(functionExplanation);\n@@ -185,13 +185,13 @@ public class FiltersFunctionScoreQuery extends Query {\n                     if (docSet.get(doc)) {\n                         filterFunction.function.setNextReader(reader);\n                         Explanation functionExplanation = filterFunction.function.explainFactor(doc);\n-                        float factor = functionExplanation.getValue();\n+                        float sc = functionExplanation.getValue();\n                         count++;\n-                        total += factor;\n-                        multiply *= factor;\n-                        max = Math.max(factor, max);\n-                        min = Math.min(factor, min);\n-                        Explanation res = new ComplexExplanation(true, factor, \"custom score, product of:\");\n+                        total += sc;\n+                        multiply *= sc;\n+                        max = Math.max(sc, max);\n+                        min = Math.min(sc, min);\n+                        Explanation res = new ComplexExplanation(true, sc, \"custom score, product of:\");\n                         res.addDetail(new Explanation(1.0f, \"match filter: \" + filterFunction.filter.toString()));\n                         res.addDetail(functionExplanation);\n                         res.addDetail(new Explanation(getValue(), \"queryBoost\"));\n@@ -199,26 +199,25 @@ public class FiltersFunctionScoreQuery extends Query {\n                     }\n                 }\n                 if (count > 0) {\n-                    float factor = 0;\n+                    float sc = 0;\n                     switch (scoreMode) {\n                         case Avg:\n-                            factor = total / count;\n+                            sc = total / count;\n                             break;\n                         case Max:\n-                            factor = max;\n+                            sc = max;\n                             break;\n                         case Min:\n-                            factor = min;\n+                            sc = min;\n                             break;\n                         case Total:\n-                            factor = total;\n+                            sc = total;\n                             break;\n                         case Multiply:\n-                            factor = multiply;\n+                            sc = multiply;\n                             break;\n                     }\n-\n-                    float sc = factor * subQueryExpl.getValue() * getValue();\n+                    sc *= getValue();\n                     Explanation res = new ComplexExplanation(true, sc, \"custom score, score mode [\" + scoreMode.toString().toLowerCase() + \"]\");\n                     res.addDetail(subQueryExpl);\n                     for (Explanation explanation : filtersExplanations) {\ndiff --git a/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java b/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java\nindex 89f4ab78fe1..3b8f00c041b 100644\n--- a/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java\n+++ b/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java\n@@ -39,7 +39,12 @@ public class SimpleTTLTests extends AbstractNodesTests {\n \n     @BeforeClass\n     public void createNodes() throws Exception {\n-        Settings settings = settingsBuilder().put(\"indices.ttl.interval\", purgeInterval).build();\n+        Settings settings = settingsBuilder()\n+                .put(\"indices.ttl.interval\", purgeInterval)\n+                .put(\"index.number_of_shards\", 2) // 2 shards to test TTL purge with routing properly\n+                .put(\"cluster.routing.operation.use_type\", false) // make sure we control the shard computation\n+                .put(\"cluster.routing.operation.hash.type\", \"djb\")\n+                .build();\n         startNode(\"node1\", settings);\n         startNode(\"node2\", settings);\n         client = getClient();\n@@ -71,7 +76,9 @@ public class SimpleTTLTests extends AbstractNodesTests {\n         client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n         long providedTTLValue = 3000;\n         logger.info(\"--> checking ttl\");\n+        // Index one doc without routing and one doc with routing\n         client.prepareIndex(\"test\", \"type1\", \"1\").setSource(\"field1\", \"value1\").setTTL(providedTTLValue).setRefresh(true).execute().actionGet();\n+        client.prepareIndex(\"test\", \"type1\", \"with_routing\").setSource(\"field1\", \"value1\").setTTL(providedTTLValue).setRouting(\"routing\").setRefresh(true).execute().actionGet();\n         long now = System.currentTimeMillis();\n \n         // realtime get check\n@@ -100,7 +107,7 @@ public class SimpleTTLTests extends AbstractNodesTests {\n         assertThat(ttl0, lessThan(providedTTLValue - (now1 - now)));\n \n         logger.info(\"--> checking purger\");\n-        // make sure the purger has done its job\n+        // make sure the purger has done its job for all indexed docs that are expired\n         long shouldBeExpiredDate = now + providedTTLValue + purgeInterval + 2000;\n         now1 = System.currentTimeMillis();\n         if (shouldBeExpiredDate - now1 > 0) {\n@@ -109,14 +116,22 @@ public class SimpleTTLTests extends AbstractNodesTests {\n         // realtime get check\n         getResponse = client.prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n         assertThat(getResponse.exists(), equalTo(false));\n+        getResponse = client.prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n+        assertThat(getResponse.exists(), equalTo(false));\n         // replica realtime get check\n         getResponse = client.prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n         assertThat(getResponse.exists(), equalTo(false));\n+        getResponse = client.prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n+        assertThat(getResponse.exists(), equalTo(false));\n         // non realtime get (stored) check\n         getResponse = client.prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n         assertThat(getResponse.exists(), equalTo(false));\n+        getResponse = client.prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n+        assertThat(getResponse.exists(), equalTo(false));\n         // non realtime get going the replica check\n         getResponse = client.prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n         assertThat(getResponse.exists(), equalTo(false));\n+        getResponse = client.prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n+        assertThat(getResponse.exists(), equalTo(false));\n     }\n }"
}