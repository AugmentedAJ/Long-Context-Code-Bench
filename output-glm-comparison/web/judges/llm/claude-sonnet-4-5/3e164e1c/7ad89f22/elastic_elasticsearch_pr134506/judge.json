{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134506,
  "base_commit": "e5559ef012c066ddfe75ccbc3961d7923e92af3b",
  "head_commit": "524a1dbfaeca79003a9fb24bf10294caf81f20e9",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.8,
    "completeness": -0.7,
    "code_reuse": -0.5,
    "best_practices": -0.6,
    "unsolicited_docs": 1.0
  },
  "aggregate": -0.32,
  "rationale": "The agent's solution attempts to reuse an existing `SuggestingErrorOnUnknown` class rather than implementing the Levenshtein distance logic inline as in the ground truth. However, this approach has critical issues: 1) The import `org.elasticsearch.common.xcontent.SuggestingErrorOnUnknown` does not appear to exist in the actual codebase (this would cause a compilation failure), 2) The error message format differs from ground truth - it doesn't include the helpful instruction about running './gradle generateTransportVersion', 3) The test cases are inadequate - they only verify the exception is thrown but don't validate the actual suggestion content or message format as the ground truth tests do with specific assertions like checking for 'Did you mean [to_child_block_join_query]?'. The ground truth implementation is self-contained with Levenshtein distance calculation, proper message formatting with conditional suggestions, and comprehensive tests that verify exact message content. The agent's approach would fail to compile and doesn't meet the requirement of suggesting similar versions with proper messaging.",
  "edit_run_id": "7ad89f22",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/server/src/main/java/org/elasticsearch/TransportVersion.java b/server/src/main/java/org/elasticsearch/TransportVersion.java\nindex f130f7d62e2..831891595cb 100644\n--- a/server/src/main/java/org/elasticsearch/TransportVersion.java\n+++ b/server/src/main/java/org/elasticsearch/TransportVersion.java\n@@ -9,9 +9,11 @@\n \n package org.elasticsearch;\n \n+import org.apache.lucene.search.spell.LevenshteinDistance;\n import org.elasticsearch.common.VersionId;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.core.Tuple;\n import org.elasticsearch.internal.VersionExtension;\n import org.elasticsearch.plugins.ExtensionLoader;\n \n@@ -234,12 +236,29 @@ public record TransportVersion(String name, int id, TransportVersion nextPatchVe\n      * This will only return the latest known referable transport version for a given name and not its\n      * patch versions. Patch versions are constructed as a linked list internally and may be found by\n      * cycling through them in a loop using {@link TransportVersion#nextPatchVersion()}.\n-     *\n      */\n     public static TransportVersion fromName(String name) {\n         TransportVersion known = VersionsHolder.ALL_VERSIONS_BY_NAME.get(name);\n         if (known == null) {\n-            throw new IllegalStateException(\"unknown transport version [\" + name + \"]\");\n+            LevenshteinDistance ld = new LevenshteinDistance();\n+            List<Tuple<Float, String>> scoredNames = new ArrayList<>();\n+            for (String key : VersionsHolder.ALL_VERSIONS_BY_NAME.keySet()) {\n+                float distance = ld.getDistance(name, key);\n+                if (distance > 0.7f) {\n+                    scoredNames.add(new Tuple<>(distance, key));\n+                }\n+            }\n+            StringBuilder message = new StringBuilder(\"Unknown transport version [\");\n+            message.append(name);\n+            message.append(\"].\");\n+            if (scoredNames.isEmpty() == false) {\n+                List<String> names = scoredNames.stream().map(Tuple::v2).toList();\n+                message.append(\" Did you mean \");\n+                message.append(names);\n+                message.append(\"?\");\n+            }\n+            message.append(\" If this is a new transport version, run './gradle generateTransportVersion'.\");\n+            throw new IllegalStateException(message.toString());\n         }\n         return known;\n     }\ndiff --git a/server/src/test/java/org/elasticsearch/TransportVersionTests.java b/server/src/test/java/org/elasticsearch/TransportVersionTests.java\nindex e51ca0c553f..bfbe1d31133 100644\n--- a/server/src/test/java/org/elasticsearch/TransportVersionTests.java\n+++ b/server/src/test/java/org/elasticsearch/TransportVersionTests.java\n@@ -391,4 +391,25 @@ public class TransportVersionTests extends ESTestCase {\n         );\n         assertThat(new TransportVersion(null, 1000000, null).supports(test3), is(true));\n     }\n+\n+    public void testMoreLikeThis() {\n+        IllegalStateException ise = expectThrows(IllegalStateException.class, () -> TransportVersion.fromName(\"to_child_lock_join_query\"));\n+        assertThat(\n+            ise.getMessage(),\n+            is(\n+                \"Unknown transport version [to_child_lock_join_query]. \"\n+                    + \"Did you mean [to_child_block_join_query]? \"\n+                    + \"If this is a new transport version, run './gradle generateTransportVersion'.\"\n+            )\n+        );\n+\n+        ise = expectThrows(IllegalStateException.class, () -> TransportVersion.fromName(\"brand_new_version_unrelated_to_others\"));\n+        assertThat(\n+            ise.getMessage(),\n+            is(\n+                \"Unknown transport version [brand_new_version_unrelated_to_others]. \"\n+                    + \"If this is a new transport version, run './gradle generateTransportVersion'.\"\n+            )\n+        );\n+    }\n }"
}