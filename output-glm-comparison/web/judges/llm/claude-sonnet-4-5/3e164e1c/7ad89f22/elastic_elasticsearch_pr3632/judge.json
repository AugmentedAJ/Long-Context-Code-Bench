{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 3632,
  "base_commit": "9e7b3963d81afc74907a130533738cb90e6f993b",
  "head_commit": "6b000d8c6d7f0162b6c3d9771785f2bcba508fbf",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.3,
    "completeness": -0.6,
    "code_reuse": 0.0,
    "best_practices": -0.2,
    "unsolicited_docs": 0.0
  },
  "aggregate": -0.21999999999999997,
  "rationale": "The agent implemented partial functionality for custom highlight queries but with significant omissions and errors. CORRECTNESS (-0.3): The FastVectorHighlighter implementation is incorrect - it creates a new CustomFieldQuery for every custom highlight query instead of using the highlightQuery from HighlighterContext, breaking the design pattern used in ground truth. The agent checks field.highlightQuery() directly rather than using highlighterContext.highlightQuery. COMPLETENESS (-0.6): Major missing components include: (1) No documentation added to highlighting.asciidoc showing rescore query example, (2) Missing SearchRequestBuilder.setHighlighterQuery() method, (3) Missing HighlightPhase changes that create HighlighterContext with highlightQuery parameter, (4) Missing HighlighterContext.highlightQuery field and constructor parameter, (5) No global highlight_query parsing in HighlighterParseElement (only per-field), (6) Missing HighlightBuilder.highlightQuery() method and serialization, (7) Missing global highlight query propagation to fields, (8) Tests don't match ground truth pattern (uses different queries and assertions). CODE_REUSE (0.0): Adequate reuse of existing patterns. BEST_PRACTICES (-0.2): Breaks architectural pattern by having highlighters access field.highlightQuery() directly instead of through context; inconsistent with ground truth design where HighlightPhase resolves the query once and passes it via HighlighterContext.",
  "edit_run_id": "7ad89f22",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/docs/reference/search/request/highlighting.asciidoc b/docs/reference/search/request/highlighting.asciidoc\nindex 43d5817aab4..6a45e813269 100644\n--- a/docs/reference/search/request/highlighting.asciidoc\n+++ b/docs/reference/search/request/highlighting.asciidoc\n@@ -142,6 +142,73 @@ order by score:\n }\n --------------------------------------------------\n \n+It is also possible to highlight against a query other than the search\n+query by setting `highlight_query`.  This is especially useful if you\n+use a rescore query because those are not taken into account by\n+highlighting by default.  Elasticsearch does not validate that\n+`highlight_query` contains the search query in any way so it is possible\n+to define it so legitimate query results aren't highlighted at all.\n+Generally it is better to include the search query in the\n+`highlight_query`.  Here is an example of including both the search\n+query and the rescore query in `highlight_query`.\n+[source,js]\n+--------------------------------------------------\n+{\n+    \"fields\": [ \"_id\" ],\n+    \"query\" : {\n+        \"match\": {\n+            \"content\": {\n+                \"query\": \"foo bar\"\n+            }\n+        }\n+    },\n+    \"rescore\": {\n+        \"window_size\": 50,\n+        \"query\": {\n+            \"rescore_query\" : {\n+                \"match_phrase\": {\n+                    \"content\": {\n+                        \"query\": \"foo bar\",\n+                        \"phrase_slop\": 1\n+                    }\n+                }\n+            },\n+            \"rescore_query_weight\" : 10\n+        }\n+    },\n+    \"highlight\" : {\n+        \"order\" : \"score\",\n+        \"fields\" : {\n+            \"content\" : {\n+                \"fragment_size\" : 150,\n+                \"number_of_fragments\" : 3,\n+                \"highlight_query\": {\n+                    \"bool\": {\n+                        \"must\": {\n+                            \"match\": {\n+                                \"content\": {\n+                                    \"query\": \"foo bar\"\n+                                }\n+                            }\n+                        },\n+                        \"should\": {\n+                            \"match_phrase\": {\n+                                \"content\": {\n+                                    \"query\": \"foo bar\",\n+                                    \"phrase_slop\": 1,\n+                                    \"boost\": 10.0\n+                                }\n+                            }\n+                        },\n+                        \"minimum_should_match\": 0\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+--------------------------------------------------\n+\n Note the score of text fragment in this case is calculated by Lucene\n highlighting framework. For implementation details you can check\n `ScoreOrderFragmentsBuilder.java` class.\ndiff --git a/src/main/java/org/elasticsearch/action/search/SearchRequestBuilder.java b/src/main/java/org/elasticsearch/action/search/SearchRequestBuilder.java\nindex 5bc80e291fd..cf4e074cea7 100644\n--- a/src/main/java/org/elasticsearch/action/search/SearchRequestBuilder.java\n+++ b/src/main/java/org/elasticsearch/action/search/SearchRequestBuilder.java\n@@ -671,6 +671,14 @@ public class SearchRequestBuilder extends ActionRequestBuilder<SearchRequest, Se\n         return this;\n     }\n \n+    /**\n+     * Sets a query to be used for highlighting all fields instead of the search query.\n+     */\n+    public SearchRequestBuilder setHighlighterQuery(QueryBuilder highlightQuery) {\n+        highlightBuilder().highlightQuery(highlightQuery);\n+        return this;\n+    }\n+\n     public SearchRequestBuilder setHighlighterRequireFieldMatch(boolean requireFieldMatch) {\n         highlightBuilder().requireFieldMatch(requireFieldMatch);\n         return this;\ndiff --git a/src/main/java/org/elasticsearch/search/highlight/FastVectorHighlighter.java b/src/main/java/org/elasticsearch/search/highlight/FastVectorHighlighter.java\nindex 7763753061a..1a62258ae47 100644\n--- a/src/main/java/org/elasticsearch/search/highlight/FastVectorHighlighter.java\n+++ b/src/main/java/org/elasticsearch/search/highlight/FastVectorHighlighter.java\n@@ -125,13 +125,13 @@ public class FastVectorHighlighter implements Highlighter {\n                 if (field.requireFieldMatch()) {\n                     if (cache.fieldMatchFieldQuery == null) {\n                         // we use top level reader to rewrite the query against all readers, with use caching it across hits (and across readers...)\n-                        cache.fieldMatchFieldQuery = new CustomFieldQuery(context.parsedQuery().query(), hitContext.topLevelReader(), true, field.requireFieldMatch());\n+                        cache.fieldMatchFieldQuery = new CustomFieldQuery(highlighterContext.highlightQuery, hitContext.topLevelReader(), true, field.requireFieldMatch());\n                     }\n                     fieldQuery = cache.fieldMatchFieldQuery;\n                 } else {\n                     if (cache.noFieldMatchFieldQuery == null) {\n                         // we use top level reader to rewrite the query against all readers, with use caching it across hits (and across readers...)\n-                        cache.noFieldMatchFieldQuery = new CustomFieldQuery(context.parsedQuery().query(), hitContext.topLevelReader(), true, field.requireFieldMatch());\n+                        cache.noFieldMatchFieldQuery = new CustomFieldQuery(highlighterContext.highlightQuery, hitContext.topLevelReader(), true, field.requireFieldMatch());\n                     }\n                     fieldQuery = cache.noFieldMatchFieldQuery;\n                 }\ndiff --git a/src/main/java/org/elasticsearch/search/highlight/HighlightBuilder.java b/src/main/java/org/elasticsearch/search/highlight/HighlightBuilder.java\nindex 4e0ccc65fa6..64d99b282db 100644\n--- a/src/main/java/org/elasticsearch/search/highlight/HighlightBuilder.java\n+++ b/src/main/java/org/elasticsearch/search/highlight/HighlightBuilder.java\n@@ -21,6 +21,7 @@ package org.elasticsearch.search.highlight;\n \n import org.elasticsearch.common.xcontent.ToXContent;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryBuilder;\n \n import java.io.IOException;\n import java.util.List;\n@@ -53,6 +54,8 @@ public class HighlightBuilder implements ToXContent {\n \n     private String fragmenter;\n \n+    private QueryBuilder highlightQuery;\n+\n     private Map<String, Object> options;\n \n     /**\n@@ -201,6 +204,14 @@ public class HighlightBuilder implements ToXContent {\n         return this;\n     }\n \n+    /**\n+     * Sets a query to be used for highlighting all fields instead of the search query.\n+     */\n+    public HighlightBuilder highlightQuery(QueryBuilder highlightQuery) {\n+        this.highlightQuery = highlightQuery;\n+        return this;\n+    }\n+\n     /**\n      * Allows to set custom options for custom highlighters.\n      */\n@@ -236,6 +247,9 @@ public class HighlightBuilder implements ToXContent {\n         if (fragmenter != null) {\n             builder.field(\"fragmenter\", fragmenter);\n         }\n+        if (highlightQuery != null) {\n+            builder.field(\"highlight_query\", highlightQuery);\n+        }\n         if (options != null && options.size() > 0) {\n             builder.field(\"options\", options);\n         }\n@@ -279,6 +293,9 @@ public class HighlightBuilder implements ToXContent {\n                 if (field.fragmenter != null) {\n                     builder.field(\"fragmenter\", field.fragmenter);\n                 }\n+                if (field.highlightQuery != null) {\n+                    builder.field(\"highlight_query\", field.highlightQuery);\n+                }\n                 if (field.options != null && field.options.size() > 0) {\n                     builder.field(\"options\", field.options);\n                 }\n@@ -306,6 +323,7 @@ public class HighlightBuilder implements ToXContent {\n         char[] boundaryChars;\n         String highlighterType;\n         String fragmenter;\n+        QueryBuilder highlightQuery;\n         Map<String, Object> options;\n \n         public Field(String name) {\n@@ -400,6 +418,14 @@ public class HighlightBuilder implements ToXContent {\n             return this;\n         }\n \n+        /**\n+         * Sets a query to use for highlighting this field instead of the search query.\n+         */\n+        public Field highlightQuery(QueryBuilder highlightQuery) {\n+            this.highlightQuery = highlightQuery;\n+            return this;\n+        }\n+\n         /**\n          * Allows to set custom options for custom highlighters.\n          * This overrides global settings set by {@link HighlightBuilder#options(Map<String, Object>)}.\ndiff --git a/src/main/java/org/elasticsearch/search/highlight/HighlightPhase.java b/src/main/java/org/elasticsearch/search/highlight/HighlightPhase.java\nindex 6ad8ea8c88a..8251c49a046 100644\n--- a/src/main/java/org/elasticsearch/search/highlight/HighlightPhase.java\n+++ b/src/main/java/org/elasticsearch/search/highlight/HighlightPhase.java\n@@ -21,6 +21,7 @@ package org.elasticsearch.search.highlight;\n \n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n+import org.apache.lucene.search.Query;\n import org.elasticsearch.ElasticSearchException;\n import org.elasticsearch.ElasticSearchIllegalArgumentException;\n import org.elasticsearch.common.component.AbstractComponent;\n@@ -100,7 +101,13 @@ public class HighlightPhase extends AbstractComponent implements FetchSubPhase {\n                     throw new ElasticSearchIllegalArgumentException(\"unknown highlighter type [\" + field.highlighterType() + \"] for the field [\" + fieldName + \"]\");\n                 }\n \n-                HighlighterContext highlighterContext = new HighlighterContext(fieldName, field, fieldMapper, context, hitContext);\n+                Query highlightQuery = field.highlightQuery();\n+                if (highlightQuery == null) {\n+                    // Don't use the context.query() since it might be rewritten, and we need to pass the non rewritten queries to\n+                    // let the highlighter handle MultiTerm ones\n+                    highlightQuery = context.parsedQuery().query();\n+                }\n+                HighlighterContext highlighterContext = new HighlighterContext(fieldName, field, fieldMapper, context, hitContext, highlightQuery);\n                 HighlightField highlightField = highlighter.highlight(highlighterContext);\n                 if (highlightField != null) {\n                     highlightFields.put(highlightField.name(), highlightField);\ndiff --git a/src/main/java/org/elasticsearch/search/highlight/HighlighterContext.java b/src/main/java/org/elasticsearch/search/highlight/HighlighterContext.java\nindex e128d55393f..080929f5e94 100644\n--- a/src/main/java/org/elasticsearch/search/highlight/HighlighterContext.java\n+++ b/src/main/java/org/elasticsearch/search/highlight/HighlighterContext.java\n@@ -18,6 +18,7 @@\n  */\n package org.elasticsearch.search.highlight;\n \n+import org.apache.lucene.search.Query;\n import org.elasticsearch.index.mapper.FieldMapper;\n import org.elasticsearch.search.fetch.FetchSubPhase;\n import org.elasticsearch.search.internal.SearchContext;\n@@ -32,13 +33,15 @@ public class HighlighterContext {\n     public FieldMapper<?> mapper;\n     public SearchContext context;\n     public FetchSubPhase.HitContext hitContext;\n+    public Query highlightQuery;\n \n-    public HighlighterContext(String fieldName, SearchContextHighlight.Field field, FieldMapper<?> mapper, SearchContext context, FetchSubPhase.HitContext hitContext) {\n+    public HighlighterContext(String fieldName, SearchContextHighlight.Field field, FieldMapper<?> mapper, SearchContext context,\n+            FetchSubPhase.HitContext hitContext, Query highlightQuery) {\n         this.fieldName = fieldName;\n         this.field = field;\n         this.mapper = mapper;\n         this.context = context;\n         this.hitContext = hitContext;\n+        this.highlightQuery = highlightQuery;\n     }\n-\n }\ndiff --git a/src/main/java/org/elasticsearch/search/highlight/HighlighterParseElement.java b/src/main/java/org/elasticsearch/search/highlight/HighlighterParseElement.java\nindex edceffc7cbc..4f1036eb5cb 100644\n--- a/src/main/java/org/elasticsearch/search/highlight/HighlighterParseElement.java\n+++ b/src/main/java/org/elasticsearch/search/highlight/HighlighterParseElement.java\n@@ -20,6 +20,7 @@\n package org.elasticsearch.search.highlight;\n \n import com.google.common.collect.Lists;\n+import org.apache.lucene.search.Query;\n import org.apache.lucene.search.vectorhighlight.SimpleBoundaryScanner;\n import org.elasticsearch.common.xcontent.XContentParser;\n import org.elasticsearch.search.SearchParseElement;\n@@ -80,6 +81,7 @@ public class HighlighterParseElement implements SearchParseElement {\n         String globalHighlighterType = null;\n         String globalFragmenter = null;\n         Map<String, Object> globalOptions = null;\n+        Query globalHighlightQuery = null;\n \n         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n             if (token == XContentParser.Token.FIELD_NAME) {\n@@ -185,13 +187,19 @@ public class HighlighterParseElement implements SearchParseElement {\n                                     } else if (\"fragmenter\".equals(fieldName)) {\n                                         field.fragmenter(parser.text());\n                                     }\n-                                } else if (fieldName.equals(\"options\")) {\n-                                    field.options(parser.map());\n+                                } else if (token == XContentParser.Token.START_OBJECT) {\n+                                    if (\"highlight_query\".equals(fieldName) || \"highlightQuery\".equals(fieldName)) {\n+                                        field.highlightQuery(context.queryParserService().parse(parser).query());\n+                                    } else if (fieldName.equals(\"options\")) {\n+                                        field.options(parser.map());\n+                                    }\n                                 }\n                             }\n                             fields.add(field);\n                         }\n                     }\n+                } else if (\"highlight_query\".equals(topLevelFieldName) || \"highlightQuery\".equals(topLevelFieldName)) {\n+                    globalHighlightQuery = context.queryParserService().parse(parser).query();\n                 }\n             }\n         }\n@@ -240,6 +248,9 @@ public class HighlighterParseElement implements SearchParseElement {\n             if (field.options() == null || field.options().size() == 0) {\n                 field.options(globalOptions);\n             }\n+            if (field.highlightQuery() == null && globalHighlightQuery != null) {\n+                field.highlightQuery(globalHighlightQuery);\n+            }\n         }\n \n         context.highlight(new SearchContextHighlight(fields));\ndiff --git a/src/main/java/org/elasticsearch/search/highlight/PlainHighlighter.java b/src/main/java/org/elasticsearch/search/highlight/PlainHighlighter.java\nindex ff1d0f8bb6f..b433d1bb83a 100644\n--- a/src/main/java/org/elasticsearch/search/highlight/PlainHighlighter.java\n+++ b/src/main/java/org/elasticsearch/search/highlight/PlainHighlighter.java\n@@ -70,9 +70,7 @@ public class PlainHighlighter implements Highlighter {\n \n         org.apache.lucene.search.highlight.Highlighter entry = cache.get(mapper);\n         if (entry == null) {\n-            // Don't use the context.query() since it might be rewritten, and we need to pass the non rewritten queries to\n-            // let the highlighter handle MultiTerm ones\n-            Query query = context.parsedQuery().query();\n+            Query query = highlighterContext.highlightQuery;\n             QueryScorer queryScorer = new CustomQueryScorer(query, field.requireFieldMatch() ? mapper.names().indexName() : null);\n             queryScorer.setExpandMultiTermQuery(true);\n             Fragmenter fragmenter;\ndiff --git a/src/main/java/org/elasticsearch/search/highlight/SearchContextHighlight.java b/src/main/java/org/elasticsearch/search/highlight/SearchContextHighlight.java\nindex 04e71d238c2..2490a56f953 100644\n--- a/src/main/java/org/elasticsearch/search/highlight/SearchContextHighlight.java\n+++ b/src/main/java/org/elasticsearch/search/highlight/SearchContextHighlight.java\n@@ -19,6 +19,8 @@\n \n package org.elasticsearch.search.highlight;\n \n+import org.apache.lucene.search.Query;\n+\n import java.util.List;\n import java.util.Map;\n \n@@ -66,6 +68,8 @@ public class SearchContextHighlight {\n         private int boundaryMaxScan = -1;\n         private Character[] boundaryChars = null;\n \n+        private Query highlightQuery;\n+\n         private Map<String, Object> options;\n \n         public Field(String field) {\n@@ -180,6 +184,14 @@ public class SearchContextHighlight {\n             this.boundaryChars = boundaryChars;\n         }\n \n+        public Query highlightQuery() {\n+            return highlightQuery;\n+        }\n+\n+        public void highlightQuery(Query highlightQuery) {\n+            this.highlightQuery = highlightQuery;\n+        }\n+\n         public Map<String, Object> options() {\n             return options;\n         }\ndiff --git a/src/main/java/org/elasticsearch/search/internal/SearchContext.java b/src/main/java/org/elasticsearch/search/internal/SearchContext.java\nindex 251bdd0841b..77e38ea87ef 100644\n--- a/src/main/java/org/elasticsearch/search/internal/SearchContext.java\n+++ b/src/main/java/org/elasticsearch/search/internal/SearchContext.java\n@@ -131,6 +131,9 @@ public abstract class SearchContext implements Releasable {\n \n     public abstract void suggest(SuggestionSearchContext suggest);\n \n+    /**\n+     * @return the rescore context or null if rescoring wasn't specified or isn't supported\n+     */\n     public abstract RescoreSearchContext rescore();\n \n     public abstract void rescore(RescoreSearchContext rescore);\ndiff --git a/src/main/java/org/elasticsearch/search/rescore/QueryRescorer.java b/src/main/java/org/elasticsearch/search/rescore/QueryRescorer.java\nindex 6549064fa2b..6f385473732 100644\n--- a/src/main/java/org/elasticsearch/search/rescore/QueryRescorer.java\n+++ b/src/main/java/org/elasticsearch/search/rescore/QueryRescorer.java\n@@ -32,9 +32,8 @@ import org.elasticsearch.search.internal.SearchContext;\n import java.io.IOException;\n import java.util.Arrays;\n import java.util.Set;\n-import java.lang.Math;\n \n-final class QueryRescorer implements Rescorer {\n+public final class QueryRescorer implements Rescorer {\n \n     private static enum ScoreMode {\n         Avg {\n@@ -189,7 +188,7 @@ final class QueryRescorer implements Rescorer {\n         return rescoreContext;\n     }\n     \n-    static class QueryRescoreContext extends RescoreSearchContext {\n+    public static class QueryRescoreContext extends RescoreSearchContext {\n         \n         public QueryRescoreContext(QueryRescorer rescorer) {\n             super(NAME, 10, rescorer);\ndiff --git a/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java b/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java\nindex 1857b9aafdd..d965ecdf68a 100644\n--- a/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java\n+++ b/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java\n@@ -22,6 +22,7 @@ package org.elasticsearch.search.highlight;\n import org.apache.lucene.util.LuceneTestCase.Slow;\n import org.elasticsearch.ElasticSearchException;\n import org.elasticsearch.action.search.SearchPhaseExecutionException;\n+import org.elasticsearch.action.search.SearchRequestBuilder;\n import org.elasticsearch.action.search.SearchResponse;\n import org.elasticsearch.action.search.SearchType;\n import org.elasticsearch.common.Priority;\n@@ -37,6 +38,7 @@ import org.elasticsearch.search.SearchHit;\n import org.elasticsearch.search.builder.SearchSourceBuilder;\n import org.elasticsearch.test.AbstractIntegrationTest;\n import org.elasticsearch.test.hamcrest.ElasticSearchAssertions;\n+import org.hamcrest.Matcher;\n import org.junit.Test;\n \n import java.io.IOException;\n@@ -50,8 +52,7 @@ import static org.elasticsearch.search.builder.SearchSourceBuilder.highlight;\n import static org.elasticsearch.search.builder.SearchSourceBuilder.searchSource;\n import static org.elasticsearch.test.hamcrest.ElasticSearchAssertions.assertHighlight;\n import static org.elasticsearch.test.hamcrest.ElasticSearchAssertions.assertNoFailures;\n-import static org.hamcrest.Matchers.equalTo;\n-import static org.hamcrest.Matchers.startsWith;\n+import static org.hamcrest.Matchers.*;\n \n /**\n  *\n@@ -1598,4 +1599,67 @@ public class HighlighterSearchTests extends AbstractIntegrationTest {\n         assertThat(response.getFailedShards(), equalTo(0));\n     }\n \n+    @Test\n+    public void testHighlightUsesHighlightQuery() throws IOException {\n+        prepareCreate(\"test\")\n+                .addMapping(\"type1\", jsonBuilder().startObject()\n+                    .startObject(\"type\")\n+                        .startObject(\"properties\")\n+                            .startObject(\"text\")\n+                                .field(\"type\", \"string\")\n+                                .field(\"store\", \"yes\")\n+                                .field(\"term_vector\", \"with_positions_offsets\")\n+                            .endObject()\n+                        .endObject()\n+                    .endObject()\n+                .endObject()).get();\n+        ensureGreen();\n+\n+        index(\"test\", \"type1\", \"1\", \"text\", \"some stuff stuff stuff stuff stuff to highlight against the stuff phrase\");\n+        refresh();\n+\n+        // Make sure the fvh doesn't highlight in the same way as we're going to do with a scoreQuery because\n+        // that would invalidate the test results.\n+        Matcher<String> highlightedMatcher = anyOf(\n+                containsString(\"<em>stuff phrase</em>\"),            // FHV normally does this\n+                containsString(\"<em>stuff</em> <em>phrase</em>\"));  // Plain normally does this\n+        HighlightBuilder.Field field = new HighlightBuilder.Field(\"text\")\n+                .fragmentSize(20)\n+                .numOfFragments(1)\n+                .highlighterType(\"fvh\");\n+        SearchRequestBuilder search = client().prepareSearch(\"test\")\n+                .setQuery(QueryBuilders.matchQuery(\"text\", \"stuff\"))\n+                .setHighlighterOrder(\"score\")\n+                .addHighlightedField(field);\n+        SearchResponse response = search.get();\n+        assertHighlight(response, 0, \"text\", 0, not(highlightedMatcher));\n+\n+        // And do the same for the plain highlighter\n+        field.highlighterType(\"plain\");\n+        response = search.get();\n+        assertHighlight(response, 0, \"text\", 0, not(highlightedMatcher));\n+\n+        // Make sure the fvh takes the highlightQuery into account\n+        field.highlighterType(\"fvh\").highlightQuery(matchPhraseQuery(\"text\", \"stuff phrase\"));\n+        response = search.get();\n+        assertHighlight(response, 0, \"text\", 0, highlightedMatcher);\n+\n+        // And do the same for the plain highlighter\n+        field.highlighterType(\"plain\");\n+        response = search.get();\n+        assertHighlight(response, 0, \"text\", 0, highlightedMatcher);\n+        // Note that the plain highlighter doesn't join the highlighted elements for us\n+\n+        // Make sure the fvh takes the highlightQuery into account when it is set on the highlight context instead of the field\n+        search.setHighlighterQuery(matchPhraseQuery(\"text\", \"stuff phrase\"));\n+        field.highlighterType(\"fvh\").highlightQuery(null);\n+        response = search.get();\n+        assertHighlight(response, 0, \"text\", 0, highlightedMatcher);\n+\n+        // And do the same for the plain highlighter\n+        field.highlighterType(\"plain\");\n+        response = search.get();\n+        assertHighlight(response, 0, \"text\", 0, highlightedMatcher);\n+        // Note that the plain highlighter doesn't join the highlighted elements for us\n+    }\n }"
}