{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 1616,
  "base_commit": "56a9c66df183ea4e9e2cfb8861877283d4048304",
  "head_commit": "08108088648f90cbc56aa5be9df8a5d25f045b60",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": 0.0,
    "completeness": -0.9,
    "code_reuse": 0.0,
    "best_practices": 0.0,
    "unsolicited_docs": 1.0
  },
  "aggregate": 0.019999999999999997,
  "rationale": "The agent correctly applied the core bug fix in TTLFieldMapper.java by adding `context.sourceToParse().ttl(ttl);` at line 185, which properly sets the default TTL value in the source context when no TTL is provided. This change is identical to the ground truth and addresses the stated bug. However, the agent is missing the entire test suite changes from SimpleTTLTests.java, which includes: (1) adding a new type2 mapping with default TTL configuration, (2) indexing test documents including one without TTL and one with default TTL, and (3) adding assertions to verify the fix works correctly for both no-TTL and default-TTL scenarios. The completeness score is -0.9 because while the production code fix is correct, the agent omitted all test coverage that validates the fix, which represents a major gap in the deliverable. Code reuse and best practices are at ground truth level (0.0) since the actual change made follows the same pattern. No unsolicited documentation was added (1.0).",
  "edit_run_id": "7ad89f22",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/index/mapper/internal/TTLFieldMapper.java b/src/main/java/org/elasticsearch/index/mapper/internal/TTLFieldMapper.java\nindex aa179f1da2f..d9f672e4c72 100644\n--- a/src/main/java/org/elasticsearch/index/mapper/internal/TTLFieldMapper.java\n+++ b/src/main/java/org/elasticsearch/index/mapper/internal/TTLFieldMapper.java\n@@ -182,6 +182,7 @@ public class TTLFieldMapper extends LongFieldMapper implements InternalMapper, R\n             long ttl = context.sourceToParse().ttl();\n             if (ttl <= 0 && defaultTTL > 0) { // no ttl provided so we use the default value\n                 ttl = defaultTTL;\n+                context.sourceToParse().ttl(ttl);\n             }\n             if (ttl > 0) { // a ttl has been provided either externally or in the _source\n                 long timestamp = context.sourceToParse().timestamp();\ndiff --git a/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java b/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java\nindex 3b8f00c041b..ed8736660ed 100644\n--- a/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java\n+++ b/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java\n@@ -72,13 +72,22 @@ public class SimpleTTLTests extends AbstractNodesTests {\n                         .startObject(\"_ttl\").field(\"enabled\", true).field(\"store\", \"yes\").endObject()\n                         .endObject()\n                         .endObject())\n+                .addMapping(\"type2\", XContentFactory.jsonBuilder()\n+                        .startObject()\n+                        .startObject(\"type2\")\n+                        .startObject(\"_timestamp\").field(\"enabled\", true).field(\"store\", \"yes\").endObject()\n+                        .startObject(\"_ttl\").field(\"enabled\", true).field(\"store\", \"yes\").field(\"default\", \"1d\").endObject()\n+                        .endObject()\n+                        .endObject())\n                 .execute().actionGet();\n         client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n         long providedTTLValue = 3000;\n         logger.info(\"--> checking ttl\");\n-        // Index one doc without routing and one doc with routing\n+        // Index one doc without routing, one doc with routing, one doc with not TTL and no default and one doc with default TTL\n         client.prepareIndex(\"test\", \"type1\", \"1\").setSource(\"field1\", \"value1\").setTTL(providedTTLValue).setRefresh(true).execute().actionGet();\n         client.prepareIndex(\"test\", \"type1\", \"with_routing\").setSource(\"field1\", \"value1\").setTTL(providedTTLValue).setRouting(\"routing\").setRefresh(true).execute().actionGet();\n+        client.prepareIndex(\"test\", \"type1\", \"no_ttl\").setSource(\"field1\", \"value1\").execute().actionGet();\n+        client.prepareIndex(\"test\", \"type2\", \"default_ttl\").setSource(\"field1\", \"value1\").execute().actionGet();\n         long now = System.currentTimeMillis();\n \n         // realtime get check\n@@ -106,6 +115,14 @@ public class SimpleTTLTests extends AbstractNodesTests {\n         assertThat(ttl0, greaterThan(0L));\n         assertThat(ttl0, lessThan(providedTTLValue - (now1 - now)));\n \n+        // no TTL provided so no TTL fetched\n+        getResponse = client.prepareGet(\"test\", \"type1\", \"no_ttl\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n+        assertThat(getResponse.field(\"_ttl\"), nullValue());\n+        // no TTL provided make sure it has default TTL\n+        getResponse = client.prepareGet(\"test\", \"type2\", \"default_ttl\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n+        ttl0 = ((Number) getResponse.field(\"_ttl\").value()).longValue();\n+        assertThat(ttl0, greaterThan(0L));\n+\n         logger.info(\"--> checking purger\");\n         // make sure the purger has done its job for all indexed docs that are expired\n         long shouldBeExpiredDate = now + providedTTLValue + purgeInterval + 2000;"
}