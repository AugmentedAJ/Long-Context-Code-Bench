{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134628,
  "base_commit": "630d52976d3fb951f6ea52a3d0e5fb492921df87",
  "head_commit": "55ac715077699238aa74d0604b22cd6926f13663",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": 0.0,
    "completeness": -0.3,
    "code_reuse": 0.0,
    "best_practices": -0.2,
    "unsolicited_docs": 1.0
  },
  "aggregate": 0.1,
  "rationale": "The agent correctly applied pattern matching to modernize the code by replacing explicit casts with pattern variables in all instanceof checks. However, there's a significant incompleteness issue: the ground truth refactored the unwrap() method from a chain of if-statements to a switch expression (modern Java pattern matching style), while the agent kept the legacy if-statement chain. This means the agent only partially modernized the code. Additionally, the agent's variable names are more verbose (constantScoreQuery, pointRangeQuery, extraPointRangeQuery, indexSortQuery, indexOrDocValuesQuery) compared to the ground truth's concise names (csq, q1, q2, isq, idq), which is less idiomatic for pattern variables in modern Java where brevity is preferred. The changes are functionally correct and don't break anything, but missing the switch expression modernization is a notable omission for a task explicitly about modernizing to use pattern matching.",
  "edit_run_id": "7ad89f22",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/QueryToFilterAdapter.java b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/QueryToFilterAdapter.java\nindex 9c6f7ddd6cc..4b7b41c9022 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/QueryToFilterAdapter.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/QueryToFilterAdapter.java\n@@ -51,14 +51,14 @@ public class QueryToFilterAdapter {\n         // Wrapping with a ConstantScoreQuery enables a few more rewrite\n         // rules as of Lucene 9.2\n         query = searcher.rewrite(new ConstantScoreQuery(query));\n-        if (query instanceof ConstantScoreQuery) {\n+        if (query instanceof ConstantScoreQuery csq) {\n             /*\n              * Unwrap constant score because it gets in the way of us\n              * understanding what the queries are trying to do and we\n              * don't use the score at all anyway. Effectively we always\n              * run in constant score mode.\n              */\n-            query = ((ConstantScoreQuery) query).getQuery();\n+            query = csq.getQuery();\n         }\n         return new QueryToFilterAdapter(searcher, key, query);\n     }\n@@ -132,8 +132,8 @@ public class QueryToFilterAdapter {\n         extraQuery = searcher().rewrite(new ConstantScoreQuery(extraQuery));\n         Query unwrappedExtraQuery = unwrap(extraQuery);\n         Query unwrappedQuery = unwrap(query);\n-        if (unwrappedQuery instanceof PointRangeQuery && unwrappedExtraQuery instanceof PointRangeQuery) {\n-            Query merged = MergedPointRangeQuery.merge((PointRangeQuery) unwrappedQuery, (PointRangeQuery) unwrappedExtraQuery);\n+        if (unwrappedQuery instanceof PointRangeQuery q1 && unwrappedExtraQuery instanceof PointRangeQuery q2) {\n+            Query merged = MergedPointRangeQuery.merge(q1, q2);\n             if (merged != null) {\n                 // Should we rewrap here?\n                 return new QueryToFilterAdapter(searcher(), key(), merged);\n@@ -157,19 +157,19 @@ public class QueryToFilterAdapter {\n \n     private static Query unwrap(Query query) {\n         while (true) {\n-            if (query instanceof ConstantScoreQuery) {\n-                query = ((ConstantScoreQuery) query).getQuery();\n-                continue;\n+            switch (query) {\n+                case ConstantScoreQuery csq:\n+                    query = csq.getQuery();\n+                    continue;\n+                case IndexSortSortedNumericDocValuesRangeQuery isq:\n+                    query = isq.getFallbackQuery();\n+                    continue;\n+                case IndexOrDocValuesQuery idq:\n+                    query = idq.getIndexQuery();\n+                    continue;\n+                default:\n+                    return query;\n             }\n-            if (query instanceof IndexSortSortedNumericDocValuesRangeQuery) {\n-                query = ((IndexSortSortedNumericDocValuesRangeQuery) query).getFallbackQuery();\n-                continue;\n-            }\n-            if (query instanceof IndexOrDocValuesQuery) {\n-                query = ((IndexOrDocValuesQuery) query).getIndexQuery();\n-                continue;\n-            }\n-            return query;\n         }\n     }\n "
}