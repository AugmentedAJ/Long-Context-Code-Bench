{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 134364,
  "base_commit": "3d2d765a1d6e99deda88603b6024bdc2f36599c2",
  "head_commit": "4e653dfe4051422a68ebab7357360efc435bf21f",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -1.0,
    "completeness": -1.0,
    "code_reuse": 0.0,
    "best_practices": -0.5,
    "unsolicited_docs": 1.0
  },
  "aggregate": -0.3,
  "rationale": "The agent modified completely different files than the ground truth. Ground truth fixes randomized test failures for small timestamps in MetricDocumentBuilderTests.java by changing timestamp assertions to explicitly cast to long values, and refactors KnnIndexer/KnnSearcher by removing HybridDirectory and simplifying directory usage. The agent instead modified TimeBasedUUIDGeneratorTests.java with timestamp initialization logic that wasn't requested. The changes are in entirely different modules (server/common vs qa/vector and x-pack/otel-data), addressing different test failures. This is a complete miss on the task - the agent did not implement any of the required changes and worked on unrelated code. The code quality of what the agent wrote is reasonable (hence not the worst best_practices score), but it's solving the wrong problem entirely.",
  "edit_run_id": "7ad89f22",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/qa/vector/src/main/java/org/elasticsearch/test/knn/KnnIndexer.java b/qa/vector/src/main/java/org/elasticsearch/test/knn/KnnIndexer.java\nindex 1534448abee..9512eedfc99 100644\n--- a/qa/vector/src/main/java/org/elasticsearch/test/knn/KnnIndexer.java\n+++ b/qa/vector/src/main/java/org/elasticsearch/test/knn/KnnIndexer.java\n@@ -32,18 +32,9 @@ import org.apache.lucene.index.IndexWriterConfig;\n import org.apache.lucene.index.MergePolicy;\n import org.apache.lucene.index.VectorEncoding;\n import org.apache.lucene.index.VectorSimilarityFunction;\n-import org.apache.lucene.store.Directory;\n import org.apache.lucene.store.FSDirectory;\n-import org.apache.lucene.store.IOContext;\n-import org.apache.lucene.store.IndexInput;\n-import org.apache.lucene.store.MMapDirectory;\n-import org.apache.lucene.store.NIOFSDirectory;\n-import org.apache.lucene.store.NativeFSLockFactory;\n import org.apache.lucene.util.PrintStreamInfoStream;\n import org.elasticsearch.common.io.Channels;\n-import org.elasticsearch.core.IOUtils;\n-import org.elasticsearch.index.store.LuceneFilesExtensions;\n-import org.elasticsearch.index.store.Store;\n \n import java.io.IOException;\n import java.io.UncheckedIOException;\n@@ -133,7 +124,7 @@ class KnnIndexer {\n \n         long start = System.nanoTime();\n         AtomicInteger numDocsIndexed = new AtomicInteger();\n-        try (Directory dir = getDirectory(indexPath); IndexWriter iw = new IndexWriter(dir, iwc)) {\n+        try (FSDirectory dir = FSDirectory.open(indexPath); IndexWriter iw = new IndexWriter(dir, iwc);) {\n             for (Path docsPath : this.docsPath) {\n                 int dim = this.dim;\n                 try (FileChannel in = FileChannel.open(docsPath)) {\n@@ -221,7 +212,7 @@ class KnnIndexer {\n         iwc.setCodec(codec);\n         logger.debug(\"KnnIndexer: forceMerge in {}\", indexPath);\n         long startNS = System.nanoTime();\n-        try (IndexWriter iw = new IndexWriter(getDirectory(indexPath), iwc)) {\n+        try (IndexWriter iw = new IndexWriter(FSDirectory.open(indexPath), iwc)) {\n             iw.forceMerge(1);\n         }\n         long endNS = System.nanoTime();\n@@ -230,14 +221,6 @@ class KnnIndexer {\n         results.forceMergeTimeMS = TimeUnit.NANOSECONDS.toMillis(elapsedNSec);\n     }\n \n-    static Directory getDirectory(Path indexPath) throws IOException {\n-        Directory dir = FSDirectory.open(indexPath);\n-        if (dir instanceof MMapDirectory mmapDir) {\n-            return new HybridDirectory(mmapDir);\n-        }\n-        return dir;\n-    }\n-\n     static class IndexerThread extends Thread {\n         private final IndexWriter iw;\n         private final AtomicInteger numDocsIndexed;\n@@ -375,64 +358,4 @@ class KnnIndexer {\n             bytes.get(dest);\n         }\n     }\n-\n-    // Copy of Elastic's HybridDirectory which extends NIOFSDirectory and uses MMapDirectory for certain files.\n-    static final class HybridDirectory extends NIOFSDirectory {\n-        private final MMapDirectory delegate;\n-\n-        HybridDirectory(MMapDirectory delegate) throws IOException {\n-            super(delegate.getDirectory(), NativeFSLockFactory.INSTANCE);\n-            this.delegate = delegate;\n-        }\n-\n-        @Override\n-        public IndexInput openInput(String name, IOContext context) throws IOException {\n-            if (useDelegate(name, context)) {\n-                // we need to do these checks on the outer directory since the inner doesn't know about pending deletes\n-                ensureOpen();\n-                ensureCanRead(name);\n-                // we switch the context here since mmap checks for the READONCE context by identity\n-                context = context == Store.READONCE_CHECKSUM ? IOContext.READONCE : context;\n-                // we only use the mmap to open inputs. Everything else is managed by the NIOFSDirectory otherwise\n-                // we might run into trouble with files that are pendingDelete in one directory but still\n-                // listed in listAll() from the other. We on the other hand don't want to list files from both dirs\n-                // and intersect for perf reasons.\n-                return delegate.openInput(name, context);\n-            } else {\n-                return super.openInput(name, context);\n-            }\n-        }\n-\n-        @Override\n-        public void close() throws IOException {\n-            IOUtils.close(super::close, delegate);\n-        }\n-\n-        private static String getExtension(String name) {\n-            // Unlike FileSwitchDirectory#getExtension, we treat `tmp` as a normal file extension, which can have its own rules for mmaping.\n-            final int lastDotIndex = name.lastIndexOf('.');\n-            if (lastDotIndex == -1) {\n-                return \"\";\n-            } else {\n-                return name.substring(lastDotIndex + 1);\n-            }\n-        }\n-\n-        static boolean useDelegate(String name, IOContext ioContext) {\n-            if (ioContext == Store.READONCE_CHECKSUM) {\n-                // If we're just reading the footer for the checksum then mmap() isn't really necessary, and it's desperately inefficient\n-                // if pre-loading is enabled on this file.\n-                return false;\n-            }\n-\n-            final LuceneFilesExtensions extension = LuceneFilesExtensions.fromExtension(getExtension(name));\n-            if (extension == null || extension.shouldMmap() == false) {\n-                // Other files are either less performance-sensitive (e.g. stored field index, norms metadata)\n-                // or are large and have a random access pattern and mmap leads to page cache trashing\n-                // (e.g. stored fields and term vectors).\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n }\ndiff --git a/qa/vector/src/main/java/org/elasticsearch/test/knn/KnnSearcher.java b/qa/vector/src/main/java/org/elasticsearch/test/knn/KnnSearcher.java\nindex c71aa21f5dd..4b41a2664aa 100644\n--- a/qa/vector/src/main/java/org/elasticsearch/test/knn/KnnSearcher.java\n+++ b/qa/vector/src/main/java/org/elasticsearch/test/knn/KnnSearcher.java\n@@ -52,6 +52,7 @@ import org.apache.lucene.search.TotalHits;\n import org.apache.lucene.search.Weight;\n import org.apache.lucene.store.Directory;\n import org.apache.lucene.store.FSDirectory;\n+import org.apache.lucene.store.MMapDirectory;\n import org.apache.lucene.util.BitSet;\n import org.apache.lucene.util.BitSetIterator;\n import org.apache.lucene.util.FixedBitSet;\n@@ -177,7 +178,7 @@ class KnnSearcher {\n             );\n             KnnIndexer.VectorReader targetReader = KnnIndexer.VectorReader.create(input, dim, vectorEncoding, offsetByteSize);\n             long startNS;\n-            try (Directory dir = KnnIndexer.getDirectory(indexPath)) {\n+            try (MMapDirectory dir = new MMapDirectory(indexPath)) {\n                 try (DirectoryReader reader = DirectoryReader.open(dir)) {\n                     IndexSearcher searcher = searchThreads > 1 ? new IndexSearcher(reader, executorService) : new IndexSearcher(reader);\n                     byte[] targetBytes = new byte[dim];\ndiff --git a/x-pack/plugin/otel-data/src/test/java/org/elasticsearch/xpack/oteldata/otlp/docbuilder/MetricDocumentBuilderTests.java b/x-pack/plugin/otel-data/src/test/java/org/elasticsearch/xpack/oteldata/otlp/docbuilder/MetricDocumentBuilderTests.java\nindex 01fa605d321..ae185f84953 100644\n--- a/x-pack/plugin/otel-data/src/test/java/org/elasticsearch/xpack/oteldata/otlp/docbuilder/MetricDocumentBuilderTests.java\n+++ b/x-pack/plugin/otel-data/src/test/java/org/elasticsearch/xpack/oteldata/otlp/docbuilder/MetricDocumentBuilderTests.java\n@@ -104,8 +104,8 @@ public class MetricDocumentBuilderTests extends ESTestCase {\n         HashMap<String, String> dynamicTemplates = documentBuilder.buildMetricDocument(builder, dataPointGroup);\n         ObjectPath doc = ObjectPath.createFromXContent(JsonXContent.jsonXContent, BytesReference.bytes(builder));\n \n-        assertThat(doc.evaluate(\"@timestamp\"), equalTo(TimeUnit.NANOSECONDS.toMillis(timestamp)));\n-        assertThat(doc.evaluate(\"start_timestamp\"), equalTo(TimeUnit.NANOSECONDS.toMillis(startTimestamp)));\n+        assertThat(doc.<Number>evaluate(\"@timestamp\").longValue(), equalTo(TimeUnit.NANOSECONDS.toMillis(timestamp)));\n+        assertThat(doc.<Number>evaluate(\"start_timestamp\").longValue(), equalTo(TimeUnit.NANOSECONDS.toMillis(startTimestamp)));\n         assertThat(doc.evaluate(\"data_stream.type\"), equalTo(\"metrics\"));\n         assertThat(doc.evaluate(\"data_stream.dataset\"), equalTo(\"generic.otel\"));\n         assertThat(doc.evaluate(\"data_stream.namespace\"), equalTo(\"default\"));"
}