{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 3640,
  "base_commit": "4155741f7f486537d4a5f7193d79098d523a6ae8",
  "head_commit": "8203d4dbcf8e61a79b72d5e9ac86bda0ff447e77",
  "judge_mode": "llm",
  "judge_model": "claude-sonnet-4-5",
  "scores": {
    "correctness": -0.8,
    "completeness": -0.9,
    "code_reuse": -0.6,
    "best_practices": -0.7,
    "unsolicited_docs": 1.0
  },
  "aggregate": -0.4,
  "rationale": "The agent's approach fundamentally differs from the ground truth and introduces critical issues. Ground truth creates a robust KeyedLock class with proper reference counting and ThreadLocal state to prevent lock leaks and ensure thread safety. The agent merely replaces the hash-based array with a ConcurrentMap but still uses plain Object locks with synchronized blocks, which doesn't address the core deadlock issue - different node IDs can still cause blocking when using shared lock objects. The agent is missing: (1) the entire KeyedLock.java implementation with atomic reference counting, (2) the conversion from synchronized blocks to acquire/release pattern in connectToChannels and all three disconnect methods, (3) the double-check pattern before acquiring locks, (4) comprehensive unit tests. The agent's cleanup of nodeLocks in three disconnect methods is a minor improvement but doesn't compensate for missing the fundamental architectural change. The connectLock method's putIfAbsent pattern still allows multiple threads to share the same lock object, perpetuating the original deadlock vulnerability. Without proper per-thread tracking and reference counting, locks will accumulate indefinitely in the map.",
  "edit_run_id": "7ad89f22",
  "judge_run_id": "3e164e1c",
  "ground_truth_patch": "diff --git a/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java b/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java\nnew file mode 100644\nindex 00000000000..6e279fbab0e\n--- /dev/null\n+++ b/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java\n@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to ElasticSearch and Shay Banon under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. ElasticSearch licenses this\n+ * file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.util.concurrent;\n+\n+import org.elasticsearch.ElasticSearchIllegalStateException;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * This class manages locks. Locks can be accessed with an identifier and are\n+ * created the first time they are acquired and removed if no thread hold the\n+ * lock. The latter is important to assure that the list of locks does not grow\n+ * infinitely.\n+ * \n+ * A Thread can acquire a lock only once.\n+ * \n+ * */\n+\n+public class KeyedLock<T> {\n+\n+    private final ConcurrentMap<T, KeyLock> map = new ConcurrentHashMap<T, KeyLock>();\n+\n+    private final ThreadLocal<KeyLock> threadLocal = new ThreadLocal<KeyedLock.KeyLock>();\n+\n+    public void acquire(T key) {\n+        while (true) {\n+            if (threadLocal.get() != null) {\n+                // if we are here, the thread already has the lock\n+                throw new ElasticSearchIllegalStateException(\"Lock already accquired in Thread\" + Thread.currentThread().getId()\n+                        + \" for key \" + key);\n+            }\n+            KeyLock perNodeLock = map.get(key);\n+            if (perNodeLock == null) {\n+                KeyLock newLock = new KeyLock();\n+                perNodeLock = map.putIfAbsent(key, newLock);\n+                if (perNodeLock == null) {\n+                    newLock.lock();\n+                    threadLocal.set(newLock);\n+                    return;\n+                }\n+            }\n+            assert perNodeLock != null;\n+            int i = perNodeLock.count.get();\n+            if (i > 0 && perNodeLock.count.compareAndSet(i, i + 1)) {\n+                perNodeLock.lock();\n+                threadLocal.set(perNodeLock);\n+                return;\n+            }\n+        }\n+    }\n+\n+    public void release(T key) {\n+        KeyLock lock = threadLocal.get();\n+        if (lock == null) {\n+            throw new ElasticSearchIllegalStateException(\"Lock not accquired\");\n+        }\n+        assert lock.isHeldByCurrentThread();\n+        assert lock == map.get(key);\n+        lock.unlock();\n+        threadLocal.set(null);\n+        int decrementAndGet = lock.count.decrementAndGet();\n+        if (decrementAndGet == 0) {\n+            map.remove(key, lock);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    private final static class KeyLock extends ReentrantLock {\n+        private final AtomicInteger count = new AtomicInteger(1);\n+    }\n+\n+    public boolean hasLockedKeys() {\n+        return !map.isEmpty();\n+    }\n+\n+}\ndiff --git a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\nindex 9764831da78..f641436b6ad 100644\n--- a/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\n+++ b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java\n@@ -44,6 +44,7 @@ import org.elasticsearch.common.transport.TransportAddress;\n import org.elasticsearch.common.unit.ByteSizeValue;\n import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.util.concurrent.EsExecutors;\n+import org.elasticsearch.common.util.concurrent.KeyedLock;\n import org.elasticsearch.monitor.jvm.JvmInfo;\n import org.elasticsearch.threadpool.ThreadPool;\n import org.elasticsearch.transport.*;\n@@ -151,7 +152,8 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n \n     private volatile BoundTransportAddress boundAddress;\n \n-    private final Object[] connectMutex;\n+    private final KeyedLock<String> connectionLock = new KeyedLock<String >();\n+    \n     // this lock is here to make sure we close this transport and disconnect all the client nodes\n     // connections while no connect operations is going on... (this might help with 100% CPU when stopping the transport?)\n     private final ReadWriteLock globalLock = new ReentrantReadWriteLock();\n@@ -167,11 +169,6 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n             System.setProperty(\"org.jboss.netty.epollBugWorkaround\", \"true\");\n         }\n \n-        this.connectMutex = new Object[500];\n-        for (int i = 0; i < connectMutex.length; i++) {\n-            connectMutex[i] = new Object();\n-        }\n-\n         this.workerCount = componentSettings.getAsInt(\"worker_count\", EsExecutors.boundedNumberOfProcessors() * 2);\n         this.bossCount = componentSettings.getAsInt(\"boss_count\", 1);\n         this.blockingServer = settings.getAsBoolean(\"transport.tcp.blocking_server\", settings.getAsBoolean(TCP_BLOCKING_SERVER, settings.getAsBoolean(TCP_BLOCKING, false)));\n@@ -591,15 +588,17 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n             if (!lifecycle.started()) {\n                 throw new ElasticSearchIllegalStateException(\"can't add nodes to a stopped transport\");\n             }\n-            synchronized (connectLock(node.id())) {\n+            NodeChannels nodeChannels = connectedNodes.get(node);\n+            if (nodeChannels != null) {\n+                return;\n+            } \n+            connectionLock.acquire(node.id());\n+            try {\n                 if (!lifecycle.started()) {\n                     throw new ElasticSearchIllegalStateException(\"can't add nodes to a stopped transport\");\n                 }\n                 try {\n-                    NodeChannels nodeChannels = connectedNodes.get(node);\n-                    if (nodeChannels != null) {\n-                        return;\n-                    }\n+\n \n                     if (light) {\n                         nodeChannels = connectToChannelsLight(node);\n@@ -629,6 +628,8 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n                 } catch (Exception e) {\n                     throw new ConnectTransportException(node, \"General node connection failure\", e);\n                 }\n+            } finally {\n+                connectionLock.release(node.id());\n             }\n         } finally {\n             globalLock.readLock().unlock();\n@@ -750,15 +751,18 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n \n     @Override\n     public void disconnectFromNode(DiscoveryNode node) {\n-        synchronized (connectLock(node.id())) {\n-            NodeChannels nodeChannels = connectedNodes.remove(node);\n-            if (nodeChannels != null) {\n-                try {\n-                    nodeChannels.close();\n-                } finally {\n-                    logger.debug(\"disconnected from [{}]\", node);\n-                    transportServiceAdapter.raiseNodeDisconnected(node);\n-                }\n+        NodeChannels nodeChannels = connectedNodes.remove(node);\n+        if (nodeChannels != null) {\n+            connectionLock.acquire(node.id());\n+            try {\n+                    try {\n+                        nodeChannels.close();\n+                    } finally {\n+                        logger.debug(\"disconnected from [{}]\", node);\n+                        transportServiceAdapter.raiseNodeDisconnected(node);\n+                    }\n+            } finally {\n+                connectionLock.release(node.id());\n             }\n         }\n     }\n@@ -767,15 +771,22 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n      * Disconnects from a node, only if the relevant channel is found to be part of the node channels.\n      */\n     private void disconnectFromNode(DiscoveryNode node, Channel channel, String reason) {\n-        synchronized (connectLock(node.id())) {\n-            NodeChannels nodeChannels = connectedNodes.get(node);\n-            if (nodeChannels != null && nodeChannels.hasChannel(channel)) {\n-                connectedNodes.remove(node);\n+        NodeChannels nodeChannels = connectedNodes.get(node);\n+        if (nodeChannels != null && nodeChannels.hasChannel(channel)) {\n+            connectionLock.acquire(node.id());\n+            if (!nodeChannels.hasChannel(channel)){ //might have been removed in the meanwhile, safety check\n+                assert !connectedNodes.containsKey(node);\n+            } else {\n                 try {\n-                    nodeChannels.close();\n+                    connectedNodes.remove(node);\n+                    try {\n+                        nodeChannels.close();\n+                    } finally {\n+                        logger.debug(\"disconnected from [{}], {}\", node, reason);\n+                        transportServiceAdapter.raiseNodeDisconnected(node);\n+                    }\n                 } finally {\n-                    logger.debug(\"disconnected from [{}], {}\", node, reason);\n-                    transportServiceAdapter.raiseNodeDisconnected(node);\n+                    connectionLock.release(node.id());\n                 }\n             }\n         }\n@@ -786,15 +797,22 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n      */\n     private void disconnectFromNodeChannel(Channel channel, Throwable failure) {\n         for (DiscoveryNode node : connectedNodes.keySet()) {\n-            synchronized (connectLock(node.id())) {\n-                NodeChannels nodeChannels = connectedNodes.get(node);\n-                if (nodeChannels != null && nodeChannels.hasChannel(channel)) {\n-                    connectedNodes.remove(node);\n+            NodeChannels nodeChannels = connectedNodes.get(node);\n+            if (nodeChannels != null && nodeChannels.hasChannel(channel)) {\n+                connectionLock.acquire(node.id());\n+                if (!nodeChannels.hasChannel(channel)) { //might have been removed in the meanwhile, safety check\n+                    assert !connectedNodes.containsKey(node);\n+                } else {\n                     try {\n-                        nodeChannels.close();\n+                        connectedNodes.remove(node);\n+                        try {\n+                            nodeChannels.close();\n+                        } finally {\n+                            logger.debug(\"disconnected from [{}] on channel failure\", failure, node);\n+                            transportServiceAdapter.raiseNodeDisconnected(node);\n+                        }\n                     } finally {\n-                        logger.debug(\"disconnected from [{}] on channel failure\", failure, node);\n-                        transportServiceAdapter.raiseNodeDisconnected(node);\n+                        connectionLock.release(node.id());\n                     }\n                 }\n             }\n@@ -809,15 +827,6 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem\n         return nodeChannels.channel(options.type());\n     }\n \n-    private Object connectLock(String nodeId) {\n-        int hash = nodeId.hashCode();\n-        // abs returns Integer.MIN_VALUE, so we need to protect against it...\n-        if (hash == Integer.MIN_VALUE) {\n-            hash = 0;\n-        }\n-        return connectMutex[Math.abs(hash) % connectMutex.length];\n-    }\n-\n     private class ChannelCloseListener implements ChannelFutureListener {\n \n         private final DiscoveryNode node;\ndiff --git a/src/test/java/org/elasticsearch/test/unit/transport/netty/KeyedLockTests.java b/src/test/java/org/elasticsearch/test/unit/transport/netty/KeyedLockTests.java\nnew file mode 100644\nindex 00000000000..a36c41e7493\n--- /dev/null\n+++ b/src/test/java/org/elasticsearch/test/unit/transport/netty/KeyedLockTests.java\n@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to ElasticSearch and Shay Banon under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. ElasticSearch licenses this\n+ * file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.test.unit.transport.netty;\n+\n+import org.elasticsearch.ElasticSearchIllegalStateException;\n+import org.elasticsearch.common.util.concurrent.KeyedLock;\n+import org.elasticsearch.test.integration.ElasticsearchTestCase;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.not;\n+\n+public class KeyedLockTests extends ElasticsearchTestCase {\n+\n+    @Test\n+    public void checkIfMapEmptyAfterLotsOfAcquireAndReleases() throws InterruptedException {\n+        ConcurrentHashMap<String, Integer> counter = new ConcurrentHashMap<String, Integer>();\n+        ConcurrentHashMap<String, AtomicInteger> safeCounter = new ConcurrentHashMap<String, AtomicInteger>();\n+        KeyedLock<String> connectionLock = new KeyedLock<String>();\n+        String[] names = new String[randomIntBetween(1, 40)];\n+        for (int i = 0; i < names.length; i++) {\n+            names[i] = randomRealisticUnicodeOfLengthBetween(10, 20);\n+        }\n+        CountDownLatch startLatch = new CountDownLatch(1);\n+        int numThreads = randomIntBetween(3, 10);\n+        Thread[] threads = new Thread[numThreads];\n+        for (int i = 0; i < numThreads; i++) {\n+            threads[i] = new AcquireAndReleaseThread(startLatch, connectionLock, names, counter, safeCounter);\n+        }\n+        for (int i = 0; i < numThreads; i++) {\n+            threads[i].start();\n+        }\n+        startLatch.countDown();\n+        for (int i = 0; i < numThreads; i++) {\n+            threads[i].join();\n+        }\n+        assertThat(connectionLock.hasLockedKeys(), equalTo(false));\n+\n+        Set<Entry<String, Integer>> entrySet = counter.entrySet();\n+        assertThat(counter.size(), equalTo(safeCounter.size()));\n+        for (Entry<String, Integer> entry : entrySet) {\n+            AtomicInteger atomicInteger = safeCounter.get(entry.getKey());\n+            assertThat(atomicInteger, not(Matchers.nullValue()));\n+            assertThat(atomicInteger.get(), equalTo(entry.getValue()));\n+        }\n+    }\n+\n+    @Test(expected = ElasticSearchIllegalStateException.class)\n+    public void checkCannotAcquireTwoLocks() throws InterruptedException {\n+        ConcurrentHashMap<String, Integer> counters = new ConcurrentHashMap<String, Integer>();\n+        ConcurrentHashMap<String, AtomicInteger> safeCounter = new ConcurrentHashMap<String, AtomicInteger>();\n+        KeyedLock<String> connectionLock = new KeyedLock<String>();\n+        String[] names = new String[randomIntBetween(1, 40)];\n+        connectionLock = new KeyedLock<String>();\n+        String name = randomRealisticUnicodeOfLength(atLeast(10));\n+        connectionLock.acquire(name);\n+        connectionLock.acquire(name);\n+    }\n+\n+    @Test(expected = ElasticSearchIllegalStateException.class)\n+    public void checkCannotReleaseUnacquiredLock() throws InterruptedException {\n+        ConcurrentHashMap<String, Integer> counters = new ConcurrentHashMap<String, Integer>();\n+        ConcurrentHashMap<String, AtomicInteger> safeCounter = new ConcurrentHashMap<String, AtomicInteger>();\n+        KeyedLock<String> connectionLock = new KeyedLock<String>();\n+        String[] names = new String[randomIntBetween(1, 40)];\n+        connectionLock = new KeyedLock<String>();\n+        String name = randomRealisticUnicodeOfLength(atLeast(10));\n+        connectionLock.release(name);\n+    }\n+\n+    public static class AcquireAndReleaseThread extends Thread {\n+        private CountDownLatch startLatch;\n+        KeyedLock<String> connectionLock;\n+        String[] names;\n+        ConcurrentHashMap<String, Integer> counter;\n+        ConcurrentHashMap<String, AtomicInteger> safeCounter;\n+\n+        public AcquireAndReleaseThread(CountDownLatch startLatch, KeyedLock<String> connectionLock, String[] names,\n+                ConcurrentHashMap<String, Integer> counter, ConcurrentHashMap<String, AtomicInteger> safeCounter) {\n+            this.startLatch = startLatch;\n+            this.connectionLock = connectionLock;\n+            this.names = names;\n+            this.counter = counter;\n+            this.safeCounter = safeCounter;\n+        }\n+\n+        public void run() {\n+            try {\n+                startLatch.await();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException();\n+            }\n+            int numRuns = atLeast(500);\n+            for (int i = 0; i < numRuns; i++) {\n+                String curName = names[randomInt(names.length - 1)];\n+                connectionLock.acquire(curName);\n+                try {\n+                    Integer integer = counter.get(curName);\n+                    if (integer == null) {\n+                        counter.put(curName, 1);\n+                    } else {\n+                        counter.put(curName, integer.intValue() + 1);\n+                    }\n+                } finally {\n+                    connectionLock.release(curName);\n+                }\n+                AtomicInteger atomicInteger = new AtomicInteger(0);\n+                AtomicInteger value = safeCounter.putIfAbsent(curName, atomicInteger);\n+                if (value == null) {\n+                    atomicInteger.incrementAndGet();\n+                } else {\n+                    value.incrementAndGet();\n+                }\n+            }\n+        }\n+    }\n+}"
}