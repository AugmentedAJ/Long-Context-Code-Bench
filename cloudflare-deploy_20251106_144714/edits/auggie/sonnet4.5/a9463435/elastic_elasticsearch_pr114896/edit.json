{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 114896,
  "base_commit": "419b74bf3a031a82020e1a659ccbcc05837bd39e",
  "runner": "auggie",
  "model": "sonnet4.5",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 729185,
  "patch_unified": "diff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/multivalue/MvPercentileTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/multivalue/MvPercentileTests.java\nindex 29cc959e..0a419d44 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/multivalue/MvPercentileTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/multivalue/MvPercentileTests.java\n@@ -17,6 +17,7 @@ import org.elasticsearch.xpack.esql.core.util.StringUtils;\n import org.elasticsearch.xpack.esql.expression.function.AbstractScalarFunctionTestCase;\n import org.elasticsearch.xpack.esql.expression.function.MultivalueTestCaseSupplier;\n import org.elasticsearch.xpack.esql.expression.function.TestCaseSupplier;\n+import org.hamcrest.Matcher;\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n@@ -28,6 +29,7 @@ import java.util.stream.Stream;\n import static org.elasticsearch.xpack.esql.core.type.DataType.DOUBLE;\n import static org.elasticsearch.xpack.esql.core.type.DataType.INTEGER;\n import static org.elasticsearch.xpack.esql.core.type.DataType.LONG;\n+import static org.hamcrest.Matchers.anyOf;\n import static org.hamcrest.Matchers.closeTo;\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.nullValue;\n@@ -375,27 +377,25 @@ public class MvPercentileTests extends AbstractScalarFunctionTestCase {\n                 var values = (List<Number>) fieldTypedData.data();\n                 var percentile = ((Number) percentileTypedData.data()).doubleValue();\n \n-                var expected = calculatePercentile(values, percentile);\n+                var expectedMatcher = makePercentileMatcher(values, percentile);\n \n                 return new TestCaseSupplier.TestCase(\n                     List.of(fieldTypedData, percentileTypedData),\n                     evaluatorString(fieldSupplier.type(), percentileSupplier.type()),\n                     fieldSupplier.type(),\n-                    expected instanceof Double expectedDouble\n-                        ? closeTo(expectedDouble, Math.abs(expectedDouble * 0.0000001))\n-                        : equalTo(expected)\n+                    expectedMatcher\n                 );\n             }\n         );\n     }\n \n-    private static Number calculatePercentile(List<Number> rawValues, double percentile) {\n+    private static Matcher<?> makePercentileMatcher(List<Number> rawValues, double percentile) {\n         if (rawValues.isEmpty() || percentile < 0 || percentile > 100) {\n-            return null;\n+            return nullValue();\n         }\n \n         if (rawValues.size() == 1) {\n-            return rawValues.get(0);\n+            return equalTo(rawValues.get(0));\n         }\n \n         int valueCount = rawValues.size();\n@@ -407,49 +407,62 @@ public class MvPercentileTests extends AbstractScalarFunctionTestCase {\n \n         if (rawValues.get(0) instanceof Integer) {\n             var values = rawValues.stream().mapToInt(Number::intValue).sorted().toArray();\n+            int expected;\n \n             if (percentile == 0) {\n-                return values[0];\n+                expected = values[0];\n             } else if (percentile == 100) {\n-                return values[valueCount - 1];\n+                expected = values[valueCount - 1];\n             } else {\n                 assert lowerIndex >= 0 && upperIndex < valueCount;\n                 var difference = (long) values[upperIndex] - values[lowerIndex];\n-                return values[lowerIndex] + (int) (fraction * difference);\n+                expected = values[lowerIndex] + (int) (fraction * difference);\n             }\n+\n+            return equalTo(expected);\n         }\n \n         if (rawValues.get(0) instanceof Long) {\n             var values = rawValues.stream().mapToLong(Number::longValue).sorted().toArray();\n+            long expected;\n \n             if (percentile == 0) {\n-                return values[0];\n+                expected = values[0];\n             } else if (percentile == 100) {\n-                return values[valueCount - 1];\n+                expected = values[valueCount - 1];\n             } else {\n                 assert lowerIndex >= 0 && upperIndex < valueCount;\n-                return calculatePercentile(fraction, new BigDecimal(values[lowerIndex]), new BigDecimal(values[upperIndex])).longValue();\n+                expected = calculatePercentile(fraction, BigDecimal.valueOf(values[lowerIndex]), BigDecimal.valueOf(values[upperIndex]))\n+                    .longValue();\n             }\n+\n+            // Double*bigLong may lose precision, we allow a small range\n+            return anyOf(equalTo(Math.min(expected, expected - 1)), equalTo(expected), equalTo(Math.max(expected, expected + 1)));\n         }\n \n         if (rawValues.get(0) instanceof Double) {\n             var values = rawValues.stream().mapToDouble(Number::doubleValue).sorted().toArray();\n+            double expected;\n \n             if (percentile == 0) {\n-                return values[0];\n+                expected = values[0];\n             } else if (percentile == 100) {\n-                return values[valueCount - 1];\n+                expected = values[valueCount - 1];\n             } else {\n                 assert lowerIndex >= 0 && upperIndex < valueCount;\n-                return calculatePercentile(fraction, new BigDecimal(values[lowerIndex]), new BigDecimal(values[upperIndex])).doubleValue();\n+                expected = calculatePercentile(fraction, new BigDecimal(values[lowerIndex]), new BigDecimal(values[upperIndex]))\n+                    .doubleValue();\n             }\n+\n+            return closeTo(expected, Math.abs(expected * 0.0000001));\n         }\n \n         throw new IllegalArgumentException(\"Unsupported type: \" + rawValues.get(0).getClass());\n     }\n \n     private static BigDecimal calculatePercentile(double fraction, BigDecimal lowerValue, BigDecimal upperValue) {\n-        return lowerValue.add(new BigDecimal(fraction).multiply(upperValue.subtract(lowerValue)));\n+        var difference = upperValue.subtract(lowerValue);\n+        return lowerValue.add(new BigDecimal(fraction).multiply(difference));\n     }\n \n     private static TestCaseSupplier.TypedData percentileWithType(Number value, DataType type) {",
  "logs_path": "auggie/sonnet4.5/a9463435/elastic_elasticsearch_pr114896/logs.jsonl",
  "errors": [],
  "edit_run_id": "a9463435",
  "test_label": "v0"
}