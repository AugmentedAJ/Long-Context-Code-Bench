{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 114872,
  "base_commit": "52587d6abfc8768b5930fe313c6241d9b9f25334",
  "runner": "auggie",
  "model": "sonnet4.5",
  "timeout_s": 1800,
  "status": "success",
  "elapsed_ms": 929272,
  "patch_unified": "diff --git a/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java b/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\nindex 16fedd9d..a7d4f24e 100644\n--- a/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\n+++ b/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\n@@ -44,9 +44,11 @@ import org.junit.ClassRule;\n \n import java.io.IOException;\n import java.util.Collection;\n+import java.util.List;\n import java.util.Map;\n \n import static org.elasticsearch.ingest.EnterpriseGeoIpTask.ENTERPRISE_GEOIP_DOWNLOADER;\n+import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_TOKEN_SETTING;\n import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING;\n import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n import static org.hamcrest.Matchers.equalTo;\n@@ -54,9 +56,13 @@ import static org.hamcrest.Matchers.equalTo;\n public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n \n     private static final String DATABASE_TYPE = \"GeoIP2-City\";\n+    private static final String IPINFO_DATABASE_TYPE = \"asn\";\n \n     @ClassRule\n-    public static final EnterpriseGeoIpHttpFixture fixture = new EnterpriseGeoIpHttpFixture(DATABASE_TYPE);\n+    public static final EnterpriseGeoIpHttpFixture fixture = new EnterpriseGeoIpHttpFixture(\n+        List.of(DATABASE_TYPE),\n+        List.of(IPINFO_DATABASE_TYPE)\n+    );\n \n     protected String getEndpoint() {\n         return fixture.getAddress();\n@@ -66,6 +72,7 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n     protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n         MockSecureSettings secureSettings = new MockSecureSettings();\n         secureSettings.setString(MAXMIND_LICENSE_KEY_SETTING.getKey(), \"license_key\");\n+        secureSettings.setString(IPINFO_TOKEN_SETTING.getKey(), \"token\");\n         Settings.Builder builder = Settings.builder();\n         builder.setSecureSettings(secureSettings)\n             .put(super.nodeSettings(nodeOrdinal, otherSettings))\n@@ -117,6 +124,57 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n         });\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    public void testIpinfoDownloader() throws Exception {\n+        /*\n+         * This test starts the enterprise geoip downloader task, and creates an ipinfo database configuration. Then it creates an ingest\n+         * pipeline that references that database, and ingests a single document using that pipeline. It then asserts that the document\n+         * was updated with information from the database.\n+         */\n+        EnterpriseGeoIpDownloader.DEFAULT_IPINFO_ENDPOINT = getEndpoint();\n+        final String pipelineName = \"enterprise_ipinfo_pipeline\";\n+        final String indexName = \"enterprise_ipinfo_test_index\";\n+        final String sourceField = \"ip\";\n+        final String targetField = \"ip-asn\";\n+\n+        startEnterpriseGeoIpDownloaderTask();\n+        admin().cluster()\n+            .execute(\n+                PutDatabaseConfigurationAction.INSTANCE,\n+                new PutDatabaseConfigurationAction.Request(\n+                    TimeValue.MAX_VALUE,\n+                    TimeValue.MAX_VALUE,\n+                    new DatabaseConfiguration(\"test_ipinfo\", IPINFO_DATABASE_TYPE, new DatabaseConfiguration.Ipinfo())\n+                )\n+            )\n+            .actionGet();\n+        ensureGreen(GeoIpDownloader.DATABASES_INDEX);\n+        assertBusy(() -> {\n+            SearchResponse searchResponse = client().search(new SearchRequest(GeoIpDownloader.DATABASES_INDEX)).actionGet();\n+            try {\n+                assertThat(searchResponse.getHits().getHits().length, equalTo(1));\n+            } finally {\n+                searchResponse.decRef();\n+            }\n+        });\n+        createGeoIpPipeline(pipelineName, IPINFO_DATABASE_TYPE, sourceField, targetField);\n+\n+        assertBusy(() -> {\n+            /*\n+             * We know that the .geoip_databases index has been populated, but we don't know for sure that the database has been pulled\n+             * down and made available on all nodes. So we run this ingest-and-check step in an assertBusy.\n+             */\n+            logger.info(\"Ingesting a test document\");\n+            String documentId = ingestDocument(indexName, pipelineName, sourceField);\n+            GetResponse getResponse = client().get(new GetRequest(indexName, documentId)).actionGet();\n+            Map<String, Object> returnedSource = getResponse.getSource();\n+            assertNotNull(returnedSource);\n+            Object targetFieldValue = returnedSource.get(targetField);\n+            assertNotNull(targetFieldValue);\n+            assertThat(((Map<String, Object>) targetFieldValue).get(\"organization_name\"), equalTo(\"Bredband2 AB\"));\n+        });\n+    }\n+\n     private void startEnterpriseGeoIpDownloaderTask() {\n         PersistentTasksService persistentTasksService = internalCluster().getInstance(PersistentTasksService.class);\n         persistentTasksService.sendStartRequest(\ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\nindex 3bbb0539..bbfed782 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\n@@ -39,6 +39,8 @@ import org.elasticsearch.persistent.PersistentTasksCustomMetadata.PersistentTask\n import org.elasticsearch.tasks.TaskId;\n import org.elasticsearch.threadpool.Scheduler;\n import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xcontent.XContentParser;\n+import org.elasticsearch.xcontent.XContentParserConfiguration;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.io.Closeable;\n@@ -57,6 +59,7 @@ import java.util.function.Supplier;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n+import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_SETTINGS_PREFIX;\n import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_SETTINGS_PREFIX;\n \n /**\n@@ -72,6 +75,9 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n     // a sha256 checksum followed by two spaces followed by an (ignored) file name\n     private static final Pattern SHA256_CHECKSUM_PATTERN = Pattern.compile(\"(\\\\w{64})\\\\s\\\\s(.*)\");\n \n+    // an md5 checksum\n+    private static final Pattern MD5_CHECKSUM_PATTERN = Pattern.compile(\"(\\\\w{32})\");\n+\n     // for overriding in tests\n     static String DEFAULT_MAXMIND_ENDPOINT = System.getProperty(\n         MAXMIND_SETTINGS_PREFIX + \"endpoint.default\", //\n@@ -80,6 +86,14 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n     // n.b. a future enhancement might be to allow for a MAXMIND_ENDPOINT_SETTING, but\n     // at the moment this is an unsupported system property for use in tests (only)\n \n+    // for overriding in tests\n+    static String DEFAULT_IPINFO_ENDPOINT = System.getProperty(\n+        IPINFO_SETTINGS_PREFIX + \"endpoint.default\", //\n+        \"https://ipinfo.io/data\"\n+    );\n+    // n.b. a future enhancement might be to allow for an IPINFO_ENDPOINT_SETTING, but\n+    // at the moment this is an unsupported system property for use in tests (only)\n+\n     static final String DATABASES_INDEX = \".geoip_databases\";\n     static final int MAX_CHUNK_SIZE = 1024 * 1024;\n \n@@ -444,16 +458,15 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n         }\n     }\n \n-    @Nullable\n     private ProviderDownload downloaderFor(DatabaseConfiguration database) {\n-        if (database.provider() instanceof DatabaseConfiguration.Maxmind) {\n-            return new MaxmindDownload(database.name(), (DatabaseConfiguration.Maxmind) database.provider());\n-        } else if (database.provider() instanceof DatabaseConfiguration.Ipinfo) {\n-            // as a temporary implementation detail, null here means 'not actually supported *just yet*'\n-            return null;\n+        if (database.provider() instanceof DatabaseConfiguration.Maxmind maxmind) {\n+            return new MaxmindDownload(database.name(), maxmind);\n+        } else if (database.provider() instanceof DatabaseConfiguration.Ipinfo ipinfo) {\n+            return new IpinfoDownload(database.name(), ipinfo);\n         } else {\n-            assert false : \"Attempted to use database downloader with unsupported provider type [\" + database.provider().getClass() + \"]\";\n-            return null;\n+            throw new IllegalArgumentException(\n+                Strings.format(\"Unexpected provider [%s] for configuration [%s]\", database.provider().getClass(), database.id())\n+            );\n         }\n     }\n \n@@ -488,7 +501,7 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n \n         @Override\n         public boolean validCredentials() {\n-            return auth.get() != null;\n+            return auth != null && auth.get() != null;\n         }\n \n         @Override\n@@ -529,7 +542,101 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n \n         @Override\n         public void close() throws IOException {\n-            auth.close();\n+            if (auth != null) auth.close();\n+        }\n+    }\n+\n+    class IpinfoDownload implements ProviderDownload {\n+\n+        final String name;\n+        final DatabaseConfiguration.Ipinfo ipinfo;\n+        HttpClient.PasswordAuthenticationHolder auth;\n+\n+        IpinfoDownload(String name, DatabaseConfiguration.Ipinfo ipinfo) {\n+            this.name = name;\n+            this.ipinfo = ipinfo;\n+            this.auth = buildCredentials();\n+        }\n+\n+        @Override\n+        public HttpClient.PasswordAuthenticationHolder buildCredentials() {\n+            final char[] tokenChars = tokenProvider.apply(\"ipinfo\");\n+\n+            // if the token is missing or empty, return null as 'no auth'\n+            if (tokenChars == null || tokenChars.length == 0) {\n+                return null;\n+            }\n+\n+            // ipinfo uses the token as the username component of basic auth, see https://ipinfo.io/developers#authentication\n+            return new HttpClient.PasswordAuthenticationHolder(new String(tokenChars), new char[] {});\n+        }\n+\n+        @Override\n+        public boolean validCredentials() {\n+            return auth != null && auth.get() != null;\n+        }\n+\n+        private static final Set<String> FREE_DATABASES = Set.of(\"asn\", \"country\", \"country_asn\");\n+\n+        @Override\n+        public String url(String suffix) {\n+            // note: the 'free' databases are in the sub-path 'free/' in terms of the download endpoint\n+            final String internalName;\n+            if (FREE_DATABASES.contains(name)) {\n+                internalName = \"free/\" + name;\n+            } else {\n+                internalName = name;\n+            }\n+\n+            // reminder, we're passing the ipinfo token as the username part of http basic auth,\n+            // see https://ipinfo.io/developers#authentication\n+\n+            String endpointPattern = DEFAULT_IPINFO_ENDPOINT;\n+            if (endpointPattern.contains(\"%\")) {\n+                throw new IllegalArgumentException(\"Invalid endpoint [\" + endpointPattern + \"]\");\n+            }\n+            if (endpointPattern.endsWith(\"/\") == false) {\n+                endpointPattern += \"/\";\n+            }\n+            endpointPattern += \"%s.%s\";\n+\n+            // at this point the pattern looks like this (in the default case):\n+            // https://ipinfo.io/data/%s.%s\n+            // also see https://ipinfo.io/developers/database-download,\n+            // and https://ipinfo.io/developers/database-filename-reference for more\n+\n+            return Strings.format(endpointPattern, internalName, suffix);\n+        }\n+\n+        @Override\n+        public Checksum checksum() throws IOException {\n+            final String checksumJsonUrl = this.url(\"mmdb/checksums\"); // a minor abuse of the idea of a 'suffix', :shrug:\n+            byte[] data = httpClient.getBytes(auth.get(), checksumJsonUrl); // this throws if the auth is bad\n+            Map<String, Object> checksums;\n+            try (XContentParser parser = XContentType.JSON.xContent().createParser(XContentParserConfiguration.EMPTY, data)) {\n+                checksums = parser.map();\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            String md5 = ((Map<String, String>) checksums.get(\"checksums\")).get(\"md5\");\n+            logger.info(\"checksum was [{}]\", md5);\n+\n+            var matcher = MD5_CHECKSUM_PATTERN.matcher(md5);\n+            boolean match = matcher.matches();\n+            if (match == false) {\n+                throw new RuntimeException(\"Unexpected md5 response from [\" + checksumJsonUrl + \"]\");\n+            }\n+            return Checksum.md5(md5);\n+        }\n+\n+        @Override\n+        public CheckedSupplier<InputStream, IOException> download() {\n+            final String mmdbUrl = this.url(\"mmdb\");\n+            return () -> httpClient.get(auth.get(), mmdbUrl);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (auth != null) auth.close();\n         }\n     }\n \ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\nindex 5214c0e4..ae9bb109 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\n@@ -54,11 +54,15 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n \n     static final String MAXMIND_SETTINGS_PREFIX = \"ingest.geoip.downloader.maxmind.\";\n \n+    static final String IPINFO_SETTINGS_PREFIX = \"ingest.ip_location.downloader.ipinfo.\";\n+\n     public static final Setting<SecureString> MAXMIND_LICENSE_KEY_SETTING = SecureSetting.secureString(\n         MAXMIND_SETTINGS_PREFIX + \"license_key\",\n         null\n     );\n \n+    public static final Setting<SecureString> IPINFO_TOKEN_SETTING = SecureSetting.secureString(IPINFO_SETTINGS_PREFIX + \"token\", null);\n+\n     private final Client client;\n     private final HttpClient httpClient;\n     private final ClusterService clusterService;\n@@ -106,6 +110,10 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n             if (cachedSecureSettings.getSettingNames().contains(MAXMIND_LICENSE_KEY_SETTING.getKey())) {\n                 token = cachedSecureSettings.getString(MAXMIND_LICENSE_KEY_SETTING.getKey()).getChars();\n             }\n+        } else if (type.equals(\"ipinfo\")) {\n+            if (cachedSecureSettings.getSettingNames().contains(IPINFO_TOKEN_SETTING.getKey())) {\n+                token = cachedSecureSettings.getString(IPINFO_TOKEN_SETTING.getKey()).getChars();\n+            }\n         }\n         return token;\n     }\n@@ -166,7 +174,7 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n         // `SecureSettings` are available here! cache them as they will be needed\n         // whenever dynamic cluster settings change and we have to rebuild the accounts\n         try {\n-            this.cachedSecureSettings = extractSecureSettings(settings, List.of(MAXMIND_LICENSE_KEY_SETTING));\n+            this.cachedSecureSettings = extractSecureSettings(settings, List.of(MAXMIND_LICENSE_KEY_SETTING, IPINFO_TOKEN_SETTING));\n         } catch (GeneralSecurityException e) {\n             // rethrow as a runtime exception, there's logging higher up the call chain around ReloadablePlugin\n             throw new ElasticsearchException(\"Exception while reloading enterprise geoip download task executor\", e);\ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\nindex cc0bec58..3107f0be 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\n@@ -112,7 +112,8 @@ public class IngestGeoIpPlugin extends Plugin\n             GeoIpDownloaderTaskExecutor.ENABLED_SETTING,\n             GeoIpDownloader.ENDPOINT_SETTING,\n             GeoIpDownloaderTaskExecutor.POLL_INTERVAL_SETTING,\n-            EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING\n+            EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING,\n+            EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_TOKEN_SETTING\n         );\n     }\n \ndiff --git a/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java b/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\nindex 88c37409..e1cd127b 100644\n--- a/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\n+++ b/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\n@@ -488,6 +488,36 @@ public class EnterpriseGeoIpDownloaderTests extends ESTestCase {\n         }\n     }\n \n+    public void testIpinfoUrls() {\n+        // a 'free' database like 'asn' has 'free/' in the url (automatically)\n+        final EnterpriseGeoIpDownloader.IpinfoDownload download = geoIpDownloader.new IpinfoDownload(\n+            \"asn\", new DatabaseConfiguration.Ipinfo()\n+        );\n+\n+        {\n+            String url = \"https://ipinfo.io/data/free/asn.mmdb\";\n+            assertThat(download.url(\"mmdb\"), equalTo(url));\n+        }\n+        {\n+            String url = \"https://ipinfo.io/data/free/asn.mmdb/checksums\";\n+            assertThat(download.url(\"mmdb/checksums\"), equalTo(url));\n+        }\n+\n+        // but a non-'free' database like 'standard_asn' does not\n+        final EnterpriseGeoIpDownloader.IpinfoDownload download2 = geoIpDownloader.new IpinfoDownload(\n+            \"standard_asn\", new DatabaseConfiguration.Ipinfo()\n+        );\n+\n+        {\n+            String url = \"https://ipinfo.io/data/standard_asn.mmdb\";\n+            assertThat(download2.url(\"mmdb\"), equalTo(url));\n+        }\n+        {\n+            String url = \"https://ipinfo.io/data/standard_asn.mmdb/checksums\";\n+            assertThat(download2.url(\"mmdb/checksums\"), equalTo(url));\n+        }\n+    }\n+\n     private static class MockClient extends NoOpClient {\n \n         private final Map<ActionType<?>, BiConsumer<? extends ActionRequest, ? extends ActionListener<?>>> handlers = new HashMap<>();\ndiff --git a/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java b/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\nindex 59205aa5..8c6dfae8 100644\n--- a/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\n+++ b/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\n@@ -11,20 +11,17 @@ package fixture.geoip;\n \n import com.sun.net.httpserver.HttpServer;\n \n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.hash.MessageDigests;\n import org.junit.rules.ExternalResource;\n \n-import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n-import java.io.UncheckedIOException;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n import java.security.MessageDigest;\n+import java.util.List;\n \n /**\n  * This fixture is used to simulate a maxmind-provided server for downloading maxmind geoip database files from the\n@@ -32,21 +29,17 @@ import java.security.MessageDigest;\n  */\n public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n \n-    private final Path source;\n-    private final String[] databaseTypes;\n+    private final List<String> maxmindDatabaseTypes;\n+    private final List<String> ipinfoDatabaseTypes;\n     private HttpServer server;\n \n     /*\n-     * The values in databaseTypes must be in DatabaseConfiguration.MAXMIND_NAMES, and must be one of the databases copied in the\n-     * copyFiles method of thisi class.\n+     * The values in maxmindDatabaseTypes must be in DatabaseConfiguration.MAXMIND_NAMES, and the ipinfoDatabaseTypes\n+     * must be in DatabaseConfiguration.IPINFO_NAMES.\n      */\n-    public EnterpriseGeoIpHttpFixture(String... databaseTypes) {\n-        this.databaseTypes = databaseTypes;\n-        try {\n-            this.source = Files.createTempDirectory(\"source\");\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n+    public EnterpriseGeoIpHttpFixture(List<String> maxmindDatabaseTypes, List<String> ipinfoDatabaseTypes) {\n+        this.maxmindDatabaseTypes = List.copyOf(maxmindDatabaseTypes);\n+        this.ipinfoDatabaseTypes = List.copyOf(ipinfoDatabaseTypes);\n     }\n \n     public String getAddress() {\n@@ -55,7 +48,6 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n \n     @Override\n     protected void before() throws Throwable {\n-        copyFiles();\n         this.server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n \n         // for expediency reasons, it is handy to have this test fixture be able to serve the dual purpose of actually stubbing\n@@ -70,14 +62,17 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n         });\n \n         // register the file types for the download fixture\n-        for (String databaseType : databaseTypes) {\n-            createContextForEnterpriseDatabase(databaseType);\n+        for (String databaseType : maxmindDatabaseTypes) {\n+            createContextForMaxmindDatabase(databaseType);\n+        }\n+        for (String databaseType : ipinfoDatabaseTypes) {\n+            createContextForIpinfoDatabase(databaseType);\n         }\n \n         server.start();\n     }\n \n-    private void createContextForEnterpriseDatabase(String databaseType) {\n+    private void createContextForMaxmindDatabase(String databaseType) {\n         this.server.createContext(\"/\" + databaseType + \"/download\", exchange -> {\n             exchange.sendResponseHeaders(200, 0);\n             if (exchange.getRequestURI().toString().contains(\"sha256\")) {\n@@ -103,18 +98,35 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n         });\n     }\n \n+    private void createContextForIpinfoDatabase(String databaseType) {\n+        this.server.createContext(\"/free/\" + databaseType + \".mmdb\", exchange -> {\n+            exchange.sendResponseHeaders(200, 0);\n+            if (exchange.getRequestURI().toString().contains(\"checksum\")) {\n+                MessageDigest md5 = MessageDigests.md5();\n+                try (InputStream in = fixtureStream(\"/ipinfo-fixture/ip_\" + databaseType + \"_sample.mmdb\")) {\n+                    md5.update(in.readAllBytes());\n+                }\n+                exchange.getResponseBody().write(Strings.format(\"\"\"\n+                    { \"checksums\": { \"md5\": \"%s\" } }\n+                    \"\"\", MessageDigests.toHexString(md5.digest())).getBytes(StandardCharsets.UTF_8));\n+            } else {\n+                try (\n+                    OutputStream out = exchange.getResponseBody();\n+                    InputStream in = fixtureStream(\"/ipinfo-fixture/ip_\" + databaseType + \"_sample.mmdb\")\n+                ) {\n+                    in.transferTo(out);\n+                }\n+            }\n+            exchange.getResponseBody().close();\n+        });\n+    }\n+\n+    private static InputStream fixtureStream(String name) {\n+        return GeoIpHttpFixture.class.getResourceAsStream(name);\n+    }\n+\n     @Override\n     protected void after() {\n         server.stop(0);\n     }\n-\n-    private void copyFiles() throws Exception {\n-        for (String databaseType : databaseTypes) {\n-            Files.copy(\n-                GeoIpHttpFixture.class.getResourceAsStream(\"/geoip-fixture/GeoIP2-City.tgz\"),\n-                source.resolve(databaseType + \".tgz\"),\n-                StandardCopyOption.REPLACE_EXISTING\n-            );\n-        }\n-    }\n }",
  "logs_path": "auggie/sonnet4.5/a9463435/elastic_elasticsearch_pr114872/logs.jsonl",
  "errors": [],
  "edit_run_id": "a9463435",
  "test_label": "v0"
}