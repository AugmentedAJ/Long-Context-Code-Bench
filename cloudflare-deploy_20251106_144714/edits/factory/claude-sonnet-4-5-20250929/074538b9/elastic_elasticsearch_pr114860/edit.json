{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 114860,
  "base_commit": "8c475a23c9aac193f8360fc9d78dd98e9dc690b8",
  "runner": "factory",
  "model": "claude-sonnet-4-5-20250929",
  "timeout_s": 7200,
  "status": "success",
  "elapsed_ms": 1134574,
  "patch_unified": "diff --git a/x-pack/plugin/esql/qa/testFixtures/src/main/resources/spatial.csv-spec b/x-pack/plugin/esql/qa/testFixtures/src/main/resources/spatial.csv-spec\nindex b72c8bcb..d5a18373 100644\n--- a/x-pack/plugin/esql/qa/testFixtures/src/main/resources/spatial.csv-spec\n+++ b/x-pack/plugin/esql/qa/testFixtures/src/main/resources/spatial.csv-spec\n@@ -2399,3 +2399,87 @@ wkt:keyword                |pt:cartesian_point\n \"POINT(111)\"               |null\n // end::to_cartesianpoint-str-parse-error-result[]\n ;\n+\n+###############################################\n+# Tests for ST_DISTANCE with multi-valued fields\n+\n+stDistanceGeoMultiValueFromSource\n+required_capability: st_distance\n+required_capability: st_distance_support_multivalues\n+\n+FROM multivalue_points\n+| EVAL distance = ST_DISTANCE(location, TO_GEOPOINT(\"POINT(0 0)\"))\n+| KEEP id, location, distance\n+| SORT id\n+;\n+\n+id:l | location:geo_point                       | distance:d\n+0    | [\"POINT(5 5)\", \"POINT(-5 5)\"]            | 710613.6157522688\n+1    | [\"POINT(0 1)\",\"POINT(1 0)\"]              | 0.0\n+2    | \"POINT(9 9)\"                             | 1408165.8417652015\n+3    | [\"POINT(-9 -9)\",\"POINT(9 9)\"]            | 1408165.8417652015\n+4    | [\"POINT(5 5)\", \"POINT(15 15)\"]           | 710613.6157522688\n+5    | [\"POINT(0 0)\",\"POINT(11 11)\"]            | 0.0\n+6    | [\"POINT(-9 -19)\",\"POINT(9 9)\"]           | 1408165.8417652015\n+7    | [\"POINT(5 15)\", \"POINT(15 5)\"]           | 710613.6157522688\n+8    | [\"POINT(0 11)\",\"POINT(11 0)\"]            | 0.0\n+9    | \"POINT(19 9)\"                            | 2218750.0992821907\n+10   | [\"POINT(-9 -19)\",\"POINT(19 9)\"]          | 1408165.8417652015\n+11   | [\"POINT(0 0)\", \"POINT(55 55)\", \"POINT(-55 -55)\"] | 0.0\n+12   | [\"POINT(0 0)\", \"POINT(55 55)\", \"POINT(-55 -55)\"] | 0.0\n+;\n+\n+stDistanceGeoMultiValueWhereClause\n+required_capability: st_distance\n+required_capability: st_distance_support_multivalues\n+\n+FROM multivalue_points\n+| WHERE ST_DISTANCE(location, TO_GEOPOINT(\"POINT(0 0)\")) < 1000000\n+| EVAL distance = ST_DISTANCE(location, TO_GEOPOINT(\"POINT(0 0)\"))\n+| KEEP id, location, distance\n+| SORT id\n+;\n+\n+id:l | location:geo_point                       | distance:d\n+1    | [\"POINT(0 1)\",\"POINT(1 0)\"]              | 0.0\n+5    | [\"POINT(0 0)\",\"POINT(11 11)\"]            | 0.0\n+8    | [\"POINT(0 11)\",\"POINT(11 0)\"]            | 0.0\n+11   | [\"POINT(0 0)\", \"POINT(55 55)\", \"POINT(-55 -55)\"] | 0.0\n+12   | [\"POINT(0 0)\", \"POINT(55 55)\", \"POINT(-55 -55)\"] | 0.0\n+;\n+\n+stDistanceCartesianMultiValueFromSource\n+required_capability: st_distance\n+required_capability: st_distance_support_multivalues\n+\n+ROW points = [TO_CARTESIANPOINT(\"POINT(10 10)\"), TO_CARTESIANPOINT(\"POINT(20 20)\")]\n+| EVAL distance = ST_DISTANCE(points, TO_CARTESIANPOINT(\"POINT(0 0)\"))\n+;\n+\n+points:cartesian_point                | distance:d\n+[\"POINT(10.0 10.0)\", \"POINT(20.0 20.0)\"] | 14.142135623730951\n+;\n+\n+stDistanceCartesianMultiValueBothSides\n+required_capability: st_distance\n+required_capability: st_distance_support_multivalues\n+\n+ROW left = [TO_CARTESIANPOINT(\"POINT(10 10)\"), TO_CARTESIANPOINT(\"POINT(30 30)\")], right = [TO_CARTESIANPOINT(\"POINT(15 15)\"), TO_CARTESIANPOINT(\"POINT(25 25)\")]\n+| EVAL distance = ST_DISTANCE(left, right)\n+;\n+\n+left:cartesian_point                       | right:cartesian_point                      | distance:d\n+[\"POINT(10.0 10.0)\", \"POINT(30.0 30.0)\"]   | [\"POINT(15.0 15.0)\", \"POINT(25.0 25.0)\"]  | 7.0710678118654755\n+;\n+\n+stDistanceGeoMultiValueWithConstant\n+required_capability: st_distance\n+required_capability: st_distance_support_multivalues\n+\n+ROW points = [TO_GEOPOINT(\"POINT(0 10)\"), TO_GEOPOINT(\"POINT(0 20)\")]\n+| EVAL distance = ROUND(ST_DISTANCE(points, TO_GEOPOINT(\"POINT(0 0)\"))/1000, 2)\n+;\n+\n+points:geo_point                          | distance:d\n+[\"POINT(0.0 10.0)\", \"POINT(0.0 20.0)\"]    | 1105.85\n+;\ndiff --git a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianPointDocValuesAndConstantEvaluator.java b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianPointDocValuesAndConstantEvaluator.java\nindex a3fc2fad..3224cf35 100644\n--- a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianPointDocValuesAndConstantEvaluator.java\n+++ b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianPointDocValuesAndConstantEvaluator.java\n@@ -10,7 +10,6 @@ import java.lang.String;\n import org.elasticsearch.compute.data.Block;\n import org.elasticsearch.compute.data.DoubleBlock;\n import org.elasticsearch.compute.data.LongBlock;\n-import org.elasticsearch.compute.data.LongVector;\n import org.elasticsearch.compute.data.Page;\n import org.elasticsearch.compute.operator.DriverContext;\n import org.elasticsearch.compute.operator.EvalOperator;\n@@ -45,44 +44,23 @@ public final class StDistanceCartesianPointDocValuesAndConstantEvaluator impleme\n   @Override\n   public Block eval(Page page) {\n     try (LongBlock leftValueBlock = (LongBlock) leftValue.eval(page)) {\n-      LongVector leftValueVector = leftValueBlock.asVector();\n-      if (leftValueVector == null) {\n-        return eval(page.getPositionCount(), leftValueBlock);\n-      }\n-      return eval(page.getPositionCount(), leftValueVector);\n+      return eval(page.getPositionCount(), leftValueBlock);\n     }\n   }\n \n   public DoubleBlock eval(int positionCount, LongBlock leftValueBlock) {\n     try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n       position: for (int p = 0; p < positionCount; p++) {\n-        if (leftValueBlock.isNull(p)) {\n-          result.appendNull();\n-          continue position;\n+        boolean allBlocksAreNulls = true;\n+        if (!leftValueBlock.isNull(p)) {\n+          allBlocksAreNulls = false;\n         }\n-        if (leftValueBlock.getValueCount(p) != 1) {\n-          if (leftValueBlock.getValueCount(p) > 1) {\n-            warnings().registerException(new IllegalArgumentException(\"single-value function encountered multi-value\"));\n-          }\n+        if (allBlocksAreNulls) {\n           result.appendNull();\n           continue position;\n         }\n         try {\n-          result.appendDouble(StDistance.processCartesianPointDocValuesAndConstant(leftValueBlock.getLong(leftValueBlock.getFirstValueIndex(p)), this.rightValue));\n-        } catch (IllegalArgumentException e) {\n-          warnings().registerException(e);\n-          result.appendNull();\n-        }\n-      }\n-      return result.build();\n-    }\n-  }\n-\n-  public DoubleBlock eval(int positionCount, LongVector leftValueVector) {\n-    try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n-      position: for (int p = 0; p < positionCount; p++) {\n-        try {\n-          result.appendDouble(StDistance.processCartesianPointDocValuesAndConstant(leftValueVector.getLong(p), this.rightValue));\n+          StDistance.processCartesianPointDocValuesAndConstant(result, p, leftValueBlock, this.rightValue);\n         } catch (IllegalArgumentException e) {\n           warnings().registerException(e);\n           result.appendNull();\ndiff --git a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianPointDocValuesAndSourceEvaluator.java b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianPointDocValuesAndSourceEvaluator.java\nindex 1da16443..5a62c1b2 100644\n--- a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianPointDocValuesAndSourceEvaluator.java\n+++ b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianPointDocValuesAndSourceEvaluator.java\n@@ -7,14 +7,10 @@ package org.elasticsearch.xpack.esql.expression.function.scalar.spatial;\n import java.lang.IllegalArgumentException;\n import java.lang.Override;\n import java.lang.String;\n-import org.apache.lucene.util.BytesRef;\n import org.elasticsearch.compute.data.Block;\n import org.elasticsearch.compute.data.BytesRefBlock;\n-import org.elasticsearch.compute.data.BytesRefVector;\n import org.elasticsearch.compute.data.DoubleBlock;\n-import org.elasticsearch.compute.data.DoubleVector;\n import org.elasticsearch.compute.data.LongBlock;\n-import org.elasticsearch.compute.data.LongVector;\n import org.elasticsearch.compute.data.Page;\n import org.elasticsearch.compute.operator.DriverContext;\n import org.elasticsearch.compute.operator.EvalOperator;\n@@ -50,15 +46,7 @@ public final class StDistanceCartesianPointDocValuesAndSourceEvaluator implement\n   public Block eval(Page page) {\n     try (LongBlock leftValueBlock = (LongBlock) leftValue.eval(page)) {\n       try (BytesRefBlock rightValueBlock = (BytesRefBlock) rightValue.eval(page)) {\n-        LongVector leftValueVector = leftValueBlock.asVector();\n-        if (leftValueVector == null) {\n-          return eval(page.getPositionCount(), leftValueBlock, rightValueBlock);\n-        }\n-        BytesRefVector rightValueVector = rightValueBlock.asVector();\n-        if (rightValueVector == null) {\n-          return eval(page.getPositionCount(), leftValueBlock, rightValueBlock);\n-        }\n-        return eval(page.getPositionCount(), leftValueVector, rightValueVector).asBlock();\n+        return eval(page.getPositionCount(), leftValueBlock, rightValueBlock);\n       }\n     }\n   }\n@@ -66,42 +54,24 @@ public final class StDistanceCartesianPointDocValuesAndSourceEvaluator implement\n   public DoubleBlock eval(int positionCount, LongBlock leftValueBlock,\n       BytesRefBlock rightValueBlock) {\n     try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n-      BytesRef rightValueScratch = new BytesRef();\n       position: for (int p = 0; p < positionCount; p++) {\n-        if (leftValueBlock.isNull(p)) {\n-          result.appendNull();\n-          continue position;\n+        boolean allBlocksAreNulls = true;\n+        if (!leftValueBlock.isNull(p)) {\n+          allBlocksAreNulls = false;\n         }\n-        if (leftValueBlock.getValueCount(p) != 1) {\n-          if (leftValueBlock.getValueCount(p) > 1) {\n-            warnings().registerException(new IllegalArgumentException(\"single-value function encountered multi-value\"));\n-          }\n-          result.appendNull();\n-          continue position;\n+        if (!rightValueBlock.isNull(p)) {\n+          allBlocksAreNulls = false;\n         }\n-        if (rightValueBlock.isNull(p)) {\n+        if (allBlocksAreNulls) {\n           result.appendNull();\n           continue position;\n         }\n-        if (rightValueBlock.getValueCount(p) != 1) {\n-          if (rightValueBlock.getValueCount(p) > 1) {\n-            warnings().registerException(new IllegalArgumentException(\"single-value function encountered multi-value\"));\n-          }\n+        try {\n+          StDistance.processCartesianPointDocValuesAndSource(result, p, leftValueBlock, rightValueBlock);\n+        } catch (IllegalArgumentException e) {\n+          warnings().registerException(e);\n           result.appendNull();\n-          continue position;\n         }\n-        result.appendDouble(StDistance.processCartesianPointDocValuesAndSource(leftValueBlock.getLong(leftValueBlock.getFirstValueIndex(p)), rightValueBlock.getBytesRef(rightValueBlock.getFirstValueIndex(p), rightValueScratch)));\n-      }\n-      return result.build();\n-    }\n-  }\n-\n-  public DoubleVector eval(int positionCount, LongVector leftValueVector,\n-      BytesRefVector rightValueVector) {\n-    try(DoubleVector.FixedBuilder result = driverContext.blockFactory().newDoubleVectorFixedBuilder(positionCount)) {\n-      BytesRef rightValueScratch = new BytesRef();\n-      position: for (int p = 0; p < positionCount; p++) {\n-        result.appendDouble(p, StDistance.processCartesianPointDocValuesAndSource(leftValueVector.getLong(p), rightValueVector.getBytesRef(p, rightValueScratch)));\n       }\n       return result.build();\n     }\ndiff --git a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianSourceAndConstantEvaluator.java b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianSourceAndConstantEvaluator.java\nindex 61329ad7..0901cdde 100644\n--- a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianSourceAndConstantEvaluator.java\n+++ b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianSourceAndConstantEvaluator.java\n@@ -8,10 +8,8 @@ import java.io.IOException;\n import java.lang.IllegalArgumentException;\n import java.lang.Override;\n import java.lang.String;\n-import org.apache.lucene.util.BytesRef;\n import org.elasticsearch.compute.data.Block;\n import org.elasticsearch.compute.data.BytesRefBlock;\n-import org.elasticsearch.compute.data.BytesRefVector;\n import org.elasticsearch.compute.data.DoubleBlock;\n import org.elasticsearch.compute.data.Page;\n import org.elasticsearch.compute.operator.DriverContext;\n@@ -47,46 +45,23 @@ public final class StDistanceCartesianSourceAndConstantEvaluator implements Eval\n   @Override\n   public Block eval(Page page) {\n     try (BytesRefBlock leftValueBlock = (BytesRefBlock) leftValue.eval(page)) {\n-      BytesRefVector leftValueVector = leftValueBlock.asVector();\n-      if (leftValueVector == null) {\n-        return eval(page.getPositionCount(), leftValueBlock);\n-      }\n-      return eval(page.getPositionCount(), leftValueVector);\n+      return eval(page.getPositionCount(), leftValueBlock);\n     }\n   }\n \n   public DoubleBlock eval(int positionCount, BytesRefBlock leftValueBlock) {\n     try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n-      BytesRef leftValueScratch = new BytesRef();\n       position: for (int p = 0; p < positionCount; p++) {\n-        if (leftValueBlock.isNull(p)) {\n-          result.appendNull();\n-          continue position;\n+        boolean allBlocksAreNulls = true;\n+        if (!leftValueBlock.isNull(p)) {\n+          allBlocksAreNulls = false;\n         }\n-        if (leftValueBlock.getValueCount(p) != 1) {\n-          if (leftValueBlock.getValueCount(p) > 1) {\n-            warnings().registerException(new IllegalArgumentException(\"single-value function encountered multi-value\"));\n-          }\n+        if (allBlocksAreNulls) {\n           result.appendNull();\n           continue position;\n         }\n         try {\n-          result.appendDouble(StDistance.processCartesianSourceAndConstant(leftValueBlock.getBytesRef(leftValueBlock.getFirstValueIndex(p), leftValueScratch), this.rightValue));\n-        } catch (IllegalArgumentException | IOException e) {\n-          warnings().registerException(e);\n-          result.appendNull();\n-        }\n-      }\n-      return result.build();\n-    }\n-  }\n-\n-  public DoubleBlock eval(int positionCount, BytesRefVector leftValueVector) {\n-    try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n-      BytesRef leftValueScratch = new BytesRef();\n-      position: for (int p = 0; p < positionCount; p++) {\n-        try {\n-          result.appendDouble(StDistance.processCartesianSourceAndConstant(leftValueVector.getBytesRef(p, leftValueScratch), this.rightValue));\n+          StDistance.processCartesianSourceAndConstant(result, p, leftValueBlock, this.rightValue);\n         } catch (IllegalArgumentException | IOException e) {\n           warnings().registerException(e);\n           result.appendNull();\ndiff --git a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianSourceAndSourceEvaluator.java b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianSourceAndSourceEvaluator.java\nindex c18c9a56..ac560ffd 100644\n--- a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianSourceAndSourceEvaluator.java\n+++ b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceCartesianSourceAndSourceEvaluator.java\n@@ -8,10 +8,8 @@ import java.io.IOException;\n import java.lang.IllegalArgumentException;\n import java.lang.Override;\n import java.lang.String;\n-import org.apache.lucene.util.BytesRef;\n import org.elasticsearch.compute.data.Block;\n import org.elasticsearch.compute.data.BytesRefBlock;\n-import org.elasticsearch.compute.data.BytesRefVector;\n import org.elasticsearch.compute.data.DoubleBlock;\n import org.elasticsearch.compute.data.Page;\n import org.elasticsearch.compute.operator.DriverContext;\n@@ -48,15 +46,7 @@ public final class StDistanceCartesianSourceAndSourceEvaluator implements EvalOp\n   public Block eval(Page page) {\n     try (BytesRefBlock leftValueBlock = (BytesRefBlock) leftValue.eval(page)) {\n       try (BytesRefBlock rightValueBlock = (BytesRefBlock) rightValue.eval(page)) {\n-        BytesRefVector leftValueVector = leftValueBlock.asVector();\n-        if (leftValueVector == null) {\n-          return eval(page.getPositionCount(), leftValueBlock, rightValueBlock);\n-        }\n-        BytesRefVector rightValueVector = rightValueBlock.asVector();\n-        if (rightValueVector == null) {\n-          return eval(page.getPositionCount(), leftValueBlock, rightValueBlock);\n-        }\n-        return eval(page.getPositionCount(), leftValueVector, rightValueVector);\n+        return eval(page.getPositionCount(), leftValueBlock, rightValueBlock);\n       }\n     }\n   }\n@@ -64,50 +54,20 @@ public final class StDistanceCartesianSourceAndSourceEvaluator implements EvalOp\n   public DoubleBlock eval(int positionCount, BytesRefBlock leftValueBlock,\n       BytesRefBlock rightValueBlock) {\n     try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n-      BytesRef leftValueScratch = new BytesRef();\n-      BytesRef rightValueScratch = new BytesRef();\n       position: for (int p = 0; p < positionCount; p++) {\n-        if (leftValueBlock.isNull(p)) {\n-          result.appendNull();\n-          continue position;\n+        boolean allBlocksAreNulls = true;\n+        if (!leftValueBlock.isNull(p)) {\n+          allBlocksAreNulls = false;\n         }\n-        if (leftValueBlock.getValueCount(p) != 1) {\n-          if (leftValueBlock.getValueCount(p) > 1) {\n-            warnings().registerException(new IllegalArgumentException(\"single-value function encountered multi-value\"));\n-          }\n-          result.appendNull();\n-          continue position;\n+        if (!rightValueBlock.isNull(p)) {\n+          allBlocksAreNulls = false;\n         }\n-        if (rightValueBlock.isNull(p)) {\n+        if (allBlocksAreNulls) {\n           result.appendNull();\n           continue position;\n         }\n-        if (rightValueBlock.getValueCount(p) != 1) {\n-          if (rightValueBlock.getValueCount(p) > 1) {\n-            warnings().registerException(new IllegalArgumentException(\"single-value function encountered multi-value\"));\n-          }\n-          result.appendNull();\n-          continue position;\n-        }\n-        try {\n-          result.appendDouble(StDistance.processCartesianSourceAndSource(leftValueBlock.getBytesRef(leftValueBlock.getFirstValueIndex(p), leftValueScratch), rightValueBlock.getBytesRef(rightValueBlock.getFirstValueIndex(p), rightValueScratch)));\n-        } catch (IllegalArgumentException | IOException e) {\n-          warnings().registerException(e);\n-          result.appendNull();\n-        }\n-      }\n-      return result.build();\n-    }\n-  }\n-\n-  public DoubleBlock eval(int positionCount, BytesRefVector leftValueVector,\n-      BytesRefVector rightValueVector) {\n-    try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n-      BytesRef leftValueScratch = new BytesRef();\n-      BytesRef rightValueScratch = new BytesRef();\n-      position: for (int p = 0; p < positionCount; p++) {\n         try {\n-          result.appendDouble(StDistance.processCartesianSourceAndSource(leftValueVector.getBytesRef(p, leftValueScratch), rightValueVector.getBytesRef(p, rightValueScratch)));\n+          StDistance.processCartesianSourceAndSource(result, p, leftValueBlock, rightValueBlock);\n         } catch (IllegalArgumentException | IOException e) {\n           warnings().registerException(e);\n           result.appendNull();\ndiff --git a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoPointDocValuesAndConstantEvaluator.java b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoPointDocValuesAndConstantEvaluator.java\nindex 2ac1ff6a..aea86f6e 100644\n--- a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoPointDocValuesAndConstantEvaluator.java\n+++ b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoPointDocValuesAndConstantEvaluator.java\n@@ -10,7 +10,6 @@ import java.lang.String;\n import org.elasticsearch.compute.data.Block;\n import org.elasticsearch.compute.data.DoubleBlock;\n import org.elasticsearch.compute.data.LongBlock;\n-import org.elasticsearch.compute.data.LongVector;\n import org.elasticsearch.compute.data.Page;\n import org.elasticsearch.compute.operator.DriverContext;\n import org.elasticsearch.compute.operator.EvalOperator;\n@@ -45,44 +44,23 @@ public final class StDistanceGeoPointDocValuesAndConstantEvaluator implements Ev\n   @Override\n   public Block eval(Page page) {\n     try (LongBlock leftValueBlock = (LongBlock) leftValue.eval(page)) {\n-      LongVector leftValueVector = leftValueBlock.asVector();\n-      if (leftValueVector == null) {\n-        return eval(page.getPositionCount(), leftValueBlock);\n-      }\n-      return eval(page.getPositionCount(), leftValueVector);\n+      return eval(page.getPositionCount(), leftValueBlock);\n     }\n   }\n \n   public DoubleBlock eval(int positionCount, LongBlock leftValueBlock) {\n     try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n       position: for (int p = 0; p < positionCount; p++) {\n-        if (leftValueBlock.isNull(p)) {\n-          result.appendNull();\n-          continue position;\n+        boolean allBlocksAreNulls = true;\n+        if (!leftValueBlock.isNull(p)) {\n+          allBlocksAreNulls = false;\n         }\n-        if (leftValueBlock.getValueCount(p) != 1) {\n-          if (leftValueBlock.getValueCount(p) > 1) {\n-            warnings().registerException(new IllegalArgumentException(\"single-value function encountered multi-value\"));\n-          }\n+        if (allBlocksAreNulls) {\n           result.appendNull();\n           continue position;\n         }\n         try {\n-          result.appendDouble(StDistance.processGeoPointDocValuesAndConstant(leftValueBlock.getLong(leftValueBlock.getFirstValueIndex(p)), this.rightValue));\n-        } catch (IllegalArgumentException e) {\n-          warnings().registerException(e);\n-          result.appendNull();\n-        }\n-      }\n-      return result.build();\n-    }\n-  }\n-\n-  public DoubleBlock eval(int positionCount, LongVector leftValueVector) {\n-    try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n-      position: for (int p = 0; p < positionCount; p++) {\n-        try {\n-          result.appendDouble(StDistance.processGeoPointDocValuesAndConstant(leftValueVector.getLong(p), this.rightValue));\n+          StDistance.processGeoPointDocValuesAndConstant(result, p, leftValueBlock, this.rightValue);\n         } catch (IllegalArgumentException e) {\n           warnings().registerException(e);\n           result.appendNull();\ndiff --git a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoPointDocValuesAndSourceEvaluator.java b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoPointDocValuesAndSourceEvaluator.java\nindex 6758d888..fa2222a4 100644\n--- a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoPointDocValuesAndSourceEvaluator.java\n+++ b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoPointDocValuesAndSourceEvaluator.java\n@@ -7,13 +7,10 @@ package org.elasticsearch.xpack.esql.expression.function.scalar.spatial;\n import java.lang.IllegalArgumentException;\n import java.lang.Override;\n import java.lang.String;\n-import org.apache.lucene.util.BytesRef;\n import org.elasticsearch.compute.data.Block;\n import org.elasticsearch.compute.data.BytesRefBlock;\n-import org.elasticsearch.compute.data.BytesRefVector;\n import org.elasticsearch.compute.data.DoubleBlock;\n import org.elasticsearch.compute.data.LongBlock;\n-import org.elasticsearch.compute.data.LongVector;\n import org.elasticsearch.compute.data.Page;\n import org.elasticsearch.compute.operator.DriverContext;\n import org.elasticsearch.compute.operator.EvalOperator;\n@@ -49,15 +46,7 @@ public final class StDistanceGeoPointDocValuesAndSourceEvaluator implements Eval\n   public Block eval(Page page) {\n     try (LongBlock leftValueBlock = (LongBlock) leftValue.eval(page)) {\n       try (BytesRefBlock rightValueBlock = (BytesRefBlock) rightValue.eval(page)) {\n-        LongVector leftValueVector = leftValueBlock.asVector();\n-        if (leftValueVector == null) {\n-          return eval(page.getPositionCount(), leftValueBlock, rightValueBlock);\n-        }\n-        BytesRefVector rightValueVector = rightValueBlock.asVector();\n-        if (rightValueVector == null) {\n-          return eval(page.getPositionCount(), leftValueBlock, rightValueBlock);\n-        }\n-        return eval(page.getPositionCount(), leftValueVector, rightValueVector);\n+        return eval(page.getPositionCount(), leftValueBlock, rightValueBlock);\n       }\n     }\n   }\n@@ -65,48 +54,20 @@ public final class StDistanceGeoPointDocValuesAndSourceEvaluator implements Eval\n   public DoubleBlock eval(int positionCount, LongBlock leftValueBlock,\n       BytesRefBlock rightValueBlock) {\n     try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n-      BytesRef rightValueScratch = new BytesRef();\n       position: for (int p = 0; p < positionCount; p++) {\n-        if (leftValueBlock.isNull(p)) {\n-          result.appendNull();\n-          continue position;\n+        boolean allBlocksAreNulls = true;\n+        if (!leftValueBlock.isNull(p)) {\n+          allBlocksAreNulls = false;\n         }\n-        if (leftValueBlock.getValueCount(p) != 1) {\n-          if (leftValueBlock.getValueCount(p) > 1) {\n-            warnings().registerException(new IllegalArgumentException(\"single-value function encountered multi-value\"));\n-          }\n-          result.appendNull();\n-          continue position;\n+        if (!rightValueBlock.isNull(p)) {\n+          allBlocksAreNulls = false;\n         }\n-        if (rightValueBlock.isNull(p)) {\n+        if (allBlocksAreNulls) {\n           result.appendNull();\n           continue position;\n         }\n-        if (rightValueBlock.getValueCount(p) != 1) {\n-          if (rightValueBlock.getValueCount(p) > 1) {\n-            warnings().registerException(new IllegalArgumentException(\"single-value function encountered multi-value\"));\n-          }\n-          result.appendNull();\n-          continue position;\n-        }\n-        try {\n-          result.appendDouble(StDistance.processGeoPointDocValuesAndSource(leftValueBlock.getLong(leftValueBlock.getFirstValueIndex(p)), rightValueBlock.getBytesRef(rightValueBlock.getFirstValueIndex(p), rightValueScratch)));\n-        } catch (IllegalArgumentException e) {\n-          warnings().registerException(e);\n-          result.appendNull();\n-        }\n-      }\n-      return result.build();\n-    }\n-  }\n-\n-  public DoubleBlock eval(int positionCount, LongVector leftValueVector,\n-      BytesRefVector rightValueVector) {\n-    try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n-      BytesRef rightValueScratch = new BytesRef();\n-      position: for (int p = 0; p < positionCount; p++) {\n         try {\n-          result.appendDouble(StDistance.processGeoPointDocValuesAndSource(leftValueVector.getLong(p), rightValueVector.getBytesRef(p, rightValueScratch)));\n+          StDistance.processGeoPointDocValuesAndSource(result, p, leftValueBlock, rightValueBlock);\n         } catch (IllegalArgumentException e) {\n           warnings().registerException(e);\n           result.appendNull();\ndiff --git a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoSourceAndConstantEvaluator.java b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoSourceAndConstantEvaluator.java\nindex 201c29cb..865a0dbb 100644\n--- a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoSourceAndConstantEvaluator.java\n+++ b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoSourceAndConstantEvaluator.java\n@@ -8,10 +8,8 @@ import java.io.IOException;\n import java.lang.IllegalArgumentException;\n import java.lang.Override;\n import java.lang.String;\n-import org.apache.lucene.util.BytesRef;\n import org.elasticsearch.compute.data.Block;\n import org.elasticsearch.compute.data.BytesRefBlock;\n-import org.elasticsearch.compute.data.BytesRefVector;\n import org.elasticsearch.compute.data.DoubleBlock;\n import org.elasticsearch.compute.data.Page;\n import org.elasticsearch.compute.operator.DriverContext;\n@@ -47,46 +45,23 @@ public final class StDistanceGeoSourceAndConstantEvaluator implements EvalOperat\n   @Override\n   public Block eval(Page page) {\n     try (BytesRefBlock leftValueBlock = (BytesRefBlock) leftValue.eval(page)) {\n-      BytesRefVector leftValueVector = leftValueBlock.asVector();\n-      if (leftValueVector == null) {\n-        return eval(page.getPositionCount(), leftValueBlock);\n-      }\n-      return eval(page.getPositionCount(), leftValueVector);\n+      return eval(page.getPositionCount(), leftValueBlock);\n     }\n   }\n \n   public DoubleBlock eval(int positionCount, BytesRefBlock leftValueBlock) {\n     try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n-      BytesRef leftValueScratch = new BytesRef();\n       position: for (int p = 0; p < positionCount; p++) {\n-        if (leftValueBlock.isNull(p)) {\n-          result.appendNull();\n-          continue position;\n+        boolean allBlocksAreNulls = true;\n+        if (!leftValueBlock.isNull(p)) {\n+          allBlocksAreNulls = false;\n         }\n-        if (leftValueBlock.getValueCount(p) != 1) {\n-          if (leftValueBlock.getValueCount(p) > 1) {\n-            warnings().registerException(new IllegalArgumentException(\"single-value function encountered multi-value\"));\n-          }\n+        if (allBlocksAreNulls) {\n           result.appendNull();\n           continue position;\n         }\n         try {\n-          result.appendDouble(StDistance.processGeoSourceAndConstant(leftValueBlock.getBytesRef(leftValueBlock.getFirstValueIndex(p), leftValueScratch), this.rightValue));\n-        } catch (IllegalArgumentException | IOException e) {\n-          warnings().registerException(e);\n-          result.appendNull();\n-        }\n-      }\n-      return result.build();\n-    }\n-  }\n-\n-  public DoubleBlock eval(int positionCount, BytesRefVector leftValueVector) {\n-    try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n-      BytesRef leftValueScratch = new BytesRef();\n-      position: for (int p = 0; p < positionCount; p++) {\n-        try {\n-          result.appendDouble(StDistance.processGeoSourceAndConstant(leftValueVector.getBytesRef(p, leftValueScratch), this.rightValue));\n+          StDistance.processGeoSourceAndConstant(result, p, leftValueBlock, this.rightValue);\n         } catch (IllegalArgumentException | IOException e) {\n           warnings().registerException(e);\n           result.appendNull();\ndiff --git a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoSourceAndSourceEvaluator.java b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoSourceAndSourceEvaluator.java\nindex 9cbe30e2..38a50bed 100644\n--- a/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoSourceAndSourceEvaluator.java\n+++ b/x-pack/plugin/esql/src/main/generated/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistanceGeoSourceAndSourceEvaluator.java\n@@ -8,10 +8,8 @@ import java.io.IOException;\n import java.lang.IllegalArgumentException;\n import java.lang.Override;\n import java.lang.String;\n-import org.apache.lucene.util.BytesRef;\n import org.elasticsearch.compute.data.Block;\n import org.elasticsearch.compute.data.BytesRefBlock;\n-import org.elasticsearch.compute.data.BytesRefVector;\n import org.elasticsearch.compute.data.DoubleBlock;\n import org.elasticsearch.compute.data.Page;\n import org.elasticsearch.compute.operator.DriverContext;\n@@ -48,15 +46,7 @@ public final class StDistanceGeoSourceAndSourceEvaluator implements EvalOperator\n   public Block eval(Page page) {\n     try (BytesRefBlock leftValueBlock = (BytesRefBlock) leftValue.eval(page)) {\n       try (BytesRefBlock rightValueBlock = (BytesRefBlock) rightValue.eval(page)) {\n-        BytesRefVector leftValueVector = leftValueBlock.asVector();\n-        if (leftValueVector == null) {\n-          return eval(page.getPositionCount(), leftValueBlock, rightValueBlock);\n-        }\n-        BytesRefVector rightValueVector = rightValueBlock.asVector();\n-        if (rightValueVector == null) {\n-          return eval(page.getPositionCount(), leftValueBlock, rightValueBlock);\n-        }\n-        return eval(page.getPositionCount(), leftValueVector, rightValueVector);\n+        return eval(page.getPositionCount(), leftValueBlock, rightValueBlock);\n       }\n     }\n   }\n@@ -64,50 +54,20 @@ public final class StDistanceGeoSourceAndSourceEvaluator implements EvalOperator\n   public DoubleBlock eval(int positionCount, BytesRefBlock leftValueBlock,\n       BytesRefBlock rightValueBlock) {\n     try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n-      BytesRef leftValueScratch = new BytesRef();\n-      BytesRef rightValueScratch = new BytesRef();\n       position: for (int p = 0; p < positionCount; p++) {\n-        if (leftValueBlock.isNull(p)) {\n-          result.appendNull();\n-          continue position;\n+        boolean allBlocksAreNulls = true;\n+        if (!leftValueBlock.isNull(p)) {\n+          allBlocksAreNulls = false;\n         }\n-        if (leftValueBlock.getValueCount(p) != 1) {\n-          if (leftValueBlock.getValueCount(p) > 1) {\n-            warnings().registerException(new IllegalArgumentException(\"single-value function encountered multi-value\"));\n-          }\n-          result.appendNull();\n-          continue position;\n+        if (!rightValueBlock.isNull(p)) {\n+          allBlocksAreNulls = false;\n         }\n-        if (rightValueBlock.isNull(p)) {\n+        if (allBlocksAreNulls) {\n           result.appendNull();\n           continue position;\n         }\n-        if (rightValueBlock.getValueCount(p) != 1) {\n-          if (rightValueBlock.getValueCount(p) > 1) {\n-            warnings().registerException(new IllegalArgumentException(\"single-value function encountered multi-value\"));\n-          }\n-          result.appendNull();\n-          continue position;\n-        }\n-        try {\n-          result.appendDouble(StDistance.processGeoSourceAndSource(leftValueBlock.getBytesRef(leftValueBlock.getFirstValueIndex(p), leftValueScratch), rightValueBlock.getBytesRef(rightValueBlock.getFirstValueIndex(p), rightValueScratch)));\n-        } catch (IllegalArgumentException | IOException e) {\n-          warnings().registerException(e);\n-          result.appendNull();\n-        }\n-      }\n-      return result.build();\n-    }\n-  }\n-\n-  public DoubleBlock eval(int positionCount, BytesRefVector leftValueVector,\n-      BytesRefVector rightValueVector) {\n-    try(DoubleBlock.Builder result = driverContext.blockFactory().newDoubleBlockBuilder(positionCount)) {\n-      BytesRef leftValueScratch = new BytesRef();\n-      BytesRef rightValueScratch = new BytesRef();\n-      position: for (int p = 0; p < positionCount; p++) {\n         try {\n-          result.appendDouble(StDistance.processGeoSourceAndSource(leftValueVector.getBytesRef(p, leftValueScratch), rightValueVector.getBytesRef(p, rightValueScratch)));\n+          StDistance.processGeoSourceAndSource(result, p, leftValueBlock, rightValueBlock);\n         } catch (IllegalArgumentException | IOException e) {\n           warnings().registerException(e);\n           result.appendNull();\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java\nindex f5baaef4..5e668f68 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java\n@@ -175,6 +175,11 @@ public class EsqlCapabilities {\n          */\n         SPATIAL_DISTANCE_PUSHDOWN_ENHANCEMENTS,\n \n+        /**\n+         * Support multi-valued fields in ST_DISTANCE function. Done in #114836.\n+         */\n+        ST_DISTANCE_SUPPORT_MULTIVALUES,\n+\n         /**\n          * Fix to GROK and DISSECT that allows extracting attributes with the same name as the input\n          * https://github.com/elastic/elasticsearch/issues/110184\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistance.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistance.java\nindex ae9d3383..7f8dfaad 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistance.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/spatial/StDistance.java\n@@ -14,6 +14,9 @@ import org.elasticsearch.common.io.stream.NamedWriteableRegistry;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.compute.ann.Evaluator;\n import org.elasticsearch.compute.ann.Fixed;\n+import org.elasticsearch.compute.data.BytesRefBlock;\n+import org.elasticsearch.compute.data.DoubleBlock;\n+import org.elasticsearch.compute.data.LongBlock;\n import org.elasticsearch.compute.operator.EvalOperator;\n import org.elasticsearch.geometry.Geometry;\n import org.elasticsearch.geometry.Point;\n@@ -116,6 +119,104 @@ public class StDistance extends BinarySpatialFunction implements EvaluatorMapper\n         public double distance(BytesRef left, Point right) {\n             return distance(this.fromBytesRef(left), right);\n         }\n+\n+        /**\n+         * Process distance calculation between a BytesRefBlock and a constant Point.\n+         * For multi-valued fields, returns the minimum distance across all values.\n+         */\n+        protected void processSourceAndConstant(DoubleBlock.Builder builder, int position, BytesRefBlock left, Point right)\n+            throws IOException {\n+            if (left.getValueCount(position) < 1) {\n+                builder.appendNull();\n+            } else {\n+                int firstValueIndex = left.getFirstValueIndex(position);\n+                int valueCount = left.getValueCount(position);\n+                BytesRef scratch = new BytesRef();\n+                double minDistance = Double.POSITIVE_INFINITY;\n+                for (int i = 0; i < valueCount; i++) {\n+                    BytesRef value = left.getBytesRef(firstValueIndex + i, scratch);\n+                    double dist = distance(value, right);\n+                    minDistance = Math.min(minDistance, dist);\n+                }\n+                builder.appendDouble(minDistance);\n+            }\n+        }\n+\n+        /**\n+         * Process distance calculation between two BytesRefBlocks.\n+         * For multi-valued fields, returns the minimum distance across all value combinations.\n+         */\n+        protected void processSourceAndSource(DoubleBlock.Builder builder, int position, BytesRefBlock left, BytesRefBlock right)\n+            throws IOException {\n+            if (left.getValueCount(position) < 1 || right.getValueCount(position) < 1) {\n+                builder.appendNull();\n+            } else {\n+                int leftFirstIndex = left.getFirstValueIndex(position);\n+                int leftValueCount = left.getValueCount(position);\n+                int rightFirstIndex = right.getFirstValueIndex(position);\n+                int rightValueCount = right.getValueCount(position);\n+                BytesRef leftScratch = new BytesRef();\n+                BytesRef rightScratch = new BytesRef();\n+                double minDistance = Double.POSITIVE_INFINITY;\n+                for (int i = 0; i < leftValueCount; i++) {\n+                    BytesRef leftValue = left.getBytesRef(leftFirstIndex + i, leftScratch);\n+                    for (int j = 0; j < rightValueCount; j++) {\n+                        BytesRef rightValue = right.getBytesRef(rightFirstIndex + j, rightScratch);\n+                        double dist = distance(leftValue, rightValue);\n+                        minDistance = Math.min(minDistance, dist);\n+                    }\n+                }\n+                builder.appendDouble(minDistance);\n+            }\n+        }\n+\n+        /**\n+         * Process distance calculation between a LongBlock (doc values) and a constant Point.\n+         * For multi-valued fields, returns the minimum distance across all values.\n+         */\n+        protected void processPointDocValuesAndConstant(DoubleBlock.Builder builder, int position, LongBlock left, Point right) {\n+            if (left.getValueCount(position) < 1) {\n+                builder.appendNull();\n+            } else {\n+                int firstValueIndex = left.getFirstValueIndex(position);\n+                int valueCount = left.getValueCount(position);\n+                double minDistance = Double.POSITIVE_INFINITY;\n+                for (int i = 0; i < valueCount; i++) {\n+                    long encoded = left.getLong(firstValueIndex + i);\n+                    double dist = distance(encoded, right);\n+                    minDistance = Math.min(minDistance, dist);\n+                }\n+                builder.appendDouble(minDistance);\n+            }\n+        }\n+\n+        /**\n+         * Process distance calculation between a LongBlock (doc values) and a BytesRefBlock.\n+         * For multi-valued fields, returns the minimum distance across all value combinations.\n+         */\n+        protected void processPointDocValuesAndSource(DoubleBlock.Builder builder, int position, LongBlock left, BytesRefBlock right) {\n+            if (left.getValueCount(position) < 1 || right.getValueCount(position) < 1) {\n+                builder.appendNull();\n+            } else {\n+                int leftFirstIndex = left.getFirstValueIndex(position);\n+                int leftValueCount = left.getValueCount(position);\n+                int rightFirstIndex = right.getFirstValueIndex(position);\n+                int rightValueCount = right.getValueCount(position);\n+                BytesRef rightScratch = new BytesRef();\n+                double minDistance = Double.POSITIVE_INFINITY;\n+                for (int i = 0; i < leftValueCount; i++) {\n+                    long encoded = left.getLong(leftFirstIndex + i);\n+                    Point leftPoint = spatialCoordinateType.longAsPoint(encoded);\n+                    for (int j = 0; j < rightValueCount; j++) {\n+                        BytesRef rightValue = right.getBytesRef(rightFirstIndex + j, rightScratch);\n+                        Geometry rightGeom = SpatialCoordinateTypes.UNSPECIFIED.wkbToGeometry(rightValue);\n+                        double dist = distance(leftPoint, (Point) rightGeom);\n+                        minDistance = Math.min(minDistance, dist);\n+                    }\n+                }\n+                builder.appendDouble(minDistance);\n+            }\n+        }\n     }\n \n     @FunctionInfo(\n@@ -250,44 +351,46 @@ public class StDistance extends BinarySpatialFunction implements EvaluatorMapper\n     }\n \n     @Evaluator(extraName = \"GeoSourceAndConstant\", warnExceptions = { IllegalArgumentException.class, IOException.class })\n-    static double processGeoSourceAndConstant(BytesRef leftValue, @Fixed Point rightValue) throws IOException {\n-        return GEO.distance(leftValue, rightValue);\n+    static void processGeoSourceAndConstant(DoubleBlock.Builder builder, int p, BytesRefBlock leftValue, @Fixed Point rightValue)\n+        throws IOException {\n+        GEO.processSourceAndConstant(builder, p, leftValue, rightValue);\n     }\n \n     @Evaluator(extraName = \"GeoSourceAndSource\", warnExceptions = { IllegalArgumentException.class, IOException.class })\n-    static double processGeoSourceAndSource(BytesRef leftValue, BytesRef rightValue) throws IOException {\n-        return GEO.distance(leftValue, rightValue);\n+    static void processGeoSourceAndSource(DoubleBlock.Builder builder, int p, BytesRefBlock leftValue, BytesRefBlock rightValue)\n+        throws IOException {\n+        GEO.processSourceAndSource(builder, p, leftValue, rightValue);\n     }\n \n     @Evaluator(extraName = \"GeoPointDocValuesAndConstant\", warnExceptions = { IllegalArgumentException.class })\n-    static double processGeoPointDocValuesAndConstant(long leftValue, @Fixed Point rightValue) {\n-        return GEO.distance(leftValue, rightValue);\n+    static void processGeoPointDocValuesAndConstant(DoubleBlock.Builder builder, int p, LongBlock leftValue, @Fixed Point rightValue) {\n+        GEO.processPointDocValuesAndConstant(builder, p, leftValue, rightValue);\n     }\n \n     @Evaluator(extraName = \"GeoPointDocValuesAndSource\", warnExceptions = { IllegalArgumentException.class })\n-    static double processGeoPointDocValuesAndSource(long leftValue, BytesRef rightValue) {\n-        Geometry geometry = SpatialCoordinateTypes.UNSPECIFIED.wkbToGeometry(rightValue);\n-        return GEO.distance(leftValue, geometry);\n+    static void processGeoPointDocValuesAndSource(DoubleBlock.Builder builder, int p, LongBlock leftValue, BytesRefBlock rightValue) {\n+        GEO.processPointDocValuesAndSource(builder, p, leftValue, rightValue);\n     }\n \n     @Evaluator(extraName = \"CartesianSourceAndConstant\", warnExceptions = { IllegalArgumentException.class, IOException.class })\n-    static double processCartesianSourceAndConstant(BytesRef leftValue, @Fixed Point rightValue) throws IOException {\n-        return CARTESIAN.distance(leftValue, rightValue);\n+    static void processCartesianSourceAndConstant(DoubleBlock.Builder builder, int p, BytesRefBlock leftValue, @Fixed Point rightValue)\n+        throws IOException {\n+        CARTESIAN.processSourceAndConstant(builder, p, leftValue, rightValue);\n     }\n \n     @Evaluator(extraName = \"CartesianSourceAndSource\", warnExceptions = { IllegalArgumentException.class, IOException.class })\n-    static double processCartesianSourceAndSource(BytesRef leftValue, BytesRef rightValue) throws IOException {\n-        return CARTESIAN.distance(leftValue, rightValue);\n+    static void processCartesianSourceAndSource(DoubleBlock.Builder builder, int p, BytesRefBlock leftValue, BytesRefBlock rightValue)\n+        throws IOException {\n+        CARTESIAN.processSourceAndSource(builder, p, leftValue, rightValue);\n     }\n \n     @Evaluator(extraName = \"CartesianPointDocValuesAndConstant\", warnExceptions = { IllegalArgumentException.class })\n-    static double processCartesianPointDocValuesAndConstant(long leftValue, @Fixed Point rightValue) {\n-        return CARTESIAN.distance(leftValue, rightValue);\n+    static void processCartesianPointDocValuesAndConstant(DoubleBlock.Builder builder, int p, LongBlock leftValue, @Fixed Point rightValue) {\n+        CARTESIAN.processPointDocValuesAndConstant(builder, p, leftValue, rightValue);\n     }\n \n-    @Evaluator(extraName = \"CartesianPointDocValuesAndSource\")\n-    static double processCartesianPointDocValuesAndSource(long leftValue, BytesRef rightValue) {\n-        Geometry geometry = SpatialCoordinateTypes.UNSPECIFIED.wkbToGeometry(rightValue);\n-        return CARTESIAN.distance(leftValue, geometry);\n+    @Evaluator(extraName = \"CartesianPointDocValuesAndSource\", warnExceptions = { IllegalArgumentException.class })\n+    static void processCartesianPointDocValuesAndSource(DoubleBlock.Builder builder, int p, LongBlock leftValue, BytesRefBlock rightValue) {\n+        CARTESIAN.processPointDocValuesAndSource(builder, p, leftValue, rightValue);\n     }\n }",
  "logs_path": "factory/claude-sonnet-4-5-20250929/074538b9/elastic_elasticsearch_pr114860/logs.jsonl",
  "errors": [],
  "edit_run_id": "074538b9",
  "test_label": "v0"
}