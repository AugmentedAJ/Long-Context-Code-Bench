{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 114872,
  "base_commit": "52587d6abfc8768b5930fe313c6241d9b9f25334",
  "runner": "factory",
  "model": "claude-sonnet-4-5-20250929",
  "timeout_s": 7200,
  "status": "success",
  "elapsed_ms": 642971,
  "patch_unified": "diff --git a/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java b/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\nindex 16fedd9d..d11612ac 100644\n--- a/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\n+++ b/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\n@@ -23,6 +23,7 @@ import org.elasticsearch.action.index.IndexRequest;\n import org.elasticsearch.action.ingest.PutPipelineRequest;\n import org.elasticsearch.action.search.SearchRequest;\n import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.bytes.BytesReference;\n import org.elasticsearch.common.settings.MockSecureSettings;\n import org.elasticsearch.common.settings.Settings;\n@@ -44,19 +45,24 @@ import org.junit.ClassRule;\n \n import java.io.IOException;\n import java.util.Collection;\n+import java.util.List;\n import java.util.Map;\n \n import static org.elasticsearch.ingest.EnterpriseGeoIpTask.ENTERPRISE_GEOIP_DOWNLOADER;\n+import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_TOKEN_SETTING;\n import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING;\n-import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n import static org.hamcrest.Matchers.equalTo;\n \n public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n \n-    private static final String DATABASE_TYPE = \"GeoIP2-City\";\n+    private static final String MAXMIND_DATABASE_TYPE = \"GeoIP2-City\";\n+    private static final String IPINFO_DATABASE_TYPE = \"asn\";\n \n     @ClassRule\n-    public static final EnterpriseGeoIpHttpFixture fixture = new EnterpriseGeoIpHttpFixture(DATABASE_TYPE);\n+    public static final EnterpriseGeoIpHttpFixture fixture = new EnterpriseGeoIpHttpFixture(\n+        List.of(MAXMIND_DATABASE_TYPE),\n+        List.of(IPINFO_DATABASE_TYPE)\n+    );\n \n     protected String getEndpoint() {\n         return fixture.getAddress();\n@@ -66,6 +72,7 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n     protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n         MockSecureSettings secureSettings = new MockSecureSettings();\n         secureSettings.setString(MAXMIND_LICENSE_KEY_SETTING.getKey(), \"license_key\");\n+        secureSettings.setString(IPINFO_TOKEN_SETTING.getKey(), \"token\");\n         Settings.Builder builder = Settings.builder();\n         builder.setSecureSettings(secureSettings)\n             .put(super.nodeSettings(nodeOrdinal, otherSettings))\n@@ -92,22 +99,27 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n          * Note that the \"enterprise database\" is actually just a geolite database being loaded by the GeoIpHttpFixture.\n          */\n         EnterpriseGeoIpDownloader.DEFAULT_MAXMIND_ENDPOINT = getEndpoint();\n-        final String pipelineName = \"enterprise_geoip_pipeline\";\n+        EnterpriseGeoIpDownloader.DEFAULT_IPINFO_ENDPOINT = getEndpoint();\n         final String indexName = \"enterprise_geoip_test_index\";\n+        final String geoipPipelineName = \"enterprise_geoip_pipeline\";\n+        final String iplocationPipelineName = \"enterprise_iplocation_pipeline\";\n         final String sourceField = \"ip\";\n-        final String targetField = \"ip-city\";\n+        final String targetField = \"ip-result\";\n \n         startEnterpriseGeoIpDownloaderTask();\n-        configureDatabase(DATABASE_TYPE);\n-        createGeoIpPipeline(pipelineName, DATABASE_TYPE, sourceField, targetField);\n+        configureMaxmindDatabase(MAXMIND_DATABASE_TYPE);\n+        configureIpinfoDatabase(IPINFO_DATABASE_TYPE);\n+        waitAround();\n+        createPipeline(geoipPipelineName, \"geoip\", MAXMIND_DATABASE_TYPE, sourceField, targetField);\n+        createPipeline(iplocationPipelineName, \"ip_location\", IPINFO_DATABASE_TYPE, sourceField, targetField);\n \n+        /*\n+         * We know that the databases index has been populated (because we waited around, :wink:), but we don't know for sure that\n+         * the databases have been pulled down and made available on all nodes. So we run these ingest-and-check steps in assertBusy blocks.\n+         */\n         assertBusy(() -> {\n-            /*\n-             * We know that the .geoip_databases index has been populated, but we don't know for sure that the database has been pulled\n-             * down and made available on all nodes. So we run this ingest-and-check step in an assertBusy.\n-             */\n             logger.info(\"Ingesting a test document\");\n-            String documentId = ingestDocument(indexName, pipelineName, sourceField);\n+            String documentId = ingestDocument(indexName, geoipPipelineName, sourceField, \"89.160.20.128\");\n             GetResponse getResponse = client().get(new GetRequest(indexName, documentId)).actionGet();\n             Map<String, Object> returnedSource = getResponse.getSource();\n             assertNotNull(returnedSource);\n@@ -115,6 +127,16 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n             assertNotNull(targetFieldValue);\n             assertThat(((Map<String, Object>) targetFieldValue).get(\"organization_name\"), equalTo(\"Bredband2 AB\"));\n         });\n+        assertBusy(() -> {\n+            logger.info(\"Ingesting another test document\");\n+            String documentId = ingestDocument(indexName, iplocationPipelineName, sourceField, \"12.10.66.1\");\n+            GetResponse getResponse = client().get(new GetRequest(indexName, documentId)).actionGet();\n+            Map<String, Object> returnedSource = getResponse.getSource();\n+            assertNotNull(returnedSource);\n+            Object targetFieldValue = returnedSource.get(targetField);\n+            assertNotNull(targetFieldValue);\n+            assertThat(((Map<String, Object>) targetFieldValue).get(\"organization_name\"), equalTo(\"OAKLAWN JOCKEY CLUB, INC.\"));\n+        });\n     }\n \n     private void startEnterpriseGeoIpDownloaderTask() {\n@@ -133,29 +155,46 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n         );\n     }\n \n-    private void configureDatabase(String databaseType) throws Exception {\n+    private void configureMaxmindDatabase(String databaseType) {\n         admin().cluster()\n             .execute(\n                 PutDatabaseConfigurationAction.INSTANCE,\n                 new PutDatabaseConfigurationAction.Request(\n                     TimeValue.MAX_VALUE,\n                     TimeValue.MAX_VALUE,\n-                    new DatabaseConfiguration(\"test\", databaseType, new DatabaseConfiguration.Maxmind(\"test_account\"))\n+                    new DatabaseConfiguration(\"test-1\", databaseType, new DatabaseConfiguration.Maxmind(\"test_account\"))\n                 )\n             )\n             .actionGet();\n+    }\n+\n+    private void configureIpinfoDatabase(String databaseType) {\n+        admin().cluster()\n+            .execute(\n+                PutDatabaseConfigurationAction.INSTANCE,\n+                new PutDatabaseConfigurationAction.Request(\n+                    TimeValue.MAX_VALUE,\n+                    TimeValue.MAX_VALUE,\n+                    new DatabaseConfiguration(\"test-2\", databaseType, new DatabaseConfiguration.Ipinfo())\n+                )\n+            )\n+            .actionGet();\n+    }\n+\n+    private void waitAround() throws Exception {\n         ensureGreen(GeoIpDownloader.DATABASES_INDEX);\n         assertBusy(() -> {\n             SearchResponse searchResponse = client().search(new SearchRequest(GeoIpDownloader.DATABASES_INDEX)).actionGet();\n             try {\n-                assertThat(searchResponse.getHits().getHits().length, equalTo(1));\n+                assertThat(searchResponse.getHits().getHits().length, equalTo(2));\n             } finally {\n                 searchResponse.decRef();\n             }\n         });\n     }\n \n-    private void createGeoIpPipeline(String pipelineName, String databaseType, String sourceField, String targetField) throws IOException {\n+    private void createPipeline(String pipelineName, String processorType, String databaseType, String sourceField, String targetField)\n+        throws IOException {\n         final BytesReference bytes;\n         try (XContentBuilder builder = JsonXContent.contentBuilder()) {\n             builder.startObject();\n@@ -165,7 +204,7 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n                 {\n                     builder.startObject();\n                     {\n-                        builder.startObject(\"geoip\");\n+                        builder.startObject(processorType);\n                         {\n                             builder.field(\"field\", sourceField);\n                             builder.field(\"target_field\", targetField);\n@@ -180,14 +219,14 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n             builder.endObject();\n             bytes = BytesReference.bytes(builder);\n         }\n-        assertAcked(clusterAdmin().putPipeline(new PutPipelineRequest(pipelineName, bytes, XContentType.JSON)).actionGet());\n+        clusterAdmin().putPipeline(new PutPipelineRequest(pipelineName, bytes, XContentType.JSON)).actionGet();\n     }\n \n-    private String ingestDocument(String indexName, String pipelineName, String sourceField) {\n+    private String ingestDocument(String indexName, String pipelineName, String sourceField, String value) {\n         BulkRequest bulkRequest = new BulkRequest();\n-        bulkRequest.add(\n-            new IndexRequest(indexName).source(\"{\\\"\" + sourceField + \"\\\": \\\"89.160.20.128\\\"}\", XContentType.JSON).setPipeline(pipelineName)\n-        );\n+        bulkRequest.add(new IndexRequest(indexName).source(Strings.format(\"\"\"\n+            { \"%s\": \"%s\"}\n+            \"\"\", sourceField, value), XContentType.JSON).setPipeline(pipelineName));\n         BulkResponse response = client().bulk(bulkRequest).actionGet();\n         BulkItemResponse[] bulkItemResponses = response.getItems();\n         assertThat(bulkItemResponses.length, equalTo(1));\ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\nindex 3bbb0539..f4ae440d 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\n@@ -23,7 +23,6 @@ import org.elasticsearch.cluster.service.ClusterService;\n import org.elasticsearch.common.CheckedSupplier;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.hash.MessageDigests;\n-import org.elasticsearch.core.Nullable;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.core.Tuple;\n import org.elasticsearch.index.query.BoolQueryBuilder;\n@@ -39,6 +38,8 @@ import org.elasticsearch.persistent.PersistentTasksCustomMetadata.PersistentTask\n import org.elasticsearch.tasks.TaskId;\n import org.elasticsearch.threadpool.Scheduler;\n import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xcontent.XContentParser;\n+import org.elasticsearch.xcontent.XContentParserConfiguration;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.io.Closeable;\n@@ -57,6 +58,7 @@ import java.util.function.Supplier;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n+import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_SETTINGS_PREFIX;\n import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_SETTINGS_PREFIX;\n \n /**\n@@ -72,6 +74,9 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n     // a sha256 checksum followed by two spaces followed by an (ignored) file name\n     private static final Pattern SHA256_CHECKSUM_PATTERN = Pattern.compile(\"(\\\\w{64})\\\\s\\\\s(.*)\");\n \n+    // an md5 checksum\n+    private static final Pattern MD5_CHECKSUM_PATTERN = Pattern.compile(\"(\\\\w{32})\");\n+\n     // for overriding in tests\n     static String DEFAULT_MAXMIND_ENDPOINT = System.getProperty(\n         MAXMIND_SETTINGS_PREFIX + \"endpoint.default\", //\n@@ -80,6 +85,14 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n     // n.b. a future enhancement might be to allow for a MAXMIND_ENDPOINT_SETTING, but\n     // at the moment this is an unsupported system property for use in tests (only)\n \n+    // for overriding in tests\n+    static String DEFAULT_IPINFO_ENDPOINT = System.getProperty(\n+        IPINFO_SETTINGS_PREFIX + \"endpoint.default\", //\n+        \"https://ipinfo.io/data\"\n+    );\n+    // n.b. a future enhancement might be to allow for an IPINFO_ENDPOINT_SETTING, but\n+    // at the moment this is an unsupported system property for use in tests (only)\n+\n     static final String DATABASES_INDEX = \".geoip_databases\";\n     static final int MAX_CHUNK_SIZE = 1024 * 1024;\n \n@@ -444,16 +457,15 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n         }\n     }\n \n-    @Nullable\n     private ProviderDownload downloaderFor(DatabaseConfiguration database) {\n-        if (database.provider() instanceof DatabaseConfiguration.Maxmind) {\n-            return new MaxmindDownload(database.name(), (DatabaseConfiguration.Maxmind) database.provider());\n-        } else if (database.provider() instanceof DatabaseConfiguration.Ipinfo) {\n-            // as a temporary implementation detail, null here means 'not actually supported *just yet*'\n-            return null;\n+        if (database.provider() instanceof DatabaseConfiguration.Maxmind maxmind) {\n+            return new MaxmindDownload(database.name(), maxmind);\n+        } else if (database.provider() instanceof DatabaseConfiguration.Ipinfo ipinfo) {\n+            return new IpinfoDownload(database.name(), ipinfo);\n         } else {\n-            assert false : \"Attempted to use database downloader with unsupported provider type [\" + database.provider().getClass() + \"]\";\n-            return null;\n+            throw new IllegalArgumentException(\n+                Strings.format(\"Unexpected provider [%s] for configuration [%s]\", database.provider().getClass(), database.id())\n+            );\n         }\n     }\n \n@@ -488,7 +500,7 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n \n         @Override\n         public boolean validCredentials() {\n-            return auth.get() != null;\n+            return auth != null && auth.get() != null;\n         }\n \n         @Override\n@@ -529,7 +541,101 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n \n         @Override\n         public void close() throws IOException {\n-            auth.close();\n+            if (auth != null) auth.close();\n+        }\n+    }\n+\n+    class IpinfoDownload implements ProviderDownload {\n+\n+        final String name;\n+        final DatabaseConfiguration.Ipinfo ipinfo;\n+        HttpClient.PasswordAuthenticationHolder auth;\n+\n+        IpinfoDownload(String name, DatabaseConfiguration.Ipinfo ipinfo) {\n+            this.name = name;\n+            this.ipinfo = ipinfo;\n+            this.auth = buildCredentials();\n+        }\n+\n+        @Override\n+        public HttpClient.PasswordAuthenticationHolder buildCredentials() {\n+            final char[] tokenChars = tokenProvider.apply(\"ipinfo\");\n+\n+            // if the token is missing or empty, return null as 'no auth'\n+            if (tokenChars == null || tokenChars.length == 0) {\n+                return null;\n+            }\n+\n+            // ipinfo uses the token as the username component of basic auth, see https://ipinfo.io/developers#authentication\n+            return new HttpClient.PasswordAuthenticationHolder(new String(tokenChars), new char[] {});\n+        }\n+\n+        @Override\n+        public boolean validCredentials() {\n+            return auth != null && auth.get() != null;\n+        }\n+\n+        private static final Set<String> FREE_DATABASES = Set.of(\"asn\", \"country\", \"country_asn\");\n+\n+        @Override\n+        public String url(String suffix) {\n+            // note: the 'free' databases are in the sub-path 'free/' in terms of the download endpoint\n+            final String internalName;\n+            if (FREE_DATABASES.contains(name)) {\n+                internalName = \"free/\" + name;\n+            } else {\n+                internalName = name;\n+            }\n+\n+            // reminder, we're passing the ipinfo token as the username part of http basic auth,\n+            // see https://ipinfo.io/developers#authentication\n+\n+            String endpointPattern = DEFAULT_IPINFO_ENDPOINT;\n+            if (endpointPattern.contains(\"%\")) {\n+                throw new IllegalArgumentException(\"Invalid endpoint [\" + endpointPattern + \"]\");\n+            }\n+            if (endpointPattern.endsWith(\"/\") == false) {\n+                endpointPattern += \"/\";\n+            }\n+            endpointPattern += \"%s.%s\";\n+\n+            // at this point the pattern looks like this (in the default case):\n+            // https://ipinfo.io/data/%s.%s\n+            // also see https://ipinfo.io/developers/database-download,\n+            // and https://ipinfo.io/developers/database-filename-reference for more\n+\n+            return Strings.format(endpointPattern, internalName, suffix);\n+        }\n+\n+        @Override\n+        public Checksum checksum() throws IOException {\n+            final String checksumJsonUrl = this.url(\"mmdb/checksums\"); // a minor abuse of the idea of a 'suffix', :shrug:\n+            byte[] data = httpClient.getBytes(auth.get(), checksumJsonUrl); // this throws if the auth is bad\n+            Map<String, Object> checksums;\n+            try (XContentParser parser = XContentType.JSON.xContent().createParser(XContentParserConfiguration.EMPTY, data)) {\n+                checksums = parser.map();\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            String md5 = ((Map<String, String>) checksums.get(\"checksums\")).get(\"md5\");\n+            logger.info(\"checksum was [{}]\", md5);\n+\n+            var matcher = MD5_CHECKSUM_PATTERN.matcher(md5);\n+            boolean match = matcher.matches();\n+            if (match == false) {\n+                throw new RuntimeException(\"Unexpected md5 response from [\" + checksumJsonUrl + \"]\");\n+            }\n+            return Checksum.md5(md5);\n+        }\n+\n+        @Override\n+        public CheckedSupplier<InputStream, IOException> download() {\n+            final String mmdbUrl = this.url(\"mmdb\");\n+            return () -> httpClient.get(auth.get(), mmdbUrl);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (auth != null) auth.close();\n         }\n     }\n \ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\nindex 5214c0e4..ae9bb109 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\n@@ -54,11 +54,15 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n \n     static final String MAXMIND_SETTINGS_PREFIX = \"ingest.geoip.downloader.maxmind.\";\n \n+    static final String IPINFO_SETTINGS_PREFIX = \"ingest.ip_location.downloader.ipinfo.\";\n+\n     public static final Setting<SecureString> MAXMIND_LICENSE_KEY_SETTING = SecureSetting.secureString(\n         MAXMIND_SETTINGS_PREFIX + \"license_key\",\n         null\n     );\n \n+    public static final Setting<SecureString> IPINFO_TOKEN_SETTING = SecureSetting.secureString(IPINFO_SETTINGS_PREFIX + \"token\", null);\n+\n     private final Client client;\n     private final HttpClient httpClient;\n     private final ClusterService clusterService;\n@@ -106,6 +110,10 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n             if (cachedSecureSettings.getSettingNames().contains(MAXMIND_LICENSE_KEY_SETTING.getKey())) {\n                 token = cachedSecureSettings.getString(MAXMIND_LICENSE_KEY_SETTING.getKey()).getChars();\n             }\n+        } else if (type.equals(\"ipinfo\")) {\n+            if (cachedSecureSettings.getSettingNames().contains(IPINFO_TOKEN_SETTING.getKey())) {\n+                token = cachedSecureSettings.getString(IPINFO_TOKEN_SETTING.getKey()).getChars();\n+            }\n         }\n         return token;\n     }\n@@ -166,7 +174,7 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n         // `SecureSettings` are available here! cache them as they will be needed\n         // whenever dynamic cluster settings change and we have to rebuild the accounts\n         try {\n-            this.cachedSecureSettings = extractSecureSettings(settings, List.of(MAXMIND_LICENSE_KEY_SETTING));\n+            this.cachedSecureSettings = extractSecureSettings(settings, List.of(MAXMIND_LICENSE_KEY_SETTING, IPINFO_TOKEN_SETTING));\n         } catch (GeneralSecurityException e) {\n             // rethrow as a runtime exception, there's logging higher up the call chain around ReloadablePlugin\n             throw new ElasticsearchException(\"Exception while reloading enterprise geoip download task executor\", e);\ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\nindex cc0bec58..3107f0be 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\n@@ -112,7 +112,8 @@ public class IngestGeoIpPlugin extends Plugin\n             GeoIpDownloaderTaskExecutor.ENABLED_SETTING,\n             GeoIpDownloader.ENDPOINT_SETTING,\n             GeoIpDownloaderTaskExecutor.POLL_INTERVAL_SETTING,\n-            EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING\n+            EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING,\n+            EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_TOKEN_SETTING\n         );\n     }\n \ndiff --git a/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java b/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\nindex 88c37409..e1cd127b 100644\n--- a/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\n+++ b/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\n@@ -488,6 +488,36 @@ public class EnterpriseGeoIpDownloaderTests extends ESTestCase {\n         }\n     }\n \n+    public void testIpinfoUrls() {\n+        // a 'free' database like 'asn' has 'free/' in the url (automatically)\n+        final EnterpriseGeoIpDownloader.IpinfoDownload download = geoIpDownloader.new IpinfoDownload(\n+            \"asn\", new DatabaseConfiguration.Ipinfo()\n+        );\n+\n+        {\n+            String url = \"https://ipinfo.io/data/free/asn.mmdb\";\n+            assertThat(download.url(\"mmdb\"), equalTo(url));\n+        }\n+        {\n+            String url = \"https://ipinfo.io/data/free/asn.mmdb/checksums\";\n+            assertThat(download.url(\"mmdb/checksums\"), equalTo(url));\n+        }\n+\n+        // but a non-'free' database like 'standard_asn' does not\n+        final EnterpriseGeoIpDownloader.IpinfoDownload download2 = geoIpDownloader.new IpinfoDownload(\n+            \"standard_asn\", new DatabaseConfiguration.Ipinfo()\n+        );\n+\n+        {\n+            String url = \"https://ipinfo.io/data/standard_asn.mmdb\";\n+            assertThat(download2.url(\"mmdb\"), equalTo(url));\n+        }\n+        {\n+            String url = \"https://ipinfo.io/data/standard_asn.mmdb/checksums\";\n+            assertThat(download2.url(\"mmdb/checksums\"), equalTo(url));\n+        }\n+    }\n+\n     private static class MockClient extends NoOpClient {\n \n         private final Map<ActionType<?>, BiConsumer<? extends ActionRequest, ? extends ActionListener<?>>> handlers = new HashMap<>();\ndiff --git a/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java b/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\nindex 59205aa5..3f3e0c0a 100644\n--- a/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\n+++ b/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\n@@ -11,20 +11,18 @@ package fixture.geoip;\n \n import com.sun.net.httpserver.HttpServer;\n \n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.hash.MessageDigests;\n import org.junit.rules.ExternalResource;\n \n-import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n-import java.io.UncheckedIOException;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n import java.security.MessageDigest;\n+import java.util.List;\n+import java.util.Objects;\n \n /**\n  * This fixture is used to simulate a maxmind-provided server for downloading maxmind geoip database files from the\n@@ -32,21 +30,17 @@ import java.security.MessageDigest;\n  */\n public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n \n-    private final Path source;\n-    private final String[] databaseTypes;\n+    private final List<String> maxmindDatabaseTypes;\n+    private final List<String> ipinfoDatabaseTypes;\n     private HttpServer server;\n \n     /*\n-     * The values in databaseTypes must be in DatabaseConfiguration.MAXMIND_NAMES, and must be one of the databases copied in the\n-     * copyFiles method of thisi class.\n+     * The values in maxmindDatabaseTypes must be in DatabaseConfiguration.MAXMIND_NAMES, and the ipinfoDatabaseTypes\n+     * must be in DatabaseConfiguration.IPINFO_NAMES.\n      */\n-    public EnterpriseGeoIpHttpFixture(String... databaseTypes) {\n-        this.databaseTypes = databaseTypes;\n-        try {\n-            this.source = Files.createTempDirectory(\"source\");\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n+    public EnterpriseGeoIpHttpFixture(List<String> maxmindDatabaseTypes, List<String> ipinfoDatabaseTypes) {\n+        this.maxmindDatabaseTypes = List.copyOf(maxmindDatabaseTypes);\n+        this.ipinfoDatabaseTypes = List.copyOf(ipinfoDatabaseTypes);\n     }\n \n     public String getAddress() {\n@@ -55,7 +49,6 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n \n     @Override\n     protected void before() throws Throwable {\n-        copyFiles();\n         this.server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n \n         // for expediency reasons, it is handy to have this test fixture be able to serve the dual purpose of actually stubbing\n@@ -64,26 +57,33 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n         this.server.createContext(\"/\", exchange -> {\n             String response = \"[]\"; // an empty json array\n             exchange.sendResponseHeaders(200, response.length());\n-            try (OutputStream os = exchange.getResponseBody()) {\n-                os.write(response.getBytes(StandardCharsets.UTF_8));\n+            try (OutputStream out = exchange.getResponseBody()) {\n+                out.write(response.getBytes(StandardCharsets.UTF_8));\n             }\n         });\n \n         // register the file types for the download fixture\n-        for (String databaseType : databaseTypes) {\n-            createContextForEnterpriseDatabase(databaseType);\n+        for (String databaseType : maxmindDatabaseTypes) {\n+            createContextForMaxmindDatabase(databaseType);\n+        }\n+        for (String databaseType : ipinfoDatabaseTypes) {\n+            createContextForIpinfoDatabase(databaseType);\n         }\n \n         server.start();\n     }\n \n-    private void createContextForEnterpriseDatabase(String databaseType) {\n+    private static InputStream fixtureStream(String name) {\n+        return Objects.requireNonNull(GeoIpHttpFixture.class.getResourceAsStream(name));\n+    }\n+\n+    private void createContextForMaxmindDatabase(String databaseType) {\n         this.server.createContext(\"/\" + databaseType + \"/download\", exchange -> {\n             exchange.sendResponseHeaders(200, 0);\n             if (exchange.getRequestURI().toString().contains(\"sha256\")) {\n                 MessageDigest sha256 = MessageDigests.sha256();\n-                try (InputStream inputStream = GeoIpHttpFixture.class.getResourceAsStream(\"/geoip-fixture/\" + databaseType + \".tgz\")) {\n-                    sha256.update(inputStream.readAllBytes());\n+                try (InputStream in = fixtureStream(\"/geoip-fixture/\" + databaseType + \".tgz\")) {\n+                    sha256.update(in.readAllBytes());\n                 }\n                 exchange.getResponseBody()\n                     .write(\n@@ -93,10 +93,33 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n                     );\n             } else {\n                 try (\n-                    OutputStream outputStream = exchange.getResponseBody();\n-                    InputStream inputStream = GeoIpHttpFixture.class.getResourceAsStream(\"/geoip-fixture/\" + databaseType + \".tgz\")\n+                    OutputStream out = exchange.getResponseBody();\n+                    InputStream in = fixtureStream(\"/geoip-fixture/\" + databaseType + \".tgz\")\n+                ) {\n+                    in.transferTo(out);\n+                }\n+            }\n+            exchange.getResponseBody().close();\n+        });\n+    }\n+\n+    private void createContextForIpinfoDatabase(String databaseType) {\n+        this.server.createContext(\"/free/\" + databaseType + \".mmdb\", exchange -> {\n+            exchange.sendResponseHeaders(200, 0);\n+            if (exchange.getRequestURI().toString().contains(\"checksum\")) {\n+                MessageDigest md5 = MessageDigests.md5();\n+                try (InputStream in = fixtureStream(\"/ipinfo-fixture/ip_\" + databaseType + \"_sample.mmdb\")) {\n+                    md5.update(in.readAllBytes());\n+                }\n+                exchange.getResponseBody().write(Strings.format(\"\"\"\n+                    { \"checksums\": { \"md5\": \"%s\" } }\n+                    \"\"\", MessageDigests.toHexString(md5.digest())).getBytes(StandardCharsets.UTF_8));\n+            } else {\n+                try (\n+                    OutputStream out = exchange.getResponseBody();\n+                    InputStream in = fixtureStream(\"/ipinfo-fixture/ip_\" + databaseType + \"_sample.mmdb\")\n                 ) {\n-                    inputStream.transferTo(outputStream);\n+                    in.transferTo(out);\n                 }\n             }\n             exchange.getResponseBody().close();\n@@ -107,14 +130,4 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n     protected void after() {\n         server.stop(0);\n     }\n-\n-    private void copyFiles() throws Exception {\n-        for (String databaseType : databaseTypes) {\n-            Files.copy(\n-                GeoIpHttpFixture.class.getResourceAsStream(\"/geoip-fixture/GeoIP2-City.tgz\"),\n-                source.resolve(databaseType + \".tgz\"),\n-                StandardCopyOption.REPLACE_EXISTING\n-            );\n-        }\n-    }\n }",
  "logs_path": "factory/claude-sonnet-4-5-20250929/074538b9/elastic_elasticsearch_pr114872/logs.jsonl",
  "errors": [],
  "edit_run_id": "074538b9",
  "test_label": "v0"
}