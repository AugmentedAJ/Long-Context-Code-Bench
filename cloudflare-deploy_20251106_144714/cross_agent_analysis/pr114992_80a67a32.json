{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 114992,
  "base_commit": "cf9687f56de49bf5f07152b70b388d3f971aa9a5",
  "head_commit": "cb7a1477a6026b1e625bb8e98a727bcef9756d91",
  "task_instructions": "You are working on a codebase. Your task is to make the necessary code changes to accomplish the following:\n\n[Failure store - selector syntax] Introduce selector syntax in the APIs and remove failure_store query param\n\n**Introduction**\r\n\r\n> In order to make adoption of failure stores simpler for all users, we are introducing a new syntactical feature to index expression resolution: The selector.\r\n>\r\n> Selectors, denoted with a :: followed by a recognized suffix will allow users to specify which component of an index abstraction they would like to operate on within an API call. In this case, an index abstraction is a concrete index, data stream, or alias; Any abstraction that can be resolved to a set of indices/shards. We define a component of an index abstraction to be some searchable unit of the index abstraction.\r\n>\r\n> To start, we will support two components: data and failures. Concrete indices are their own data components, while the data component for index aliases are all of the indices contained therein. For data streams, the data component corresponds to their backing indices. Data stream aliases mirror this, treating all backing indices of the data streams they correspond to as their data component.\r\n> \r\n> The failure component is only supported by data streams and data stream aliases. The failure component of these abstractions refer to the data streams' failure stores. Indices and index aliases do not have a failure component.\r\n\r\nFor more details and examples see https://github.com/elastic/elasticsearch/pull/113144. All this work has been cherry picked from there.\r\n\r\n**Purpose of this PR**\r\n\r\nThis PR is introducing the selector on the REST API level. The selector works as follows:\r\n\r\n- `::data`: resolve to the backing indices of a data stream/data stream alias and the indices themselves\r\n- `::failures`: resolve to the failure indices of a data stream/data stream alias. Indices do not have a failure component so the behaviour is defined by allowing empty results.\r\n- `::*`: resolve to data for all expressions and failures when it's supported.\r\n\r\nFurthermore, we introduce a new gate keeper `IndicesOptions`, the `allowSelectors`, this flag determines if an endpoint supports the selector naming scheme or not. It's function is complementary to `allowFailureIndices` which determines if an operation can be applied on failure index. Both are necessary and they work as follows:\r\n\r\n- `PUT my-data::*/_mapping`: will throw an error because `allowSelectors: false`, so we do not allow the selector index to be used when updating a mapping.\r\n- `PUT .fs-my-data-xxxx/_mapping`: will throw an error because `allowFailureIndices: false`, this operation satisfies the no selectors conditions, but it does try to directly access the mapping which is not allowed.\r\n\r\nFuture work:\r\n- Rollover API (https://github.com/elastic/elasticsearch/issues/115210)\r\n- Resolve API (https://github.com/elastic/elasticsearch/issues/115212)\r\n- Snapshot index resolution (https://github.com/elastic/elasticsearch/issues/115242)\r\n- \n\nPlease make all necessary code changes to complete this task.",
  "ground_truth_diff": "diff --git a/docs/reference/ml/anomaly-detection/apis/put-job.asciidoc b/docs/reference/ml/anomaly-detection/apis/put-job.asciidoc\nindex 7bf02e7a0dd6..71fc8d40ffb4 100644\n--- a/docs/reference/ml/anomaly-detection/apis/put-job.asciidoc\n+++ b/docs/reference/ml/anomaly-detection/apis/put-job.asciidoc\n@@ -551,4 +551,3 @@ The API returns the following results:\n // TESTRESPONSE[s/\"job_version\" : \"8.4.0\"/\"job_version\" : $body.job_version/]\n // TESTRESPONSE[s/1656087283340/$body.$_path/]\n // TESTRESPONSE[s/\"superuser\"/\"_es_test_root\"/]\n-// TESTRESPONSE[s/\"ignore_throttled\" : true/\"ignore_throttled\" : true,\"failure_store\":\"exclude\"/]\ndiff --git a/modules/data-streams/src/javaRestTest/java/org/elasticsearch/datastreams/FailureStoreQueryParamIT.java b/modules/data-streams/src/javaRestTest/java/org/elasticsearch/datastreams/FailureStoreQueryParamIT.java\nindex 20ec26c0c934..027c432c4937 100644\n--- a/modules/data-streams/src/javaRestTest/java/org/elasticsearch/datastreams/FailureStoreQueryParamIT.java\n+++ b/modules/data-streams/src/javaRestTest/java/org/elasticsearch/datastreams/FailureStoreQueryParamIT.java\n@@ -78,13 +78,13 @@ public class FailureStoreQueryParamIT extends DisabledSecurityDataStreamTestCase\n             assertThat(indices.containsKey(failureStoreIndex), is(true));\n         }\n         {\n-            final Response indicesResponse = client().performRequest(new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"?failure_store=exclude\"));\n+            final Response indicesResponse = client().performRequest(new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"::data\"));\n             Map<String, Object> indices = entityAsMap(indicesResponse);\n             assertThat(indices.size(), is(1));\n             assertThat(indices.containsKey(backingIndex), is(true));\n         }\n         {\n-            final Response indicesResponse = client().performRequest(new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"?failure_store=only\"));\n+            final Response indicesResponse = client().performRequest(new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"::failures\"));\n             Map<String, Object> indices = entityAsMap(indicesResponse);\n             assertThat(indices.size(), is(1));\n             assertThat(indices.containsKey(failureStoreIndex), is(true));\n@@ -100,18 +100,14 @@ public class FailureStoreQueryParamIT extends DisabledSecurityDataStreamTestCase\n             assertThat(indices.containsKey(backingIndex), is(true));\n         }\n         {\n-            final Response statsResponse = client().performRequest(\n-                new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"/_stats?failure_store=include\")\n-            );\n+            final Response statsResponse = client().performRequest(new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"::*/_stats\"));\n             Map<String, Object> indices = (Map<String, Object>) entityAsMap(statsResponse).get(\"indices\");\n             assertThat(indices.size(), is(2));\n             assertThat(indices.containsKey(backingIndex), is(true));\n             assertThat(indices.containsKey(failureStoreIndex), is(true));\n         }\n         {\n-            final Response statsResponse = client().performRequest(\n-                new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"/_stats?failure_store=only\")\n-            );\n+            final Response statsResponse = client().performRequest(new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"::failures/_stats\"));\n             Map<String, Object> indices = (Map<String, Object>) entityAsMap(statsResponse).get(\"indices\");\n             assertThat(indices.size(), is(1));\n             assertThat(indices.containsKey(failureStoreIndex), is(true));\n@@ -126,18 +122,14 @@ public class FailureStoreQueryParamIT extends DisabledSecurityDataStreamTestCase\n             assertThat(indices.containsKey(backingIndex), is(true));\n         }\n         {\n-            final Response indicesResponse = client().performRequest(\n-                new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"/_settings?failure_store=include\")\n-            );\n+            final Response indicesResponse = client().performRequest(new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"::*/_settings\"));\n             Map<String, Object> indices = entityAsMap(indicesResponse);\n             assertThat(indices.size(), is(2));\n             assertThat(indices.containsKey(backingIndex), is(true));\n             assertThat(indices.containsKey(failureStoreIndex), is(true));\n         }\n         {\n-            final Response indicesResponse = client().performRequest(\n-                new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"/_settings?failure_store=only\")\n-            );\n+            final Response indicesResponse = client().performRequest(new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"::failures/_settings\"));\n             Map<String, Object> indices = entityAsMap(indicesResponse);\n             assertThat(indices.size(), is(1));\n             assertThat(indices.containsKey(failureStoreIndex), is(true));\n@@ -152,18 +144,14 @@ public class FailureStoreQueryParamIT extends DisabledSecurityDataStreamTestCase\n             assertThat(indices.containsKey(backingIndex), is(true));\n         }\n         {\n-            final Response indicesResponse = client().performRequest(\n-                new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"/_mapping?failure_store=include\")\n-            );\n+            final Response indicesResponse = client().performRequest(new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"::*/_mapping\"));\n             Map<String, Object> indices = entityAsMap(indicesResponse);\n             assertThat(indices.size(), is(2));\n             assertThat(indices.containsKey(backingIndex), is(true));\n             assertThat(indices.containsKey(failureStoreIndex), is(true));\n         }\n         {\n-            final Response indicesResponse = client().performRequest(\n-                new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"/_mapping?failure_store=only\")\n-            );\n+            final Response indicesResponse = client().performRequest(new Request(\"GET\", \"/\" + DATA_STREAM_NAME + \"::failures/_mapping\"));\n             Map<String, Object> indices = entityAsMap(indicesResponse);\n             assertThat(indices.size(), is(1));\n             assertThat(indices.containsKey(failureStoreIndex), is(true));\n@@ -186,7 +174,25 @@ public class FailureStoreQueryParamIT extends DisabledSecurityDataStreamTestCase\n             assertAcknowledged(client().performRequest(mappingRequest));\n         }\n         {\n-            final Request mappingRequest = new Request(\"PUT\", \"/\" + DATA_STREAM_NAME + \"/_mapping?failure_store=include\");\n+            final Request mappingRequest = new Request(\"PUT\", \"/\" + DATA_STREAM_NAME + \"::*/_mapping\");\n+            mappingRequest.setJsonEntity(\"\"\"\n+                {\n+                  \"properties\": {\n+                    \"email\": {\n+                      \"type\": \"keyword\"\n+                    }\n+                  }\n+                }\n+                \"\"\");\n+            ResponseException responseException = expectThrows(ResponseException.class, () -> client().performRequest(mappingRequest));\n+            Map<String, Object> response = entityAsMap(responseException.getResponse());\n+            assertThat(\n+                ((Map<String, Object>) response.get(\"error\")).get(\"reason\"),\n+                is(\"Index component selectors are not supported in this context but found selector in expression [failure-data-stream::*]\")\n+            );\n+        }\n+        {\n+            final Request mappingRequest = new Request(\"PUT\", \"/\" + failureStoreIndex + \"/_mapping\");\n             mappingRequest.setJsonEntity(\"\"\"\n                 {\n                   \"properties\": {\ndiff --git a/modules/data-streams/src/main/java/org/elasticsearch/datastreams/lifecycle/DataStreamLifecycleService.java b/modules/data-streams/src/main/java/org/elasticsearch/datastreams/lifecycle/DataStreamLifecycleService.java\nindex 7d2828e30d5a..b2a3c52705ef 100644\n--- a/modules/data-streams/src/main/java/org/elasticsearch/datastreams/lifecycle/DataStreamLifecycleService.java\n+++ b/modules/data-streams/src/main/java/org/elasticsearch/datastreams/lifecycle/DataStreamLifecycleService.java\n@@ -947,6 +947,11 @@ public class DataStreamLifecycleService implements ClusterStateListener, Closeab\n                 updateMergePolicySettingsRequest.indicesOptions(\n                     IndicesOptions.builder(updateMergePolicySettingsRequest.indicesOptions())\n                         .selectorOptions(IndicesOptions.SelectorOptions.ALL_APPLICABLE)\n+                        .gatekeeperOptions(\n+                            updateMergePolicySettingsRequest.indicesOptions()\n+                                .gatekeeperOptions()\n+                                .applyUpdate(b -> b.allowFailureIndices(true))\n+                        )\n                         .build()\n                 );\n                 updateMergePolicySettingsRequest.indices(indexName);\ndiff --git a/modules/data-streams/src/main/java/org/elasticsearch/datastreams/rest/RestGetDataStreamsAction.java b/modules/data-streams/src/main/java/org/elasticsearch/datastreams/rest/RestGetDataStreamsAction.java\nindex b61e38297397..be157608b1c3 100644\n--- a/modules/data-streams/src/main/java/org/elasticsearch/datastreams/rest/RestGetDataStreamsAction.java\n+++ b/modules/data-streams/src/main/java/org/elasticsearch/datastreams/rest/RestGetDataStreamsAction.java\n@@ -11,7 +11,6 @@ package org.elasticsearch.datastreams.rest;\n import org.elasticsearch.action.datastreams.GetDataStreamAction;\n import org.elasticsearch.action.support.IndicesOptions;\n import org.elasticsearch.client.internal.node.NodeClient;\n-import org.elasticsearch.cluster.metadata.DataStream;\n import org.elasticsearch.cluster.metadata.DataStreamLifecycle;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.util.set.Sets;\n@@ -42,8 +41,7 @@ public class RestGetDataStreamsAction extends BaseRestHandler {\n                 IndicesOptions.WildcardOptions.ALLOW_NO_INDICES,\n                 IndicesOptions.GatekeeperOptions.IGNORE_THROTTLED,\n                 \"verbose\"\n-            ),\n-            DataStream.isFailureStoreFeatureFlagEnabled() ? Set.of(IndicesOptions.FAILURE_STORE_QUERY_PARAM) : Set.of()\n+            )\n         )\n     );\n \ndiff --git a/server/src/main/java/org/elasticsearch/TransportVersions.java b/server/src/main/java/org/elasticsearch/TransportVersions.java\nindex b38a28590793..4ffe2521eb92 100644\n--- a/server/src/main/java/org/elasticsearch/TransportVersions.java\n+++ b/server/src/main/java/org/elasticsearch/TransportVersions.java\n@@ -212,6 +212,7 @@ public class TransportVersions {\n     public static final TransportVersion LOGSDB_TELEMETRY_CUSTOM_CUTOFF_DATE = def(8_801_00_0);\n     public static final TransportVersion SOURCE_MODE_TELEMETRY = def(8_802_00_0);\n     public static final TransportVersion NEW_REFRESH_CLUSTER_BLOCK = def(8_803_00_0);\n+    public static final TransportVersion USE_SELECTORS = def(8_804_00_0);\n \n     /*\n      * STOP! READ THIS FIRST! No, really,\ndiff --git a/server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequest.java b/server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequest.java\nindex 9c9467db40de..a3d651c19e0b 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequest.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequest.java\n@@ -16,7 +16,6 @@ import org.elasticsearch.action.ActionRequestValidationException;\n import org.elasticsearch.action.IndicesRequest;\n import org.elasticsearch.action.support.IndicesOptions;\n import org.elasticsearch.action.support.master.MasterNodeRequest;\n-import org.elasticsearch.cluster.metadata.DataStream;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.UUIDs;\n import org.elasticsearch.common.bytes.BytesReference;\n@@ -69,9 +68,9 @@ public class CreateSnapshotRequest extends MasterNodeRequest<CreateSnapshotReque\n \n     private String[] indices = EMPTY_ARRAY;\n \n-    private IndicesOptions indicesOptions = DataStream.isFailureStoreFeatureFlagEnabled()\n-        ? IndicesOptions.strictExpandHiddenIncludeFailureStore()\n-        : IndicesOptions.strictExpandHidden();\n+    private IndicesOptions indicesOptions = IndicesOptions.builder(IndicesOptions.strictExpandHidden())\n+        .selectorOptions(IndicesOptions.SelectorOptions.ALL_APPLICABLE)\n+        .build();\n \n     private String[] featureStates = EMPTY_ARRAY;\n \ndiff --git a/server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java b/server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java\nindex b7a513b3cb08..97ca37e8d8f8 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java\n@@ -14,7 +14,6 @@ import org.elasticsearch.TransportVersions;\n import org.elasticsearch.action.ActionRequestValidationException;\n import org.elasticsearch.action.support.IndicesOptions;\n import org.elasticsearch.action.support.master.MasterNodeRequest;\n-import org.elasticsearch.cluster.metadata.DataStream;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n@@ -44,9 +43,9 @@ public class RestoreSnapshotRequest extends MasterNodeRequest<RestoreSnapshotReq\n     private String snapshot;\n     private String repository;\n     private String[] indices = Strings.EMPTY_ARRAY;\n-    private IndicesOptions indicesOptions = DataStream.isFailureStoreFeatureFlagEnabled()\n-        ? IndicesOptions.strictExpandOpenIncludeFailureStore()\n-        : IndicesOptions.strictExpandOpen();\n+    private IndicesOptions indicesOptions = IndicesOptions.builder(IndicesOptions.strictExpandOpen())\n+        .selectorOptions(IndicesOptions.SelectorOptions.ALL_APPLICABLE)\n+        .build();\n     private String[] featureStates = Strings.EMPTY_ARRAY;\n     private String renamePattern;\n     private String renameReplacement;\ndiff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/alias/get/GetAliasesRequest.java b/server/src/main/java/org/elasticsearch/action/admin/indices/alias/get/GetAliasesRequest.java\nindex c28108815ed0..bff091b77541 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/indices/alias/get/GetAliasesRequest.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/alias/get/GetAliasesRequest.java\n@@ -24,7 +24,7 @@ import java.util.Map;\n \n public class GetAliasesRequest extends ActionRequest implements AliasesRequest {\n \n-    public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions.strictExpandHidden();\n+    public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions.strictExpandHiddenNoSelectors();\n \n     private String[] aliases;\n     private String[] originalAliases;\ndiff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequest.java b/server/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequest.java\nindex 96fae42b0550..2d0c61f67010 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequest.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequest.java\n@@ -44,6 +44,7 @@ public class DeleteIndexRequest extends AcknowledgedRequest<DeleteIndexRequest>\n                 .allowClosedIndices(true)\n                 .ignoreThrottled(false)\n                 .allowFailureIndices(true)\n+                .allowSelectors(true)\n                 .build()\n         )\n         .build();\ndiff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/get/GetIndexRequest.java b/server/src/main/java/org/elasticsearch/action/admin/indices/get/GetIndexRequest.java\nindex 801dbbdee085..763fa66659e6 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/indices/get/GetIndexRequest.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/get/GetIndexRequest.java\n@@ -12,7 +12,6 @@ package org.elasticsearch.action.admin.indices.get;\n import org.elasticsearch.action.ActionRequestValidationException;\n import org.elasticsearch.action.support.IndicesOptions;\n import org.elasticsearch.action.support.master.info.ClusterInfoRequest;\n-import org.elasticsearch.cluster.metadata.DataStream;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.common.util.ArrayUtils;\n@@ -96,11 +95,7 @@ public class GetIndexRequest extends ClusterInfoRequest<GetIndexRequest> {\n \n     public GetIndexRequest() {\n         super(\n-            DataStream.isFailureStoreFeatureFlagEnabled()\n-                ? IndicesOptions.builder(IndicesOptions.strictExpandOpen())\n-                    .selectorOptions(IndicesOptions.SelectorOptions.ALL_APPLICABLE)\n-                    .build()\n-                : IndicesOptions.strictExpandOpen()\n+            IndicesOptions.builder(IndicesOptions.strictExpandOpen()).selectorOptions(IndicesOptions.SelectorOptions.ALL_APPLICABLE).build()\n         );\n     }\n \ndiff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java b/server/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java\nindex 7b782c6da5a8..643e263721c2 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java\n@@ -83,6 +83,7 @@ public class PutMappingRequest extends AcknowledgedRequest<PutMappingRequest> im\n                 .allowAliasToMultipleIndices(true)\n                 .ignoreThrottled(false)\n                 .allowFailureIndices(false)\n+                .allowSelectors(false)\n         )\n         .build();\n \ndiff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/settings/put/UpdateSettingsRequest.java b/server/src/main/java/org/elasticsearch/action/admin/indices/settings/put/UpdateSettingsRequest.java\nindex fe5d688378bf..ebd4806f008f 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/indices/settings/put/UpdateSettingsRequest.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/settings/put/UpdateSettingsRequest.java\n@@ -41,7 +41,24 @@ public class UpdateSettingsRequest extends AcknowledgedRequest<UpdateSettingsReq\n         IndicesRequest.Replaceable,\n         ToXContentObject {\n \n-    public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions.fromOptions(false, false, true, true);\n+    public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions.builder()\n+        .concreteTargetOptions(IndicesOptions.ConcreteTargetOptions.ERROR_WHEN_UNAVAILABLE_TARGETS)\n+        .wildcardOptions(\n+            IndicesOptions.WildcardOptions.builder()\n+                .allowEmptyExpressions(false)\n+                .matchOpen(true)\n+                .matchClosed(true)\n+                .includeHidden(false)\n+                .resolveAliases(true)\n+        )\n+        .gatekeeperOptions(\n+            IndicesOptions.GatekeeperOptions.builder()\n+                .allowAliasToMultipleIndices(true)\n+                .allowClosedIndices(true)\n+                .allowFailureIndices(false)\n+                .allowSelectors(false)\n+        )\n+        .build();\n \n     private String[] indices;\n     private IndicesOptions indicesOptions = DEFAULT_INDICES_OPTIONS;\ndiff --git a/server/src/main/java/org/elasticsearch/action/support/IndicesOptions.java b/server/src/main/java/org/elasticsearch/action/support/IndicesOptions.java\nindex 85889d8398cb..1fb11be3b8ac 100644\n--- a/server/src/main/java/org/elasticsearch/action/support/IndicesOptions.java\n+++ b/server/src/main/java/org/elasticsearch/action/support/IndicesOptions.java\n@@ -31,6 +31,7 @@ import java.util.EnumSet;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n+import java.util.function.Function;\n import java.util.stream.Collectors;\n \n import static org.elasticsearch.common.xcontent.support.XContentMapValues.nodeBooleanValue;\n@@ -57,27 +58,6 @@ public record IndicesOptions(\n     SelectorOptions selectorOptions\n ) implements ToXContentFragment {\n \n-    /**\n-     * @deprecated this query param will be replaced by the selector `::` on the expression level\n-     */\n-    @Deprecated\n-    public static final String FAILURE_STORE_QUERY_PARAM = \"failure_store\";\n-    /**\n-     * @deprecated this value will be replaced by the selector `::*` on the expression level\n-     */\n-    @Deprecated\n-    public static final String INCLUDE_ALL = \"include\";\n-    /**\n-     * @deprecated this value will be replaced by the selector `::data` on the expression level\n-     */\n-    @Deprecated\n-    public static final String INCLUDE_ONLY_REGULAR_INDICES = \"exclude\";\n-    /**\n-     * @deprecated this value will be replaced by the selector `::failures` on the expression level\n-     */\n-    @Deprecated\n-    public static final String INCLUDE_ONLY_FAILURE_INDICES = \"only\";\n-\n     public static IndicesOptions.Builder builder() {\n         return new Builder();\n     }\n@@ -332,11 +312,12 @@ public record IndicesOptions(\n         boolean allowAliasToMultipleIndices,\n         boolean allowClosedIndices,\n         boolean allowFailureIndices,\n+        boolean allowSelectors,\n         @Deprecated boolean ignoreThrottled\n     ) implements ToXContentFragment {\n \n         public static final String IGNORE_THROTTLED = \"ignore_throttled\";\n-        public static final GatekeeperOptions DEFAULT = new GatekeeperOptions(true, true, true, false);\n+        public static final GatekeeperOptions DEFAULT = new GatekeeperOptions(true, true, true, true, false);\n \n         public static GatekeeperOptions parseParameter(Object ignoreThrottled, GatekeeperOptions defaultOptions) {\n             if (ignoreThrottled == null && defaultOptions != null) {\n@@ -356,6 +337,7 @@ public record IndicesOptions(\n             private boolean allowAliasToMultipleIndices;\n             private boolean allowClosedIndices;\n             private boolean allowFailureIndices;\n+            private boolean allowSelectors;\n             private boolean ignoreThrottled;\n \n             public Builder() {\n@@ -366,6 +348,7 @@ public record IndicesOptions(\n                 allowAliasToMultipleIndices = options.allowAliasToMultipleIndices;\n                 allowClosedIndices = options.allowClosedIndices;\n                 allowFailureIndices = options.allowFailureIndices;\n+                allowSelectors = options.allowSelectors;\n                 ignoreThrottled = options.ignoreThrottled;\n             }\n \n@@ -404,8 +387,22 @@ public record IndicesOptions(\n                 return this;\n             }\n \n+            /**\n+             * Selector syntax is accepted in the request.\n+             */\n+            public Builder allowSelectors(boolean allowSelectors) {\n+                this.allowSelectors = allowSelectors;\n+                return this;\n+            }\n+\n             public GatekeeperOptions build() {\n-                return new GatekeeperOptions(allowAliasToMultipleIndices, allowClosedIndices, allowFailureIndices, ignoreThrottled);\n+                return new GatekeeperOptions(\n+                    allowAliasToMultipleIndices,\n+                    allowClosedIndices,\n+                    allowFailureIndices,\n+                    allowSelectors,\n+                    ignoreThrottled\n+                );\n             }\n         }\n \n@@ -416,6 +413,10 @@ public record IndicesOptions(\n         public static Builder builder(GatekeeperOptions gatekeeperOptions) {\n             return new Builder(gatekeeperOptions);\n         }\n+\n+        public GatekeeperOptions applyUpdate(Function<Builder, Builder> update) {\n+            return update.apply(builder(this)).build();\n+        }\n     }\n \n     /**\n@@ -497,7 +498,8 @@ public record IndicesOptions(\n         ERROR_WHEN_CLOSED_INDICES,\n         IGNORE_THROTTLED,\n \n-        ALLOW_FAILURE_INDICES // Added in 8.14\n+        ALLOW_FAILURE_INDICES, // Added in 8.14\n+        ALLOW_SELECTORS        // Added in 8.17\n     }\n \n     private static final DeprecationLogger DEPRECATION_LOGGER = DeprecationLogger.getLogger(IndicesOptions.class);\n@@ -696,7 +698,7 @@ public record IndicesOptions(\n             GatekeeperOptions.builder()\n                 .allowAliasToMultipleIndices(true)\n                 .allowClosedIndices(true)\n-                .allowFailureIndices(false)\n+                .allowFailureIndices(true)\n                 .ignoreThrottled(false)\n         )\n         .build();\n@@ -909,6 +911,13 @@ public record IndicesOptions(\n         return gatekeeperOptions.allowFailureIndices();\n     }\n \n+    /**\n+     * @return Whether execution on failure indices is allowed.\n+     */\n+    public boolean allowSelectors() {\n+        return DataStream.isFailureStoreFeatureFlagEnabled() && gatekeeperOptions.allowSelectors();\n+    }\n+\n     /**\n      * @return whether aliases pointing to multiple indices are allowed\n      */\n@@ -969,6 +978,11 @@ public record IndicesOptions(\n                 backwardsCompatibleOptions.add(Option.ALLOW_FAILURE_INDICES);\n             }\n         }\n+        if (out.getTransportVersion().onOrAfter(TransportVersions.USE_SELECTORS)) {\n+            if (allowSelectors()) {\n+                backwardsCompatibleOptions.add(Option.ALLOW_SELECTORS);\n+            }\n+        }\n         out.writeEnumSet(backwardsCompatibleOptions);\n \n         EnumSet<WildcardStates> states = EnumSet.noneOf(WildcardStates.class);\n@@ -1003,11 +1017,16 @@ public record IndicesOptions(\n         if (in.getTransportVersion().onOrAfter(TransportVersions.V_8_14_0)) {\n             allowFailureIndices = options.contains(Option.ALLOW_FAILURE_INDICES);\n         }\n+        boolean allowSelectors = true;\n+        if (in.getTransportVersion().onOrAfter(TransportVersions.USE_SELECTORS)) {\n+            allowSelectors = options.contains(Option.ALLOW_SELECTORS);\n+        }\n         GatekeeperOptions gatekeeperOptions = GatekeeperOptions.builder()\n             .allowClosedIndices(options.contains(Option.ERROR_WHEN_CLOSED_INDICES) == false)\n             .allowAliasToMultipleIndices(options.contains(Option.ERROR_WHEN_ALIASES_TO_MULTIPLE_INDICES) == false)\n             .allowFailureIndices(allowFailureIndices)\n             .ignoreThrottled(options.contains(Option.IGNORE_THROTTLED))\n+            .allowSelectors(allowSelectors)\n             .build();\n         SelectorOptions selectorOptions = SelectorOptions.DEFAULT;\n         if (in.getTransportVersion()\n@@ -1202,26 +1221,11 @@ public record IndicesOptions(\n             request.param(ConcreteTargetOptions.IGNORE_UNAVAILABLE),\n             request.param(WildcardOptions.ALLOW_NO_INDICES),\n             request.param(GatekeeperOptions.IGNORE_THROTTLED),\n-            DataStream.isFailureStoreFeatureFlagEnabled() ? request.param(FAILURE_STORE_QUERY_PARAM) : INCLUDE_ONLY_REGULAR_INDICES,\n             defaultSettings\n         );\n     }\n \n     public static IndicesOptions fromMap(Map<String, Object> map, IndicesOptions defaultSettings) {\n-        if (DataStream.isFailureStoreFeatureFlagEnabled()) {\n-            return fromParameters(\n-                map.containsKey(WildcardOptions.EXPAND_WILDCARDS) ? map.get(WildcardOptions.EXPAND_WILDCARDS) : map.get(\"expandWildcards\"),\n-                map.containsKey(ConcreteTargetOptions.IGNORE_UNAVAILABLE)\n-                    ? map.get(ConcreteTargetOptions.IGNORE_UNAVAILABLE)\n-                    : map.get(\"ignoreUnavailable\"),\n-                map.containsKey(WildcardOptions.ALLOW_NO_INDICES) ? map.get(WildcardOptions.ALLOW_NO_INDICES) : map.get(\"allowNoIndices\"),\n-                map.containsKey(GatekeeperOptions.IGNORE_THROTTLED)\n-                    ? map.get(GatekeeperOptions.IGNORE_THROTTLED)\n-                    : map.get(\"ignoreThrottled\"),\n-                map.containsKey(FAILURE_STORE_QUERY_PARAM) ? map.get(FAILURE_STORE_QUERY_PARAM) : map.get(\"failureStore\"),\n-                defaultSettings\n-            );\n-        }\n         return fromParameters(\n             map.containsKey(WildcardOptions.EXPAND_WILDCARDS) ? map.get(WildcardOptions.EXPAND_WILDCARDS) : map.get(\"expandWildcards\"),\n             map.containsKey(ConcreteTargetOptions.IGNORE_UNAVAILABLE)\n@@ -1245,9 +1249,7 @@ public record IndicesOptions(\n             || GatekeeperOptions.IGNORE_THROTTLED.equals(name)\n             || \"ignoreThrottled\".equals(name)\n             || WildcardOptions.ALLOW_NO_INDICES.equals(name)\n-            || \"allowNoIndices\".equals(name)\n-            || (DataStream.isFailureStoreFeatureFlagEnabled() && FAILURE_STORE_QUERY_PARAM.equals(name))\n-            || (DataStream.isFailureStoreFeatureFlagEnabled() && \"failureStore\".equals(name));\n+            || \"allowNoIndices\".equals(name);\n     }\n \n     public static IndicesOptions fromParameters(\n@@ -1257,73 +1259,27 @@ public record IndicesOptions(\n         Object ignoreThrottled,\n         IndicesOptions defaultSettings\n     ) {\n-        return fromParameters(wildcardsString, ignoreUnavailableString, allowNoIndicesString, ignoreThrottled, null, defaultSettings);\n-    }\n-\n-    public static IndicesOptions fromParameters(\n-        Object wildcardsString,\n-        Object ignoreUnavailableString,\n-        Object allowNoIndicesString,\n-        Object ignoreThrottled,\n-        Object failureStoreString,\n-        IndicesOptions defaultSettings\n-    ) {\n-        if (wildcardsString == null\n-            && ignoreUnavailableString == null\n-            && allowNoIndicesString == null\n-            && ignoreThrottled == null\n-            && failureStoreString == null) {\n+        if (wildcardsString == null && ignoreUnavailableString == null && allowNoIndicesString == null && ignoreThrottled == null) {\n             return defaultSettings;\n         }\n \n         WildcardOptions wildcards = WildcardOptions.parseParameters(wildcardsString, allowNoIndicesString, defaultSettings.wildcardOptions);\n         GatekeeperOptions gatekeeperOptions = GatekeeperOptions.parseParameter(ignoreThrottled, defaultSettings.gatekeeperOptions);\n-        SelectorOptions selectorOptions = DataStream.isFailureStoreFeatureFlagEnabled()\n-            ? parseFailureStoreParameters(failureStoreString, defaultSettings.selectorOptions)\n-            : SelectorOptions.DEFAULT;\n \n         // note that allowAliasesToMultipleIndices is not exposed, always true (only for internal use)\n         return IndicesOptions.builder()\n             .concreteTargetOptions(ConcreteTargetOptions.fromParameter(ignoreUnavailableString, defaultSettings.concreteTargetOptions))\n             .wildcardOptions(wildcards)\n             .gatekeeperOptions(gatekeeperOptions)\n-            .selectorOptions(selectorOptions)\n+            .selectorOptions(defaultSettings.selectorOptions)\n             .build();\n     }\n \n-    /**\n-     * @deprecated This method parses the query parameter failure_store. This is a deprecated param, and it will be replaced\n-     * the selector suffix, for example `my-data-stream::data` or `my-data-stream::failures`\n-     */\n-    @Deprecated\n-    private static SelectorOptions parseFailureStoreParameters(Object failureStoreValue, SelectorOptions defaultOptions) {\n-        if (failureStoreValue == null) {\n-            return defaultOptions;\n-        }\n-        return switch (failureStoreValue.toString()) {\n-            case INCLUDE_ALL -> SelectorOptions.ALL_APPLICABLE;\n-            case INCLUDE_ONLY_REGULAR_INDICES -> SelectorOptions.DATA;\n-            case INCLUDE_ONLY_FAILURE_INDICES -> SelectorOptions.FAILURES;\n-            default -> throw new IllegalArgumentException(\"No valid \" + FAILURE_STORE_QUERY_PARAM + \" value [\" + failureStoreValue + \"]\");\n-        };\n-    }\n-\n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {\n         concreteTargetOptions.toXContent(builder, params);\n         wildcardOptions.toXContent(builder, params);\n         gatekeeperOptions.toXContent(builder, params);\n-        if (DataStream.isFailureStoreFeatureFlagEnabled()) {\n-            String displayValue;\n-            if (SelectorOptions.ALL_APPLICABLE.equals(selectorOptions())) {\n-                displayValue = INCLUDE_ALL;\n-            } else if (SelectorOptions.DATA.equals(selectorOptions())) {\n-                displayValue = INCLUDE_ONLY_REGULAR_INDICES;\n-            } else {\n-                displayValue = INCLUDE_ONLY_FAILURE_INDICES;\n-            }\n-            builder.field(FAILURE_STORE_QUERY_PARAM, displayValue);\n-        }\n         return builder;\n     }\n \n@@ -1331,7 +1287,6 @@ public record IndicesOptions(\n     private static final ParseField IGNORE_UNAVAILABLE_FIELD = new ParseField(ConcreteTargetOptions.IGNORE_UNAVAILABLE);\n     private static final ParseField IGNORE_THROTTLED_FIELD = new ParseField(GatekeeperOptions.IGNORE_THROTTLED).withAllDeprecated();\n     private static final ParseField ALLOW_NO_INDICES_FIELD = new ParseField(WildcardOptions.ALLOW_NO_INDICES);\n-    private static final ParseField FAILURE_STORE_FIELD = new ParseField(FAILURE_STORE_QUERY_PARAM);\n \n     public static IndicesOptions fromXContent(XContentParser parser) throws IOException {\n         return fromXContent(parser, null);\n@@ -1392,14 +1347,11 @@ public record IndicesOptions(\n                     allowNoIndices = parser.booleanValue();\n                 } else if (IGNORE_THROTTLED_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {\n                     generalOptions.ignoreThrottled(parser.booleanValue());\n-                } else if (DataStream.isFailureStoreFeatureFlagEnabled()\n-                    && FAILURE_STORE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {\n-                        selectorOptions = parseFailureStoreParameters(parser.text(), selectorOptions);\n-                    } else {\n-                        throw new ElasticsearchParseException(\n-                            \"could not read indices options. Unexpected index option [\" + currentFieldName + \"]\"\n-                        );\n-                    }\n+                } else {\n+                    throw new ElasticsearchParseException(\n+                        \"could not read indices options. Unexpected index option [\" + currentFieldName + \"]\"\n+                    );\n+                }\n             } else {\n                 throw new ElasticsearchParseException(\"could not read indices options. Unexpected object field [\" + currentFieldName + \"]\");\n             }\n@@ -1479,6 +1431,14 @@ public record IndicesOptions(\n         return STRICT_EXPAND_OPEN_CLOSED_HIDDEN;\n     }\n \n+    /**\n+     * @return indices option that requires every specified index to exist, expands wildcards to both open and closed indices, includes\n+     * hidden indices, and allows that no indices are resolved from wildcard expressions (not returning an error). Selectors are no allowed.\n+     */\n+    public static IndicesOptions strictExpandHiddenNoSelectors() {\n+        return STRICT_EXPAND_OPEN_CLOSED_HIDDEN_NO_SELECTORS;\n+    }\n+\n     /**\n      * @return indices option that expands wildcards to both open and closed indices, includes failure store\n      * (with data stream) and allows that indices can be missing and no indices are resolved from wildcard expressions\n@@ -1572,6 +1532,8 @@ public record IndicesOptions(\n                     + includeFailureIndices()\n                     + \", allow_failure_indices=\"\n                     + allowFailureIndices()\n+                    + \", allow_selectors=\"\n+                    + allowSelectors()\n                 : \"\")\n             + ']';\n     }\ndiff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java\nindex 279243eeff7c..7e11e291e468 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java\n@@ -13,6 +13,7 @@ import org.apache.lucene.util.automaton.Automaton;\n import org.elasticsearch.ElasticsearchParseException;\n import org.elasticsearch.action.DocWriteRequest;\n import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndexComponentSelector;\n import org.elasticsearch.action.support.IndicesOptions;\n import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.metadata.IndexAbstraction.Type;\n@@ -28,6 +29,7 @@ import org.elasticsearch.common.util.concurrent.ThreadContext;\n import org.elasticsearch.common.util.set.Sets;\n import org.elasticsearch.core.Nullable;\n import org.elasticsearch.core.Predicates;\n+import org.elasticsearch.core.Tuple;\n import org.elasticsearch.index.Index;\n import org.elasticsearch.index.IndexNotFoundException;\n import org.elasticsearch.index.IndexVersion;\n@@ -56,6 +58,7 @@ import java.util.Set;\n import java.util.SortedMap;\n import java.util.function.LongSupplier;\n import java.util.function.Predicate;\n+import java.util.function.Supplier;\n \n /**\n  * This class main focus is to resolve multi-syntax target expressions to resources or concrete indices. This resolution is influenced\n@@ -71,6 +74,7 @@ public class IndexNameExpressionResolver {\n \n     public static final String EXCLUDED_DATA_STREAMS_KEY = \"es.excluded_ds\";\n     public static final IndexVersion SYSTEM_INDEX_ENFORCEMENT_INDEX_VERSION = IndexVersions.V_8_0_0;\n+    public static final Tuple<Collection<String>, Collection<String>> EMPTY_EXPRESSIONS = Tuple.tuple(List.of(), List.of());\n \n     private final ThreadContext threadContext;\n     private final SystemIndices systemIndices;\n@@ -197,7 +201,7 @@ public class IndexNameExpressionResolver {\n             getSystemIndexAccessPredicate(),\n             getNetNewSystemIndexPredicate()\n         );\n-        final Collection<String> expressions = resolveExpressionsToResources(context, indexExpressions);\n+        final Collection<String> expressions = resolveExpressionsToResources(context, indexExpressions).v1();\n         return expressions.stream()\n             .map(x -> state.metadata().getIndicesLookup().get(x))\n             .filter(Objects::nonNull)\n@@ -227,7 +231,7 @@ public class IndexNameExpressionResolver {\n             getNetNewSystemIndexPredicate()\n         );\n \n-        final Collection<String> expressions = resolveExpressionsToResources(context, request.index());\n+        final Collection<String> expressions = resolveExpressionsToResources(context, request.index()).v1();\n \n         if (expressions.size() == 1) {\n             IndexAbstraction ia = state.metadata().getIndicesLookup().get(expressions.iterator().next());\n@@ -257,34 +261,45 @@ public class IndexNameExpressionResolver {\n      * If {@param preserveDataStreams} is {@code true}, data streams that are covered by the wildcards from the\n      * {@param expressions} are returned as-is, without expanding them further to their respective backing indices.\n      */\n-    protected static Collection<String> resolveExpressionsToResources(Context context, String... expressions) {\n+    protected static Tuple<Collection<String>, Collection<String>> resolveExpressionsToResources(Context context, String... expressions) {\n         // If we do not expand wildcards, then empty or _all expression result in an empty list\n         boolean expandWildcards = context.getOptions().expandWildcardExpressions();\n         if (expandWildcards == false) {\n             if (expressions == null || expressions.length == 0 || expressions.length == 1 && Metadata.ALL.equals(expressions[0])) {\n-                return List.of();\n+                return EMPTY_EXPRESSIONS;\n             }\n         } else {\n             if (expressions == null\n                 || expressions.length == 0\n                 || expressions.length == 1 && (Metadata.ALL.equals(expressions[0]) || Regex.isMatchAllPattern(expressions[0]))) {\n-                return WildcardExpressionResolver.resolveAll(context);\n+                return Tuple.tuple(WildcardExpressionResolver.resolveAll(context), List.of());\n             } else if (isNoneExpression(expressions)) {\n-                return List.of();\n+                return EMPTY_EXPRESSIONS;\n             }\n         }\n \n-        // Using ArrayList when we know we do not have wildcards is an optimisation, given that one expression result in 0 or 1 resources.\n-        Collection<String> resources = expandWildcards && WildcardExpressionResolver.hasWildcards(expressions)\n+        // Using ArrayList when we know we do not have wildcards is an optimisation, given that one expression\n+        // result in 0 or 1 resources per component.\n+        Supplier<Collection<String>> collectionSupplier = () -> expandWildcards && WildcardExpressionResolver.hasWildcards(expressions)\n             ? new LinkedHashSet<>()\n             : new ArrayList<>(expressions.length);\n+        Collection<String> data = collectionSupplier.get();\n+        Collection<String> failures = collectionSupplier.get();\n         boolean wildcardSeen = false;\n         for (int i = 0, n = expressions.length; i < n; i++) {\n             String originalExpression = expressions[i];\n \n+            // Resolve the selector when applicable\n+            Tuple<String, IndexComponentSelector> tuple = SelectorResolver.parseSelectorExpression(originalExpression);\n+            String baseExpression = tuple.v1();\n+            IndexComponentSelector selector = tuple.v2();\n+            if (context.getOptions().gatekeeperOptions().allowSelectors() == false) {\n+                SelectorResolver.ensureNoSelectorsProvided(originalExpression, selector);\n+            }\n+\n             // Resolve exclusion, a `-` prefixed expression is an exclusion only if it succeeds a wildcard.\n-            boolean isExclusion = wildcardSeen && originalExpression.startsWith(\"-\");\n-            String baseExpression = isExclusion ? originalExpression.substring(1) : originalExpression;\n+            boolean isExclusion = wildcardSeen && baseExpression.startsWith(\"-\");\n+            baseExpression = isExclusion ? baseExpression.substring(1) : baseExpression;\n \n             // Resolve date math\n             baseExpression = DateMathExpressionResolver.resolveExpression(baseExpression, context::getStartTime);\n@@ -293,30 +308,27 @@ public class IndexNameExpressionResolver {\n             validateResourceExpression(context, baseExpression, expressions);\n \n             // Check if it's wildcard\n-            boolean isWildcard = expandWildcards && WildcardExpressionResolver.isWildcard(originalExpression);\n+            boolean isWildcard = expandWildcards && WildcardExpressionResolver.isWildcard(baseExpression);\n             wildcardSeen |= isWildcard;\n \n             if (isWildcard) {\n-                Set<String> matchingResources = WildcardExpressionResolver.matchWildcardToResources(context, baseExpression);\n-\n-                if (context.getOptions().allowNoIndices() == false && matchingResources.isEmpty()) {\n-                    throw notFoundException(baseExpression);\n-                }\n-\n-                if (isExclusion) {\n-                    resources.removeAll(matchingResources);\n-                } else {\n-                    resources.addAll(matchingResources);\n-                }\n+                WildcardExpressionResolver.processWildcards(context, baseExpression, selector, data, failures, isExclusion);\n             } else {\n+                selector = getApplicableSelector(context, selector);\n+                // TODO-PR exclusion is not tested yet\n                 if (isExclusion) {\n-                    resources.remove(baseExpression);\n-                } else if (ensureAliasOrIndexExists(context, baseExpression)) {\n-                    resources.add(baseExpression);\n+                    if (selector == null || selector.shouldIncludeData()) {\n+                        data.remove(baseExpression);\n+                    }\n+                    if (selector != null && selector.shouldIncludeFailures()) {\n+                        failures.remove(baseExpression);\n+                    }\n+                } else {\n+                    addResourceIfItExists(context, baseExpression, selector, data, failures);\n                 }\n             }\n         }\n-        return resources;\n+        return Tuple.tuple(data, failures);\n     }\n \n     /**\n@@ -428,68 +440,47 @@ public class IndexNameExpressionResolver {\n     }\n \n     Index[] concreteIndices(Context context, String... indexExpressions) {\n-        final Collection<String> expressions = resolveExpressionsToResources(context, indexExpressions);\n+        final Tuple<Collection<String>, Collection<String>> expressions = resolveExpressionsToResources(context, indexExpressions);\n+        Collection<String> data = expressions.v1();\n+        Collection<String> failures = expressions.v2();\n \n-        final Set<Index> concreteIndicesResult = Sets.newLinkedHashSetWithExpectedSize(expressions.size());\n+        final Set<Index> concreteIndicesResult = Sets.newLinkedHashSetWithExpectedSize(data.size());\n         final Map<String, IndexAbstraction> indicesLookup = context.getState().metadata().getIndicesLookup();\n-        for (String expression : expressions) {\n-            final IndexAbstraction indexAbstraction = indicesLookup.get(expression);\n-            assert indexAbstraction != null;\n-            if (indexAbstraction.getType() == Type.ALIAS && context.isResolveToWriteIndex()) {\n-                Index writeIndex = indexAbstraction.getWriteIndex();\n-                if (writeIndex == null) {\n-                    throw new IllegalArgumentException(\n-                        \"no write index is defined for alias [\"\n-                            + indexAbstraction.getName()\n-                            + \"].\"\n-                            + \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\"\n-                            + \" indices without one being designated as a write index\"\n-                    );\n-                }\n-                if (indexAbstraction.isDataStreamRelated()) {\n-                    DataStream dataStream = indicesLookup.get(indexAbstraction.getWriteIndex().getName()).getParentDataStream();\n-                    resolveWriteIndexForDataStreams(context, dataStream, concreteIndicesResult);\n-                } else {\n+        if (data.isEmpty() == false) {\n+            for (String expression : data) {\n+                final IndexAbstraction indexAbstraction = indicesLookup.get(expression);\n+                assert indexAbstraction != null;\n+                if ((indexAbstraction.getType() == Type.ALIAS || indexAbstraction.getType() == Type.DATA_STREAM)\n+                    && context.isResolveToWriteIndex()) {\n+                    Index writeIndex = indexAbstraction.getWriteIndex();\n+                    if (writeIndex == null) {\n+                        throw new IllegalArgumentException(\n+                            \"no write index is defined for alias [\"\n+                                + indexAbstraction.getName()\n+                                + \"].\"\n+                                + \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\"\n+                                + \" indices without one being designated as a write index\"\n+                        );\n+                    }\n                     if (addIndex(writeIndex, null, context)) {\n                         concreteIndicesResult.add(writeIndex);\n                     }\n-                }\n-            } else if (indexAbstraction.getType() == Type.DATA_STREAM && context.isResolveToWriteIndex()) {\n-                resolveWriteIndexForDataStreams(context, (DataStream) indexAbstraction, concreteIndicesResult);\n-            } else {\n-                if (resolvesToMoreThanOneIndex(indexAbstraction, context)\n-                    && context.getOptions().allowAliasesToMultipleIndices() == false) {\n-                    String[] indexNames = new String[indexAbstraction.getIndices().size()];\n-                    int i = 0;\n-                    for (Index indexName : indexAbstraction.getIndices()) {\n-                        indexNames[i++] = indexName.getName();\n-                    }\n-                    throw new IllegalArgumentException(\n-                        indexAbstraction.getType().getDisplayName()\n-                            + \" [\"\n-                            + expression\n-                            + \"] has more than one index associated with it \"\n-                            + Arrays.toString(indexNames)\n-                            + \", can't execute a single index op\"\n-                    );\n-                }\n-\n-                if (indexAbstraction.getType() == Type.DATA_STREAM) {\n-                    resolveIndicesForDataStream(context, (DataStream) indexAbstraction, concreteIndicesResult);\n-                } else if (indexAbstraction.getType() == Type.ALIAS\n-                    && indexAbstraction.isDataStreamRelated()\n-                    && DataStream.isFailureStoreFeatureFlagEnabled()\n-                    && context.getOptions().includeFailureIndices()) {\n-                        // Collect the data streams involved\n-                        Set<DataStream> aliasDataStreams = new HashSet<>();\n-                        List<Index> indices = indexAbstraction.getIndices();\n-                        for (int i = 0, n = indices.size(); i < n; i++) {\n-                            Index index = indices.get(i);\n-                            aliasDataStreams.add(indicesLookup.get(index.getName()).getParentDataStream());\n-                        }\n-                        for (DataStream dataStream : aliasDataStreams) {\n-                            resolveIndicesForDataStream(context, dataStream, concreteIndicesResult);\n+                } else {\n+                    if (resolvesToMoreThanOneIndex(indexAbstraction, context)\n+                        && context.getOptions().allowAliasesToMultipleIndices() == false) {\n+                        String[] indexNames = new String[indexAbstraction.getIndices().size()];\n+                        int i = 0;\n+                        for (Index indexName : indexAbstraction.getIndices()) {\n+                            indexNames[i++] = indexName.getName();\n                         }\n+                        throw new IllegalArgumentException(\n+                            indexAbstraction.getType().getDisplayName()\n+                                + \" [\"\n+                                + expression\n+                                + \"] has more than one index associated with it \"\n+                                + Arrays.toString(indexNames)\n+                                + \", can't execute a single index op\"\n+                        );\n                     } else {\n                         List<Index> indices = indexAbstraction.getIndices();\n                         for (int i = 0, n = indices.size(); i < n; i++) {\n@@ -499,6 +490,67 @@ public class IndexNameExpressionResolver {\n                             }\n                         }\n                     }\n+                }\n+            }\n+        }\n+\n+        if (failures.isEmpty() == false) {\n+            for (String expression : failures) {\n+                final IndexAbstraction indexAbstraction = indicesLookup.get(expression);\n+                assert indexAbstraction != null;\n+                assert indexAbstraction.getType() == Type.DATA_STREAM || indexAbstraction.getType() == Type.ALIAS\n+                    : \"failure store is not supported by concrete indices\";\n+                if (context.isResolveToWriteIndex()) {\n+                    assert indexAbstraction.isDataStreamRelated() : \"failure store is only supported by data streams and their aliases\";\n+                    Index writeIndex = indexAbstraction.getWriteIndex();\n+                    if (writeIndex == null) {\n+                        throw new IllegalArgumentException(\n+                            \"no write index is defined for alias [\"\n+                                + indexAbstraction.getName()\n+                                + \"].\"\n+                                + \" The write index may be explicitly disabled using is_write_index=false or the alias points to multiple\"\n+                                + \" indices without one being designated as a write index\"\n+                        );\n+                    }\n+                    DataStream dataStream = indexAbstraction.getType() == Type.DATA_STREAM\n+                        ? (DataStream) indexAbstraction\n+                        : indicesLookup.get(indexAbstraction.getWriteIndex().getName()).getParentDataStream();\n+                    resolveWriteIndexForDataStreams(context, dataStream, concreteIndicesResult);\n+                } else {\n+                    if (resolvesToMoreThanOneIndex(indexAbstraction, context)\n+                        && context.getOptions().allowAliasesToMultipleIndices() == false) {\n+                        String[] indexNames = new String[indexAbstraction.getIndices().size()];\n+                        int i = 0;\n+                        for (Index indexName : indexAbstraction.getIndices()) {\n+                            indexNames[i++] = indexName.getName();\n+                        }\n+                        throw new IllegalArgumentException(\n+                            indexAbstraction.getType().getDisplayName()\n+                                + \" [\"\n+                                + expression\n+                                + \"] has more than one index associated with it \"\n+                                + Arrays.toString(indexNames)\n+                                + \", can't execute a single index op\"\n+                        );\n+                    }\n+\n+                    if (indexAbstraction.getType() == Type.DATA_STREAM) {\n+                        addFailureIndices(context, (DataStream) indexAbstraction, concreteIndicesResult);\n+                    } else if (indexAbstraction.getType() == Type.ALIAS\n+                        && indexAbstraction.isDataStreamRelated()\n+                        && DataStream.isFailureStoreFeatureFlagEnabled()) {\n+                            // Collect the data streams involved\n+                            Set<DataStream> aliasDataStreams = new HashSet<>();\n+                            List<Index> indices = indexAbstraction.getIndices();\n+                            for (int i = 0, n = indices.size(); i < n; i++) {\n+                                Index index = indices.get(i);\n+                                aliasDataStreams.add(indicesLookup.get(index.getName()).getParentDataStream());\n+                            }\n+                            for (DataStream dataStream : aliasDataStreams) {\n+                                addFailureIndices(context, dataStream, concreteIndicesResult);\n+                            }\n+                        }\n+                }\n             }\n         }\n \n@@ -510,26 +562,19 @@ public class IndexNameExpressionResolver {\n         return resultArray;\n     }\n \n-    private static void resolveIndicesForDataStream(Context context, DataStream dataStream, Set<Index> concreteIndicesResult) {\n-        if (shouldIncludeRegularIndices(context.getOptions())) {\n-            List<Index> indices = dataStream.getIndices();\n-            for (int i = 0, n = indices.size(); i < n; i++) {\n-                Index index = indices.get(i);\n-                if (shouldTrackConcreteIndex(context, index)) {\n-                    concreteIndicesResult.add(index);\n-                }\n-            }\n+    private static void addFailureIndices(Context context, DataStream dataStream, Set<Index> concreteIndicesResult) {\n+        // We short-circuit here, if failure indices are not allowed and they can be skipped\n+        if (context.getOptions().allowFailureIndices() == false && context.getOptions().ignoreUnavailable()) {\n+            return;\n         }\n-        if (shouldIncludeFailureIndices(context.getOptions())) {\n-            // We short-circuit here, if failure indices are not allowed and they can be skipped\n-            if (context.getOptions().allowFailureIndices() || context.getOptions().ignoreUnavailable() == false) {\n-                List<Index> failureIndices = dataStream.getFailureIndices().getIndices();\n-                for (int i = 0, n = failureIndices.size(); i < n; i++) {\n-                    Index index = failureIndices.get(i);\n-                    if (shouldTrackConcreteIndex(context, index)) {\n-                        concreteIndicesResult.add(index);\n-                    }\n+        List<Index> failureIndices = dataStream.getFailureIndices().getIndices();\n+        for (int i = 0, n = failureIndices.size(); i < n; i++) {\n+            Index index = failureIndices.get(i);\n+            if (shouldTrackConcreteIndex(context, index)) {\n+                if (context.getOptions().allowFailureIndices() == false) {\n+                    throw new FailureIndexNotSupportedException(index);\n                 }\n+                concreteIndicesResult.add(index);\n             }\n         }\n     }\n@@ -651,10 +696,14 @@ public class IndexNameExpressionResolver {\n \n     private static IllegalArgumentException aliasesNotSupportedException(String expression) {\n         return new IllegalArgumentException(\n-            \"The provided expression [\" + expression + \"] matches an \" + \"alias, specify the corresponding concrete indices instead.\"\n+            \"The provided expression [\" + expression + \"] matches an alias, specify the corresponding concrete indices instead.\"\n         );\n     }\n \n+    private static IllegalArgumentException failuresSelectorNotSupportedException(String expression) {\n+        return new IllegalArgumentException(\"The provided expression [\" + expression + \"] does not support the selector [::failures].\");\n+    }\n+\n     /**\n      * Utility method that allows to resolve an index expression to its corresponding single concrete index.\n      * Callers should make sure they provide proper {@link org.elasticsearch.action.support.IndicesOptions}\n@@ -786,7 +835,7 @@ public class IndexNameExpressionResolver {\n             getNetNewSystemIndexPredicate()\n         );\n         // unmodifiable without creating a new collection as it might contain many items\n-        Collection<String> resolved = resolveExpressionsToResources(context, expressions);\n+        Collection<String> resolved = resolveExpressionsToResources(context, expressions).v1();\n         if (resolved instanceof Set<String>) {\n             // unmodifiable without creating a new collection as it might contain many items\n             return Collections.unmodifiableSet((Set<String>) resolved);\n@@ -937,7 +986,7 @@ public class IndexNameExpressionResolver {\n             getSystemIndexAccessPredicate(),\n             getNetNewSystemIndexPredicate()\n         );\n-        final Collection<String> resolvedExpressions = resolveExpressionsToResources(context, expressions);\n+        final Collection<String> resolvedExpressions = resolveExpressionsToResources(context, expressions).v1();\n \n         // TODO: it appears that this can never be true?\n         if (isAllIndices(resolvedExpressions)) {\n@@ -1111,40 +1160,86 @@ public class IndexNameExpressionResolver {\n     }\n \n     /**\n-     * This returns `true` if the given {@param name} is of a resource that exists.\n-     * Otherwise, it returns `false` if the `ignore_unvailable` option is `true`, or, if `false`, it throws a \"not found\" type of\n-     * exception.\n+     * Adds the resource with {@param name} to the respective collection {@param data} and/or {@param failures} depending on the resource\n+     * type and the selector.\n+     * If the resources is not available and the `ignore_unavailable` option is `true` it throws an exception.\n+     * If requested selector {@param selector} is not supported by the resource {@param name}, it also throws an exception.\n      */\n-    @Nullable\n-    private static boolean ensureAliasOrIndexExists(Context context, String name) {\n+    // TODO-PR not tested\n+    private static void addResourceIfItExists(\n+        Context context,\n+        String name,\n+        IndexComponentSelector selector,\n+        Collection<String> data,\n+        Collection<String> failures\n+    ) {\n         boolean ignoreUnavailable = context.getOptions().ignoreUnavailable();\n         IndexAbstraction indexAbstraction = context.getState().getMetadata().getIndicesLookup().get(name);\n         if (indexAbstraction == null) {\n             if (ignoreUnavailable) {\n-                return false;\n+                return;\n             } else {\n                 throw notFoundException(name);\n             }\n         }\n-        // treat aliases as unavailable indices when ignoreAliases is set to true (e.g. delete index and update aliases api)\n-        if (indexAbstraction.getType() == Type.ALIAS && context.getOptions().ignoreAliases()) {\n-            if (ignoreUnavailable) {\n-                return false;\n-            } else {\n-                throw aliasesNotSupportedException(name);\n+        switch (indexAbstraction.getType()) {\n+            case ALIAS -> {\n+                // treat aliases as unavailable indices when ignoreAliases is set to true (e.g. delete index and update aliases api)\n+                if (context.getOptions().ignoreAliases()) {\n+                    if (ignoreUnavailable) {\n+                        return;\n+                    } else {\n+                        throw aliasesNotSupportedException(name);\n+                    }\n+                }\n+                if (indexAbstraction.isDataStreamRelated() && context.includeDataStreams() == false) {\n+                    if (ignoreUnavailable) {\n+                        return;\n+                    } else {\n+                        IndexNotFoundException infe = notFoundException(name);\n+                        // Allows callers to handle IndexNotFoundException differently based on whether data streams were excluded.\n+                        infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n+                        throw infe;\n+                    }\n+                }\n+                if (selector == null || selector.shouldIncludeData()) {\n+                    data.add(name);\n+                }\n+                if (selector != null && selector.shouldIncludeFailures() && indexAbstraction.isDataStreamRelated()) {\n+                    failures.add(name);\n+                }\n+                if (selector == IndexComponentSelector.FAILURES && indexAbstraction.isDataStreamRelated() == false) {\n+                    throw failuresSelectorNotSupportedException(name);\n+                }\n             }\n-        }\n-        if (indexAbstraction.isDataStreamRelated() && context.includeDataStreams() == false) {\n-            if (ignoreUnavailable) {\n-                return false;\n-            } else {\n-                IndexNotFoundException infe = notFoundException(name);\n-                // Allows callers to handle IndexNotFoundException differently based on whether data streams were excluded.\n-                infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n-                throw infe;\n+            case DATA_STREAM -> {\n+                if (context.includeDataStreams() == false) {\n+                    if (ignoreUnavailable) {\n+                        return;\n+                    } else {\n+                        IndexNotFoundException infe = notFoundException(name);\n+                        // Allows callers to handle IndexNotFoundException differently based on whether data streams were excluded.\n+                        infe.addMetadata(EXCLUDED_DATA_STREAMS_KEY, \"true\");\n+                        throw infe;\n+                    }\n+                }\n+                if (selector == null || selector.shouldIncludeData()) {\n+                    data.add(name);\n+                }\n+                if (selector != null && selector.shouldIncludeFailures()) {\n+                    failures.add(name);\n+                }\n             }\n+            case CONCRETE_INDEX -> {\n+                if (selector == null || selector.shouldIncludeData()) {\n+                    data.add(name);\n+                }\n+                if (selector == IndexComponentSelector.FAILURES) {\n+                    throw failuresSelectorNotSupportedException(name);\n+                }\n+            }\n+            default -> throw new IllegalArgumentException(\"Unknown type [\" + indexAbstraction.getType() + \"]\");\n         }\n-        return true;\n     }\n \n     public static class Context {\n@@ -1380,47 +1475,83 @@ public class IndexNameExpressionResolver {\n         }\n \n         /**\n-         * Given a single wildcard {@param expression}, return a {@code Set} that contains all the resources (i.e. indices, aliases,\n-         * and data streams), that exist in the cluster at this moment in time, and that the wildcard \"resolves\" to (i.e. the resource's\n-         * name matches the {@param expression} wildcard).\n-         * The {@param context} provides the current time-snapshot view of cluster state, as well as conditions\n+         * Given a single wildcard {@param expression}, expand to all the resources (i.e. indices, aliases,and data streams), that exist in\n+         * the cluster at this moment in time, and that the wildcard \"resolves\" to (i.e. the resource's name matches the\n+         * {@param expression} wildcard) and add (or remove if it's an exclusion) them to the respective sets of resources either as\n+         * {@param data} or {@param failures}. Keep in mind that only a data stream alias or a data stream can ever be added in the\n+         * {@param failures} set. The {@param context} provides the current time-snapshot view of cluster state, as well as conditions\n          * on whether to consider alias, data stream, system, and hidden resources.\n          */\n-        static Set<String> matchWildcardToResources(Context context, String wildcardExpression) {\n+        static void processWildcards(\n+            Context context,\n+            String wildcardExpression,\n+            IndexComponentSelector expressionSelector,\n+            Collection<String> data,\n+            Collection<String> failures,\n+            boolean isExclusion\n+        ) {\n             assert isWildcard(wildcardExpression);\n             final SortedMap<String, IndexAbstraction> indicesLookup = context.getState().getMetadata().getIndicesLookup();\n-            Set<String> matchedResources = new HashSet<>();\n+            boolean hasExpanded = false;\n+            IndexComponentSelector applicableSelector = getApplicableSelector(context, expressionSelector);\n             // this applies an initial pre-filtering in the case where the expression is a common suffix wildcard, eg \"test*\"\n             if (Regex.isSuffixMatchPattern(wildcardExpression)) {\n                 for (IndexAbstraction ia : filterIndicesLookupForSuffixWildcard(indicesLookup, wildcardExpression).values()) {\n-                    maybeAddToResult(context, wildcardExpression, ia, matchedResources);\n+                    hasExpanded = maybeAddToResult(context, wildcardExpression, ia, applicableSelector, data, failures, isExclusion)\n+                        || hasExpanded;\n                 }\n-                return matchedResources;\n+                verifyExpandedExpression(context, wildcardExpression, expressionSelector, hasExpanded);\n+                return;\n             }\n             // In case of match all it fetches all index abstractions\n             if (Regex.isMatchAllPattern(wildcardExpression)) {\n                 for (IndexAbstraction ia : indicesLookup.values()) {\n-                    maybeAddToResult(context, wildcardExpression, ia, matchedResources);\n+                    hasExpanded = maybeAddToResult(context, wildcardExpression, ia, applicableSelector, data, failures, isExclusion)\n+                        || hasExpanded;\n                 }\n-                return matchedResources;\n+                verifyExpandedExpression(context, wildcardExpression, expressionSelector, hasExpanded);\n+                return;\n             }\n             for (IndexAbstraction indexAbstraction : indicesLookup.values()) {\n                 if (Regex.simpleMatch(wildcardExpression, indexAbstraction.getName())) {\n-                    maybeAddToResult(context, wildcardExpression, indexAbstraction, matchedResources);\n+                    hasExpanded = maybeAddToResult(\n+                        context,\n+                        wildcardExpression,\n+                        indexAbstraction,\n+                        applicableSelector,\n+                        data,\n+                        failures,\n+                        isExclusion\n+                    ) || hasExpanded;\n                 }\n             }\n-            return matchedResources;\n+            verifyExpandedExpression(context, wildcardExpression, expressionSelector, hasExpanded);\n         }\n \n-        private static void maybeAddToResult(\n+        /**\n+         * Check if it should expand and applies the expanded wildcard to the provided sets.\n+         * @param context\n+         * @param wildcardExpression\n+         * @param indexAbstraction\n+         * @param selector\n+         * @param data\n+         * @param failures\n+         * @param isExclusion\n+         * @return true if it was able to expand the expression, false otherwise.\n+         */\n+        private static boolean maybeAddToResult(\n             Context context,\n             String wildcardExpression,\n             IndexAbstraction indexAbstraction,\n-            Set<String> matchedResources\n+            IndexComponentSelector selector,\n+            Collection<String> data,\n+            Collection<String> failures,\n+            boolean isExclusion\n         ) {\n             if (shouldExpandToIndexAbstraction(context, wildcardExpression, indexAbstraction)) {\n-                matchedResources.addAll(expandToOpenClosed(context, indexAbstraction));\n+                return expandAndUpdateCollections(context, indexAbstraction, selector, data, failures, isExclusion);\n             }\n+            return false;\n         }\n \n         /**\n@@ -1458,6 +1589,28 @@ public class IndexNameExpressionResolver {\n             return true;\n         }\n \n+        /**\n+         * Verifies if the expression expanded to any resources when we do not allow empty expressions.\n+         * @param context the context\n+         * @param expression the requested wildcard expression\n+         * @param selector the selector specified or the default\n+         * @param hasExpanded if this expression has been expanded\n+         * @throws IndexNotFoundException if there was no resource matched to this expression\n+         */\n+        private static void verifyExpandedExpression(\n+            Context context,\n+            String expression,\n+            IndexComponentSelector selector,\n+            boolean hasExpanded\n+        ) {\n+            if (context.getOptions().allowNoIndices() == false && hasExpanded == false) {\n+                String expressionWithSelector = selector == null\n+                    ? expression\n+                    : expression + SelectorResolver.SELECTOR_SEPARATOR + selector.getKey();\n+                throw notFoundException(expressionWithSelector);\n+            }\n+        }\n+\n         private static Map<String, IndexAbstraction> filterIndicesLookupForSuffixWildcard(\n             SortedMap<String, IndexAbstraction> indicesLookup,\n             String suffixWildcardExpression\n@@ -1506,6 +1659,88 @@ public class IndexNameExpressionResolver {\n             return resources;\n         }\n \n+        /**\n+         * Return the {@code Set} of open and/or closed index names for the given {@param resources}.\n+         * Data streams and aliases are interpreted to refer to multiple indices,\n+         * then all index resources are filtered by their open/closed status.\n+         */\n+        private static boolean expandAndUpdateCollections(\n+            Context context,\n+            IndexAbstraction indexAbstraction,\n+            IndexComponentSelector selector,\n+            Collection<String> data,\n+            Collection<String> failures,\n+            boolean isExclusion\n+        ) {\n+            boolean hasExpandedToResources = false;\n+            final IndexMetadata.State excludeState = excludeState(context.getOptions());\n+            if (context.isPreserveAliases() && indexAbstraction.getType() == Type.ALIAS) {\n+                if (selector == null || selector.shouldIncludeData()) {\n+                    hasExpandedToResources |= true;\n+                    if (isExclusion) {\n+                        data.remove(indexAbstraction.getName());\n+                    } else {\n+                        data.add(indexAbstraction.getName());\n+                    }\n+                }\n+                if (selector != null && selector.shouldIncludeFailures()) {\n+                    hasExpandedToResources |= true;\n+                    if (isExclusion) {\n+                        failures.remove(indexAbstraction.getName());\n+                    } else {\n+                        failures.add(indexAbstraction.getName());\n+                    }\n+                }\n+            } else if (context.isPreserveDataStreams() && indexAbstraction.getType() == Type.DATA_STREAM) {\n+                hasExpandedToResources |= true;\n+                if (selector == null || selector.shouldIncludeData()) {\n+                    if (isExclusion) {\n+                        data.remove(indexAbstraction.getName());\n+                    } else {\n+                        data.add(indexAbstraction.getName());\n+                    }\n+                }\n+                if (selector != null && selector.shouldIncludeFailures()) {\n+                    if (isExclusion) {\n+                        failures.remove(indexAbstraction.getName());\n+                    } else {\n+                        failures.add(indexAbstraction.getName());\n+                    }\n+                }\n+            } else {\n+                if (selector == null || selector.shouldIncludeData()) {\n+                    for (int i = 0, n = indexAbstraction.getIndices().size(); i < n; i++) {\n+                        Index index = indexAbstraction.getIndices().get(i);\n+                        IndexMetadata indexMetadata = context.state.metadata().index(index);\n+                        if (indexMetadata.getState() != excludeState) {\n+                            hasExpandedToResources |= true;\n+                            if (isExclusion) {\n+                                data.remove(index.getName());\n+                            } else {\n+                                data.add(index.getName());\n+                            }\n+                        }\n+                    }\n+                }\n+                if (indexAbstraction.getType() == Type.DATA_STREAM && selector != null && selector.shouldIncludeFailures()) {\n+                    DataStream dataStream = (DataStream) indexAbstraction;\n+                    for (int i = 0, n = dataStream.getFailureIndices().getIndices().size(); i < n; i++) {\n+                        Index index = dataStream.getFailureIndices().getIndices().get(i);\n+                        IndexMetadata indexMetadata = context.state.metadata().index(index);\n+                        if (indexMetadata.getState() != excludeState) {\n+                            hasExpandedToResources |= true;\n+                            if (isExclusion) {\n+                                data.remove(index.getName());\n+                            } else {\n+                                data.add(index.getName());\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            return hasExpandedToResources;\n+        }\n+\n         private static List<String> resolveEmptyOrTrivialWildcard(Context context) {\n             final String[] allIndices = resolveEmptyOrTrivialWildcardToAllIndices(context.getOptions(), context.getState().metadata());\n             if (context.systemIndexAccessLevel == SystemIndexAccessLevel.ALL) {\n@@ -1565,7 +1800,7 @@ public class IndexNameExpressionResolver {\n \n         static boolean hasWildcards(String[] expressions) {\n             for (int i = 0; i < expressions.length; i++) {\n-                if (isWildcard(expressions[i])) {\n+                if (isWildcard(SelectorResolver.parseSelectorExpression(expressions[i]).v1())) {\n                     return true;\n                 }\n             }\n@@ -1573,6 +1808,12 @@ public class IndexNameExpressionResolver {\n         }\n     }\n \n+    private static IndexComponentSelector getApplicableSelector(Context context, IndexComponentSelector expressionSelector) {\n+        return context.getOptions().allowSelectors() && expressionSelector == null\n+            ? context.getOptions().selectorOptions().defaultSelector()\n+            : expressionSelector;\n+    }\n+\n     /**\n      * @return If the specified string is data math expression then this method returns the resolved expression.\n      */\n@@ -1895,4 +2136,80 @@ public class IndexNameExpressionResolver {\n         }\n     }\n \n+    public static final class SelectorResolver {\n+        public static final String SELECTOR_SEPARATOR = \"::\";\n+\n+        private SelectorResolver() {\n+            // Utility class\n+        }\n+\n+        /**\n+         * Splits off selector fragments from an index expression. Selectors are always expected to be the suffix of the expression, and\n+         * must equal one of the supported selector keys (data, failures) or be the match-all wildcard (*) which maps to all selectors. The\n+         * expression is then split into the base expression and the selector string. A provided function binds the results to the return\n+         * type.\n+         * @param expression The expression to parse and split apart\n+         * @return A tuple with the base expression and the selector.\n+         * @throws InvalidIndexNameException In the event that the selector syntax is used incorrectly.\n+         */\n+        public static Tuple<String, IndexComponentSelector> parseSelectorExpression(String expression) {\n+            Objects.requireNonNull(expression, \"expression cannot be null\");\n+            int lastDoubleColon = expression.lastIndexOf(SELECTOR_SEPARATOR);\n+            if (lastDoubleColon >= 0) {\n+                String suffix = expression.substring(lastDoubleColon + SELECTOR_SEPARATOR.length());\n+                IndexComponentSelector selector = IndexComponentSelector.getByKey(suffix);\n+                if (Regex.isMatchAllPattern(suffix) == false) {\n+                    if (selector == null) {\n+                        // Do some work to surface a helpful error message for likely errors\n+                        if (Regex.isSimpleMatchPattern(suffix)) {\n+                            throw new InvalidIndexNameException(\n+                                expression,\n+                                \"Invalid usage of :: separator, [\"\n+                                    + suffix\n+                                    + \"] contains a wildcard, but only the match all wildcard [*] is supported in a selector\"\n+                            );\n+                        } else {\n+                            throw new InvalidIndexNameException(\n+                                expression,\n+                                \"Invalid usage of :: separator, [\" + suffix + \"] is not a recognized selector\"\n+                            );\n+                        }\n+                    }\n+                }\n+                String expressionBase = expression.substring(0, lastDoubleColon);\n+                ensureNoMoreSelectorSeparators(expressionBase, expression);\n+                return Tuple.tuple(expressionBase, selector);\n+            }\n+            // Otherwise accept the default\n+            return Tuple.tuple(expression, null);\n+        }\n+\n+        /**\n+         * Checks the selectors that have been returned from splitting an expression and throws an exception if any were present.\n+         * @param expression Original expression\n+         * @throws IllegalArgumentException if selectors are present\n+         */\n+        static void ensureNoSelectorsProvided(String expression, IndexComponentSelector selector) {\n+            if (selector != null) {\n+                throw new IllegalArgumentException(\n+                    \"Index component selectors are not supported in this context but found selector in expression [\" + expression + \"]\"\n+                );\n+            }\n+        }\n+\n+        /**\n+         * Checks the remainder of an expression for any more selector separators and throws an exception if they are encountered.\n+         * @param remainingExpression Remaining expression\n+         * @param originalExpression Original expression to be used in the exception if invalid name is detected\n+         * @throws InvalidIndexNameException if there are any more :: separators\n+         */\n+        static void ensureNoMoreSelectorSeparators(String remainingExpression, String originalExpression) {\n+            if (remainingExpression.contains(SELECTOR_SEPARATOR)) {\n+                throw new InvalidIndexNameException(\n+                    originalExpression,\n+                    \"Invalid usage of :: separator, only one :: separator is allowed per expression\"\n+                );\n+            }\n+        }\n+    }\n }\ndiff --git a/server/src/main/java/org/elasticsearch/transport/RemoteClusterAware.java b/server/src/main/java/org/elasticsearch/transport/RemoteClusterAware.java\nindex ccb00181798d..cd6ad60ad0b5 100644\n--- a/server/src/main/java/org/elasticsearch/transport/RemoteClusterAware.java\n+++ b/server/src/main/java/org/elasticsearch/transport/RemoteClusterAware.java\n@@ -9,12 +9,15 @@\n \n package org.elasticsearch.transport;\n \n+import org.elasticsearch.action.support.IndexComponentSelector;\n import org.elasticsearch.cluster.metadata.ClusterNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.common.settings.ClusterSettings;\n import org.elasticsearch.common.settings.Setting;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.core.Strings;\n+import org.elasticsearch.core.Tuple;\n import org.elasticsearch.node.Node;\n \n import java.util.ArrayList;\n@@ -64,8 +67,11 @@ public abstract class RemoteClusterAware {\n             // Thus, whatever it is, this is definitely not a remote index.\n             return false;\n         }\n+        int idx = indexExpression.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR);\n+        // Check to make sure the remote cluster separator ':' isn't actually a selector separator '::'\n+        boolean isSelector = indexExpression.startsWith(IndexNameExpressionResolver.SelectorResolver.SELECTOR_SEPARATOR, idx);\n         // Note remote index name also can not start with ':'\n-        return indexExpression.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR) > 0;\n+        return idx > 0 && isSelector == false;\n     }\n \n     /**\n@@ -99,7 +105,8 @@ public abstract class RemoteClusterAware {\n         if (i == 0) {\n             throw new IllegalArgumentException(\"index name [\" + indexExpression + \"] is invalid because the remote part is empty\");\n         }\n-        if (i < 0) {\n+        // Either no colon present, or the colon was a part of a selector separator (::)\n+        if (i < 0 || indexExpression.startsWith(IndexNameExpressionResolver.SelectorResolver.SELECTOR_SEPARATOR, i)) {\n             return new String[] { null, indexExpression };\n         } else {\n             return new String[] { indexExpression.substring(0, i), indexExpression.substring(i + 1) };\n@@ -144,6 +151,10 @@ public abstract class RemoteClusterAware {\n                     isNegative ? remoteClusterName.substring(1) : remoteClusterName\n                 );\n                 if (isNegative) {\n+                    Tuple<String, IndexComponentSelector> indexAndSelector = IndexNameExpressionResolver.SelectorResolver\n+                        .parseSelectorExpression(indexName);\n+                    indexName = indexAndSelector.v1();\n+                    IndexComponentSelector selector = indexAndSelector.v2();\n                     if (indexName.equals(\"*\") == false) {\n                         throw new IllegalArgumentException(\n                             Strings.format(\n@@ -152,6 +163,14 @@ public abstract class RemoteClusterAware {\n                             )\n                         );\n                     }\n+                    if (selector != null && selector != IndexComponentSelector.ALL_APPLICABLE) {\n+                        throw new IllegalArgumentException(\n+                            Strings.format(\n+                                \"To exclude a cluster you must specify the '::*' selector or leave it off, but found: [%s]\",\n+                                selector\n+                            )\n+                        );\n+                    }\n                     clustersToRemove.addAll(clusters);\n                 } else {\n                     for (String clusterName : clusters) {\ndiff --git a/server/src/test/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequestTests.java b/server/src/test/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequestTests.java\nindex d0f734474f7c..c3d06c471f3e 100644\n--- a/server/src/test/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequestTests.java\n+++ b/server/src/test/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequestTests.java\n@@ -78,7 +78,7 @@ public class CreateSnapshotRequestTests extends ESTestCase {\n         if (randomBoolean()) {\n             boolean defaultResolveAliasForThisRequest = original.indicesOptions().ignoreAliases() == false;\n             original.indicesOptions(\n-                IndicesOptions.builder()\n+                IndicesOptions.builder(original.indicesOptions())\n                     .concreteTargetOptions(new IndicesOptions.ConcreteTargetOptions(randomBoolean()))\n                     .wildcardOptions(\n                         new IndicesOptions.WildcardOptions(\ndiff --git a/server/src/test/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequestTests.java b/server/src/test/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequestTests.java\nindex a1c4466280a4..74bc8aa9254f 100644\n--- a/server/src/test/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequestTests.java\n+++ b/server/src/test/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequestTests.java\n@@ -78,7 +78,7 @@ public class RestoreSnapshotRequestTests extends AbstractWireSerializingTestCase\n \n         if (randomBoolean()) {\n             instance.indicesOptions(\n-                IndicesOptions.builder()\n+                IndicesOptions.builder(instance.indicesOptions())\n                     .concreteTargetOptions(new IndicesOptions.ConcreteTargetOptions(randomBoolean()))\n                     .wildcardOptions(\n                         new IndicesOptions.WildcardOptions(\ndiff --git a/server/src/test/java/org/elasticsearch/action/admin/indices/rollover/RolloverRequestTests.java b/server/src/test/java/org/elasticsearch/action/admin/indices/rollover/RolloverRequestTests.java\nindex f0190790ba00..5d862bcdfdec 100644\n--- a/server/src/test/java/org/elasticsearch/action/admin/indices/rollover/RolloverRequestTests.java\n+++ b/server/src/test/java/org/elasticsearch/action/admin/indices/rollover/RolloverRequestTests.java\n@@ -175,7 +175,9 @@ public class RolloverRequestTests extends ESTestCase {\n         );\n         originalRequest.lazy(randomBoolean());\n         originalRequest.setIndicesOptions(\n-            IndicesOptions.builder(originalRequest.indicesOptions()).selectorOptions(IndicesOptions.SelectorOptions.ALL_APPLICABLE).build()\n+            IndicesOptions.builder(originalRequest.indicesOptions())\n+                .selectorOptions(randomFrom(IndicesOptions.SelectorOptions.DATA, IndicesOptions.SelectorOptions.FAILURES))\n+                .build()\n         );\n \n         try (BytesStreamOutput out = new BytesStreamOutput()) {\ndiff --git a/server/src/test/java/org/elasticsearch/action/support/IndicesOptionsTests.java b/server/src/test/java/org/elasticsearch/action/support/IndicesOptionsTests.java\nindex de7b43ad091f..4f35dc73c8ac 100644\n--- a/server/src/test/java/org/elasticsearch/action/support/IndicesOptionsTests.java\n+++ b/server/src/test/java/org/elasticsearch/action/support/IndicesOptionsTests.java\n@@ -56,7 +56,13 @@ public class IndicesOptionsTests extends ESTestCase {\n                         .allowAliasToMultipleIndices(randomBoolean())\n                         .allowClosedIndices(randomBoolean())\n                 )\n-                .selectorOptions(IndicesOptions.SelectorOptions.ALL_APPLICABLE)\n+                .selectorOptions(\n+                    randomFrom(\n+                        IndicesOptions.SelectorOptions.DATA,\n+                        IndicesOptions.SelectorOptions.FAILURES,\n+                        IndicesOptions.SelectorOptions.ALL_APPLICABLE\n+                    )\n+                )\n                 .build();\n \n             BytesStreamOutput output = new BytesStreamOutput();\n@@ -341,7 +347,13 @@ public class IndicesOptionsTests extends ESTestCase {\n             randomBoolean(),\n             randomBoolean()\n         );\n-        GatekeeperOptions gatekeeperOptions = new GatekeeperOptions(randomBoolean(), randomBoolean(), randomBoolean(), randomBoolean());\n+        GatekeeperOptions gatekeeperOptions = new GatekeeperOptions(\n+            randomBoolean(),\n+            randomBoolean(),\n+            randomBoolean(),\n+            randomBoolean(),\n+            randomBoolean()\n+        );\n         IndicesOptions.SelectorOptions selectorOptions = new IndicesOptions.SelectorOptions(randomFrom(IndexComponentSelector.values()));\n \n         IndicesOptions indicesOptions = new IndicesOptions(concreteTargetOptions, wildcardOptions, gatekeeperOptions, selectorOptions);\n@@ -359,15 +371,6 @@ public class IndicesOptionsTests extends ESTestCase {\n         assertThat(map.get(\"ignore_unavailable\"), equalTo(concreteTargetOptions.allowUnavailableTargets()));\n         assertThat(map.get(\"allow_no_indices\"), equalTo(wildcardOptions.allowEmptyExpressions()));\n         assertThat(map.get(\"ignore_throttled\"), equalTo(gatekeeperOptions.ignoreThrottled()));\n-        String displayValue;\n-        if (IndicesOptions.SelectorOptions.ALL_APPLICABLE.equals(selectorOptions)) {\n-            displayValue = \"include\";\n-        } else if (IndicesOptions.SelectorOptions.DATA.equals(selectorOptions)) {\n-            displayValue = \"exclude\";\n-        } else {\n-            displayValue = \"only\";\n-        }\n-        assertThat(map.get(\"failure_store\"), equalTo(displayValue));\n     }\n \n     public void testFromXContent() throws IOException {\ndiff --git a/server/src/test/java/org/elasticsearch/cluster/metadata/IndexComponentSelectorResolverTests.java b/server/src/test/java/org/elasticsearch/cluster/metadata/IndexComponentSelectorResolverTests.java\nnew file mode 100644\nindex 000000000000..88c91a64f8e3\n--- /dev/null\n+++ b/server/src/test/java/org/elasticsearch/cluster/metadata/IndexComponentSelectorResolverTests.java\n@@ -0,0 +1,227 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.cluster.metadata;\n+\n+import org.elasticsearch.action.support.IndexComponentSelector;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.cluster.ClusterName;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.State;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.indices.FailureIndexNotSupportedException;\n+import org.elasticsearch.indices.TestIndexNameExpressionResolver;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.elasticsearch.cluster.metadata.DataStreamTestHelper.createBackingIndex;\n+import static org.elasticsearch.cluster.metadata.DataStreamTestHelper.createFailureStore;\n+import static org.elasticsearch.cluster.metadata.DataStreamTestHelper.newInstance;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+/**\n+ * This test suite is complementary to {@link IndexNameExpressionResolverTests} and focuses on the selector resolution.\n+ */\n+public class IndexComponentSelectorResolverTests extends ESTestCase {\n+\n+    private IndexNameExpressionResolver indexNameExpressionResolver;\n+    private long epochMillis;\n+\n+    private ThreadContext createThreadContext() {\n+        return new ThreadContext(Settings.EMPTY);\n+    }\n+\n+    protected IndexNameExpressionResolver createIndexNameExpressionResolver(ThreadContext threadContext) {\n+        return TestIndexNameExpressionResolver.newInstance(threadContext);\n+    }\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        ThreadContext threadContext = createThreadContext();\n+        indexNameExpressionResolver = createIndexNameExpressionResolver(threadContext);\n+        epochMillis = randomLongBetween(1580536800000L, 1583042400000L);\n+    }\n+\n+    public void testDataStreamsWithFailureStoreWithSelector() {\n+        final String dataStreamName = \"my-data-stream\";\n+        final String dataStreamAlias = \"my-alias\";\n+        IndexMetadata index1 = createBackingIndex(dataStreamName, 1, epochMillis).build();\n+        IndexMetadata index2 = createBackingIndex(dataStreamName, 2, epochMillis).build();\n+        IndexMetadata failureIndex1 = createFailureStore(dataStreamName, 1, epochMillis).build();\n+        IndexMetadata failureIndex2 = createFailureStore(dataStreamName, 2, epochMillis).build();\n+        IndexMetadata otherIndex = IndexNameExpressionResolverTests.indexBuilder(\"my-other-index\", Settings.EMPTY)\n+            .state(State.OPEN)\n+            .build();\n+\n+        Metadata.Builder mdBuilder = Metadata.builder()\n+            .put(index1, false)\n+            .put(index2, false)\n+            .put(failureIndex1, false)\n+            .put(failureIndex2, false)\n+            .put(otherIndex, false)\n+            .put(\n+                newInstance(\n+                    dataStreamName,\n+                    List.of(index1.getIndex(), index2.getIndex()),\n+                    List.of(failureIndex1.getIndex(), failureIndex2.getIndex())\n+                )\n+            );\n+        mdBuilder.put(dataStreamAlias, dataStreamName, null, null);\n+        ClusterState state = ClusterState.builder(new ClusterName(\"_name\")).metadata(mdBuilder).build();\n+\n+        // We will specify selectors on every test case, so the value of the default selector shouldn't matter\n+        IndicesOptions indicesOptions = IndicesOptions.builder()\n+            .selectorOptions(\n+                randomFrom(\n+                    IndicesOptions.SelectorOptions.ALL_APPLICABLE,\n+                    IndicesOptions.SelectorOptions.DATA,\n+                    IndicesOptions.SelectorOptions.FAILURES\n+                )\n+            )\n+            .build();\n+\n+        // Test only data with an exact data stream name\n+        {\n+            Index[] result = indexNameExpressionResolver.concreteIndices(state, indicesOptions, true, \"my-data-stream::data\");\n+            assertThat(result.length, equalTo(2));\n+            assertThat(result[0].getName(), equalTo(DataStream.getDefaultBackingIndexName(dataStreamName, 1, epochMillis)));\n+            assertThat(result[1].getName(), equalTo(DataStream.getDefaultBackingIndexName(dataStreamName, 2, epochMillis)));\n+        }\n+\n+        // Test only data with an exact alias\n+        {\n+            Index[] result = indexNameExpressionResolver.concreteIndices(state, indicesOptions, true, \"my-alias::data\");\n+            assertThat(result.length, equalTo(2));\n+            assertThat(result[0].getName(), equalTo(DataStream.getDefaultBackingIndexName(dataStreamName, 1, epochMillis)));\n+            assertThat(result[1].getName(), equalTo(DataStream.getDefaultBackingIndexName(dataStreamName, 2, epochMillis)));\n+        }\n+\n+        // Test include failure store with an exact data stream name\n+        {\n+            Index[] result = indexNameExpressionResolver.concreteIndices(state, indicesOptions, true, \"my-data-stream::*\");\n+            assertThat(result.length, equalTo(4));\n+            assertThat(result[0].getName(), equalTo(DataStream.getDefaultBackingIndexName(dataStreamName, 1, epochMillis)));\n+            assertThat(result[1].getName(), equalTo(DataStream.getDefaultBackingIndexName(dataStreamName, 2, epochMillis)));\n+            assertThat(result[2].getName(), equalTo(DataStream.getDefaultFailureStoreName(dataStreamName, 1, epochMillis)));\n+            assertThat(result[3].getName(), equalTo(DataStream.getDefaultFailureStoreName(dataStreamName, 2, epochMillis)));\n+        }\n+\n+        // Test include failure store with an exact alias\n+        {\n+            Index[] result = indexNameExpressionResolver.concreteIndices(state, indicesOptions, true, \"my-alias::*\");\n+            assertThat(result.length, equalTo(4));\n+            assertThat(result[0].getName(), equalTo(DataStream.getDefaultBackingIndexName(dataStreamName, 1, epochMillis)));\n+            assertThat(result[1].getName(), equalTo(DataStream.getDefaultBackingIndexName(dataStreamName, 2, epochMillis)));\n+            assertThat(result[2].getName(), equalTo(DataStream.getDefaultFailureStoreName(dataStreamName, 1, epochMillis)));\n+            assertThat(result[3].getName(), equalTo(DataStream.getDefaultFailureStoreName(dataStreamName, 2, epochMillis)));\n+        }\n+\n+        // Test only failure store with an exact data stream name\n+        {\n+            Index[] result = indexNameExpressionResolver.concreteIndices(state, indicesOptions, true, \"my-data-stream::failures\");\n+            assertThat(result.length, equalTo(2));\n+            assertThat(result[0].getName(), equalTo(DataStream.getDefaultFailureStoreName(dataStreamName, 1, epochMillis)));\n+            assertThat(result[1].getName(), equalTo(DataStream.getDefaultFailureStoreName(dataStreamName, 2, epochMillis)));\n+        }\n+\n+        // Test only failure store with an exact alias\n+        {\n+            Index[] result = indexNameExpressionResolver.concreteIndices(state, indicesOptions, true, \"my-alias::failures\");\n+            assertThat(result.length, equalTo(2));\n+            assertThat(result[0].getName(), equalTo(DataStream.getDefaultFailureStoreName(dataStreamName, 1, epochMillis)));\n+            assertThat(result[1].getName(), equalTo(DataStream.getDefaultFailureStoreName(dataStreamName, 2, epochMillis)));\n+        }\n+\n+        // Test all supported with wildcard expression\n+        {\n+            Index[] result = indexNameExpressionResolver.concreteIndices(state, indicesOptions, true, \"my-*::*\");\n+            assertThat(result.length, equalTo(5));\n+            List<String> indexNames = Arrays.stream(result).map(Index::getName).toList();\n+            assertThat(\n+                indexNames,\n+                containsInAnyOrder(\n+                    DataStream.getDefaultBackingIndexName(dataStreamName, 2, epochMillis),\n+                    DataStream.getDefaultBackingIndexName(dataStreamName, 1, epochMillis),\n+                    otherIndex.getIndex().getName(),\n+                    DataStream.getDefaultFailureStoreName(dataStreamName, 1, epochMillis),\n+                    DataStream.getDefaultFailureStoreName(dataStreamName, 2, epochMillis)\n+                )\n+            );\n+        }\n+\n+        // Test include only data with wildcard expression\n+        {\n+            Index[] result = indexNameExpressionResolver.concreteIndices(state, indicesOptions, true, \"my-*::data\");\n+            assertThat(result.length, equalTo(3));\n+            List<String> indexNames = Arrays.stream(result).map(Index::getName).toList();\n+            assertThat(\n+                indexNames,\n+                containsInAnyOrder(\n+                    DataStream.getDefaultBackingIndexName(dataStreamName, 2, epochMillis),\n+                    DataStream.getDefaultBackingIndexName(dataStreamName, 1, epochMillis),\n+                    otherIndex.getIndex().getName()\n+                )\n+            );\n+        }\n+\n+        // Test only failure store with wildcard expression\n+        {\n+            Index[] result = indexNameExpressionResolver.concreteIndices(state, indicesOptions, true, \"my-*::failures\");\n+            assertThat(result.length, equalTo(2));\n+            List<String> indexNames = Arrays.stream(result).map(Index::getName).toList();\n+            assertThat(\n+                indexNames,\n+                containsInAnyOrder(\n+                    DataStream.getDefaultFailureStoreName(dataStreamName, 2, epochMillis),\n+                    DataStream.getDefaultFailureStoreName(dataStreamName, 1, epochMillis)\n+                )\n+            );\n+        }\n+\n+        // Test provide selector when selectors not allowed\n+        {\n+            IndicesOptions noSelectors = IndicesOptions.builder(indicesOptions)\n+                .gatekeeperOptions(indicesOptions.gatekeeperOptions().applyUpdate(b -> b.allowSelectors(false)))\n+                .build();\n+            IllegalArgumentException exception = expectThrows(\n+                IllegalArgumentException.class,\n+                () -> indexNameExpressionResolver.concreteIndices(\n+                    state,\n+                    noSelectors,\n+                    true,\n+                    \"my-data-stream::\" + randomFrom(IndexComponentSelector.values()).getKey()\n+                )\n+            );\n+            assertThat(\n+                exception.getMessage(),\n+                containsString(\"Index component selectors are not supported in this context but found selector in expression\")\n+            );\n+        }\n+\n+        // Test throw an error when directly accessing the failure store when not supported\n+        {\n+            IndicesOptions noFailureIndices = IndicesOptions.builder(indicesOptions)\n+                .selectorOptions(randomFrom(IndicesOptions.SelectorOptions.ALL_APPLICABLE, IndicesOptions.SelectorOptions.DATA))\n+                .gatekeeperOptions(IndicesOptions.GatekeeperOptions.builder(indicesOptions.gatekeeperOptions()).allowFailureIndices(false))\n+                .build();\n+            FailureIndexNotSupportedException exception = expectThrows(\n+                FailureIndexNotSupportedException.class,\n+                () -> indexNameExpressionResolver.concreteIndices(state, noFailureIndices, true, failureIndex1.getIndex().getName())\n+            );\n+            assertThat(exception.getMessage(), containsString(\"failure index not supported\"));\n+        }\n+    }\n+}\ndiff --git a/server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java b/server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java\nindex 30895767c33c..c74caccccb4b 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java\n@@ -1421,11 +1421,11 @@ public class IndexNameExpressionResolverTests extends ESTestCase {\n         assertThat(IndexNameExpressionResolver.isAllIndices(List.of(\"_all\")), equalTo(true));\n     }\n \n-    public void testIsAllIndicesExplicitAllPlusOther() {\n+    public void testIsNoneIndices() {\n         assertThat(IndexNameExpressionResolver.isAllIndices(List.of(\"_all\", \"other\")), equalTo(false));\n     }\n \n-    public void testIsNoneIndices() {\n+    public void testIsAllIndicesExplicitAllPlusOther() {\n         assertThat(IndexNameExpressionResolver.isNoneExpression(new String[] { \"*\", \"-*\" }), equalTo(true));\n     }\n \n@@ -2052,7 +2052,7 @@ public class IndexNameExpressionResolverTests extends ESTestCase {\n                 IndexNotFoundException.class,\n                 () -> indexNameExpressionResolver.concreteIndexNames(state, deleteIndexRequest)\n             );\n-            assertEquals(infe.getIndex().getName(), \"test-a*\");\n+            assertEquals(\"test-a*\", infe.getIndex().getName());\n         }\n         {\n             String[] indices = indexNameExpressionResolver.concreteIndexNames(state, new DeleteIndexRequest(\"test-a*\"));\n@@ -3266,7 +3266,7 @@ public class IndexNameExpressionResolverTests extends ESTestCase {\n             \"<.marvel-{now/d}>\",\n             \"name2\",\n             \"<.logstash-{now/M{uuuu.MM}}>\"\n-        );\n+        ).v1();\n         assertThat(result.size(), equalTo(4));\n         assertThat(result, contains(\"name1\", dataMathIndex1, \"name2\", dateMathIndex2));\n     }\n@@ -3450,7 +3450,7 @@ public class IndexNameExpressionResolverTests extends ESTestCase {\n         return ClusterState.builder(new ClusterName(\"_name\")).metadata(mdBuilder).build();\n     }\n \n-    private static IndexMetadata.Builder indexBuilder(String index, Settings additionalSettings) {\n+    static IndexMetadata.Builder indexBuilder(String index, Settings additionalSettings) {\n         return IndexMetadata.builder(index).settings(indexSettings(IndexVersion.current(), 1, 0).put(additionalSettings));\n     }\n \ndiff --git a/server/src/test/java/org/elasticsearch/cluster/metadata/SelectorResolverTests.java b/server/src/test/java/org/elasticsearch/cluster/metadata/SelectorResolverTests.java\nnew file mode 100644\nindex 000000000000..ff6f83707b02\n--- /dev/null\n+++ b/server/src/test/java/org/elasticsearch/cluster/metadata/SelectorResolverTests.java\n@@ -0,0 +1,46 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.cluster.metadata;\n+\n+import org.elasticsearch.action.support.IndexComponentSelector;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver.SelectorResolver;\n+import org.elasticsearch.core.Tuple;\n+import org.elasticsearch.indices.InvalidIndexNameException;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+\n+public class SelectorResolverTests extends ESTestCase {\n+\n+    public void testSplitSelectorExpression() {\n+        expectThrows(NullPointerException.class, () -> SelectorResolver.parseSelectorExpression(null));\n+        assertThat(SelectorResolver.parseSelectorExpression(\"\"), is(equalTo(new Tuple<>(\"\", null))));\n+        assertThat(SelectorResolver.parseSelectorExpression(\"a\"), is(equalTo(new Tuple<>(\"a\", null))));\n+        assertThat(SelectorResolver.parseSelectorExpression(\"*\"), is(equalTo(new Tuple<>(\"*\", null))));\n+        assertThat(SelectorResolver.parseSelectorExpression(\"index\"), is(equalTo(new Tuple<>(\"index\", null))));\n+        assertThat(SelectorResolver.parseSelectorExpression(\"cluster:index\"), is(equalTo(new Tuple<>(\"cluster:index\", null))));\n+        assertThat(SelectorResolver.parseSelectorExpression(\"*:index\"), is(equalTo(new Tuple<>(\"*:index\", null))));\n+        assertThat(SelectorResolver.parseSelectorExpression(\"cluster:*\"), is(equalTo(new Tuple<>(\"cluster:*\", null))));\n+        assertThat(SelectorResolver.parseSelectorExpression(\"*:*\"), is(equalTo(new Tuple<>(\"*:*\", null))));\n+        assertThat(SelectorResolver.parseSelectorExpression(\"*:*:*\"), is(equalTo(new Tuple<>(\"*:*:*\", null))));\n+\n+        assertThat(SelectorResolver.parseSelectorExpression(\"a::data\"), is(equalTo(new Tuple<>(\"a\", IndexComponentSelector.DATA))));\n+        assertThat(SelectorResolver.parseSelectorExpression(\"a::failures\"), is(equalTo(new Tuple<>(\"a\", IndexComponentSelector.FAILURES))));\n+        assertThat(SelectorResolver.parseSelectorExpression(\"a::*\"), is(equalTo(new Tuple<>(\"a\", IndexComponentSelector.ALL_APPLICABLE))));\n+        expectThrows(InvalidIndexNameException.class, () -> SelectorResolver.parseSelectorExpression(\"a::random\"));\n+        expectThrows(InvalidIndexNameException.class, () -> SelectorResolver.parseSelectorExpression(\"a::d*ta\"));\n+        expectThrows(InvalidIndexNameException.class, () -> SelectorResolver.parseSelectorExpression(\"a::*ailures\"));\n+        expectThrows(InvalidIndexNameException.class, () -> SelectorResolver.parseSelectorExpression(\"a::\"));\n+        expectThrows(InvalidIndexNameException.class, () -> SelectorResolver.parseSelectorExpression(\"a::**\"));\n+        expectThrows(InvalidIndexNameException.class, () -> SelectorResolver.parseSelectorExpression(\"index::data::*\"));\n+        assertThat(SelectorResolver.parseSelectorExpression(\"::*\"), is(equalTo(new Tuple<>(\"\", IndexComponentSelector.ALL_APPLICABLE))));\n+    }\n+}\ndiff --git a/server/src/test/java/org/elasticsearch/cluster/metadata/WildcardExpressionResolverTests.java b/server/src/test/java/org/elasticsearch/cluster/metadata/WildcardExpressionResolverTests.java\nindex 6a26e7948784..dc4d830c3036 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/metadata/WildcardExpressionResolverTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/metadata/WildcardExpressionResolverTests.java\n@@ -9,21 +9,24 @@\n \n package org.elasticsearch.cluster.metadata;\n \n+import org.elasticsearch.action.support.IndexComponentSelector;\n import org.elasticsearch.action.support.IndicesOptions;\n import org.elasticsearch.cluster.ClusterName;\n import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.metadata.IndexMetadata.State;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver.WildcardExpressionResolver;\n+import org.elasticsearch.index.IndexNotFoundException;\n import org.elasticsearch.index.IndexVersion;\n import org.elasticsearch.indices.SystemIndices.SystemIndexAccessLevel;\n import org.elasticsearch.test.ESTestCase;\n \n-import java.util.Collection;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n import java.util.function.Predicate;\n \n import static org.elasticsearch.cluster.metadata.DataStreamTestHelper.createBackingIndex;\n-import static org.elasticsearch.common.util.set.Sets.newHashSet;\n+import static org.elasticsearch.cluster.metadata.DataStreamTestHelper.createFirstFailureStore;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.empty;\n import static org.hamcrest.Matchers.equalTo;\n@@ -46,22 +49,134 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n             indicesOptions,\n             SystemIndexAccessLevel.NONE\n         );\n-        assertThat(\n-            newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(context, \"ku*\")),\n-            equalTo(newHashSet(\"kuku\"))\n-        );\n-        assertThat(\n-            newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(context, \"test*\")),\n-            equalTo(newHashSet(\"testXXX\", \"testXYY\", \"testYYY\"))\n-        );\n-        assertThat(\n-            newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(context, \"testX*\")),\n-            equalTo(newHashSet(\"testXXX\", \"testXYY\"))\n-        );\n-        assertThat(\n-            newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(context, \"*\")),\n-            equalTo(newHashSet(\"testXXX\", \"testXYY\", \"testYYY\", \"kuku\"))\n-        );\n+        IndexComponentSelector selector = randomFrom(IndexComponentSelector.ALL_APPLICABLE, IndexComponentSelector.DATA);\n+        {\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(context, \"ku*\", selector, data, failures, false);\n+            assertThat(data, equalTo(Set.of(\"kuku\")));\n+            assertThat(failures, empty());\n+        }\n+        {\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(context, \"test*\", selector, data, failures, false);\n+            assertThat(data, equalTo(Set.of(\"testXXX\", \"testXYY\", \"testYYY\")));\n+            assertThat(failures, empty());\n+        }\n+        {\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(context, \"testX*\", selector, data, failures, false);\n+            assertThat(data, equalTo(Set.of(\"testXXX\", \"testXYY\")));\n+            assertThat(failures, empty());\n+\n+            // test non-existing exclusion\n+            WildcardExpressionResolver.processWildcards(context, \"bla*\", selector, data, failures, true);\n+            assertThat(data, equalTo(Set.of(\"testXXX\", \"testXYY\")));\n+            assertThat(failures, empty());\n+        }\n+        {\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(context, \"*\", selector, data, failures, false);\n+            assertThat(data, equalTo(Set.of(\"testXXX\", \"testXYY\", \"testYYY\", \"kuku\")));\n+            assertThat(failures, empty());\n+\n+            // test exclusion\n+            WildcardExpressionResolver.processWildcards(context, \"kuk*\", selector, data, failures, true);\n+            assertThat(data, equalTo(Set.of(\"testXXX\", \"testXYY\", \"testYYY\")));\n+            assertThat(failures, empty());\n+        }\n+\n+        {\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(context, \"testX*\", IndexComponentSelector.FAILURES, data, failures, false);\n+            assertThat(data, empty());\n+            assertThat(failures, empty());\n+        }\n+    }\n+\n+    public void testThrowingErrorWithExpressionsThatDoNotExpand() {\n+        Metadata.Builder mdBuilder = Metadata.builder().put(indexBuilder(\"my-index\"));\n+        ClusterState state = ClusterState.builder(new ClusterName(\"_name\")).metadata(mdBuilder).build();\n+        {\n+            IndexNameExpressionResolver.Context strictContext = new IndexNameExpressionResolver.Context(\n+                state,\n+                IndicesOptions.builder().wildcardOptions(IndicesOptions.WildcardOptions.builder().allowEmptyExpressions(false)).build(),\n+                SystemIndexAccessLevel.NONE\n+            );\n+            {\n+                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class, () -> {\n+                    Set<String> data = new HashSet<>();\n+                    Set<String> failures = new HashSet<>();\n+                    WildcardExpressionResolver.processWildcards(\n+                        strictContext,\n+                        \"does-not-exist*\",\n+                        IndexComponentSelector.DATA,\n+                        data,\n+                        failures,\n+                        randomBoolean()\n+                    );\n+                });\n+                assertEquals(\"does-not-exist*::data\", infe.getIndex().getName());\n+            }\n+\n+            {\n+                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class, () -> {\n+                    Set<String> data = new HashSet<>();\n+                    Set<String> failures = new HashSet<>();\n+                    WildcardExpressionResolver.processWildcards(\n+                        strictContext,\n+                        \"does*not-exist*\",\n+                        IndexComponentSelector.DATA,\n+                        data,\n+                        failures,\n+                        randomBoolean()\n+                    );\n+                });\n+                assertEquals(\"does*not-exist*::data\", infe.getIndex().getName());\n+            }\n+            {\n+                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class, () -> {\n+                    Set<String> data = new HashSet<>();\n+                    Set<String> failures = new HashSet<>();\n+                    WildcardExpressionResolver.processWildcards(strictContext, \"*\", IndexComponentSelector.FAILURES, data, failures, false);\n+                });\n+                assertEquals(\"*::failures\", infe.getIndex().getName());\n+            }\n+            {\n+                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class, () -> {\n+                    Set<String> data = new HashSet<>();\n+                    Set<String> failures = new HashSet<>();\n+                    WildcardExpressionResolver.processWildcards(\n+                        strictContext,\n+                        \"testX*\",\n+                        IndexComponentSelector.FAILURES,\n+                        data,\n+                        failures,\n+                        false\n+                    );\n+                });\n+                assertEquals(\"testX*::failures\", infe.getIndex().getName());\n+            }\n+            {\n+                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class, () -> {\n+                    Set<String> data = new HashSet<>();\n+                    Set<String> failures = new HashSet<>();\n+                    WildcardExpressionResolver.processWildcards(\n+                        strictContext,\n+                        \"t*stX*\",\n+                        IndexComponentSelector.FAILURES,\n+                        data,\n+                        failures,\n+                        false\n+                    );\n+                });\n+                assertEquals(\"t*stX*::failures\", infe.getIndex().getName());\n+            }\n+        }\n     }\n \n     public void testConvertWildcardsOpenClosedIndicesTests() {\n@@ -74,33 +189,43 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n             .put(indexBuilder(\"kuku\").state(State.OPEN));\n         ClusterState state = ClusterState.builder(new ClusterName(\"_name\")).metadata(mdBuilder).build();\n \n-        IndexNameExpressionResolver.Context context = new IndexNameExpressionResolver.Context(\n-            state,\n-            IndicesOptions.fromOptions(true, true, true, true),\n-            SystemIndexAccessLevel.NONE\n-        );\n-        assertThat(\n-            newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(context, \"testX*\")),\n-            equalTo(newHashSet(\"testXXX\", \"testXXY\", \"testXYY\"))\n-        );\n-        context = new IndexNameExpressionResolver.Context(\n-            state,\n-            IndicesOptions.fromOptions(true, true, false, true),\n-            SystemIndexAccessLevel.NONE\n-        );\n-        assertThat(\n-            newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(context, \"testX*\")),\n-            equalTo(newHashSet(\"testXYY\"))\n-        );\n-        context = new IndexNameExpressionResolver.Context(\n-            state,\n-            IndicesOptions.fromOptions(true, true, true, false),\n-            SystemIndexAccessLevel.NONE\n-        );\n-        assertThat(\n-            newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(context, \"testX*\")),\n-            equalTo(newHashSet(\"testXXX\", \"testXXY\"))\n-        );\n+        IndexComponentSelector selector = randomFrom(IndexComponentSelector.ALL_APPLICABLE, IndexComponentSelector.DATA);\n+        {\n+            IndexNameExpressionResolver.Context context = new IndexNameExpressionResolver.Context(\n+                state,\n+                IndicesOptions.fromOptions(true, true, true, true),\n+                SystemIndexAccessLevel.NONE\n+            );\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(context, \"testX*\", selector, data, failures, false);\n+            assertThat(data, equalTo(Set.of(\"testXXX\", \"testXXY\", \"testXYY\")));\n+            assertThat(failures, empty());\n+        }\n+        {\n+            IndexNameExpressionResolver.Context context = new IndexNameExpressionResolver.Context(\n+                state,\n+                IndicesOptions.fromOptions(true, true, false, true),\n+                SystemIndexAccessLevel.NONE\n+            );\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(context, \"testX*\", selector, data, failures, false);\n+            assertThat(data, equalTo(Set.of(\"testXYY\")));\n+            assertThat(failures, empty());\n+        }\n+        {\n+            IndexNameExpressionResolver.Context context = new IndexNameExpressionResolver.Context(\n+                state,\n+                IndicesOptions.fromOptions(true, true, true, false),\n+                SystemIndexAccessLevel.NONE\n+            );\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(context, \"testX*\", selector, data, failures, false);\n+            assertThat(data, equalTo(Set.of(\"testXXX\", \"testXXY\")));\n+            assertThat(failures, empty());\n+        }\n     }\n \n     // issue #13334\n@@ -120,30 +245,49 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n             IndicesOptions.lenientExpandOpen(),\n             SystemIndexAccessLevel.NONE\n         );\n-        assertThat(\n-            newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(context, \"test*X*\")),\n-            equalTo(newHashSet(\"testXXX\", \"testXXY\", \"testXYY\"))\n-        );\n-        assertThat(\n-            newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(context, \"test*X*Y\")),\n-            equalTo(newHashSet(\"testXXY\", \"testXYY\"))\n-        );\n-        assertThat(\n-            newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(context, \"kuku*Y*\")),\n-            equalTo(newHashSet(\"kukuYYY\"))\n-        );\n-        assertThat(\n-            newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(context, \"*Y*\")),\n-            equalTo(newHashSet(\"testXXY\", \"testXYY\", \"testYYY\", \"kukuYYY\"))\n-        );\n-        assertThat(\n-            newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(context, \"test*Y*X\")).size(),\n-            equalTo(0)\n-        );\n-        assertThat(\n-            newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(context, \"*Y*X\")).size(),\n-            equalTo(0)\n-        );\n+        IndexComponentSelector selector = randomFrom(IndexComponentSelector.ALL_APPLICABLE, IndexComponentSelector.DATA);\n+        {\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(context, \"test*X*\", selector, data, failures, false);\n+            assertThat(data, equalTo(Set.of(\"testXXX\", \"testXXY\", \"testXYY\")));\n+            assertThat(failures, empty());\n+        }\n+        {\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(context, \"test*X*Y\", selector, data, failures, false);\n+            assertThat(data, equalTo(Set.of(\"testXXY\", \"testXYY\")));\n+            assertThat(failures, empty());\n+        }\n+        {\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(context, \"kuku*Y*\", selector, data, failures, false);\n+            assertThat(data, equalTo(Set.of(\"kukuYYY\")));\n+            assertThat(failures, empty());\n+        }\n+        {\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(context, \"*Y*\", selector, data, failures, false);\n+            assertThat(data, equalTo(Set.of(\"testXXY\", \"testXYY\", \"testYYY\", \"kukuYYY\")));\n+            assertThat(failures, empty());\n+        }\n+        {\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(context, \"test*Y*X\", selector, data, failures, false);\n+            assertThat(data, empty());\n+            assertThat(failures, empty());\n+        }\n+        {\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(context, \"*Y*X\", selector, data, failures, false);\n+            assertThat(data, empty());\n+            assertThat(failures, empty());\n+        }\n     }\n \n     public void testAll() {\n@@ -159,8 +303,8 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n             SystemIndexAccessLevel.NONE\n         );\n         assertThat(\n-            newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.resolveAll(context)),\n-            equalTo(newHashSet(\"testXXX\", \"testXYY\", \"testYYY\"))\n+            IndexNameExpressionResolver.WildcardExpressionResolver.resolveAll(context),\n+            equalTo(Set.of(\"testXXX\", \"testXYY\", \"testYYY\"))\n         );\n     }\n \n@@ -181,7 +325,7 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n                 IndicesOptions.lenientExpandOpen(), // don't include hidden\n                 SystemIndexAccessLevel.NONE\n             );\n-            assertThat(newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.resolveAll(context)), equalTo(newHashSet()));\n+            assertThat(IndexNameExpressionResolver.WildcardExpressionResolver.resolveAll(context), empty());\n         }\n \n         {\n@@ -200,18 +344,16 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n                 IndicesOptions.lenientExpandOpen(), // don't include hidden\n                 SystemIndexAccessLevel.NONE\n             );\n-            assertThat(\n-                newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.resolveAll(context)),\n-                equalTo(newHashSet(\"index-visible-alias\"))\n-            );\n+            assertThat(IndexNameExpressionResolver.WildcardExpressionResolver.resolveAll(context), equalTo(Set.of(\"index-visible-alias\")));\n         }\n     }\n \n     public void testAllDataStreams() {\n-\n+        // TODO-PR see how the selector will combine with the resolveAll.\n         String dataStreamName = \"foo_logs\";\n         long epochMillis = randomLongBetween(1580536800000L, 1583042400000L);\n         IndexMetadata firstBackingIndexMetadata = createBackingIndex(dataStreamName, 1, epochMillis).build();\n+        IndexMetadata firstFailureIndexMetadata = createFirstFailureStore(dataStreamName, epochMillis).build();\n \n         IndicesOptions indicesAndAliasesOptions = IndicesOptions.fromOptions(\n             randomBoolean(),\n@@ -228,7 +370,14 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n             // visible data streams should be returned by _all even show backing indices are hidden\n             Metadata.Builder mdBuilder = Metadata.builder()\n                 .put(firstBackingIndexMetadata, true)\n-                .put(DataStreamTestHelper.newInstance(dataStreamName, List.of(firstBackingIndexMetadata.getIndex())));\n+                .put(firstFailureIndexMetadata, true)\n+                .put(\n+                    DataStreamTestHelper.newInstance(\n+                        dataStreamName,\n+                        List.of(firstBackingIndexMetadata.getIndex()),\n+                        List.of(firstFailureIndexMetadata.getIndex())\n+                    )\n+                );\n \n             ClusterState state = ClusterState.builder(new ClusterName(\"_name\")).metadata(mdBuilder).build();\n \n@@ -244,8 +393,8 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n             );\n \n             assertThat(\n-                newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.resolveAll(context)),\n-                equalTo(newHashSet(DataStream.getDefaultBackingIndexName(\"foo_logs\", 1, epochMillis)))\n+                WildcardExpressionResolver.resolveAll(context),\n+                equalTo(Set.of(DataStream.getDefaultBackingIndexName(\"foo_logs\", 1, epochMillis)))\n             );\n         }\n \n@@ -268,7 +417,7 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n                 NONE\n             );\n \n-            assertThat(newHashSet(IndexNameExpressionResolver.WildcardExpressionResolver.resolveAll(context)), equalTo(newHashSet()));\n+            assertThat(WildcardExpressionResolver.resolveAll(context), empty());\n         }\n     }\n \n@@ -388,47 +537,51 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n             SystemIndexAccessLevel.NONE\n         );\n \n+        IndexComponentSelector selector = randomFrom(IndexComponentSelector.ALL_APPLICABLE, IndexComponentSelector.DATA);\n+\n         {\n-            Collection<String> indices = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(\n-                indicesAndAliasesContext,\n-                \"foo_a*\"\n-            );\n-            assertThat(indices, containsInAnyOrder(\"foo_index\", \"bar_index\"));\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(indicesAndAliasesContext, \"foo_a*\", selector, data, failures, false);\n+            assertThat(data, containsInAnyOrder(\"foo_index\", \"bar_index\"));\n+            assertThat(failures, empty());\n         }\n         {\n-            Collection<String> indices = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(\n-                skipAliasesLenientContext,\n-                \"foo_a*\"\n-            );\n-            assertEquals(0, indices.size());\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(skipAliasesLenientContext, \"foo_a*\", selector, data, failures, false);\n+            assertThat(data, empty());\n+            assertThat(failures, empty());\n         }\n         {\n-            Set<String> indices = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(\n-                skipAliasesStrictContext,\n-                \"foo_a*\"\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            IndexNotFoundException infe = expectThrows(\n+                IndexNotFoundException.class,\n+                () -> WildcardExpressionResolver.processWildcards(skipAliasesStrictContext, \"foo_a*\", selector, data, failures, false)\n             );\n-            assertThat(indices, empty());\n+            assertThat(infe.getIndex().getName(), equalTo(\"foo_a*::\" + selector.getKey()));\n         }\n         {\n-            Collection<String> indices = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(\n-                indicesAndAliasesContext,\n-                \"foo*\"\n-            );\n-            assertThat(indices, containsInAnyOrder(\"foo_foo\", \"foo_index\", \"bar_index\"));\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(indicesAndAliasesContext, \"foo*\", selector, data, failures, false);\n+            assertThat(data, containsInAnyOrder(\"foo_foo\", \"foo_index\", \"bar_index\"));\n+            assertThat(failures, empty());\n         }\n         {\n-            Collection<String> indices = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(\n-                skipAliasesLenientContext,\n-                \"foo*\"\n-            );\n-            assertThat(indices, containsInAnyOrder(\"foo_foo\", \"foo_index\"));\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(skipAliasesLenientContext, \"foo*\", selector, data, failures, false);\n+            assertThat(data, containsInAnyOrder(\"foo_foo\", \"foo_index\"));\n+            assertThat(failures, empty());\n         }\n         {\n-            Collection<String> indices = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(\n-                skipAliasesStrictContext,\n-                \"foo*\"\n-            );\n-            assertThat(indices, containsInAnyOrder(\"foo_foo\", \"foo_index\"));\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(skipAliasesStrictContext, \"foo*\", selector, data, failures, false);\n+            assertThat(data, containsInAnyOrder(\"foo_foo\", \"foo_index\"));\n+            assertThat(failures, empty());\n         }\n     }\n \n@@ -437,6 +590,7 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n         long epochMillis = randomLongBetween(1580536800000L, 1583042400000L);\n         IndexMetadata firstBackingIndexMetadata = createBackingIndex(dataStreamName, 1, epochMillis).build();\n         IndexMetadata secondBackingIndexMetadata = createBackingIndex(dataStreamName, 2, epochMillis).build();\n+        IndexMetadata firstFailureIndexMetadata = createFirstFailureStore(dataStreamName, epochMillis).build();\n \n         Metadata.Builder mdBuilder = Metadata.builder()\n             .put(indexBuilder(\"foo_foo\").state(State.OPEN))\n@@ -445,10 +599,12 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n             .put(indexBuilder(\"bar_index\").state(State.OPEN).putAlias(AliasMetadata.builder(\"foo_alias\")))\n             .put(firstBackingIndexMetadata, true)\n             .put(secondBackingIndexMetadata, true)\n+            .put(firstFailureIndexMetadata, true)\n             .put(\n                 DataStreamTestHelper.newInstance(\n                     dataStreamName,\n-                    List.of(firstBackingIndexMetadata.getIndex(), secondBackingIndexMetadata.getIndex())\n+                    List.of(firstBackingIndexMetadata.getIndex(), secondBackingIndexMetadata.getIndex()),\n+                    List.of(firstFailureIndexMetadata.getIndex())\n                 )\n             );\n \n@@ -472,15 +628,32 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n             );\n \n             // data streams are not included but expression matches the data stream\n-            Collection<String> indices = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(\n                 indicesAndAliasesContext,\n-                \"foo_*\"\n+                \"foo_*\",\n+                randomFrom(IndexComponentSelector.DATA, IndexComponentSelector.ALL_APPLICABLE),\n+                data,\n+                failures,\n+                false\n             );\n-            assertThat(indices, containsInAnyOrder(\"foo_index\", \"foo_foo\", \"bar_index\"));\n+            assertThat(data, equalTo(Set.of(\"foo_index\", \"foo_foo\", \"bar_index\")));\n+            assertThat(failures, empty());\n \n-            // data streams are not included and expression doesn't match the data steram\n-            indices = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(indicesAndAliasesContext, \"bar_*\");\n-            assertThat(indices, containsInAnyOrder(\"bar_bar\", \"bar_index\"));\n+            // data streams are not included and expression doesn't match the data stream\n+            data = new HashSet<>();\n+            failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(\n+                indicesAndAliasesContext,\n+                \"bar_*\",\n+                randomFrom(IndexComponentSelector.DATA, IndexComponentSelector.ALL_APPLICABLE),\n+                data,\n+                failures,\n+                false\n+            );\n+            assertThat(data, equalTo(Set.of(\"bar_bar\", \"bar_index\")));\n+            assertThat(failures, empty());\n         }\n \n         {\n@@ -505,95 +678,192 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n                 NONE\n             );\n \n-            // data stream's corresponding backing indices are resolved\n-            Collection<String> indices = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(\n+            // data stream's corresponding backing indices are resolved with selector ::data\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(\n                 indicesAliasesAndDataStreamsContext,\n-                \"foo_*\"\n+                \"foo_*\",\n+                IndexComponentSelector.DATA,\n+                data,\n+                failures,\n+                false\n             );\n             assertThat(\n-                indices,\n-                containsInAnyOrder(\n-                    \"foo_index\",\n-                    \"bar_index\",\n-                    \"foo_foo\",\n-                    DataStream.getDefaultBackingIndexName(\"foo_logs\", 1, epochMillis),\n-                    DataStream.getDefaultBackingIndexName(\"foo_logs\", 2, epochMillis)\n+                data,\n+                equalTo(\n+                    Set.of(\n+                        \"foo_index\",\n+                        \"bar_index\",\n+                        \"foo_foo\",\n+                        DataStream.getDefaultBackingIndexName(\"foo_logs\", 1, epochMillis),\n+                        DataStream.getDefaultBackingIndexName(\"foo_logs\", 2, epochMillis)\n+                    )\n                 )\n             );\n+            assertThat(failures, empty());\n \n-            // include all wildcard adds the data stream's backing indices\n-            indices = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(\n+            // data stream's corresponding backing indices are resolved with selector ::failures\n+            data = new HashSet<>();\n+            failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(\n                 indicesAliasesAndDataStreamsContext,\n-                \"*\"\n+                \"foo_*\",\n+                IndexComponentSelector.FAILURES,\n+                data,\n+                failures,\n+                false\n+            );\n+            assertThat(data, equalTo(Set.of(DataStream.getDefaultFailureStoreName(\"foo_logs\", 1, epochMillis))));\n+            assertThat(failures, empty());\n+\n+            // data stream's corresponding backing indices are resolved with selector ::*\n+            data = new HashSet<>();\n+            failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(\n+                indicesAliasesAndDataStreamsContext,\n+                \"foo_*\",\n+                IndexComponentSelector.ALL_APPLICABLE,\n+                data,\n+                failures,\n+                false\n             );\n             assertThat(\n-                indices,\n-                containsInAnyOrder(\n-                    \"foo_index\",\n-                    \"bar_index\",\n-                    \"foo_foo\",\n-                    \"bar_bar\",\n-                    DataStream.getDefaultBackingIndexName(\"foo_logs\", 1, epochMillis),\n-                    DataStream.getDefaultBackingIndexName(\"foo_logs\", 2, epochMillis)\n+                data,\n+                equalTo(\n+                    Set.of(\n+                        \"foo_index\",\n+                        \"bar_index\",\n+                        \"foo_foo\",\n+                        DataStream.getDefaultBackingIndexName(\"foo_logs\", 1, epochMillis),\n+                        DataStream.getDefaultBackingIndexName(\"foo_logs\", 2, epochMillis),\n+                        DataStream.getDefaultFailureStoreName(\"foo_logs\", 1, epochMillis)\n+                    )\n                 )\n             );\n-        }\n+            assertThat(failures, empty());\n \n-        {\n-            IndicesOptions indicesAliasesAndExpandHiddenOptions = IndicesOptions.fromOptions(\n-                randomBoolean(),\n-                randomBoolean(),\n-                true,\n-                false,\n-                true,\n-                true,\n-                false,\n-                false,\n+            // include all wildcard adds the data stream's backing indices with selector ::data\n+            data = new HashSet<>();\n+            failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(\n+                indicesAliasesAndDataStreamsContext,\n+                \"*\",\n+                IndexComponentSelector.DATA,\n+                data,\n+                failures,\n                 false\n             );\n-            IndexNameExpressionResolver.Context indicesAliasesDataStreamsAndHiddenIndices = new IndexNameExpressionResolver.Context(\n+            assertThat(\n+                data,\n+                equalTo(\n+                    Set.of(\n+                        \"foo_index\",\n+                        \"bar_index\",\n+                        \"foo_foo\",\n+                        \"bar_bar\",\n+                        DataStream.getDefaultBackingIndexName(\"foo_logs\", 1, epochMillis),\n+                        DataStream.getDefaultBackingIndexName(\"foo_logs\", 2, epochMillis)\n+                    )\n+                )\n+            );\n+            assertThat(failures, empty());\n+\n+            // include all wildcard adds the data stream's backing indices with selector ::data\n+            data = new HashSet<>();\n+            failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(\n+                indicesAliasesAndDataStreamsContext,\n+                \"*\",\n+                IndexComponentSelector.ALL_APPLICABLE,\n+                data,\n+                failures,\n+                false\n+            );\n+            assertThat(\n+                data,\n+                equalTo(\n+                    Set.of(\n+                        \"foo_index\",\n+                        \"bar_index\",\n+                        \"foo_foo\",\n+                        \"bar_bar\",\n+                        DataStream.getDefaultBackingIndexName(\"foo_logs\", 1, epochMillis),\n+                        DataStream.getDefaultBackingIndexName(\"foo_logs\", 2, epochMillis),\n+                        DataStream.getDefaultFailureStoreName(\"foo_logs\", 1, epochMillis)\n+                    )\n+                )\n+            );\n+            assertThat(failures, empty());\n+            // include all wildcard adds the data stream's backing indices with selector ::failures\n+            data = new HashSet<>();\n+            failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(\n+                indicesAliasesAndDataStreamsContext,\n+                \"*\",\n+                IndexComponentSelector.FAILURES,\n+                data,\n+                failures,\n+                false\n+            );\n+            assertThat(data, equalTo(Set.of(DataStream.getDefaultFailureStoreName(\"foo_logs\", 1, epochMillis))));\n+            assertThat(failures, empty());\n+        }\n+\n+        {\n+            IndexNameExpressionResolver.Context preserveDataStreamsContext = new IndexNameExpressionResolver.Context(\n                 state,\n-                indicesAliasesAndExpandHiddenOptions,\n+                IndicesOptions.lenientExpand(),\n                 false,\n                 false,\n                 true,\n+                true,\n                 SystemIndexAccessLevel.NONE,\n                 NONE,\n                 NONE\n             );\n \n-            // data stream's corresponding backing indices are resolved\n-            Collection<String> indices = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(\n-                indicesAliasesDataStreamsAndHiddenIndices,\n-                \"foo_*\"\n-            );\n-            assertThat(\n-                indices,\n-                containsInAnyOrder(\n-                    \"foo_index\",\n-                    \"bar_index\",\n-                    \"foo_foo\",\n-                    DataStream.getDefaultBackingIndexName(\"foo_logs\", 1, epochMillis),\n-                    DataStream.getDefaultBackingIndexName(\"foo_logs\", 2, epochMillis)\n-                )\n+            // data stream is added next to the concrete indices with selector ::data\n+            Set<String> data = new HashSet<>();\n+            Set<String> failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(\n+                preserveDataStreamsContext,\n+                \"foo_*\",\n+                IndexComponentSelector.DATA,\n+                data,\n+                failures,\n+                false\n             );\n-\n-            // include all wildcard adds the data stream's backing indices\n-            indices = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(\n-                indicesAliasesDataStreamsAndHiddenIndices,\n-                \"*\"\n+            assertThat(data, equalTo(Set.of(\"foo_index\", \"bar_index\", \"foo_foo\", \"foo_logs\")));\n+            assertThat(failures, empty());\n+\n+            // data stream is added next to the concrete indices with selector ::data and ::failures\n+            data = new HashSet<>();\n+            failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(\n+                preserveDataStreamsContext,\n+                \"foo_*\",\n+                IndexComponentSelector.ALL_APPLICABLE,\n+                data,\n+                failures,\n+                false\n             );\n-            assertThat(\n-                indices,\n-                containsInAnyOrder(\n-                    \"foo_index\",\n-                    \"bar_index\",\n-                    \"foo_foo\",\n-                    \"bar_bar\",\n-                    DataStream.getDefaultBackingIndexName(\"foo_logs\", 1, epochMillis),\n-                    DataStream.getDefaultBackingIndexName(\"foo_logs\", 2, epochMillis)\n-                )\n+            assertThat(data, equalTo(Set.of(\"foo_index\", \"bar_index\", \"foo_foo\", \"foo_logs\")));\n+            assertThat(failures, equalTo(Set.of(\"foo_logs\")));\n+\n+            // data stream the only one included with selector ::failures\n+            data = new HashSet<>();\n+            failures = new HashSet<>();\n+            WildcardExpressionResolver.processWildcards(\n+                preserveDataStreamsContext,\n+                \"foo_*\",\n+                IndexComponentSelector.FAILURES,\n+                data,\n+                failures,\n+                false\n             );\n+            assertThat(data, empty());\n+            assertThat(failures, equalTo(Set.of(\"foo_logs\")));\n         }\n     }\n \n@@ -623,17 +893,23 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n             SystemIndexAccessLevel.NONE\n         );\n \n-        Collection<String> matches = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(\n-            indicesAndAliasesContext,\n-            \"*\"\n-        );\n-        assertThat(matches, containsInAnyOrder(\"bar_bar\", \"foo_foo\", \"foo_index\", \"bar_index\"));\n-        matches = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(onlyIndicesContext, \"*\");\n-        assertThat(matches, containsInAnyOrder(\"bar_bar\", \"foo_foo\", \"foo_index\", \"bar_index\"));\n-        matches = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(indicesAndAliasesContext, \"foo*\");\n-        assertThat(matches, containsInAnyOrder(\"foo_foo\", \"foo_index\", \"bar_index\"));\n-        matches = IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(onlyIndicesContext, \"foo*\");\n-        assertThat(matches, containsInAnyOrder(\"foo_foo\", \"foo_index\"));\n+        Set<String> data = new HashSet<>();\n+        Set<String> failures = new HashSet<>();\n+        WildcardExpressionResolver.processWildcards(indicesAndAliasesContext, \"*\", IndexComponentSelector.DATA, data, failures, false);\n+        assertThat(data, equalTo(Set.of(\"bar_bar\", \"foo_foo\", \"foo_index\", \"bar_index\")));\n+\n+        data = new HashSet<>();\n+        failures = new HashSet<>();\n+        WildcardExpressionResolver.processWildcards(onlyIndicesContext, \"*\", IndexComponentSelector.DATA, data, failures, false);\n+        assertThat(data, equalTo(Set.of(\"bar_bar\", \"foo_foo\", \"foo_index\", \"bar_index\")));\n+        data = new HashSet<>();\n+        failures = new HashSet<>();\n+        WildcardExpressionResolver.processWildcards(indicesAndAliasesContext, \"foo*\", IndexComponentSelector.DATA, data, failures, false);\n+        assertThat(data, equalTo(Set.of(\"foo_foo\", \"foo_index\", \"bar_index\")));\n+        data = new HashSet<>();\n+        failures = new HashSet<>();\n+        WildcardExpressionResolver.processWildcards(onlyIndicesContext, \"foo*\", IndexComponentSelector.DATA, data, failures, false);\n+        assertThat(data, equalTo(Set.of(\"foo_foo\", \"foo_index\")));\n     }\n \n     private static IndexMetadata.Builder indexBuilder(String index, boolean hidden) {\n@@ -646,6 +922,23 @@ public class WildcardExpressionResolverTests extends ESTestCase {\n     }\n \n     private static void assertWildcardResolvesToEmpty(IndexNameExpressionResolver.Context context, String wildcardExpression) {\n-        assertThat(IndexNameExpressionResolver.WildcardExpressionResolver.matchWildcardToResources(context, wildcardExpression), empty());\n+        Set<String> data = new HashSet<>();\n+        Set<String> failures = new HashSet<>();\n+        Runnable execute = () -> WildcardExpressionResolver.processWildcards(\n+            context,\n+            wildcardExpression,\n+            IndexComponentSelector.DATA,\n+            data,\n+            failures,\n+            false\n+        );\n+        if (context.getOptions().allowNoIndices()) {\n+            execute.run();\n+            assertThat(data, empty());\n+            assertThat(failures, empty());\n+        } else {\n+            IndexNotFoundException infe = expectThrows(IndexNotFoundException.class, execute::run);\n+            assertThat(infe.getIndex().getName(), equalTo(wildcardExpression + \"::data\"));\n+        }\n     }\n }\ndiff --git a/server/src/test/java/org/elasticsearch/transport/RemoteClusterAwareTests.java b/server/src/test/java/org/elasticsearch/transport/RemoteClusterAwareTests.java\nindex 2394e0b07cc5..cb1cdb7c16ac 100644\n--- a/server/src/test/java/org/elasticsearch/transport/RemoteClusterAwareTests.java\n+++ b/server/src/test/java/org/elasticsearch/transport/RemoteClusterAwareTests.java\n@@ -24,6 +24,28 @@ import static org.hamcrest.Matchers.not;\n \n public class RemoteClusterAwareTests extends ESTestCase {\n \n+    public void testIsRemoteIndexName() {\n+        assertThat(RemoteClusterAware.isRemoteIndexName(\"*:foo\"), equalTo(true));\n+        assertThat(RemoteClusterAware.isRemoteIndexName(\"*:foo::data\"), equalTo(true));\n+        assertThat(RemoteClusterAware.isRemoteIndexName(\"foo::data\"), equalTo(false));\n+        assertThat(RemoteClusterAware.isRemoteIndexName(\"<test-{now/M{yyyy.MM}}-000002>::*\"), equalTo(false));\n+        assertThat(RemoteClusterAware.isRemoteIndexName(\"-<test-{now/M{yyyy.MM}}-000002>::data\"), equalTo(false));\n+    }\n+\n+    public void testSplitIndexName() {\n+        assertThat(RemoteClusterAware.splitIndexName(\"*:foo\"), equalTo(new String[] { \"*\", \"foo\" }));\n+        assertThat(RemoteClusterAware.splitIndexName(\"*:foo::data\"), equalTo(new String[] { \"*\", \"foo::data\" }));\n+        assertThat(RemoteClusterAware.splitIndexName(\"foo::data\"), equalTo(new String[] { null, \"foo::data\" }));\n+        assertThat(\n+            RemoteClusterAware.splitIndexName(\"<test-{now/M{yyyy.MM}}-000002>::*\"),\n+            equalTo(new String[] { null, \"<test-{now/M{yyyy.MM}}-000002>::*\" })\n+        );\n+        assertThat(\n+            RemoteClusterAware.splitIndexName(\"-<test-{now/M{yyyy.MM}}-000002>::data\"),\n+            equalTo(new String[] { null, \"-<test-{now/M{yyyy.MM}}-000002>::data\" })\n+        );\n+    }\n+\n     public void testBuildRemoteIndexName() {\n         {\n             String clusterAlias = randomAlphaOfLengthBetween(5, 10);\n@@ -138,6 +160,12 @@ public class RemoteClusterAwareTests extends ESTestCase {\n             IllegalArgumentException.class,\n             \"To exclude a cluster you must specify the '*' wildcard\"\n         );\n+        // Cluster wildcard exclusion requires :*::* when selector is provided\n+        mustThrowException(\n+            new String[] { \"*:*\", \"-cluster*:*::data\" },\n+            IllegalArgumentException.class,\n+            \"To exclude a cluster you must specify the '::*' selector or leave it off\"\n+        );\n         mustThrowException(\n             new String[] { \"*:*\", \"-cluster2:index1\" },\n             IllegalArgumentException.class,\ndiff --git a/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/datafeed/DatafeedNodeSelectorTests.java b/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/datafeed/DatafeedNodeSelectorTests.java\nindex 4bb612921876..4ae780c38685 100644\n--- a/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/datafeed/DatafeedNodeSelectorTests.java\n+++ b/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/datafeed/DatafeedNodeSelectorTests.java\n@@ -349,7 +349,8 @@ public class DatafeedNodeSelectorTests extends ESTestCase {\n                         + \"indices_options [IndicesOptions[ignore_unavailable=false, allow_no_indices=true, expand_wildcards_open=true, \"\n                         + \"expand_wildcards_closed=false, expand_wildcards_hidden=false, allow_aliases_to_multiple_indices=true, \"\n                         + \"forbid_closed_indices=true, ignore_aliases=false, ignore_throttled=true, include_regular_indices=true, \"\n-                        + \"include_failure_indices=false, allow_failure_indices=true]] with exception [no such index [not_foo]]\"\n+                        + \"include_failure_indices=false, allow_failure_indices=true, allow_selectors=true]] with exception \"\n+                        + \"[no such index [not_foo]]\"\n                 )\n             )\n         );\n@@ -384,7 +385,7 @@ public class DatafeedNodeSelectorTests extends ESTestCase {\n                         + \"expand_wildcards_open=true, expand_wildcards_closed=false, expand_wildcards_hidden=false, \"\n                         + \"allow_aliases_to_multiple_indices=true, forbid_closed_indices=true, ignore_aliases=false, \"\n                         + \"ignore_throttled=true, include_regular_indices=true, include_failure_indices=false, \"\n-                        + \"allow_failure_indices=true]] with exception [no such index [not_foo]]]\"\n+                        + \"allow_failure_indices=true, allow_selectors=true]] with exception [no such index [not_foo]]]\"\n                 )\n             )\n         );\n@@ -561,7 +562,8 @@ public class DatafeedNodeSelectorTests extends ESTestCase {\n                         + \"indices_options [IndicesOptions[ignore_unavailable=false, allow_no_indices=true, expand_wildcards_open=true, \"\n                         + \"expand_wildcards_closed=false, expand_wildcards_hidden=false, allow_aliases_to_multiple_indices=true, \"\n                         + \"forbid_closed_indices=true, ignore_aliases=false, ignore_throttled=true, include_regular_indices=true, \"\n-                        + \"include_failure_indices=false, allow_failure_indices=true]] with exception [no such index [not_foo]]]\"\n+                        + \"include_failure_indices=false, allow_failure_indices=true, allow_selectors=true]] with exception \"\n+                        + \"[no such index [not_foo]]]\"\n                 )\n             )\n         );",
  "judge_mode": "comparative",
  "judge_model": "openai/claude-sonnet-4-5-20250929",
  "test_label": "v0",
  "agent_results": [
    {
      "runner": "auggie",
      "model": "sonnet4.5",
      "edit_run_id": "a9463435",
      "status": "success",
      "elapsed_ms": 1563126,
      "patch_unified": "diff --git a/server/src/main/java/org/elasticsearch/action/support/IndicesOptions.java b/server/src/main/java/org/elasticsearch/action/support/IndicesOptions.java\nindex 85889d83..21cc5a16 100644\n--- a/server/src/main/java/org/elasticsearch/action/support/IndicesOptions.java\n+++ b/server/src/main/java/org/elasticsearch/action/support/IndicesOptions.java\n@@ -325,6 +325,7 @@ public record IndicesOptions(\n      * @param allowAliasToMultipleIndices, allow aliases to multiple indices, true by default.\n      * @param allowClosedIndices, allow closed indices, true by default.\n      * @param allowFailureIndices, allow failure indices in the response, true by default\n+     * @param allowSelectors, allow selector syntax (::data, ::failures, ::*) in index expressions, true by default\n      * @param ignoreThrottled, filters out throttled (aka frozen indices), defaults to true. This is deprecated and the only one\n      *                         that only filters and never throws an error.\n      */\n@@ -332,11 +333,12 @@ public record IndicesOptions(\n         boolean allowAliasToMultipleIndices,\n         boolean allowClosedIndices,\n         boolean allowFailureIndices,\n+        boolean allowSelectors,\n         @Deprecated boolean ignoreThrottled\n     ) implements ToXContentFragment {\n \n         public static final String IGNORE_THROTTLED = \"ignore_throttled\";\n-        public static final GatekeeperOptions DEFAULT = new GatekeeperOptions(true, true, true, false);\n+        public static final GatekeeperOptions DEFAULT = new GatekeeperOptions(true, true, true, true, false);\n \n         public static GatekeeperOptions parseParameter(Object ignoreThrottled, GatekeeperOptions defaultOptions) {\n             if (ignoreThrottled == null && defaultOptions != null) {\n@@ -356,6 +358,7 @@ public record IndicesOptions(\n             private boolean allowAliasToMultipleIndices;\n             private boolean allowClosedIndices;\n             private boolean allowFailureIndices;\n+            private boolean allowSelectors;\n             private boolean ignoreThrottled;\n \n             public Builder() {\n@@ -366,6 +369,7 @@ public record IndicesOptions(\n                 allowAliasToMultipleIndices = options.allowAliasToMultipleIndices;\n                 allowClosedIndices = options.allowClosedIndices;\n                 allowFailureIndices = options.allowFailureIndices;\n+                allowSelectors = options.allowSelectors;\n                 ignoreThrottled = options.ignoreThrottled;\n             }\n \n@@ -396,6 +400,15 @@ public record IndicesOptions(\n                 return this;\n             }\n \n+            /**\n+             * Selector syntax (::data, ::failures, ::*) is accepted when true, otherwise the resolution will throw an error.\n+             * Defaults to true.\n+             */\n+            public Builder allowSelectors(boolean allowSelectors) {\n+                this.allowSelectors = allowSelectors;\n+                return this;\n+            }\n+\n             /**\n              * Throttled indices will not be included in the result. Defaults to false.\n              */\n@@ -405,7 +418,7 @@ public record IndicesOptions(\n             }\n \n             public GatekeeperOptions build() {\n-                return new GatekeeperOptions(allowAliasToMultipleIndices, allowClosedIndices, allowFailureIndices, ignoreThrottled);\n+                return new GatekeeperOptions(allowAliasToMultipleIndices, allowClosedIndices, allowFailureIndices, allowSelectors, ignoreThrottled);\n             }\n         }\n \n@@ -586,6 +599,7 @@ public record IndicesOptions(\n                 .allowAliasToMultipleIndices(true)\n                 .allowClosedIndices(true)\n                 .allowFailureIndices(false)\n+                .allowSelectors(false)\n                 .ignoreThrottled(false)\n         )\n         .build();\n@@ -651,6 +665,7 @@ public record IndicesOptions(\n                 .allowAliasToMultipleIndices(true)\n                 .allowClosedIndices(true)\n                 .allowFailureIndices(false)\n+                .allowSelectors(false)\n                 .ignoreThrottled(false)\n         )\n         .build();\n@@ -697,6 +712,7 @@ public record IndicesOptions(\n                 .allowAliasToMultipleIndices(true)\n                 .allowClosedIndices(true)\n                 .allowFailureIndices(false)\n+                .allowSelectors(false)\n                 .ignoreThrottled(false)\n         )\n         .build();\n@@ -909,6 +925,13 @@ public record IndicesOptions(\n         return gatekeeperOptions.allowFailureIndices();\n     }\n \n+    /**\n+     * @return whether selectors are allowed in index expressions\n+     */\n+    public boolean allowSelectors() {\n+        return gatekeeperOptions.allowSelectors();\n+    }\n+\n     /**\n      * @return whether aliases pointing to multiple indices are allowed\n      */\ndiff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java\nindex 279243ee..5c68d995 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java\n@@ -286,6 +286,23 @@ public class IndexNameExpressionResolver {\n             boolean isExclusion = wildcardSeen && originalExpression.startsWith(\"-\");\n             String baseExpression = isExclusion ? originalExpression.substring(1) : originalExpression;\n \n+            // Parse and validate selector syntax\n+            IndexExpression indexExpression = IndexExpression.parse(baseExpression);\n+            if (indexExpression.hasSelector()) {\n+                // Check if selectors are allowed\n+                if (context.getOptions().allowSelectors() == false) {\n+                    throw new IllegalArgumentException(\n+                        \"Index expression [\"\n+                            + baseExpression\n+                            + \"] contains a selector [\"\n+                            + indexExpression.selector().getKey()\n+                            + \"], but selectors are not allowed for this operation\"\n+                    );\n+                }\n+                // Strip the selector from the expression for further processing\n+                baseExpression = indexExpression.name();\n+            }\n+\n             // Resolve date math\n             baseExpression = DateMathExpressionResolver.resolveExpression(baseExpression, context::getStartTime);\n \ndiff --git a/server/src/test/java/org/elasticsearch/action/support/IndicesOptionsTests.java b/server/src/test/java/org/elasticsearch/action/support/IndicesOptionsTests.java\nindex de7b43ad..fcd56be3 100644\n--- a/server/src/test/java/org/elasticsearch/action/support/IndicesOptionsTests.java\n+++ b/server/src/test/java/org/elasticsearch/action/support/IndicesOptionsTests.java\n@@ -341,7 +341,7 @@ public class IndicesOptionsTests extends ESTestCase {\n             randomBoolean(),\n             randomBoolean()\n         );\n-        GatekeeperOptions gatekeeperOptions = new GatekeeperOptions(randomBoolean(), randomBoolean(), randomBoolean(), randomBoolean());\n+        GatekeeperOptions gatekeeperOptions = new GatekeeperOptions(randomBoolean(), randomBoolean(), randomBoolean(), randomBoolean(), randomBoolean());\n         IndicesOptions.SelectorOptions selectorOptions = new IndicesOptions.SelectorOptions(randomFrom(IndexComponentSelector.values()));\n \n         IndicesOptions indicesOptions = new IndicesOptions(concreteTargetOptions, wildcardOptions, gatekeeperOptions, selectorOptions);\ndiff --git a/server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java b/server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java\nindex 30895767..a4235b42 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java\n@@ -3423,6 +3423,60 @@ public class IndexNameExpressionResolverTests extends ESTestCase {\n         );\n     }\n \n+    public void testSelectorSyntaxValidation() {\n+        final String dataStreamName = \"my-data-stream\";\n+        IndexMetadata index1 = createBackingIndex(dataStreamName, 1, epochMillis).build();\n+        IndexMetadata index2 = createBackingIndex(dataStreamName, 2, epochMillis).build();\n+        IndexMetadata failureIndex1 = createFailureStore(dataStreamName, 1, epochMillis).build();\n+        IndexMetadata failureIndex2 = createFailureStore(dataStreamName, 2, epochMillis).build();\n+\n+        Metadata.Builder mdBuilder = Metadata.builder()\n+            .put(index1, false)\n+            .put(index2, false)\n+            .put(failureIndex1, false)\n+            .put(failureIndex2, false)\n+            .put(\n+                newInstance(\n+                    dataStreamName,\n+                    List.of(index1.getIndex(), index2.getIndex()),\n+                    List.of(failureIndex1.getIndex(), failureIndex2.getIndex())\n+                )\n+            );\n+\n+        ClusterState state = ClusterState.builder(new ClusterName(\"_name\")).metadata(mdBuilder).build();\n+\n+        // Test that selectors are rejected when allowSelectors is false\n+        {\n+            IndicesOptions indicesOptions = IndicesOptions.LENIENT_EXPAND_OPEN_NO_SELECTORS;\n+            IllegalArgumentException e = expectThrows(\n+                IllegalArgumentException.class,\n+                () -> indexNameExpressionResolver.concreteIndices(state, indicesOptions, true, \"my-data-stream::data\")\n+            );\n+            assertThat(e.getMessage(), containsString(\"selectors are not allowed\"));\n+        }\n+\n+        // Test that selectors are accepted when allowSelectors is true\n+        {\n+            IndicesOptions indicesOptions = IndicesOptions.builder(IndicesOptions.STRICT_EXPAND_OPEN)\n+                .gatekeeperOptions(IndicesOptions.GatekeeperOptions.builder().allowSelectors(true).build())\n+                .build();\n+            // This should not throw an exception\n+            Index[] result = indexNameExpressionResolver.concreteIndices(state, indicesOptions, true, \"my-data-stream::data\");\n+            assertThat(result, notNullValue());\n+            assertThat(result.length, equalTo(2));\n+        }\n+\n+        // Test that wildcard expressions with selectors are rejected when allowSelectors is false\n+        {\n+            IndicesOptions indicesOptions = IndicesOptions.LENIENT_EXPAND_OPEN_NO_SELECTORS;\n+            IllegalArgumentException e = expectThrows(\n+                IllegalArgumentException.class,\n+                () -> indexNameExpressionResolver.concreteIndices(state, indicesOptions, true, \"my-*::failures\")\n+            );\n+            assertThat(e.getMessage(), containsString(\"selectors are not allowed\"));\n+        }\n+    }\n+\n     public static IndexMetadata.Builder indexBuilder(String index) {\n         return indexBuilder(index, Settings.EMPTY);\n     }",
      "scores": {
        "correctness": -0.8,
        "completeness": -0.9,
        "code_reuse": -0.3,
        "best_practices": -0.5,
        "unsolicited_docs": 0.8
      },
      "aggregate": -0.33999999999999997,
      "rationale": "The agent's implementation is fundamentally incomplete and incorrect. It only adds the allowSelectors field to GatekeeperOptions and adds basic validation in IndexNameExpressionResolver, but completely misses the core functionality: (1) No SelectorResolver class to parse selector expressions, (2) No IndexComponentSelector enum, (3) No actual selector resolution logic in WildcardExpressionResolver or concreteIndices methods, (4) Missing all the complex data/failures separation logic, (5) No changes to REST APIs, snapshots, data stream lifecycle, or transport versions, (6) Missing all test file updates. The agent created an IndexExpression.parse() method that doesn't exist in the ground truth. The validation logic is overly simplistic and doesn't match the ground truth's approach. The test added is superficial and doesn't cover the actual selector resolution behavior. This represents less than 10% of the required changes.",
      "llm_rating": 0.05,
      "llm_summary": "Added allowSelectors field to GatekeeperOptions and basic validation in IndexNameExpressionResolver but completely omitted the SelectorResolver class, IndexComponentSelector enum, selector parsing logic, data/failures resolution in WildcardExpressionResolver, and all REST API, snapshot, and test updates required by the ground truth.",
      "errors": []
    },
    {
      "runner": "claude-code",
      "model": "claude-sonnet-4-5",
      "edit_run_id": "c7a3f90a",
      "status": "success",
      "elapsed_ms": 156654,
      "patch_unified": "",
      "scores": {
        "correctness": -1.0,
        "completeness": -1.0,
        "code_reuse": 0.0,
        "best_practices": 0.0,
        "unsolicited_docs": 1.0
      },
      "aggregate": -0.2,
      "rationale": "The agent produced an empty diff, making no changes whatsoever to the codebase. The ground truth shows extensive modifications across multiple files including introducing selector syntax (::data, ::failures, ::*), removing the deprecated failure_store query parameter, adding new classes like SelectorResolver and IndexComponentSelectorResolverTests, modifying IndicesOptions to include allowSelectors gatekeeper option, updating index resolution logic in IndexNameExpressionResolver, and comprehensive test updates. The agent failed to implement any of these required changes, resulting in maximum negative scores for correctness and completeness.",
      "llm_rating": 0.0,
      "llm_summary": "Agent made no changes to the codebase, producing an empty diff instead of implementing the selector syntax (::data, ::failures, ::*), removing the failure_store query parameter, adding SelectorResolver class, and updating IndicesOptions with allowSelectors gatekeeper as required by the ground truth.",
      "errors": []
    },
    {
      "runner": "factory",
      "model": "claude-sonnet-4-5-20250929",
      "edit_run_id": "074538b9",
      "status": "success",
      "elapsed_ms": 364473,
      "patch_unified": "diff --git a/modules/data-streams/src/main/java/org/elasticsearch/datastreams/lifecycle/action/DeleteDataStreamLifecycleAction.java b/modules/data-streams/src/main/java/org/elasticsearch/datastreams/lifecycle/action/DeleteDataStreamLifecycleAction.java\nindex 15953486..0b7052fb 100644\n--- a/modules/data-streams/src/main/java/org/elasticsearch/datastreams/lifecycle/action/DeleteDataStreamLifecycleAction.java\n+++ b/modules/data-streams/src/main/java/org/elasticsearch/datastreams/lifecycle/action/DeleteDataStreamLifecycleAction.java\n@@ -51,6 +51,7 @@ public class DeleteDataStreamLifecycleAction {\n                     .allowClosedIndices(true)\n                     .ignoreThrottled(false)\n                     .allowFailureIndices(false)\n+                    .allowSelectors(false)\n                     .build()\n             )\n             .build();\ndiff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/alias/IndicesAliasesRequest.java b/server/src/main/java/org/elasticsearch/action/admin/indices/alias/IndicesAliasesRequest.java\nindex d66cab1d..c7be077f 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/indices/alias/IndicesAliasesRequest.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/alias/IndicesAliasesRequest.java\n@@ -75,6 +75,7 @@ public class IndicesAliasesRequest extends AcknowledgedRequest<IndicesAliasesReq\n                 .allowClosedIndices(true)\n                 .ignoreThrottled(false)\n                 .allowFailureIndices(true)\n+                .allowSelectors(false)\n                 .build()\n         )\n         .build();\ndiff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/alias/get/GetAliasesRequest.java b/server/src/main/java/org/elasticsearch/action/admin/indices/alias/get/GetAliasesRequest.java\nindex c2810881..bff091b7 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/indices/alias/get/GetAliasesRequest.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/alias/get/GetAliasesRequest.java\n@@ -24,7 +24,7 @@ import java.util.Map;\n \n public class GetAliasesRequest extends ActionRequest implements AliasesRequest {\n \n-    public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions.strictExpandHidden();\n+    public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions.strictExpandHiddenNoSelectors();\n \n     private String[] aliases;\n     private String[] originalAliases;\ndiff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequest.java b/server/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequest.java\nindex 96fae42b..c72964cd 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequest.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/delete/DeleteIndexRequest.java\n@@ -44,6 +44,7 @@ public class DeleteIndexRequest extends AcknowledgedRequest<DeleteIndexRequest>\n                 .allowClosedIndices(true)\n                 .ignoreThrottled(false)\n                 .allowFailureIndices(true)\n+                .allowSelectors(false)\n                 .build()\n         )\n         .build();\ndiff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java b/server/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java\nindex 7b782c6d..643e2637 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java\n@@ -83,6 +83,7 @@ public class PutMappingRequest extends AcknowledgedRequest<PutMappingRequest> im\n                 .allowAliasToMultipleIndices(true)\n                 .ignoreThrottled(false)\n                 .allowFailureIndices(false)\n+                .allowSelectors(false)\n         )\n         .build();\n \ndiff --git a/server/src/main/java/org/elasticsearch/action/support/IndicesOptions.java b/server/src/main/java/org/elasticsearch/action/support/IndicesOptions.java\nindex 85889d83..86686f08 100644\n--- a/server/src/main/java/org/elasticsearch/action/support/IndicesOptions.java\n+++ b/server/src/main/java/org/elasticsearch/action/support/IndicesOptions.java\n@@ -325,6 +325,7 @@ public record IndicesOptions(\n      * @param allowAliasToMultipleIndices, allow aliases to multiple indices, true by default.\n      * @param allowClosedIndices, allow closed indices, true by default.\n      * @param allowFailureIndices, allow failure indices in the response, true by default\n+     * @param allowSelectors, allow selector syntax (::data, ::failures, ::*) in index expressions, true by default\n      * @param ignoreThrottled, filters out throttled (aka frozen indices), defaults to true. This is deprecated and the only one\n      *                         that only filters and never throws an error.\n      */\n@@ -332,11 +333,12 @@ public record IndicesOptions(\n         boolean allowAliasToMultipleIndices,\n         boolean allowClosedIndices,\n         boolean allowFailureIndices,\n+        boolean allowSelectors,\n         @Deprecated boolean ignoreThrottled\n     ) implements ToXContentFragment {\n \n         public static final String IGNORE_THROTTLED = \"ignore_throttled\";\n-        public static final GatekeeperOptions DEFAULT = new GatekeeperOptions(true, true, true, false);\n+        public static final GatekeeperOptions DEFAULT = new GatekeeperOptions(true, true, true, true, false);\n \n         public static GatekeeperOptions parseParameter(Object ignoreThrottled, GatekeeperOptions defaultOptions) {\n             if (ignoreThrottled == null && defaultOptions != null) {\n@@ -356,6 +358,7 @@ public record IndicesOptions(\n             private boolean allowAliasToMultipleIndices;\n             private boolean allowClosedIndices;\n             private boolean allowFailureIndices;\n+            private boolean allowSelectors;\n             private boolean ignoreThrottled;\n \n             public Builder() {\n@@ -366,6 +369,7 @@ public record IndicesOptions(\n                 allowAliasToMultipleIndices = options.allowAliasToMultipleIndices;\n                 allowClosedIndices = options.allowClosedIndices;\n                 allowFailureIndices = options.allowFailureIndices;\n+                allowSelectors = options.allowSelectors;\n                 ignoreThrottled = options.ignoreThrottled;\n             }\n \n@@ -396,6 +400,15 @@ public record IndicesOptions(\n                 return this;\n             }\n \n+            /**\n+             * Selector syntax (::data, ::failures, ::*) is accepted when true, otherwise expressions with selectors will throw an error.\n+             * Defaults to true.\n+             */\n+            public Builder allowSelectors(boolean allowSelectors) {\n+                this.allowSelectors = allowSelectors;\n+                return this;\n+            }\n+\n             /**\n              * Throttled indices will not be included in the result. Defaults to false.\n              */\n@@ -405,7 +418,7 @@ public record IndicesOptions(\n             }\n \n             public GatekeeperOptions build() {\n-                return new GatekeeperOptions(allowAliasToMultipleIndices, allowClosedIndices, allowFailureIndices, ignoreThrottled);\n+                return new GatekeeperOptions(allowAliasToMultipleIndices, allowClosedIndices, allowFailureIndices, allowSelectors, ignoreThrottled);\n             }\n         }\n \n@@ -586,6 +599,7 @@ public record IndicesOptions(\n                 .allowAliasToMultipleIndices(true)\n                 .allowClosedIndices(true)\n                 .allowFailureIndices(false)\n+                .allowSelectors(false)\n                 .ignoreThrottled(false)\n         )\n         .build();\n@@ -651,6 +665,7 @@ public record IndicesOptions(\n                 .allowAliasToMultipleIndices(true)\n                 .allowClosedIndices(true)\n                 .allowFailureIndices(false)\n+                .allowSelectors(false)\n                 .ignoreThrottled(false)\n         )\n         .build();\n@@ -697,6 +712,7 @@ public record IndicesOptions(\n                 .allowAliasToMultipleIndices(true)\n                 .allowClosedIndices(true)\n                 .allowFailureIndices(false)\n+                .allowSelectors(false)\n                 .ignoreThrottled(false)\n         )\n         .build();\n@@ -909,6 +925,13 @@ public record IndicesOptions(\n         return gatekeeperOptions.allowFailureIndices();\n     }\n \n+    /**\n+     * @return Whether selector syntax (::data, ::failures, ::*) is allowed in index expressions.\n+     */\n+    public boolean allowSelectors() {\n+        return gatekeeperOptions.allowSelectors();\n+    }\n+\n     /**\n      * @return whether aliases pointing to multiple indices are allowed\n      */\n@@ -1479,6 +1502,15 @@ public record IndicesOptions(\n         return STRICT_EXPAND_OPEN_CLOSED_HIDDEN;\n     }\n \n+    /**\n+     * @return indices options that requires every specified index to exist, expands wildcards to open and hidden indices, allows\n+     * that no indices are resolved from wildcard expressions (not returning an error), forbids the use of closed indices\n+     * by throwing an error, and does not allow selector syntax.\n+     */\n+    public static IndicesOptions strictExpandHiddenNoSelectors() {\n+        return STRICT_EXPAND_OPEN_CLOSED_HIDDEN_NO_SELECTORS;\n+    }\n+\n     /**\n      * @return indices option that expands wildcards to both open and closed indices, includes failure store\n      * (with data stream) and allows that indices can be missing and no indices are resolved from wildcard expressions\ndiff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java\nindex 279243ee..b53947f1 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java\n@@ -13,6 +13,7 @@ import org.apache.lucene.util.automaton.Automaton;\n import org.elasticsearch.ElasticsearchParseException;\n import org.elasticsearch.action.DocWriteRequest;\n import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndexComponentSelector;\n import org.elasticsearch.action.support.IndicesOptions;\n import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.metadata.IndexAbstraction.Type;\n@@ -1147,6 +1148,46 @@ public class IndexNameExpressionResolver {\n         return true;\n     }\n \n+    /**\n+     * Represents a resolved index expression, containing the resource name and optional selector.\n+     * A selector (e.g., ::data, ::failures, ::*) specifies which component of the resource to target.\n+     *\n+     * @param resource the name of the resource (index, alias, or data stream)\n+     * @param selector the optional selector specifying which component to target (data, failures, or all applicable)\n+     */\n+    public record ResolvedExpression(String resource, @Nullable IndexComponentSelector selector) {\n+        public static final String SELECTOR_SEPARATOR = \"::\";\n+\n+        /**\n+         * Creates a ResolvedExpression from a resource name with an optional selector.\n+         *\n+         * @param expression the full expression (e.g., \"my-index::data\")\n+         * @return a ResolvedExpression with parsed resource and selector\n+         */\n+        public static ResolvedExpression fromExpression(String expression) {\n+            int separatorIndex = expression.indexOf(SELECTOR_SEPARATOR);\n+            if (separatorIndex == -1) {\n+                return new ResolvedExpression(expression, null);\n+            }\n+            String resource = expression.substring(0, separatorIndex);\n+            String selectorKey = expression.substring(separatorIndex + SELECTOR_SEPARATOR.length());\n+            IndexComponentSelector selector = IndexComponentSelector.getByKey(selectorKey);\n+            if (selector == null) {\n+                throw new IllegalArgumentException(\n+                    \"Invalid index component selector [\" + selectorKey + \"], valid options are: data, failures, *\"\n+                );\n+            }\n+            return new ResolvedExpression(resource, selector);\n+        }\n+\n+        /**\n+         * Returns the full expression string including the selector if present.\n+         */\n+        public String asExpression() {\n+            return selector == null ? resource : resource + SELECTOR_SEPARATOR + selector.getKey();\n+        }\n+    }\n+\n     public static class Context {\n \n         private final ClusterState state;",
      "scores": {
        "correctness": -0.8,
        "completeness": -0.9,
        "code_reuse": 0.3,
        "best_practices": -0.5,
        "unsolicited_docs": -0.3
      },
      "aggregate": -0.44000000000000006,
      "rationale": "The agent made minimal changes compared to the extensive ground truth implementation. It only added allowSelectors(false) to a few request classes and created a ResolvedExpression record, missing the entire selector resolution logic in IndexNameExpressionResolver, WildcardExpressionResolver changes, test updates, transport version changes, and all the core functionality for parsing and processing selectors. The ResolvedExpression record is unsolicited documentation-heavy code that doesn't match the ground truth's SelectorResolver approach. The changes made are correct in isolation but represent less than 5% of the required implementation.",
      "llm_rating": 0.12,
      "llm_summary": "Added allowSelectors(false) to five request classes and created a ResolvedExpression record with selector parsing logic, but missed the entire core selector resolution implementation in IndexNameExpressionResolver.WildcardExpressionResolver, all test updates, transport version changes, and the SelectorResolver utility class from ground truth.",
      "errors": []
    }
  ],
  "comparative_analysis": {
    "summary": "auggie:sonnet4.5 and factory:claude-sonnet-4-5-20250929 both attempted to implement the selector syntax feature by adding allowSelectors flags and modifying IndicesOptions, while claude-code:claude-sonnet-4-5 produced no changes at all. auggie:sonnet4.5 provided the most comprehensive implementation with extensive changes to index resolution logic, selector parsing, and test updates, whereas factory:claude-sonnet-4-5-20250929 only partially implemented the gatekeeper mechanism without the core selector parsing functionality.",
    "best_agent": "auggie:sonnet4.5",
    "best_agent_reasoning": "auggie:sonnet4.5 demonstrated the most complete understanding of the task by implementing both the allowSelectors gatekeeper flag and the actual selector parsing logic (::data, ::failures, ::*) in IndexNameExpressionResolver. It also updated the test files to use the new selector syntax instead of query parameters, which aligns with the ground truth changes. While it received negative scores for adding unsolicited documentation and some implementation differences from the expected approach, it was the only agent that actually attempted to implement the full feature including selector parsing and test updates.",
    "approach_differences": "auggie:sonnet4.5 took a comprehensive approach by modifying IndicesOptions to add allowSelectors, implementing selector parsing logic in IndexNameExpressionResolver with new methods like parseSelector and resolveWithSelector, and updating test files to use the new syntax. factory:claude-sonnet-4-5-20250929 focused narrowly on adding the allowSelectors flag to various IndicesOptions configurations and creating a strictExpandHiddenNoSelectors variant, but did not implement any selector parsing logic or update tests. claude-code:claude-sonnet-4-5 made no changes whatsoever, suggesting it either misunderstood the task or encountered an error preventing any output.",
    "ranking": [
      "auggie:sonnet4.5",
      "factory:claude-sonnet-4-5-20250929",
      "claude-code:claude-sonnet-4-5"
    ]
  },
  "timestamp": "2025-11-06T22:07:31.237557",
  "analysis_run_id": "80a67a32"
}