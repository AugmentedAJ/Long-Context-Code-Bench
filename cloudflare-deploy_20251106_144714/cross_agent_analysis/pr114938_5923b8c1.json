{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 114938,
  "base_commit": "54e3bdb61708ff64337c16964bdc667126fb83f0",
  "head_commit": "1f5e3741788b77e5b90efc651f1066b1ba00e75b",
  "task_instructions": "You are working on a codebase. Your task is to make the necessary code changes to accomplish the following:\n\n[8.16] Make ESQL EnrichPolicyResolver try to do proper connection before sending requests (#114870)\n\n# Backport\n\nThis will backport the following commits from `main` to `8.16`:\n - [Make ESQL EnrichPolicyResolver try to do proper connection before sending requests (#114870)](https://github.com/elastic/elasticsearch/pull/114870)\n\n<!--- Backport version: 9.6.0 -->\n\n### Questions ?\nPlease refer to the [Backport tool documentation](https://github.com/sorenlouv/backport)\n\nPlease make all necessary code changes to complete this task.",
  "ground_truth_diff": "diff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java\nindex 447df09942ca..e67c406e2692 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java\n@@ -25,6 +25,7 @@ import org.elasticsearch.core.Tuple;\n import org.elasticsearch.tasks.Task;\n import org.elasticsearch.threadpool.ThreadPool;\n import org.elasticsearch.transport.RemoteClusterAware;\n+import org.elasticsearch.transport.RemoteClusterService;\n import org.elasticsearch.transport.Transport;\n import org.elasticsearch.transport.TransportChannel;\n import org.elasticsearch.transport.TransportRequest;\n@@ -72,12 +73,14 @@ public class EnrichPolicyResolver {\n     private final IndexResolver indexResolver;\n     private final TransportService transportService;\n     private final ThreadPool threadPool;\n+    private final RemoteClusterService remoteClusterService;\n \n     public EnrichPolicyResolver(ClusterService clusterService, TransportService transportService, IndexResolver indexResolver) {\n         this.clusterService = clusterService;\n         this.transportService = transportService;\n         this.indexResolver = indexResolver;\n         this.threadPool = transportService.getThreadPool();\n+        this.remoteClusterService = transportService.getRemoteClusterService();\n         transportService.registerRequestHandler(\n             RESOLVE_ACTION_NAME,\n             threadPool.executor(ThreadPool.Names.SEARCH),\n@@ -257,22 +260,21 @@ public class EnrichPolicyResolver {\n             // remote clusters\n             if (remotePolicies.isEmpty() == false) {\n                 for (String cluster : remoteClusters) {\n-                    final Transport.Connection connection;\n-                    try {\n-                        connection = getRemoteConnection(cluster);\n-                    } catch (Exception e) {\n-                        refs.acquire().onFailure(e);\n-                        return;\n-                    }\n-                    transportService.sendRequest(\n-                        connection,\n-                        RESOLVE_ACTION_NAME,\n-                        new LookupRequest(cluster, remotePolicies),\n-                        TransportRequestOptions.EMPTY,\n-                        new ActionListenerResponseHandler<>(\n-                            refs.acquire(resp -> lookupResponses.put(cluster, resp)),\n-                            LookupResponse::new,\n-                            threadPool.executor(ThreadPool.Names.SEARCH)\n+                    ActionListener<LookupResponse> lookupListener = refs.acquire(resp -> lookupResponses.put(cluster, resp));\n+                    getRemoteConnection(\n+                        cluster,\n+                        lookupListener.delegateFailureAndWrap(\n+                            (delegate, connection) -> transportService.sendRequest(\n+                                connection,\n+                                RESOLVE_ACTION_NAME,\n+                                new LookupRequest(cluster, remotePolicies),\n+                                TransportRequestOptions.EMPTY,\n+                                new ActionListenerResponseHandler<>(\n+                                    delegate,\n+                                    LookupResponse::new,\n+                                    threadPool.executor(ThreadPool.Names.SEARCH)\n+                                )\n+                            )\n                         )\n                     );\n                 }\n@@ -389,13 +391,16 @@ public class EnrichPolicyResolver {\n         return metadata == null ? Map.of() : metadata.getPolicies();\n     }\n \n-    protected Transport.Connection getRemoteConnection(String cluster) {\n-        return transportService.getRemoteClusterService().getConnection(cluster);\n+    protected void getRemoteConnection(String cluster, ActionListener<Transport.Connection> listener) {\n+        remoteClusterService.maybeEnsureConnectedAndGetConnection(\n+            cluster,\n+            remoteClusterService.isSkipUnavailable(cluster) == false,\n+            listener\n+        );\n     }\n \n     public Map<String, List<String>> groupIndicesPerCluster(String[] indices) {\n-        return transportService.getRemoteClusterService()\n-            .groupIndices(SearchRequest.DEFAULT_INDICES_OPTIONS, indices)\n+        return remoteClusterService.groupIndices(SearchRequest.DEFAULT_INDICES_OPTIONS, indices)\n             .entrySet()\n             .stream()\n             .collect(Collectors.toMap(Map.Entry::getKey, e -> Arrays.asList(e.getValue().indices())));\ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolverTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolverTests.java\nindex 05a7486a1806..39170f1a305d 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolverTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolverTests.java\n@@ -446,9 +446,9 @@ public class EnrichPolicyResolverTests extends ESTestCase {\n         }\n \n         @Override\n-        protected Transport.Connection getRemoteConnection(String remoteCluster) {\n+        protected void getRemoteConnection(String remoteCluster, ActionListener<Transport.Connection> listener) {\n             assertThat(\"Must only called on the local cluster\", cluster, equalTo(LOCAL_CLUSTER_GROUP_KEY));\n-            return transports.get(\"\").getConnection(transports.get(remoteCluster).getLocalNode());\n+            listener.onResponse(transports.get(\"\").getConnection(transports.get(remoteCluster).getLocalNode()));\n         }\n \n         static ClusterService mockClusterService(Map<String, EnrichPolicy> policies) {",
  "judge_mode": "comparative",
  "judge_model": "openai/claude-sonnet-4-5-20250929",
  "test_label": "v0",
  "agent_results": [
    {
      "runner": "auggie",
      "model": "sonnet4.5",
      "edit_run_id": "a9463435",
      "status": "success",
      "elapsed_ms": 725076,
      "patch_unified": "diff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java\nindex 447df099..50c1d841 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java\n@@ -257,24 +257,19 @@ public class EnrichPolicyResolver {\n             // remote clusters\n             if (remotePolicies.isEmpty() == false) {\n                 for (String cluster : remoteClusters) {\n-                    final Transport.Connection connection;\n-                    try {\n-                        connection = getRemoteConnection(cluster);\n-                    } catch (Exception e) {\n-                        refs.acquire().onFailure(e);\n-                        return;\n-                    }\n-                    transportService.sendRequest(\n-                        connection,\n-                        RESOLVE_ACTION_NAME,\n-                        new LookupRequest(cluster, remotePolicies),\n-                        TransportRequestOptions.EMPTY,\n-                        new ActionListenerResponseHandler<>(\n-                            refs.acquire(resp -> lookupResponses.put(cluster, resp)),\n-                            LookupResponse::new,\n-                            threadPool.executor(ThreadPool.Names.SEARCH)\n-                        )\n-                    );\n+                    getRemoteConnection(cluster, refs.acquire(connection -> {\n+                        transportService.sendRequest(\n+                            connection,\n+                            RESOLVE_ACTION_NAME,\n+                            new LookupRequest(cluster, remotePolicies),\n+                            TransportRequestOptions.EMPTY,\n+                            new ActionListenerResponseHandler<>(\n+                                refs.acquire(resp -> lookupResponses.put(cluster, resp)),\n+                                LookupResponse::new,\n+                                threadPool.executor(ThreadPool.Names.SEARCH)\n+                            )\n+                        );\n+                    }));\n                 }\n             }\n             // local cluster\n@@ -389,8 +384,13 @@ public class EnrichPolicyResolver {\n         return metadata == null ? Map.of() : metadata.getPolicies();\n     }\n \n-    protected Transport.Connection getRemoteConnection(String cluster) {\n-        return transportService.getRemoteClusterService().getConnection(cluster);\n+    protected void getRemoteConnection(String cluster, ActionListener<Transport.Connection> listener) {\n+        transportService.getRemoteClusterService()\n+            .maybeEnsureConnectedAndGetConnection(\n+                cluster,\n+                transportService.getRemoteClusterService().isSkipUnavailable(cluster) == false,\n+                listener\n+            );\n     }\n \n     public Map<String, List<String>> groupIndicesPerCluster(String[] indices) {\ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolverTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolverTests.java\nindex 05a7486a..8885a7fc 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolverTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolverTests.java\n@@ -446,9 +446,12 @@ public class EnrichPolicyResolverTests extends ESTestCase {\n         }\n \n         @Override\n-        protected Transport.Connection getRemoteConnection(String remoteCluster) {\n+        protected void getRemoteConnection(String remoteCluster, ActionListener<Transport.Connection> listener) {\n             assertThat(\"Must only called on the local cluster\", cluster, equalTo(LOCAL_CLUSTER_GROUP_KEY));\n-            return transports.get(\"\").getConnection(transports.get(remoteCluster).getLocalNode());\n+            ActionListener.completeWith(\n+                listener,\n+                () -> transports.get(\"\").getConnection(transports.get(remoteCluster).getLocalNode())\n+            );\n         }\n \n         static ClusterService mockClusterService(Map<String, EnrichPolicy> policies) {",
      "scores": {
        "correctness": 0.7,
        "completeness": 0.5,
        "code_reuse": 0.8,
        "best_practices": 0.6,
        "unsolicited_docs": 1.0
      },
      "aggregate": 0.72,
      "rationale": "The agent correctly converted getRemoteConnection to async with ActionListener and updated the call site to use the async pattern. However, it missed two important changes: (1) adding RemoteClusterService as a field and initializing it in the constructor, instead calling transportService.getRemoteClusterService() repeatedly, and (2) using delegateFailureAndWrap pattern at the call site instead of a simpler callback. In the test, it used ActionListener.completeWith instead of the simpler listener.onResponse. The core functionality is correct but the implementation differs from ground truth in efficiency and pattern usage.",
      "llm_rating": 0.64,
      "llm_summary": "Converted getRemoteConnection to async ActionListener pattern and updated call sites in EnrichPolicyResolver and tests, but missed adding RemoteClusterService field and used ActionListener.completeWith instead of direct listener.onResponse in tests.",
      "errors": []
    },
    {
      "runner": "claude-code",
      "model": "claude-sonnet-4-5",
      "edit_run_id": "c7a3f90a",
      "status": "success",
      "elapsed_ms": 144313,
      "patch_unified": "diff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java\nindex 447df099..6b109368 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java\n@@ -262,7 +262,7 @@ public class EnrichPolicyResolver {\n                         connection = getRemoteConnection(cluster);\n                     } catch (Exception e) {\n                         refs.acquire().onFailure(e);\n-                        return;\n+                        continue;\n                     }\n                     transportService.sendRequest(\n                         connection,",
      "scores": {
        "correctness": -0.9,
        "completeness": -0.95,
        "code_reuse": 0.0,
        "best_practices": -0.8,
        "unsolicited_docs": 1.0
      },
      "aggregate": -0.33000000000000007,
      "rationale": "The agent made a trivial change (replacing 'return' with 'continue' in an exception handler) that completely misses the actual requirements. The ground truth implements a significant refactoring: (1) adds RemoteClusterService field, (2) changes getRemoteConnection from synchronous to asynchronous with ActionListener callback, (3) refactors the remote cluster request sending to use the async connection pattern with proper error handling, and (4) updates test mocks accordingly. The agent's change is not only incomplete but also incorrect - changing 'return' to 'continue' in the exception handler would cause the code to proceed with a null connection, likely causing NullPointerException. This demonstrates a fundamental misunderstanding of the task, which was to make the resolver establish proper connections before sending requests using async patterns.",
      "llm_rating": 0.02,
      "llm_summary": "Changed exception handler from 'return' to 'continue' in EnrichPolicyResolver instead of implementing the required async connection pattern with RemoteClusterService field, getRemoteConnection callback refactoring, and ActionListener-based request sending.",
      "errors": []
    },
    {
      "runner": "factory",
      "model": "claude-sonnet-4-5-20250929",
      "edit_run_id": "074538b9",
      "status": "success",
      "elapsed_ms": 224526,
      "patch_unified": "diff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java\nindex 447df099..e67c406e 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java\n@@ -25,6 +25,7 @@ import org.elasticsearch.core.Tuple;\n import org.elasticsearch.tasks.Task;\n import org.elasticsearch.threadpool.ThreadPool;\n import org.elasticsearch.transport.RemoteClusterAware;\n+import org.elasticsearch.transport.RemoteClusterService;\n import org.elasticsearch.transport.Transport;\n import org.elasticsearch.transport.TransportChannel;\n import org.elasticsearch.transport.TransportRequest;\n@@ -72,12 +73,14 @@ public class EnrichPolicyResolver {\n     private final IndexResolver indexResolver;\n     private final TransportService transportService;\n     private final ThreadPool threadPool;\n+    private final RemoteClusterService remoteClusterService;\n \n     public EnrichPolicyResolver(ClusterService clusterService, TransportService transportService, IndexResolver indexResolver) {\n         this.clusterService = clusterService;\n         this.transportService = transportService;\n         this.indexResolver = indexResolver;\n         this.threadPool = transportService.getThreadPool();\n+        this.remoteClusterService = transportService.getRemoteClusterService();\n         transportService.registerRequestHandler(\n             RESOLVE_ACTION_NAME,\n             threadPool.executor(ThreadPool.Names.SEARCH),\n@@ -257,22 +260,21 @@ public class EnrichPolicyResolver {\n             // remote clusters\n             if (remotePolicies.isEmpty() == false) {\n                 for (String cluster : remoteClusters) {\n-                    final Transport.Connection connection;\n-                    try {\n-                        connection = getRemoteConnection(cluster);\n-                    } catch (Exception e) {\n-                        refs.acquire().onFailure(e);\n-                        return;\n-                    }\n-                    transportService.sendRequest(\n-                        connection,\n-                        RESOLVE_ACTION_NAME,\n-                        new LookupRequest(cluster, remotePolicies),\n-                        TransportRequestOptions.EMPTY,\n-                        new ActionListenerResponseHandler<>(\n-                            refs.acquire(resp -> lookupResponses.put(cluster, resp)),\n-                            LookupResponse::new,\n-                            threadPool.executor(ThreadPool.Names.SEARCH)\n+                    ActionListener<LookupResponse> lookupListener = refs.acquire(resp -> lookupResponses.put(cluster, resp));\n+                    getRemoteConnection(\n+                        cluster,\n+                        lookupListener.delegateFailureAndWrap(\n+                            (delegate, connection) -> transportService.sendRequest(\n+                                connection,\n+                                RESOLVE_ACTION_NAME,\n+                                new LookupRequest(cluster, remotePolicies),\n+                                TransportRequestOptions.EMPTY,\n+                                new ActionListenerResponseHandler<>(\n+                                    delegate,\n+                                    LookupResponse::new,\n+                                    threadPool.executor(ThreadPool.Names.SEARCH)\n+                                )\n+                            )\n                         )\n                     );\n                 }\n@@ -389,13 +391,16 @@ public class EnrichPolicyResolver {\n         return metadata == null ? Map.of() : metadata.getPolicies();\n     }\n \n-    protected Transport.Connection getRemoteConnection(String cluster) {\n-        return transportService.getRemoteClusterService().getConnection(cluster);\n+    protected void getRemoteConnection(String cluster, ActionListener<Transport.Connection> listener) {\n+        remoteClusterService.maybeEnsureConnectedAndGetConnection(\n+            cluster,\n+            remoteClusterService.isSkipUnavailable(cluster) == false,\n+            listener\n+        );\n     }\n \n     public Map<String, List<String>> groupIndicesPerCluster(String[] indices) {\n-        return transportService.getRemoteClusterService()\n-            .groupIndices(SearchRequest.DEFAULT_INDICES_OPTIONS, indices)\n+        return remoteClusterService.groupIndices(SearchRequest.DEFAULT_INDICES_OPTIONS, indices)\n             .entrySet()\n             .stream()\n             .collect(Collectors.toMap(Map.Entry::getKey, e -> Arrays.asList(e.getValue().indices())));\ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolverTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolverTests.java\nindex 05a7486a..39170f1a 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolverTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolverTests.java\n@@ -446,9 +446,9 @@ public class EnrichPolicyResolverTests extends ESTestCase {\n         }\n \n         @Override\n-        protected Transport.Connection getRemoteConnection(String remoteCluster) {\n+        protected void getRemoteConnection(String remoteCluster, ActionListener<Transport.Connection> listener) {\n             assertThat(\"Must only called on the local cluster\", cluster, equalTo(LOCAL_CLUSTER_GROUP_KEY));\n-            return transports.get(\"\").getConnection(transports.get(remoteCluster).getLocalNode());\n+            listener.onResponse(transports.get(\"\").getConnection(transports.get(remoteCluster).getLocalNode()));\n         }\n \n         static ClusterService mockClusterService(Map<String, EnrichPolicy> policies) {",
      "scores": {
        "correctness": 1.0,
        "completeness": 1.0,
        "code_reuse": 1.0,
        "best_practices": 1.0,
        "unsolicited_docs": 1.0
      },
      "aggregate": 1.0,
      "rationale": "The agent's diff is identical to the ground truth diff. All changes are present and correct: (1) Added RemoteClusterService import and field, (2) Changed getRemoteConnection from synchronous to asynchronous with ActionListener parameter, (3) Refactored remote cluster connection handling to use maybeEnsureConnectedAndGetConnection with proper error handling via delegateFailureAndWrap, (4) Updated groupIndicesPerCluster to use the remoteClusterService field, and (5) Modified the test override to match the new async signature. The implementation correctly transforms the synchronous connection retrieval into an asynchronous pattern with proper listener chaining, which is the core intent of the change.",
      "llm_rating": 1.0,
      "llm_summary": "Agent perfectly replicated all changes by converting getRemoteConnection to async with ActionListener, adding RemoteClusterService field, refactoring remote cluster connection handling with maybeEnsureConnectedAndGetConnection, and updating both EnrichPolicyResolver and EnrichPolicyResolverTests to match the ground truth exactly.",
      "errors": []
    }
  ],
  "comparative_analysis": {
    "summary": "factory:claude-sonnet-4-5-20250929 produced a perfect implementation matching the ground truth exactly, including all necessary changes to both production and test code. auggie:sonnet4.5 implemented the core async connection logic correctly but missed the RemoteClusterService field optimization and had a minor listener handling difference. claude-code:claude-sonnet-4-5 completely misunderstood the task, making only a trivial change from 'return' to 'continue' that doesn't address the connection handling requirement.",
    "best_agent": "factory:claude-sonnet-4-5-20250929",
    "best_agent_reasoning": "factory:claude-sonnet-4-5-20250929 achieved a perfect score by implementing all required changes exactly as specified in the ground truth: converting getRemoteConnection to async with ActionListener, using maybeEnsureConnectedAndGetConnection for proper connection establishment, adding the RemoteClusterService field for efficiency, properly handling the listener delegation with delegateFailureAndWrap, and updating both production and test code completely.",
    "approach_differences": "factory:claude-sonnet-4-5-20250929 took a comprehensive approach by adding a RemoteClusterService field to avoid repeated calls to getRemoteClusterService() and used delegateFailureAndWrap for proper error propagation. auggie:sonnet4.5 implemented the async connection pattern correctly but called getRemoteClusterService() multiple times and used a simpler listener chaining approach without delegateFailureAndWrap. claude-code:claude-sonnet-4-5 fundamentally misunderstood the requirement, making only a control flow change (return to continue) instead of implementing the async connection establishment pattern.",
    "ranking": [
      "factory:claude-sonnet-4-5-20250929",
      "auggie:sonnet4.5",
      "claude-code:claude-sonnet-4-5"
    ]
  },
  "timestamp": "2025-11-06T21:57:11.549713",
  "analysis_run_id": "5923b8c1"
}