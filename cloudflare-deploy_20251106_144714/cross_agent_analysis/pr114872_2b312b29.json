{
  "repo_url": "https://github.com/elastic/elasticsearch.git",
  "pr_number": 114872,
  "base_commit": "52587d6abfc8768b5930fe313c6241d9b9f25334",
  "head_commit": "664632884ef50b0ef38313ef7fea044ee61b715b",
  "task_instructions": "You are working on a codebase. Your task is to make the necessary code changes to accomplish the following:\n\n[8.x] Download IPinfo ip location databases (#114847)\n\nBackport of #114847\n\nPlease make all necessary code changes to complete this task.",
  "ground_truth_diff": "diff --git a/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java b/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\nindex 16fedd9d37dc..3a1efabb38ec 100644\n--- a/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\n+++ b/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\n@@ -23,6 +23,7 @@ import org.elasticsearch.action.index.IndexRequest;\n import org.elasticsearch.action.ingest.PutPipelineRequest;\n import org.elasticsearch.action.search.SearchRequest;\n import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.bytes.BytesReference;\n import org.elasticsearch.common.settings.MockSecureSettings;\n import org.elasticsearch.common.settings.Settings;\n@@ -44,19 +45,25 @@ import org.junit.ClassRule;\n \n import java.io.IOException;\n import java.util.Collection;\n+import java.util.List;\n import java.util.Map;\n \n import static org.elasticsearch.ingest.EnterpriseGeoIpTask.ENTERPRISE_GEOIP_DOWNLOADER;\n+import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_TOKEN_SETTING;\n import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING;\n import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n import static org.hamcrest.Matchers.equalTo;\n \n public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n \n-    private static final String DATABASE_TYPE = \"GeoIP2-City\";\n+    private static final String MAXMIND_DATABASE_TYPE = \"GeoIP2-City\";\n+    private static final String IPINFO_DATABASE_TYPE = \"asn\";\n \n     @ClassRule\n-    public static final EnterpriseGeoIpHttpFixture fixture = new EnterpriseGeoIpHttpFixture(DATABASE_TYPE);\n+    public static final EnterpriseGeoIpHttpFixture fixture = new EnterpriseGeoIpHttpFixture(\n+        List.of(MAXMIND_DATABASE_TYPE),\n+        List.of(IPINFO_DATABASE_TYPE)\n+    );\n \n     protected String getEndpoint() {\n         return fixture.getAddress();\n@@ -66,6 +73,7 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n     protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n         MockSecureSettings secureSettings = new MockSecureSettings();\n         secureSettings.setString(MAXMIND_LICENSE_KEY_SETTING.getKey(), \"license_key\");\n+        secureSettings.setString(IPINFO_TOKEN_SETTING.getKey(), \"token\");\n         Settings.Builder builder = Settings.builder();\n         builder.setSecureSettings(secureSettings)\n             .put(super.nodeSettings(nodeOrdinal, otherSettings))\n@@ -92,22 +100,27 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n          * Note that the \"enterprise database\" is actually just a geolite database being loaded by the GeoIpHttpFixture.\n          */\n         EnterpriseGeoIpDownloader.DEFAULT_MAXMIND_ENDPOINT = getEndpoint();\n-        final String pipelineName = \"enterprise_geoip_pipeline\";\n+        EnterpriseGeoIpDownloader.DEFAULT_IPINFO_ENDPOINT = getEndpoint();\n         final String indexName = \"enterprise_geoip_test_index\";\n+        final String geoipPipelineName = \"enterprise_geoip_pipeline\";\n+        final String iplocationPipelineName = \"enterprise_iplocation_pipeline\";\n         final String sourceField = \"ip\";\n-        final String targetField = \"ip-city\";\n+        final String targetField = \"ip-result\";\n \n         startEnterpriseGeoIpDownloaderTask();\n-        configureDatabase(DATABASE_TYPE);\n-        createGeoIpPipeline(pipelineName, DATABASE_TYPE, sourceField, targetField);\n+        configureMaxmindDatabase(MAXMIND_DATABASE_TYPE);\n+        configureIpinfoDatabase(IPINFO_DATABASE_TYPE);\n+        waitAround();\n+        createPipeline(geoipPipelineName, \"geoip\", MAXMIND_DATABASE_TYPE, sourceField, targetField);\n+        createPipeline(iplocationPipelineName, \"ip_location\", IPINFO_DATABASE_TYPE, sourceField, targetField);\n \n+        /*\n+         * We know that the databases index has been populated (because we waited around, :wink:), but we don't know for sure that\n+         * the databases have been pulled down and made available on all nodes. So we run these ingest-and-check steps in assertBusy blocks.\n+         */\n         assertBusy(() -> {\n-            /*\n-             * We know that the .geoip_databases index has been populated, but we don't know for sure that the database has been pulled\n-             * down and made available on all nodes. So we run this ingest-and-check step in an assertBusy.\n-             */\n             logger.info(\"Ingesting a test document\");\n-            String documentId = ingestDocument(indexName, pipelineName, sourceField);\n+            String documentId = ingestDocument(indexName, geoipPipelineName, sourceField, \"89.160.20.128\");\n             GetResponse getResponse = client().get(new GetRequest(indexName, documentId)).actionGet();\n             Map<String, Object> returnedSource = getResponse.getSource();\n             assertNotNull(returnedSource);\n@@ -115,6 +128,16 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n             assertNotNull(targetFieldValue);\n             assertThat(((Map<String, Object>) targetFieldValue).get(\"organization_name\"), equalTo(\"Bredband2 AB\"));\n         });\n+        assertBusy(() -> {\n+            logger.info(\"Ingesting another test document\");\n+            String documentId = ingestDocument(indexName, iplocationPipelineName, sourceField, \"12.10.66.1\");\n+            GetResponse getResponse = client().get(new GetRequest(indexName, documentId)).actionGet();\n+            Map<String, Object> returnedSource = getResponse.getSource();\n+            assertNotNull(returnedSource);\n+            Object targetFieldValue = returnedSource.get(targetField);\n+            assertNotNull(targetFieldValue);\n+            assertThat(((Map<String, Object>) targetFieldValue).get(\"organization_name\"), equalTo(\"OAKLAWN JOCKEY CLUB, INC.\"));\n+        });\n     }\n \n     private void startEnterpriseGeoIpDownloaderTask() {\n@@ -133,29 +156,46 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n         );\n     }\n \n-    private void configureDatabase(String databaseType) throws Exception {\n+    private void configureMaxmindDatabase(String databaseType) {\n         admin().cluster()\n             .execute(\n                 PutDatabaseConfigurationAction.INSTANCE,\n                 new PutDatabaseConfigurationAction.Request(\n                     TimeValue.MAX_VALUE,\n                     TimeValue.MAX_VALUE,\n-                    new DatabaseConfiguration(\"test\", databaseType, new DatabaseConfiguration.Maxmind(\"test_account\"))\n+                    new DatabaseConfiguration(\"test-1\", databaseType, new DatabaseConfiguration.Maxmind(\"test_account\"))\n                 )\n             )\n             .actionGet();\n+    }\n+\n+    private void configureIpinfoDatabase(String databaseType) {\n+        admin().cluster()\n+            .execute(\n+                PutDatabaseConfigurationAction.INSTANCE,\n+                new PutDatabaseConfigurationAction.Request(\n+                    TimeValue.MAX_VALUE,\n+                    TimeValue.MAX_VALUE,\n+                    new DatabaseConfiguration(\"test-2\", databaseType, new DatabaseConfiguration.Ipinfo())\n+                )\n+            )\n+            .actionGet();\n+    }\n+\n+    private void waitAround() throws Exception {\n         ensureGreen(GeoIpDownloader.DATABASES_INDEX);\n         assertBusy(() -> {\n             SearchResponse searchResponse = client().search(new SearchRequest(GeoIpDownloader.DATABASES_INDEX)).actionGet();\n             try {\n-                assertThat(searchResponse.getHits().getHits().length, equalTo(1));\n+                assertThat(searchResponse.getHits().getHits().length, equalTo(2));\n             } finally {\n                 searchResponse.decRef();\n             }\n         });\n     }\n \n-    private void createGeoIpPipeline(String pipelineName, String databaseType, String sourceField, String targetField) throws IOException {\n+    private void createPipeline(String pipelineName, String processorType, String databaseType, String sourceField, String targetField)\n+        throws IOException {\n         final BytesReference bytes;\n         try (XContentBuilder builder = JsonXContent.contentBuilder()) {\n             builder.startObject();\n@@ -165,7 +205,7 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n                 {\n                     builder.startObject();\n                     {\n-                        builder.startObject(\"geoip\");\n+                        builder.startObject(processorType);\n                         {\n                             builder.field(\"field\", sourceField);\n                             builder.field(\"target_field\", targetField);\n@@ -183,11 +223,11 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n         assertAcked(clusterAdmin().putPipeline(new PutPipelineRequest(pipelineName, bytes, XContentType.JSON)).actionGet());\n     }\n \n-    private String ingestDocument(String indexName, String pipelineName, String sourceField) {\n+    private String ingestDocument(String indexName, String pipelineName, String sourceField, String value) {\n         BulkRequest bulkRequest = new BulkRequest();\n-        bulkRequest.add(\n-            new IndexRequest(indexName).source(\"{\\\"\" + sourceField + \"\\\": \\\"89.160.20.128\\\"}\", XContentType.JSON).setPipeline(pipelineName)\n-        );\n+        bulkRequest.add(new IndexRequest(indexName).source(Strings.format(\"\"\"\n+            { \"%s\": \"%s\"}\n+            \"\"\", sourceField, value), XContentType.JSON).setPipeline(pipelineName));\n         BulkResponse response = client().bulk(bulkRequest).actionGet();\n         BulkItemResponse[] bulkItemResponses = response.getItems();\n         assertThat(bulkItemResponses.length, equalTo(1));\ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\nindex 3bbb0539f193..e04014ff693b 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\n@@ -23,7 +23,6 @@ import org.elasticsearch.cluster.service.ClusterService;\n import org.elasticsearch.common.CheckedSupplier;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.hash.MessageDigests;\n-import org.elasticsearch.core.Nullable;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.core.Tuple;\n import org.elasticsearch.index.query.BoolQueryBuilder;\n@@ -39,6 +38,8 @@ import org.elasticsearch.persistent.PersistentTasksCustomMetadata.PersistentTask\n import org.elasticsearch.tasks.TaskId;\n import org.elasticsearch.threadpool.Scheduler;\n import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xcontent.XContentParser;\n+import org.elasticsearch.xcontent.XContentParserConfiguration;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.io.Closeable;\n@@ -57,6 +58,7 @@ import java.util.function.Supplier;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n+import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_SETTINGS_PREFIX;\n import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_SETTINGS_PREFIX;\n \n /**\n@@ -72,6 +74,9 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n     // a sha256 checksum followed by two spaces followed by an (ignored) file name\n     private static final Pattern SHA256_CHECKSUM_PATTERN = Pattern.compile(\"(\\\\w{64})\\\\s\\\\s(.*)\");\n \n+    // an md5 checksum\n+    private static final Pattern MD5_CHECKSUM_PATTERN = Pattern.compile(\"(\\\\w{32})\");\n+\n     // for overriding in tests\n     static String DEFAULT_MAXMIND_ENDPOINT = System.getProperty(\n         MAXMIND_SETTINGS_PREFIX + \"endpoint.default\", //\n@@ -80,6 +85,14 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n     // n.b. a future enhancement might be to allow for a MAXMIND_ENDPOINT_SETTING, but\n     // at the moment this is an unsupported system property for use in tests (only)\n \n+    // for overriding in tests\n+    static String DEFAULT_IPINFO_ENDPOINT = System.getProperty(\n+        IPINFO_SETTINGS_PREFIX + \"endpoint.default\", //\n+        \"https://ipinfo.io/data\"\n+    );\n+    // n.b. a future enhancement might be to allow for an IPINFO_ENDPOINT_SETTING, but\n+    // at the moment this is an unsupported system property for use in tests (only)\n+\n     static final String DATABASES_INDEX = \".geoip_databases\";\n     static final int MAX_CHUNK_SIZE = 1024 * 1024;\n \n@@ -444,16 +457,15 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n         }\n     }\n \n-    @Nullable\n     private ProviderDownload downloaderFor(DatabaseConfiguration database) {\n-        if (database.provider() instanceof DatabaseConfiguration.Maxmind) {\n-            return new MaxmindDownload(database.name(), (DatabaseConfiguration.Maxmind) database.provider());\n-        } else if (database.provider() instanceof DatabaseConfiguration.Ipinfo) {\n-            // as a temporary implementation detail, null here means 'not actually supported *just yet*'\n-            return null;\n+        if (database.provider() instanceof DatabaseConfiguration.Maxmind maxmind) {\n+            return new MaxmindDownload(database.name(), maxmind);\n+        } else if (database.provider() instanceof DatabaseConfiguration.Ipinfo ipinfo) {\n+            return new IpinfoDownload(database.name(), ipinfo);\n         } else {\n-            assert false : \"Attempted to use database downloader with unsupported provider type [\" + database.provider().getClass() + \"]\";\n-            return null;\n+            throw new IllegalArgumentException(\n+                Strings.format(\"Unexpected provider [%s] for configuration [%s]\", database.provider().getClass(), database.id())\n+            );\n         }\n     }\n \n@@ -488,7 +500,7 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n \n         @Override\n         public boolean validCredentials() {\n-            return auth.get() != null;\n+            return auth != null && auth.get() != null;\n         }\n \n         @Override\n@@ -529,7 +541,101 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n \n         @Override\n         public void close() throws IOException {\n-            auth.close();\n+            if (auth != null) auth.close();\n+        }\n+    }\n+\n+    class IpinfoDownload implements ProviderDownload {\n+\n+        final String name;\n+        final DatabaseConfiguration.Ipinfo ipinfo;\n+        HttpClient.PasswordAuthenticationHolder auth;\n+\n+        IpinfoDownload(String name, DatabaseConfiguration.Ipinfo ipinfo) {\n+            this.name = name;\n+            this.ipinfo = ipinfo;\n+            this.auth = buildCredentials();\n+        }\n+\n+        @Override\n+        public HttpClient.PasswordAuthenticationHolder buildCredentials() {\n+            final char[] tokenChars = tokenProvider.apply(\"ipinfo\");\n+\n+            // if the token is missing or empty, return null as 'no auth'\n+            if (tokenChars == null || tokenChars.length == 0) {\n+                return null;\n+            }\n+\n+            // ipinfo uses the token as the username component of basic auth, see https://ipinfo.io/developers#authentication\n+            return new HttpClient.PasswordAuthenticationHolder(new String(tokenChars), new char[] {});\n+        }\n+\n+        @Override\n+        public boolean validCredentials() {\n+            return auth != null && auth.get() != null;\n+        }\n+\n+        private static final Set<String> FREE_DATABASES = Set.of(\"asn\", \"country\", \"country_asn\");\n+\n+        @Override\n+        public String url(String suffix) {\n+            // note: the 'free' databases are in the sub-path 'free/' in terms of the download endpoint\n+            final String internalName;\n+            if (FREE_DATABASES.contains(name)) {\n+                internalName = \"free/\" + name;\n+            } else {\n+                internalName = name;\n+            }\n+\n+            // reminder, we're passing the ipinfo token as the username part of http basic auth,\n+            // see https://ipinfo.io/developers#authentication\n+\n+            String endpointPattern = DEFAULT_IPINFO_ENDPOINT;\n+            if (endpointPattern.contains(\"%\")) {\n+                throw new IllegalArgumentException(\"Invalid endpoint [\" + endpointPattern + \"]\");\n+            }\n+            if (endpointPattern.endsWith(\"/\") == false) {\n+                endpointPattern += \"/\";\n+            }\n+            endpointPattern += \"%s.%s\";\n+\n+            // at this point the pattern looks like this (in the default case):\n+            // https://ipinfo.io/data/%s.%s\n+            // also see https://ipinfo.io/developers/database-download,\n+            // and https://ipinfo.io/developers/database-filename-reference for more\n+\n+            return Strings.format(endpointPattern, internalName, suffix);\n+        }\n+\n+        @Override\n+        public Checksum checksum() throws IOException {\n+            final String checksumJsonUrl = this.url(\"mmdb/checksums\"); // a minor abuse of the idea of a 'suffix', :shrug:\n+            byte[] data = httpClient.getBytes(auth.get(), checksumJsonUrl); // this throws if the auth is bad\n+            Map<String, Object> checksums;\n+            try (XContentParser parser = XContentType.JSON.xContent().createParser(XContentParserConfiguration.EMPTY, data)) {\n+                checksums = parser.map();\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            String md5 = ((Map<String, String>) checksums.get(\"checksums\")).get(\"md5\");\n+            logger.trace(\"checksum was [{}]\", md5);\n+\n+            var matcher = MD5_CHECKSUM_PATTERN.matcher(md5);\n+            boolean match = matcher.matches();\n+            if (match == false) {\n+                throw new RuntimeException(\"Unexpected md5 response from [\" + checksumJsonUrl + \"]\");\n+            }\n+            return Checksum.md5(md5);\n+        }\n+\n+        @Override\n+        public CheckedSupplier<InputStream, IOException> download() {\n+            final String mmdbUrl = this.url(\"mmdb\");\n+            return () -> httpClient.get(auth.get(), mmdbUrl);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (auth != null) auth.close();\n         }\n     }\n \ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\nindex 5214c0e4a6a5..ae9bb109a3bf 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\n@@ -54,11 +54,15 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n \n     static final String MAXMIND_SETTINGS_PREFIX = \"ingest.geoip.downloader.maxmind.\";\n \n+    static final String IPINFO_SETTINGS_PREFIX = \"ingest.ip_location.downloader.ipinfo.\";\n+\n     public static final Setting<SecureString> MAXMIND_LICENSE_KEY_SETTING = SecureSetting.secureString(\n         MAXMIND_SETTINGS_PREFIX + \"license_key\",\n         null\n     );\n \n+    public static final Setting<SecureString> IPINFO_TOKEN_SETTING = SecureSetting.secureString(IPINFO_SETTINGS_PREFIX + \"token\", null);\n+\n     private final Client client;\n     private final HttpClient httpClient;\n     private final ClusterService clusterService;\n@@ -106,6 +110,10 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n             if (cachedSecureSettings.getSettingNames().contains(MAXMIND_LICENSE_KEY_SETTING.getKey())) {\n                 token = cachedSecureSettings.getString(MAXMIND_LICENSE_KEY_SETTING.getKey()).getChars();\n             }\n+        } else if (type.equals(\"ipinfo\")) {\n+            if (cachedSecureSettings.getSettingNames().contains(IPINFO_TOKEN_SETTING.getKey())) {\n+                token = cachedSecureSettings.getString(IPINFO_TOKEN_SETTING.getKey()).getChars();\n+            }\n         }\n         return token;\n     }\n@@ -166,7 +174,7 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n         // `SecureSettings` are available here! cache them as they will be needed\n         // whenever dynamic cluster settings change and we have to rebuild the accounts\n         try {\n-            this.cachedSecureSettings = extractSecureSettings(settings, List.of(MAXMIND_LICENSE_KEY_SETTING));\n+            this.cachedSecureSettings = extractSecureSettings(settings, List.of(MAXMIND_LICENSE_KEY_SETTING, IPINFO_TOKEN_SETTING));\n         } catch (GeneralSecurityException e) {\n             // rethrow as a runtime exception, there's logging higher up the call chain around ReloadablePlugin\n             throw new ElasticsearchException(\"Exception while reloading enterprise geoip download task executor\", e);\ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\nindex cc0bec583483..3107f0bed55e 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\n@@ -112,7 +112,8 @@ public class IngestGeoIpPlugin extends Plugin\n             GeoIpDownloaderTaskExecutor.ENABLED_SETTING,\n             GeoIpDownloader.ENDPOINT_SETTING,\n             GeoIpDownloaderTaskExecutor.POLL_INTERVAL_SETTING,\n-            EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING\n+            EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING,\n+            EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_TOKEN_SETTING\n         );\n     }\n \ndiff --git a/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java b/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\nindex 88c37409713a..e1cd127be9c8 100644\n--- a/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\n+++ b/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\n@@ -488,6 +488,36 @@ public class EnterpriseGeoIpDownloaderTests extends ESTestCase {\n         }\n     }\n \n+    public void testIpinfoUrls() {\n+        // a 'free' database like 'asn' has 'free/' in the url (automatically)\n+        final EnterpriseGeoIpDownloader.IpinfoDownload download = geoIpDownloader.new IpinfoDownload(\n+            \"asn\", new DatabaseConfiguration.Ipinfo()\n+        );\n+\n+        {\n+            String url = \"https://ipinfo.io/data/free/asn.mmdb\";\n+            assertThat(download.url(\"mmdb\"), equalTo(url));\n+        }\n+        {\n+            String url = \"https://ipinfo.io/data/free/asn.mmdb/checksums\";\n+            assertThat(download.url(\"mmdb/checksums\"), equalTo(url));\n+        }\n+\n+        // but a non-'free' database like 'standard_asn' does not\n+        final EnterpriseGeoIpDownloader.IpinfoDownload download2 = geoIpDownloader.new IpinfoDownload(\n+            \"standard_asn\", new DatabaseConfiguration.Ipinfo()\n+        );\n+\n+        {\n+            String url = \"https://ipinfo.io/data/standard_asn.mmdb\";\n+            assertThat(download2.url(\"mmdb\"), equalTo(url));\n+        }\n+        {\n+            String url = \"https://ipinfo.io/data/standard_asn.mmdb/checksums\";\n+            assertThat(download2.url(\"mmdb/checksums\"), equalTo(url));\n+        }\n+    }\n+\n     private static class MockClient extends NoOpClient {\n \n         private final Map<ActionType<?>, BiConsumer<? extends ActionRequest, ? extends ActionListener<?>>> handlers = new HashMap<>();\ndiff --git a/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java b/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\nindex 59205aa546cd..3f3e0c0a2557 100644\n--- a/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\n+++ b/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\n@@ -11,20 +11,18 @@ package fixture.geoip;\n \n import com.sun.net.httpserver.HttpServer;\n \n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.hash.MessageDigests;\n import org.junit.rules.ExternalResource;\n \n-import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n-import java.io.UncheckedIOException;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n import java.security.MessageDigest;\n+import java.util.List;\n+import java.util.Objects;\n \n /**\n  * This fixture is used to simulate a maxmind-provided server for downloading maxmind geoip database files from the\n@@ -32,21 +30,17 @@ import java.security.MessageDigest;\n  */\n public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n \n-    private final Path source;\n-    private final String[] databaseTypes;\n+    private final List<String> maxmindDatabaseTypes;\n+    private final List<String> ipinfoDatabaseTypes;\n     private HttpServer server;\n \n     /*\n-     * The values in databaseTypes must be in DatabaseConfiguration.MAXMIND_NAMES, and must be one of the databases copied in the\n-     * copyFiles method of thisi class.\n+     * The values in maxmindDatabaseTypes must be in DatabaseConfiguration.MAXMIND_NAMES, and the ipinfoDatabaseTypes\n+     * must be in DatabaseConfiguration.IPINFO_NAMES.\n      */\n-    public EnterpriseGeoIpHttpFixture(String... databaseTypes) {\n-        this.databaseTypes = databaseTypes;\n-        try {\n-            this.source = Files.createTempDirectory(\"source\");\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n+    public EnterpriseGeoIpHttpFixture(List<String> maxmindDatabaseTypes, List<String> ipinfoDatabaseTypes) {\n+        this.maxmindDatabaseTypes = List.copyOf(maxmindDatabaseTypes);\n+        this.ipinfoDatabaseTypes = List.copyOf(ipinfoDatabaseTypes);\n     }\n \n     public String getAddress() {\n@@ -55,7 +49,6 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n \n     @Override\n     protected void before() throws Throwable {\n-        copyFiles();\n         this.server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n \n         // for expediency reasons, it is handy to have this test fixture be able to serve the dual purpose of actually stubbing\n@@ -64,26 +57,33 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n         this.server.createContext(\"/\", exchange -> {\n             String response = \"[]\"; // an empty json array\n             exchange.sendResponseHeaders(200, response.length());\n-            try (OutputStream os = exchange.getResponseBody()) {\n-                os.write(response.getBytes(StandardCharsets.UTF_8));\n+            try (OutputStream out = exchange.getResponseBody()) {\n+                out.write(response.getBytes(StandardCharsets.UTF_8));\n             }\n         });\n \n         // register the file types for the download fixture\n-        for (String databaseType : databaseTypes) {\n-            createContextForEnterpriseDatabase(databaseType);\n+        for (String databaseType : maxmindDatabaseTypes) {\n+            createContextForMaxmindDatabase(databaseType);\n+        }\n+        for (String databaseType : ipinfoDatabaseTypes) {\n+            createContextForIpinfoDatabase(databaseType);\n         }\n \n         server.start();\n     }\n \n-    private void createContextForEnterpriseDatabase(String databaseType) {\n+    private static InputStream fixtureStream(String name) {\n+        return Objects.requireNonNull(GeoIpHttpFixture.class.getResourceAsStream(name));\n+    }\n+\n+    private void createContextForMaxmindDatabase(String databaseType) {\n         this.server.createContext(\"/\" + databaseType + \"/download\", exchange -> {\n             exchange.sendResponseHeaders(200, 0);\n             if (exchange.getRequestURI().toString().contains(\"sha256\")) {\n                 MessageDigest sha256 = MessageDigests.sha256();\n-                try (InputStream inputStream = GeoIpHttpFixture.class.getResourceAsStream(\"/geoip-fixture/\" + databaseType + \".tgz\")) {\n-                    sha256.update(inputStream.readAllBytes());\n+                try (InputStream in = fixtureStream(\"/geoip-fixture/\" + databaseType + \".tgz\")) {\n+                    sha256.update(in.readAllBytes());\n                 }\n                 exchange.getResponseBody()\n                     .write(\n@@ -93,10 +93,33 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n                     );\n             } else {\n                 try (\n-                    OutputStream outputStream = exchange.getResponseBody();\n-                    InputStream inputStream = GeoIpHttpFixture.class.getResourceAsStream(\"/geoip-fixture/\" + databaseType + \".tgz\")\n+                    OutputStream out = exchange.getResponseBody();\n+                    InputStream in = fixtureStream(\"/geoip-fixture/\" + databaseType + \".tgz\")\n+                ) {\n+                    in.transferTo(out);\n+                }\n+            }\n+            exchange.getResponseBody().close();\n+        });\n+    }\n+\n+    private void createContextForIpinfoDatabase(String databaseType) {\n+        this.server.createContext(\"/free/\" + databaseType + \".mmdb\", exchange -> {\n+            exchange.sendResponseHeaders(200, 0);\n+            if (exchange.getRequestURI().toString().contains(\"checksum\")) {\n+                MessageDigest md5 = MessageDigests.md5();\n+                try (InputStream in = fixtureStream(\"/ipinfo-fixture/ip_\" + databaseType + \"_sample.mmdb\")) {\n+                    md5.update(in.readAllBytes());\n+                }\n+                exchange.getResponseBody().write(Strings.format(\"\"\"\n+                    { \"checksums\": { \"md5\": \"%s\" } }\n+                    \"\"\", MessageDigests.toHexString(md5.digest())).getBytes(StandardCharsets.UTF_8));\n+            } else {\n+                try (\n+                    OutputStream out = exchange.getResponseBody();\n+                    InputStream in = fixtureStream(\"/ipinfo-fixture/ip_\" + databaseType + \"_sample.mmdb\")\n                 ) {\n-                    inputStream.transferTo(outputStream);\n+                    in.transferTo(out);\n                 }\n             }\n             exchange.getResponseBody().close();\n@@ -107,14 +130,4 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n     protected void after() {\n         server.stop(0);\n     }\n-\n-    private void copyFiles() throws Exception {\n-        for (String databaseType : databaseTypes) {\n-            Files.copy(\n-                GeoIpHttpFixture.class.getResourceAsStream(\"/geoip-fixture/GeoIP2-City.tgz\"),\n-                source.resolve(databaseType + \".tgz\"),\n-                StandardCopyOption.REPLACE_EXISTING\n-            );\n-        }\n-    }\n }\ndiff --git a/test/fixtures/geoip-fixture/src/main/resources/ipinfo-fixture/ip_asn_sample.mmdb b/test/fixtures/geoip-fixture/src/main/resources/ipinfo-fixture/ip_asn_sample.mmdb\nnew file mode 100644\nindex 000000000000..3e1fc49ba48a\nBinary files /dev/null and b/test/fixtures/geoip-fixture/src/main/resources/ipinfo-fixture/ip_asn_sample.mmdb differ",
  "judge_mode": "comparative",
  "judge_model": "openai/claude-sonnet-4-5-20250929",
  "test_label": "v0",
  "agent_results": [
    {
      "runner": "auggie",
      "model": "sonnet4.5",
      "edit_run_id": "a9463435",
      "status": "success",
      "elapsed_ms": 929272,
      "patch_unified": "diff --git a/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java b/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\nindex 16fedd9d..a7d4f24e 100644\n--- a/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\n+++ b/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\n@@ -44,9 +44,11 @@ import org.junit.ClassRule;\n \n import java.io.IOException;\n import java.util.Collection;\n+import java.util.List;\n import java.util.Map;\n \n import static org.elasticsearch.ingest.EnterpriseGeoIpTask.ENTERPRISE_GEOIP_DOWNLOADER;\n+import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_TOKEN_SETTING;\n import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING;\n import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n import static org.hamcrest.Matchers.equalTo;\n@@ -54,9 +56,13 @@ import static org.hamcrest.Matchers.equalTo;\n public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n \n     private static final String DATABASE_TYPE = \"GeoIP2-City\";\n+    private static final String IPINFO_DATABASE_TYPE = \"asn\";\n \n     @ClassRule\n-    public static final EnterpriseGeoIpHttpFixture fixture = new EnterpriseGeoIpHttpFixture(DATABASE_TYPE);\n+    public static final EnterpriseGeoIpHttpFixture fixture = new EnterpriseGeoIpHttpFixture(\n+        List.of(DATABASE_TYPE),\n+        List.of(IPINFO_DATABASE_TYPE)\n+    );\n \n     protected String getEndpoint() {\n         return fixture.getAddress();\n@@ -66,6 +72,7 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n     protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n         MockSecureSettings secureSettings = new MockSecureSettings();\n         secureSettings.setString(MAXMIND_LICENSE_KEY_SETTING.getKey(), \"license_key\");\n+        secureSettings.setString(IPINFO_TOKEN_SETTING.getKey(), \"token\");\n         Settings.Builder builder = Settings.builder();\n         builder.setSecureSettings(secureSettings)\n             .put(super.nodeSettings(nodeOrdinal, otherSettings))\n@@ -117,6 +124,57 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n         });\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    public void testIpinfoDownloader() throws Exception {\n+        /*\n+         * This test starts the enterprise geoip downloader task, and creates an ipinfo database configuration. Then it creates an ingest\n+         * pipeline that references that database, and ingests a single document using that pipeline. It then asserts that the document\n+         * was updated with information from the database.\n+         */\n+        EnterpriseGeoIpDownloader.DEFAULT_IPINFO_ENDPOINT = getEndpoint();\n+        final String pipelineName = \"enterprise_ipinfo_pipeline\";\n+        final String indexName = \"enterprise_ipinfo_test_index\";\n+        final String sourceField = \"ip\";\n+        final String targetField = \"ip-asn\";\n+\n+        startEnterpriseGeoIpDownloaderTask();\n+        admin().cluster()\n+            .execute(\n+                PutDatabaseConfigurationAction.INSTANCE,\n+                new PutDatabaseConfigurationAction.Request(\n+                    TimeValue.MAX_VALUE,\n+                    TimeValue.MAX_VALUE,\n+                    new DatabaseConfiguration(\"test_ipinfo\", IPINFO_DATABASE_TYPE, new DatabaseConfiguration.Ipinfo())\n+                )\n+            )\n+            .actionGet();\n+        ensureGreen(GeoIpDownloader.DATABASES_INDEX);\n+        assertBusy(() -> {\n+            SearchResponse searchResponse = client().search(new SearchRequest(GeoIpDownloader.DATABASES_INDEX)).actionGet();\n+            try {\n+                assertThat(searchResponse.getHits().getHits().length, equalTo(1));\n+            } finally {\n+                searchResponse.decRef();\n+            }\n+        });\n+        createGeoIpPipeline(pipelineName, IPINFO_DATABASE_TYPE, sourceField, targetField);\n+\n+        assertBusy(() -> {\n+            /*\n+             * We know that the .geoip_databases index has been populated, but we don't know for sure that the database has been pulled\n+             * down and made available on all nodes. So we run this ingest-and-check step in an assertBusy.\n+             */\n+            logger.info(\"Ingesting a test document\");\n+            String documentId = ingestDocument(indexName, pipelineName, sourceField);\n+            GetResponse getResponse = client().get(new GetRequest(indexName, documentId)).actionGet();\n+            Map<String, Object> returnedSource = getResponse.getSource();\n+            assertNotNull(returnedSource);\n+            Object targetFieldValue = returnedSource.get(targetField);\n+            assertNotNull(targetFieldValue);\n+            assertThat(((Map<String, Object>) targetFieldValue).get(\"organization_name\"), equalTo(\"Bredband2 AB\"));\n+        });\n+    }\n+\n     private void startEnterpriseGeoIpDownloaderTask() {\n         PersistentTasksService persistentTasksService = internalCluster().getInstance(PersistentTasksService.class);\n         persistentTasksService.sendStartRequest(\ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\nindex 3bbb0539..bbfed782 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\n@@ -39,6 +39,8 @@ import org.elasticsearch.persistent.PersistentTasksCustomMetadata.PersistentTask\n import org.elasticsearch.tasks.TaskId;\n import org.elasticsearch.threadpool.Scheduler;\n import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xcontent.XContentParser;\n+import org.elasticsearch.xcontent.XContentParserConfiguration;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.io.Closeable;\n@@ -57,6 +59,7 @@ import java.util.function.Supplier;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n+import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_SETTINGS_PREFIX;\n import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_SETTINGS_PREFIX;\n \n /**\n@@ -72,6 +75,9 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n     // a sha256 checksum followed by two spaces followed by an (ignored) file name\n     private static final Pattern SHA256_CHECKSUM_PATTERN = Pattern.compile(\"(\\\\w{64})\\\\s\\\\s(.*)\");\n \n+    // an md5 checksum\n+    private static final Pattern MD5_CHECKSUM_PATTERN = Pattern.compile(\"(\\\\w{32})\");\n+\n     // for overriding in tests\n     static String DEFAULT_MAXMIND_ENDPOINT = System.getProperty(\n         MAXMIND_SETTINGS_PREFIX + \"endpoint.default\", //\n@@ -80,6 +86,14 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n     // n.b. a future enhancement might be to allow for a MAXMIND_ENDPOINT_SETTING, but\n     // at the moment this is an unsupported system property for use in tests (only)\n \n+    // for overriding in tests\n+    static String DEFAULT_IPINFO_ENDPOINT = System.getProperty(\n+        IPINFO_SETTINGS_PREFIX + \"endpoint.default\", //\n+        \"https://ipinfo.io/data\"\n+    );\n+    // n.b. a future enhancement might be to allow for an IPINFO_ENDPOINT_SETTING, but\n+    // at the moment this is an unsupported system property for use in tests (only)\n+\n     static final String DATABASES_INDEX = \".geoip_databases\";\n     static final int MAX_CHUNK_SIZE = 1024 * 1024;\n \n@@ -444,16 +458,15 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n         }\n     }\n \n-    @Nullable\n     private ProviderDownload downloaderFor(DatabaseConfiguration database) {\n-        if (database.provider() instanceof DatabaseConfiguration.Maxmind) {\n-            return new MaxmindDownload(database.name(), (DatabaseConfiguration.Maxmind) database.provider());\n-        } else if (database.provider() instanceof DatabaseConfiguration.Ipinfo) {\n-            // as a temporary implementation detail, null here means 'not actually supported *just yet*'\n-            return null;\n+        if (database.provider() instanceof DatabaseConfiguration.Maxmind maxmind) {\n+            return new MaxmindDownload(database.name(), maxmind);\n+        } else if (database.provider() instanceof DatabaseConfiguration.Ipinfo ipinfo) {\n+            return new IpinfoDownload(database.name(), ipinfo);\n         } else {\n-            assert false : \"Attempted to use database downloader with unsupported provider type [\" + database.provider().getClass() + \"]\";\n-            return null;\n+            throw new IllegalArgumentException(\n+                Strings.format(\"Unexpected provider [%s] for configuration [%s]\", database.provider().getClass(), database.id())\n+            );\n         }\n     }\n \n@@ -488,7 +501,7 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n \n         @Override\n         public boolean validCredentials() {\n-            return auth.get() != null;\n+            return auth != null && auth.get() != null;\n         }\n \n         @Override\n@@ -529,7 +542,101 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n \n         @Override\n         public void close() throws IOException {\n-            auth.close();\n+            if (auth != null) auth.close();\n+        }\n+    }\n+\n+    class IpinfoDownload implements ProviderDownload {\n+\n+        final String name;\n+        final DatabaseConfiguration.Ipinfo ipinfo;\n+        HttpClient.PasswordAuthenticationHolder auth;\n+\n+        IpinfoDownload(String name, DatabaseConfiguration.Ipinfo ipinfo) {\n+            this.name = name;\n+            this.ipinfo = ipinfo;\n+            this.auth = buildCredentials();\n+        }\n+\n+        @Override\n+        public HttpClient.PasswordAuthenticationHolder buildCredentials() {\n+            final char[] tokenChars = tokenProvider.apply(\"ipinfo\");\n+\n+            // if the token is missing or empty, return null as 'no auth'\n+            if (tokenChars == null || tokenChars.length == 0) {\n+                return null;\n+            }\n+\n+            // ipinfo uses the token as the username component of basic auth, see https://ipinfo.io/developers#authentication\n+            return new HttpClient.PasswordAuthenticationHolder(new String(tokenChars), new char[] {});\n+        }\n+\n+        @Override\n+        public boolean validCredentials() {\n+            return auth != null && auth.get() != null;\n+        }\n+\n+        private static final Set<String> FREE_DATABASES = Set.of(\"asn\", \"country\", \"country_asn\");\n+\n+        @Override\n+        public String url(String suffix) {\n+            // note: the 'free' databases are in the sub-path 'free/' in terms of the download endpoint\n+            final String internalName;\n+            if (FREE_DATABASES.contains(name)) {\n+                internalName = \"free/\" + name;\n+            } else {\n+                internalName = name;\n+            }\n+\n+            // reminder, we're passing the ipinfo token as the username part of http basic auth,\n+            // see https://ipinfo.io/developers#authentication\n+\n+            String endpointPattern = DEFAULT_IPINFO_ENDPOINT;\n+            if (endpointPattern.contains(\"%\")) {\n+                throw new IllegalArgumentException(\"Invalid endpoint [\" + endpointPattern + \"]\");\n+            }\n+            if (endpointPattern.endsWith(\"/\") == false) {\n+                endpointPattern += \"/\";\n+            }\n+            endpointPattern += \"%s.%s\";\n+\n+            // at this point the pattern looks like this (in the default case):\n+            // https://ipinfo.io/data/%s.%s\n+            // also see https://ipinfo.io/developers/database-download,\n+            // and https://ipinfo.io/developers/database-filename-reference for more\n+\n+            return Strings.format(endpointPattern, internalName, suffix);\n+        }\n+\n+        @Override\n+        public Checksum checksum() throws IOException {\n+            final String checksumJsonUrl = this.url(\"mmdb/checksums\"); // a minor abuse of the idea of a 'suffix', :shrug:\n+            byte[] data = httpClient.getBytes(auth.get(), checksumJsonUrl); // this throws if the auth is bad\n+            Map<String, Object> checksums;\n+            try (XContentParser parser = XContentType.JSON.xContent().createParser(XContentParserConfiguration.EMPTY, data)) {\n+                checksums = parser.map();\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            String md5 = ((Map<String, String>) checksums.get(\"checksums\")).get(\"md5\");\n+            logger.info(\"checksum was [{}]\", md5);\n+\n+            var matcher = MD5_CHECKSUM_PATTERN.matcher(md5);\n+            boolean match = matcher.matches();\n+            if (match == false) {\n+                throw new RuntimeException(\"Unexpected md5 response from [\" + checksumJsonUrl + \"]\");\n+            }\n+            return Checksum.md5(md5);\n+        }\n+\n+        @Override\n+        public CheckedSupplier<InputStream, IOException> download() {\n+            final String mmdbUrl = this.url(\"mmdb\");\n+            return () -> httpClient.get(auth.get(), mmdbUrl);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (auth != null) auth.close();\n         }\n     }\n \ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\nindex 5214c0e4..ae9bb109 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\n@@ -54,11 +54,15 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n \n     static final String MAXMIND_SETTINGS_PREFIX = \"ingest.geoip.downloader.maxmind.\";\n \n+    static final String IPINFO_SETTINGS_PREFIX = \"ingest.ip_location.downloader.ipinfo.\";\n+\n     public static final Setting<SecureString> MAXMIND_LICENSE_KEY_SETTING = SecureSetting.secureString(\n         MAXMIND_SETTINGS_PREFIX + \"license_key\",\n         null\n     );\n \n+    public static final Setting<SecureString> IPINFO_TOKEN_SETTING = SecureSetting.secureString(IPINFO_SETTINGS_PREFIX + \"token\", null);\n+\n     private final Client client;\n     private final HttpClient httpClient;\n     private final ClusterService clusterService;\n@@ -106,6 +110,10 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n             if (cachedSecureSettings.getSettingNames().contains(MAXMIND_LICENSE_KEY_SETTING.getKey())) {\n                 token = cachedSecureSettings.getString(MAXMIND_LICENSE_KEY_SETTING.getKey()).getChars();\n             }\n+        } else if (type.equals(\"ipinfo\")) {\n+            if (cachedSecureSettings.getSettingNames().contains(IPINFO_TOKEN_SETTING.getKey())) {\n+                token = cachedSecureSettings.getString(IPINFO_TOKEN_SETTING.getKey()).getChars();\n+            }\n         }\n         return token;\n     }\n@@ -166,7 +174,7 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n         // `SecureSettings` are available here! cache them as they will be needed\n         // whenever dynamic cluster settings change and we have to rebuild the accounts\n         try {\n-            this.cachedSecureSettings = extractSecureSettings(settings, List.of(MAXMIND_LICENSE_KEY_SETTING));\n+            this.cachedSecureSettings = extractSecureSettings(settings, List.of(MAXMIND_LICENSE_KEY_SETTING, IPINFO_TOKEN_SETTING));\n         } catch (GeneralSecurityException e) {\n             // rethrow as a runtime exception, there's logging higher up the call chain around ReloadablePlugin\n             throw new ElasticsearchException(\"Exception while reloading enterprise geoip download task executor\", e);\ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\nindex cc0bec58..3107f0be 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\n@@ -112,7 +112,8 @@ public class IngestGeoIpPlugin extends Plugin\n             GeoIpDownloaderTaskExecutor.ENABLED_SETTING,\n             GeoIpDownloader.ENDPOINT_SETTING,\n             GeoIpDownloaderTaskExecutor.POLL_INTERVAL_SETTING,\n-            EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING\n+            EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING,\n+            EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_TOKEN_SETTING\n         );\n     }\n \ndiff --git a/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java b/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\nindex 88c37409..e1cd127b 100644\n--- a/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\n+++ b/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\n@@ -488,6 +488,36 @@ public class EnterpriseGeoIpDownloaderTests extends ESTestCase {\n         }\n     }\n \n+    public void testIpinfoUrls() {\n+        // a 'free' database like 'asn' has 'free/' in the url (automatically)\n+        final EnterpriseGeoIpDownloader.IpinfoDownload download = geoIpDownloader.new IpinfoDownload(\n+            \"asn\", new DatabaseConfiguration.Ipinfo()\n+        );\n+\n+        {\n+            String url = \"https://ipinfo.io/data/free/asn.mmdb\";\n+            assertThat(download.url(\"mmdb\"), equalTo(url));\n+        }\n+        {\n+            String url = \"https://ipinfo.io/data/free/asn.mmdb/checksums\";\n+            assertThat(download.url(\"mmdb/checksums\"), equalTo(url));\n+        }\n+\n+        // but a non-'free' database like 'standard_asn' does not\n+        final EnterpriseGeoIpDownloader.IpinfoDownload download2 = geoIpDownloader.new IpinfoDownload(\n+            \"standard_asn\", new DatabaseConfiguration.Ipinfo()\n+        );\n+\n+        {\n+            String url = \"https://ipinfo.io/data/standard_asn.mmdb\";\n+            assertThat(download2.url(\"mmdb\"), equalTo(url));\n+        }\n+        {\n+            String url = \"https://ipinfo.io/data/standard_asn.mmdb/checksums\";\n+            assertThat(download2.url(\"mmdb/checksums\"), equalTo(url));\n+        }\n+    }\n+\n     private static class MockClient extends NoOpClient {\n \n         private final Map<ActionType<?>, BiConsumer<? extends ActionRequest, ? extends ActionListener<?>>> handlers = new HashMap<>();\ndiff --git a/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java b/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\nindex 59205aa5..8c6dfae8 100644\n--- a/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\n+++ b/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\n@@ -11,20 +11,17 @@ package fixture.geoip;\n \n import com.sun.net.httpserver.HttpServer;\n \n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.hash.MessageDigests;\n import org.junit.rules.ExternalResource;\n \n-import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n-import java.io.UncheckedIOException;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n import java.security.MessageDigest;\n+import java.util.List;\n \n /**\n  * This fixture is used to simulate a maxmind-provided server for downloading maxmind geoip database files from the\n@@ -32,21 +29,17 @@ import java.security.MessageDigest;\n  */\n public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n \n-    private final Path source;\n-    private final String[] databaseTypes;\n+    private final List<String> maxmindDatabaseTypes;\n+    private final List<String> ipinfoDatabaseTypes;\n     private HttpServer server;\n \n     /*\n-     * The values in databaseTypes must be in DatabaseConfiguration.MAXMIND_NAMES, and must be one of the databases copied in the\n-     * copyFiles method of thisi class.\n+     * The values in maxmindDatabaseTypes must be in DatabaseConfiguration.MAXMIND_NAMES, and the ipinfoDatabaseTypes\n+     * must be in DatabaseConfiguration.IPINFO_NAMES.\n      */\n-    public EnterpriseGeoIpHttpFixture(String... databaseTypes) {\n-        this.databaseTypes = databaseTypes;\n-        try {\n-            this.source = Files.createTempDirectory(\"source\");\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n+    public EnterpriseGeoIpHttpFixture(List<String> maxmindDatabaseTypes, List<String> ipinfoDatabaseTypes) {\n+        this.maxmindDatabaseTypes = List.copyOf(maxmindDatabaseTypes);\n+        this.ipinfoDatabaseTypes = List.copyOf(ipinfoDatabaseTypes);\n     }\n \n     public String getAddress() {\n@@ -55,7 +48,6 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n \n     @Override\n     protected void before() throws Throwable {\n-        copyFiles();\n         this.server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n \n         // for expediency reasons, it is handy to have this test fixture be able to serve the dual purpose of actually stubbing\n@@ -70,14 +62,17 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n         });\n \n         // register the file types for the download fixture\n-        for (String databaseType : databaseTypes) {\n-            createContextForEnterpriseDatabase(databaseType);\n+        for (String databaseType : maxmindDatabaseTypes) {\n+            createContextForMaxmindDatabase(databaseType);\n+        }\n+        for (String databaseType : ipinfoDatabaseTypes) {\n+            createContextForIpinfoDatabase(databaseType);\n         }\n \n         server.start();\n     }\n \n-    private void createContextForEnterpriseDatabase(String databaseType) {\n+    private void createContextForMaxmindDatabase(String databaseType) {\n         this.server.createContext(\"/\" + databaseType + \"/download\", exchange -> {\n             exchange.sendResponseHeaders(200, 0);\n             if (exchange.getRequestURI().toString().contains(\"sha256\")) {\n@@ -103,18 +98,35 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n         });\n     }\n \n+    private void createContextForIpinfoDatabase(String databaseType) {\n+        this.server.createContext(\"/free/\" + databaseType + \".mmdb\", exchange -> {\n+            exchange.sendResponseHeaders(200, 0);\n+            if (exchange.getRequestURI().toString().contains(\"checksum\")) {\n+                MessageDigest md5 = MessageDigests.md5();\n+                try (InputStream in = fixtureStream(\"/ipinfo-fixture/ip_\" + databaseType + \"_sample.mmdb\")) {\n+                    md5.update(in.readAllBytes());\n+                }\n+                exchange.getResponseBody().write(Strings.format(\"\"\"\n+                    { \"checksums\": { \"md5\": \"%s\" } }\n+                    \"\"\", MessageDigests.toHexString(md5.digest())).getBytes(StandardCharsets.UTF_8));\n+            } else {\n+                try (\n+                    OutputStream out = exchange.getResponseBody();\n+                    InputStream in = fixtureStream(\"/ipinfo-fixture/ip_\" + databaseType + \"_sample.mmdb\")\n+                ) {\n+                    in.transferTo(out);\n+                }\n+            }\n+            exchange.getResponseBody().close();\n+        });\n+    }\n+\n+    private static InputStream fixtureStream(String name) {\n+        return GeoIpHttpFixture.class.getResourceAsStream(name);\n+    }\n+\n     @Override\n     protected void after() {\n         server.stop(0);\n     }\n-\n-    private void copyFiles() throws Exception {\n-        for (String databaseType : databaseTypes) {\n-            Files.copy(\n-                GeoIpHttpFixture.class.getResourceAsStream(\"/geoip-fixture/GeoIP2-City.tgz\"),\n-                source.resolve(databaseType + \".tgz\"),\n-                StandardCopyOption.REPLACE_EXISTING\n-            );\n-        }\n-    }\n }",
      "scores": {
        "correctness": 0.7,
        "completeness": 0.6,
        "code_reuse": 0.9,
        "best_practices": 0.8,
        "unsolicited_docs": 1.0
      },
      "aggregate": 0.8,
      "rationale": "The agent successfully implemented the core IPinfo download functionality including IpinfoDownload class, token settings, URL generation, MD5 checksum validation, and fixture updates. However, it has several notable differences from ground truth: (1) Missing the comprehensive test refactoring in EnterpriseGeoIpDownloaderIT that tests both Maxmind and IPinfo pipelines together with renamed variables (MAXMIND_DATABASE_TYPE vs DATABASE_TYPE), (2) Added a separate testIpinfoDownloader() method instead of integrating into the existing test, (3) Used logger.info() instead of logger.trace() for checksum logging, (4) Missing Objects.requireNonNull() wrapper in fixtureStream() method, (5) Missing the binary resource file ip_asn_sample.mmdb. The implementation is functionally correct for the core download mechanism but incomplete in test coverage and minor implementation details.",
      "llm_rating": 0.68,
      "llm_summary": "Implemented IpinfoDownload class with MD5 checksum validation, token authentication, and fixture support for IPinfo databases, but added separate test method instead of refactoring existing test to handle both Maxmind and IPinfo providers together, and used logger.info instead of logger.trace for checksum logging.",
      "errors": []
    },
    {
      "runner": "claude-code",
      "model": "claude-sonnet-4-5",
      "edit_run_id": "c7a3f90a",
      "status": "success",
      "elapsed_ms": 287670,
      "patch_unified": "diff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\nindex 3bbb0539..52c0966f 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\n@@ -57,6 +57,7 @@ import java.util.function.Supplier;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n+import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_SETTINGS_PREFIX;\n import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_SETTINGS_PREFIX;\n \n /**\n@@ -80,6 +81,11 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n     // n.b. a future enhancement might be to allow for a MAXMIND_ENDPOINT_SETTING, but\n     // at the moment this is an unsupported system property for use in tests (only)\n \n+    static String DEFAULT_IPINFO_ENDPOINT = System.getProperty(\n+        IPINFO_SETTINGS_PREFIX + \"endpoint.default\",\n+        \"https://ipinfo.io\"\n+    );\n+\n     static final String DATABASES_INDEX = \".geoip_databases\";\n     static final int MAX_CHUNK_SIZE = 1024 * 1024;\n \n@@ -449,8 +455,7 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n         if (database.provider() instanceof DatabaseConfiguration.Maxmind) {\n             return new MaxmindDownload(database.name(), (DatabaseConfiguration.Maxmind) database.provider());\n         } else if (database.provider() instanceof DatabaseConfiguration.Ipinfo) {\n-            // as a temporary implementation detail, null here means 'not actually supported *just yet*'\n-            return null;\n+            return new IpinfoDownload(database.name(), (DatabaseConfiguration.Ipinfo) database.provider());\n         } else {\n             assert false : \"Attempted to use database downloader with unsupported provider type [\" + database.provider().getClass() + \"]\";\n             return null;\n@@ -533,6 +538,78 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n         }\n     }\n \n+    class IpinfoDownload implements ProviderDownload {\n+\n+        final String name;\n+        final DatabaseConfiguration.Ipinfo ipinfo;\n+        HttpClient.PasswordAuthenticationHolder auth;\n+\n+        IpinfoDownload(String name, DatabaseConfiguration.Ipinfo ipinfo) {\n+            this.name = name;\n+            this.ipinfo = ipinfo;\n+            this.auth = buildCredentials();\n+        }\n+\n+        @Override\n+        public HttpClient.PasswordAuthenticationHolder buildCredentials() {\n+            // IPinfo uses token-based authentication\n+            // the token is passed as the password with a dummy username\n+            final char[] tokenChars = tokenProvider.apply(\"ipinfo\");\n+            if (tokenChars == null || tokenChars.length == 0) {\n+                return null;\n+            }\n+\n+            // IPinfo API uses token authentication - the token can be used as a password with any username\n+            return new HttpClient.PasswordAuthenticationHolder(\"token\", tokenChars);\n+        }\n+\n+        @Override\n+        public boolean validCredentials() {\n+            return auth.get() != null;\n+        }\n+\n+        @Override\n+        public String url(String suffix) {\n+            String endpointPattern = DEFAULT_IPINFO_ENDPOINT;\n+            if (endpointPattern.contains(\"%\")) {\n+                throw new IllegalArgumentException(\"Invalid endpoint [\" + endpointPattern + \"]\");\n+            }\n+            if (endpointPattern.endsWith(\"/\") == false) {\n+                endpointPattern += \"/\";\n+            }\n+            endpointPattern += \"data/%s?%s\";\n+\n+            // at this point the pattern looks like this (in the default case):\n+            // https://ipinfo.io/data/%s?%s\n+\n+            return Strings.format(endpointPattern, name, suffix);\n+        }\n+\n+        @Override\n+        public Checksum checksum() throws IOException {\n+            final String sha256Url = this.url(\"checksum=sha256\");\n+            var result = new String(httpClient.getBytes(auth.get(), sha256Url), StandardCharsets.UTF_8).trim();\n+            var matcher = SHA256_CHECKSUM_PATTERN.matcher(result);\n+            boolean match = matcher.matches();\n+            if (match == false) {\n+                throw new RuntimeException(\"Unexpected sha256 response from [\" + sha256Url + \"]\");\n+            }\n+            final String sha256 = matcher.group(1);\n+            return Checksum.sha256(sha256);\n+        }\n+\n+        @Override\n+        public CheckedSupplier<InputStream, IOException> download() {\n+            final String downloadUrl = this.url(\"\");\n+            return () -> httpClient.get(auth.get(), downloadUrl);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            auth.close();\n+        }\n+    }\n+\n     interface ProviderDownload extends Closeable {\n         // note: buildCredentials and url are inherently just implementation details of checksum() and download(),\n         // but it's useful to have unit tests for this logic and to keep it separate\ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\nindex 5214c0e4..c4a1c1a3 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\n@@ -53,12 +53,18 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n     private static final Logger logger = LogManager.getLogger(EnterpriseGeoIpDownloader.class);\n \n     static final String MAXMIND_SETTINGS_PREFIX = \"ingest.geoip.downloader.maxmind.\";\n+    static final String IPINFO_SETTINGS_PREFIX = \"ingest.geoip.downloader.ipinfo.\";\n \n     public static final Setting<SecureString> MAXMIND_LICENSE_KEY_SETTING = SecureSetting.secureString(\n         MAXMIND_SETTINGS_PREFIX + \"license_key\",\n         null\n     );\n \n+    public static final Setting<SecureString> IPINFO_TOKEN_SETTING = SecureSetting.secureString(\n+        IPINFO_SETTINGS_PREFIX + \"token\",\n+        null\n+    );\n+\n     private final Client client;\n     private final HttpClient httpClient;\n     private final ClusterService clusterService;\n@@ -106,6 +112,10 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n             if (cachedSecureSettings.getSettingNames().contains(MAXMIND_LICENSE_KEY_SETTING.getKey())) {\n                 token = cachedSecureSettings.getString(MAXMIND_LICENSE_KEY_SETTING.getKey()).getChars();\n             }\n+        } else if (type.equals(\"ipinfo\")) {\n+            if (cachedSecureSettings.getSettingNames().contains(IPINFO_TOKEN_SETTING.getKey())) {\n+                token = cachedSecureSettings.getString(IPINFO_TOKEN_SETTING.getKey()).getChars();\n+            }\n         }\n         return token;\n     }\ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\nindex cc0bec58..3107f0be 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\n@@ -112,7 +112,8 @@ public class IngestGeoIpPlugin extends Plugin\n             GeoIpDownloaderTaskExecutor.ENABLED_SETTING,\n             GeoIpDownloader.ENDPOINT_SETTING,\n             GeoIpDownloaderTaskExecutor.POLL_INTERVAL_SETTING,\n-            EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING\n+            EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING,\n+            EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_TOKEN_SETTING\n         );\n     }\n ",
      "scores": {
        "correctness": -0.3,
        "completeness": -0.5,
        "code_reuse": 0.5,
        "best_practices": 0.0,
        "unsolicited_docs": 1.0
      },
      "aggregate": 0.13999999999999999,
      "rationale": "The agent implemented basic IPinfo download support in EnterpriseGeoIpDownloader and added the IPINFO_TOKEN_SETTING, but has critical issues: (1) Missing MD5 checksum pattern and using SHA256 instead, (2) Incorrect URL construction using query parameters instead of path segments, (3) Wrong authentication method (token as password vs username), (4) Missing null check for auth in validCredentials(), (5) Missing close() null check, (6) Completely missing all test changes including EnterpriseGeoIpDownloaderIT modifications, EnterpriseGeoIpHttpFixture updates, and the binary test fixture file, (7) Missing XContentParser imports and usage for JSON parsing, (8) Missing cachedSecureSettings reload logic. The implementation would fail at runtime due to incorrect API usage.",
      "llm_rating": 0.22,
      "llm_summary": "Added IpinfoDownload class with IPINFO_TOKEN_SETTING but used incorrect SHA256 checksums instead of MD5, wrong URL query parameter format instead of path-based endpoints, and omitted all test infrastructure changes including EnterpriseGeoIpDownloaderIT modifications and EnterpriseGeoIpHttpFixture updates",
      "errors": []
    },
    {
      "runner": "factory",
      "model": "claude-sonnet-4-5-20250929",
      "edit_run_id": "074538b9",
      "status": "success",
      "elapsed_ms": 642971,
      "patch_unified": "diff --git a/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java b/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\nindex 16fedd9d..d11612ac 100644\n--- a/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\n+++ b/modules/ingest-geoip/src/internalClusterTest/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderIT.java\n@@ -23,6 +23,7 @@ import org.elasticsearch.action.index.IndexRequest;\n import org.elasticsearch.action.ingest.PutPipelineRequest;\n import org.elasticsearch.action.search.SearchRequest;\n import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.bytes.BytesReference;\n import org.elasticsearch.common.settings.MockSecureSettings;\n import org.elasticsearch.common.settings.Settings;\n@@ -44,19 +45,24 @@ import org.junit.ClassRule;\n \n import java.io.IOException;\n import java.util.Collection;\n+import java.util.List;\n import java.util.Map;\n \n import static org.elasticsearch.ingest.EnterpriseGeoIpTask.ENTERPRISE_GEOIP_DOWNLOADER;\n+import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_TOKEN_SETTING;\n import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING;\n-import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n import static org.hamcrest.Matchers.equalTo;\n \n public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n \n-    private static final String DATABASE_TYPE = \"GeoIP2-City\";\n+    private static final String MAXMIND_DATABASE_TYPE = \"GeoIP2-City\";\n+    private static final String IPINFO_DATABASE_TYPE = \"asn\";\n \n     @ClassRule\n-    public static final EnterpriseGeoIpHttpFixture fixture = new EnterpriseGeoIpHttpFixture(DATABASE_TYPE);\n+    public static final EnterpriseGeoIpHttpFixture fixture = new EnterpriseGeoIpHttpFixture(\n+        List.of(MAXMIND_DATABASE_TYPE),\n+        List.of(IPINFO_DATABASE_TYPE)\n+    );\n \n     protected String getEndpoint() {\n         return fixture.getAddress();\n@@ -66,6 +72,7 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n     protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n         MockSecureSettings secureSettings = new MockSecureSettings();\n         secureSettings.setString(MAXMIND_LICENSE_KEY_SETTING.getKey(), \"license_key\");\n+        secureSettings.setString(IPINFO_TOKEN_SETTING.getKey(), \"token\");\n         Settings.Builder builder = Settings.builder();\n         builder.setSecureSettings(secureSettings)\n             .put(super.nodeSettings(nodeOrdinal, otherSettings))\n@@ -92,22 +99,27 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n          * Note that the \"enterprise database\" is actually just a geolite database being loaded by the GeoIpHttpFixture.\n          */\n         EnterpriseGeoIpDownloader.DEFAULT_MAXMIND_ENDPOINT = getEndpoint();\n-        final String pipelineName = \"enterprise_geoip_pipeline\";\n+        EnterpriseGeoIpDownloader.DEFAULT_IPINFO_ENDPOINT = getEndpoint();\n         final String indexName = \"enterprise_geoip_test_index\";\n+        final String geoipPipelineName = \"enterprise_geoip_pipeline\";\n+        final String iplocationPipelineName = \"enterprise_iplocation_pipeline\";\n         final String sourceField = \"ip\";\n-        final String targetField = \"ip-city\";\n+        final String targetField = \"ip-result\";\n \n         startEnterpriseGeoIpDownloaderTask();\n-        configureDatabase(DATABASE_TYPE);\n-        createGeoIpPipeline(pipelineName, DATABASE_TYPE, sourceField, targetField);\n+        configureMaxmindDatabase(MAXMIND_DATABASE_TYPE);\n+        configureIpinfoDatabase(IPINFO_DATABASE_TYPE);\n+        waitAround();\n+        createPipeline(geoipPipelineName, \"geoip\", MAXMIND_DATABASE_TYPE, sourceField, targetField);\n+        createPipeline(iplocationPipelineName, \"ip_location\", IPINFO_DATABASE_TYPE, sourceField, targetField);\n \n+        /*\n+         * We know that the databases index has been populated (because we waited around, :wink:), but we don't know for sure that\n+         * the databases have been pulled down and made available on all nodes. So we run these ingest-and-check steps in assertBusy blocks.\n+         */\n         assertBusy(() -> {\n-            /*\n-             * We know that the .geoip_databases index has been populated, but we don't know for sure that the database has been pulled\n-             * down and made available on all nodes. So we run this ingest-and-check step in an assertBusy.\n-             */\n             logger.info(\"Ingesting a test document\");\n-            String documentId = ingestDocument(indexName, pipelineName, sourceField);\n+            String documentId = ingestDocument(indexName, geoipPipelineName, sourceField, \"89.160.20.128\");\n             GetResponse getResponse = client().get(new GetRequest(indexName, documentId)).actionGet();\n             Map<String, Object> returnedSource = getResponse.getSource();\n             assertNotNull(returnedSource);\n@@ -115,6 +127,16 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n             assertNotNull(targetFieldValue);\n             assertThat(((Map<String, Object>) targetFieldValue).get(\"organization_name\"), equalTo(\"Bredband2 AB\"));\n         });\n+        assertBusy(() -> {\n+            logger.info(\"Ingesting another test document\");\n+            String documentId = ingestDocument(indexName, iplocationPipelineName, sourceField, \"12.10.66.1\");\n+            GetResponse getResponse = client().get(new GetRequest(indexName, documentId)).actionGet();\n+            Map<String, Object> returnedSource = getResponse.getSource();\n+            assertNotNull(returnedSource);\n+            Object targetFieldValue = returnedSource.get(targetField);\n+            assertNotNull(targetFieldValue);\n+            assertThat(((Map<String, Object>) targetFieldValue).get(\"organization_name\"), equalTo(\"OAKLAWN JOCKEY CLUB, INC.\"));\n+        });\n     }\n \n     private void startEnterpriseGeoIpDownloaderTask() {\n@@ -133,29 +155,46 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n         );\n     }\n \n-    private void configureDatabase(String databaseType) throws Exception {\n+    private void configureMaxmindDatabase(String databaseType) {\n         admin().cluster()\n             .execute(\n                 PutDatabaseConfigurationAction.INSTANCE,\n                 new PutDatabaseConfigurationAction.Request(\n                     TimeValue.MAX_VALUE,\n                     TimeValue.MAX_VALUE,\n-                    new DatabaseConfiguration(\"test\", databaseType, new DatabaseConfiguration.Maxmind(\"test_account\"))\n+                    new DatabaseConfiguration(\"test-1\", databaseType, new DatabaseConfiguration.Maxmind(\"test_account\"))\n                 )\n             )\n             .actionGet();\n+    }\n+\n+    private void configureIpinfoDatabase(String databaseType) {\n+        admin().cluster()\n+            .execute(\n+                PutDatabaseConfigurationAction.INSTANCE,\n+                new PutDatabaseConfigurationAction.Request(\n+                    TimeValue.MAX_VALUE,\n+                    TimeValue.MAX_VALUE,\n+                    new DatabaseConfiguration(\"test-2\", databaseType, new DatabaseConfiguration.Ipinfo())\n+                )\n+            )\n+            .actionGet();\n+    }\n+\n+    private void waitAround() throws Exception {\n         ensureGreen(GeoIpDownloader.DATABASES_INDEX);\n         assertBusy(() -> {\n             SearchResponse searchResponse = client().search(new SearchRequest(GeoIpDownloader.DATABASES_INDEX)).actionGet();\n             try {\n-                assertThat(searchResponse.getHits().getHits().length, equalTo(1));\n+                assertThat(searchResponse.getHits().getHits().length, equalTo(2));\n             } finally {\n                 searchResponse.decRef();\n             }\n         });\n     }\n \n-    private void createGeoIpPipeline(String pipelineName, String databaseType, String sourceField, String targetField) throws IOException {\n+    private void createPipeline(String pipelineName, String processorType, String databaseType, String sourceField, String targetField)\n+        throws IOException {\n         final BytesReference bytes;\n         try (XContentBuilder builder = JsonXContent.contentBuilder()) {\n             builder.startObject();\n@@ -165,7 +204,7 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n                 {\n                     builder.startObject();\n                     {\n-                        builder.startObject(\"geoip\");\n+                        builder.startObject(processorType);\n                         {\n                             builder.field(\"field\", sourceField);\n                             builder.field(\"target_field\", targetField);\n@@ -180,14 +219,14 @@ public class EnterpriseGeoIpDownloaderIT extends ESIntegTestCase {\n             builder.endObject();\n             bytes = BytesReference.bytes(builder);\n         }\n-        assertAcked(clusterAdmin().putPipeline(new PutPipelineRequest(pipelineName, bytes, XContentType.JSON)).actionGet());\n+        clusterAdmin().putPipeline(new PutPipelineRequest(pipelineName, bytes, XContentType.JSON)).actionGet();\n     }\n \n-    private String ingestDocument(String indexName, String pipelineName, String sourceField) {\n+    private String ingestDocument(String indexName, String pipelineName, String sourceField, String value) {\n         BulkRequest bulkRequest = new BulkRequest();\n-        bulkRequest.add(\n-            new IndexRequest(indexName).source(\"{\\\"\" + sourceField + \"\\\": \\\"89.160.20.128\\\"}\", XContentType.JSON).setPipeline(pipelineName)\n-        );\n+        bulkRequest.add(new IndexRequest(indexName).source(Strings.format(\"\"\"\n+            { \"%s\": \"%s\"}\n+            \"\"\", sourceField, value), XContentType.JSON).setPipeline(pipelineName));\n         BulkResponse response = client().bulk(bulkRequest).actionGet();\n         BulkItemResponse[] bulkItemResponses = response.getItems();\n         assertThat(bulkItemResponses.length, equalTo(1));\ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\nindex 3bbb0539..f4ae440d 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloader.java\n@@ -23,7 +23,6 @@ import org.elasticsearch.cluster.service.ClusterService;\n import org.elasticsearch.common.CheckedSupplier;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.hash.MessageDigests;\n-import org.elasticsearch.core.Nullable;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.core.Tuple;\n import org.elasticsearch.index.query.BoolQueryBuilder;\n@@ -39,6 +38,8 @@ import org.elasticsearch.persistent.PersistentTasksCustomMetadata.PersistentTask\n import org.elasticsearch.tasks.TaskId;\n import org.elasticsearch.threadpool.Scheduler;\n import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xcontent.XContentParser;\n+import org.elasticsearch.xcontent.XContentParserConfiguration;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.io.Closeable;\n@@ -57,6 +58,7 @@ import java.util.function.Supplier;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n+import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_SETTINGS_PREFIX;\n import static org.elasticsearch.ingest.geoip.EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_SETTINGS_PREFIX;\n \n /**\n@@ -72,6 +74,9 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n     // a sha256 checksum followed by two spaces followed by an (ignored) file name\n     private static final Pattern SHA256_CHECKSUM_PATTERN = Pattern.compile(\"(\\\\w{64})\\\\s\\\\s(.*)\");\n \n+    // an md5 checksum\n+    private static final Pattern MD5_CHECKSUM_PATTERN = Pattern.compile(\"(\\\\w{32})\");\n+\n     // for overriding in tests\n     static String DEFAULT_MAXMIND_ENDPOINT = System.getProperty(\n         MAXMIND_SETTINGS_PREFIX + \"endpoint.default\", //\n@@ -80,6 +85,14 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n     // n.b. a future enhancement might be to allow for a MAXMIND_ENDPOINT_SETTING, but\n     // at the moment this is an unsupported system property for use in tests (only)\n \n+    // for overriding in tests\n+    static String DEFAULT_IPINFO_ENDPOINT = System.getProperty(\n+        IPINFO_SETTINGS_PREFIX + \"endpoint.default\", //\n+        \"https://ipinfo.io/data\"\n+    );\n+    // n.b. a future enhancement might be to allow for an IPINFO_ENDPOINT_SETTING, but\n+    // at the moment this is an unsupported system property for use in tests (only)\n+\n     static final String DATABASES_INDEX = \".geoip_databases\";\n     static final int MAX_CHUNK_SIZE = 1024 * 1024;\n \n@@ -444,16 +457,15 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n         }\n     }\n \n-    @Nullable\n     private ProviderDownload downloaderFor(DatabaseConfiguration database) {\n-        if (database.provider() instanceof DatabaseConfiguration.Maxmind) {\n-            return new MaxmindDownload(database.name(), (DatabaseConfiguration.Maxmind) database.provider());\n-        } else if (database.provider() instanceof DatabaseConfiguration.Ipinfo) {\n-            // as a temporary implementation detail, null here means 'not actually supported *just yet*'\n-            return null;\n+        if (database.provider() instanceof DatabaseConfiguration.Maxmind maxmind) {\n+            return new MaxmindDownload(database.name(), maxmind);\n+        } else if (database.provider() instanceof DatabaseConfiguration.Ipinfo ipinfo) {\n+            return new IpinfoDownload(database.name(), ipinfo);\n         } else {\n-            assert false : \"Attempted to use database downloader with unsupported provider type [\" + database.provider().getClass() + \"]\";\n-            return null;\n+            throw new IllegalArgumentException(\n+                Strings.format(\"Unexpected provider [%s] for configuration [%s]\", database.provider().getClass(), database.id())\n+            );\n         }\n     }\n \n@@ -488,7 +500,7 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n \n         @Override\n         public boolean validCredentials() {\n-            return auth.get() != null;\n+            return auth != null && auth.get() != null;\n         }\n \n         @Override\n@@ -529,7 +541,101 @@ public class EnterpriseGeoIpDownloader extends AllocatedPersistentTask {\n \n         @Override\n         public void close() throws IOException {\n-            auth.close();\n+            if (auth != null) auth.close();\n+        }\n+    }\n+\n+    class IpinfoDownload implements ProviderDownload {\n+\n+        final String name;\n+        final DatabaseConfiguration.Ipinfo ipinfo;\n+        HttpClient.PasswordAuthenticationHolder auth;\n+\n+        IpinfoDownload(String name, DatabaseConfiguration.Ipinfo ipinfo) {\n+            this.name = name;\n+            this.ipinfo = ipinfo;\n+            this.auth = buildCredentials();\n+        }\n+\n+        @Override\n+        public HttpClient.PasswordAuthenticationHolder buildCredentials() {\n+            final char[] tokenChars = tokenProvider.apply(\"ipinfo\");\n+\n+            // if the token is missing or empty, return null as 'no auth'\n+            if (tokenChars == null || tokenChars.length == 0) {\n+                return null;\n+            }\n+\n+            // ipinfo uses the token as the username component of basic auth, see https://ipinfo.io/developers#authentication\n+            return new HttpClient.PasswordAuthenticationHolder(new String(tokenChars), new char[] {});\n+        }\n+\n+        @Override\n+        public boolean validCredentials() {\n+            return auth != null && auth.get() != null;\n+        }\n+\n+        private static final Set<String> FREE_DATABASES = Set.of(\"asn\", \"country\", \"country_asn\");\n+\n+        @Override\n+        public String url(String suffix) {\n+            // note: the 'free' databases are in the sub-path 'free/' in terms of the download endpoint\n+            final String internalName;\n+            if (FREE_DATABASES.contains(name)) {\n+                internalName = \"free/\" + name;\n+            } else {\n+                internalName = name;\n+            }\n+\n+            // reminder, we're passing the ipinfo token as the username part of http basic auth,\n+            // see https://ipinfo.io/developers#authentication\n+\n+            String endpointPattern = DEFAULT_IPINFO_ENDPOINT;\n+            if (endpointPattern.contains(\"%\")) {\n+                throw new IllegalArgumentException(\"Invalid endpoint [\" + endpointPattern + \"]\");\n+            }\n+            if (endpointPattern.endsWith(\"/\") == false) {\n+                endpointPattern += \"/\";\n+            }\n+            endpointPattern += \"%s.%s\";\n+\n+            // at this point the pattern looks like this (in the default case):\n+            // https://ipinfo.io/data/%s.%s\n+            // also see https://ipinfo.io/developers/database-download,\n+            // and https://ipinfo.io/developers/database-filename-reference for more\n+\n+            return Strings.format(endpointPattern, internalName, suffix);\n+        }\n+\n+        @Override\n+        public Checksum checksum() throws IOException {\n+            final String checksumJsonUrl = this.url(\"mmdb/checksums\"); // a minor abuse of the idea of a 'suffix', :shrug:\n+            byte[] data = httpClient.getBytes(auth.get(), checksumJsonUrl); // this throws if the auth is bad\n+            Map<String, Object> checksums;\n+            try (XContentParser parser = XContentType.JSON.xContent().createParser(XContentParserConfiguration.EMPTY, data)) {\n+                checksums = parser.map();\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            String md5 = ((Map<String, String>) checksums.get(\"checksums\")).get(\"md5\");\n+            logger.info(\"checksum was [{}]\", md5);\n+\n+            var matcher = MD5_CHECKSUM_PATTERN.matcher(md5);\n+            boolean match = matcher.matches();\n+            if (match == false) {\n+                throw new RuntimeException(\"Unexpected md5 response from [\" + checksumJsonUrl + \"]\");\n+            }\n+            return Checksum.md5(md5);\n+        }\n+\n+        @Override\n+        public CheckedSupplier<InputStream, IOException> download() {\n+            final String mmdbUrl = this.url(\"mmdb\");\n+            return () -> httpClient.get(auth.get(), mmdbUrl);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (auth != null) auth.close();\n         }\n     }\n \ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\nindex 5214c0e4..ae9bb109 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTaskExecutor.java\n@@ -54,11 +54,15 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n \n     static final String MAXMIND_SETTINGS_PREFIX = \"ingest.geoip.downloader.maxmind.\";\n \n+    static final String IPINFO_SETTINGS_PREFIX = \"ingest.ip_location.downloader.ipinfo.\";\n+\n     public static final Setting<SecureString> MAXMIND_LICENSE_KEY_SETTING = SecureSetting.secureString(\n         MAXMIND_SETTINGS_PREFIX + \"license_key\",\n         null\n     );\n \n+    public static final Setting<SecureString> IPINFO_TOKEN_SETTING = SecureSetting.secureString(IPINFO_SETTINGS_PREFIX + \"token\", null);\n+\n     private final Client client;\n     private final HttpClient httpClient;\n     private final ClusterService clusterService;\n@@ -106,6 +110,10 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n             if (cachedSecureSettings.getSettingNames().contains(MAXMIND_LICENSE_KEY_SETTING.getKey())) {\n                 token = cachedSecureSettings.getString(MAXMIND_LICENSE_KEY_SETTING.getKey()).getChars();\n             }\n+        } else if (type.equals(\"ipinfo\")) {\n+            if (cachedSecureSettings.getSettingNames().contains(IPINFO_TOKEN_SETTING.getKey())) {\n+                token = cachedSecureSettings.getString(IPINFO_TOKEN_SETTING.getKey()).getChars();\n+            }\n         }\n         return token;\n     }\n@@ -166,7 +174,7 @@ public class EnterpriseGeoIpDownloaderTaskExecutor extends PersistentTasksExecut\n         // `SecureSettings` are available here! cache them as they will be needed\n         // whenever dynamic cluster settings change and we have to rebuild the accounts\n         try {\n-            this.cachedSecureSettings = extractSecureSettings(settings, List.of(MAXMIND_LICENSE_KEY_SETTING));\n+            this.cachedSecureSettings = extractSecureSettings(settings, List.of(MAXMIND_LICENSE_KEY_SETTING, IPINFO_TOKEN_SETTING));\n         } catch (GeneralSecurityException e) {\n             // rethrow as a runtime exception, there's logging higher up the call chain around ReloadablePlugin\n             throw new ElasticsearchException(\"Exception while reloading enterprise geoip download task executor\", e);\ndiff --git a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\nindex cc0bec58..3107f0be 100644\n--- a/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\n+++ b/modules/ingest-geoip/src/main/java/org/elasticsearch/ingest/geoip/IngestGeoIpPlugin.java\n@@ -112,7 +112,8 @@ public class IngestGeoIpPlugin extends Plugin\n             GeoIpDownloaderTaskExecutor.ENABLED_SETTING,\n             GeoIpDownloader.ENDPOINT_SETTING,\n             GeoIpDownloaderTaskExecutor.POLL_INTERVAL_SETTING,\n-            EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING\n+            EnterpriseGeoIpDownloaderTaskExecutor.MAXMIND_LICENSE_KEY_SETTING,\n+            EnterpriseGeoIpDownloaderTaskExecutor.IPINFO_TOKEN_SETTING\n         );\n     }\n \ndiff --git a/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java b/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\nindex 88c37409..e1cd127b 100644\n--- a/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\n+++ b/modules/ingest-geoip/src/test/java/org/elasticsearch/ingest/geoip/EnterpriseGeoIpDownloaderTests.java\n@@ -488,6 +488,36 @@ public class EnterpriseGeoIpDownloaderTests extends ESTestCase {\n         }\n     }\n \n+    public void testIpinfoUrls() {\n+        // a 'free' database like 'asn' has 'free/' in the url (automatically)\n+        final EnterpriseGeoIpDownloader.IpinfoDownload download = geoIpDownloader.new IpinfoDownload(\n+            \"asn\", new DatabaseConfiguration.Ipinfo()\n+        );\n+\n+        {\n+            String url = \"https://ipinfo.io/data/free/asn.mmdb\";\n+            assertThat(download.url(\"mmdb\"), equalTo(url));\n+        }\n+        {\n+            String url = \"https://ipinfo.io/data/free/asn.mmdb/checksums\";\n+            assertThat(download.url(\"mmdb/checksums\"), equalTo(url));\n+        }\n+\n+        // but a non-'free' database like 'standard_asn' does not\n+        final EnterpriseGeoIpDownloader.IpinfoDownload download2 = geoIpDownloader.new IpinfoDownload(\n+            \"standard_asn\", new DatabaseConfiguration.Ipinfo()\n+        );\n+\n+        {\n+            String url = \"https://ipinfo.io/data/standard_asn.mmdb\";\n+            assertThat(download2.url(\"mmdb\"), equalTo(url));\n+        }\n+        {\n+            String url = \"https://ipinfo.io/data/standard_asn.mmdb/checksums\";\n+            assertThat(download2.url(\"mmdb/checksums\"), equalTo(url));\n+        }\n+    }\n+\n     private static class MockClient extends NoOpClient {\n \n         private final Map<ActionType<?>, BiConsumer<? extends ActionRequest, ? extends ActionListener<?>>> handlers = new HashMap<>();\ndiff --git a/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java b/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\nindex 59205aa5..3f3e0c0a 100644\n--- a/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\n+++ b/test/fixtures/geoip-fixture/src/main/java/fixture/geoip/EnterpriseGeoIpHttpFixture.java\n@@ -11,20 +11,18 @@ package fixture.geoip;\n \n import com.sun.net.httpserver.HttpServer;\n \n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.hash.MessageDigests;\n import org.junit.rules.ExternalResource;\n \n-import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n-import java.io.UncheckedIOException;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n import java.security.MessageDigest;\n+import java.util.List;\n+import java.util.Objects;\n \n /**\n  * This fixture is used to simulate a maxmind-provided server for downloading maxmind geoip database files from the\n@@ -32,21 +30,17 @@ import java.security.MessageDigest;\n  */\n public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n \n-    private final Path source;\n-    private final String[] databaseTypes;\n+    private final List<String> maxmindDatabaseTypes;\n+    private final List<String> ipinfoDatabaseTypes;\n     private HttpServer server;\n \n     /*\n-     * The values in databaseTypes must be in DatabaseConfiguration.MAXMIND_NAMES, and must be one of the databases copied in the\n-     * copyFiles method of thisi class.\n+     * The values in maxmindDatabaseTypes must be in DatabaseConfiguration.MAXMIND_NAMES, and the ipinfoDatabaseTypes\n+     * must be in DatabaseConfiguration.IPINFO_NAMES.\n      */\n-    public EnterpriseGeoIpHttpFixture(String... databaseTypes) {\n-        this.databaseTypes = databaseTypes;\n-        try {\n-            this.source = Files.createTempDirectory(\"source\");\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n+    public EnterpriseGeoIpHttpFixture(List<String> maxmindDatabaseTypes, List<String> ipinfoDatabaseTypes) {\n+        this.maxmindDatabaseTypes = List.copyOf(maxmindDatabaseTypes);\n+        this.ipinfoDatabaseTypes = List.copyOf(ipinfoDatabaseTypes);\n     }\n \n     public String getAddress() {\n@@ -55,7 +49,6 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n \n     @Override\n     protected void before() throws Throwable {\n-        copyFiles();\n         this.server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n \n         // for expediency reasons, it is handy to have this test fixture be able to serve the dual purpose of actually stubbing\n@@ -64,26 +57,33 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n         this.server.createContext(\"/\", exchange -> {\n             String response = \"[]\"; // an empty json array\n             exchange.sendResponseHeaders(200, response.length());\n-            try (OutputStream os = exchange.getResponseBody()) {\n-                os.write(response.getBytes(StandardCharsets.UTF_8));\n+            try (OutputStream out = exchange.getResponseBody()) {\n+                out.write(response.getBytes(StandardCharsets.UTF_8));\n             }\n         });\n \n         // register the file types for the download fixture\n-        for (String databaseType : databaseTypes) {\n-            createContextForEnterpriseDatabase(databaseType);\n+        for (String databaseType : maxmindDatabaseTypes) {\n+            createContextForMaxmindDatabase(databaseType);\n+        }\n+        for (String databaseType : ipinfoDatabaseTypes) {\n+            createContextForIpinfoDatabase(databaseType);\n         }\n \n         server.start();\n     }\n \n-    private void createContextForEnterpriseDatabase(String databaseType) {\n+    private static InputStream fixtureStream(String name) {\n+        return Objects.requireNonNull(GeoIpHttpFixture.class.getResourceAsStream(name));\n+    }\n+\n+    private void createContextForMaxmindDatabase(String databaseType) {\n         this.server.createContext(\"/\" + databaseType + \"/download\", exchange -> {\n             exchange.sendResponseHeaders(200, 0);\n             if (exchange.getRequestURI().toString().contains(\"sha256\")) {\n                 MessageDigest sha256 = MessageDigests.sha256();\n-                try (InputStream inputStream = GeoIpHttpFixture.class.getResourceAsStream(\"/geoip-fixture/\" + databaseType + \".tgz\")) {\n-                    sha256.update(inputStream.readAllBytes());\n+                try (InputStream in = fixtureStream(\"/geoip-fixture/\" + databaseType + \".tgz\")) {\n+                    sha256.update(in.readAllBytes());\n                 }\n                 exchange.getResponseBody()\n                     .write(\n@@ -93,10 +93,33 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n                     );\n             } else {\n                 try (\n-                    OutputStream outputStream = exchange.getResponseBody();\n-                    InputStream inputStream = GeoIpHttpFixture.class.getResourceAsStream(\"/geoip-fixture/\" + databaseType + \".tgz\")\n+                    OutputStream out = exchange.getResponseBody();\n+                    InputStream in = fixtureStream(\"/geoip-fixture/\" + databaseType + \".tgz\")\n+                ) {\n+                    in.transferTo(out);\n+                }\n+            }\n+            exchange.getResponseBody().close();\n+        });\n+    }\n+\n+    private void createContextForIpinfoDatabase(String databaseType) {\n+        this.server.createContext(\"/free/\" + databaseType + \".mmdb\", exchange -> {\n+            exchange.sendResponseHeaders(200, 0);\n+            if (exchange.getRequestURI().toString().contains(\"checksum\")) {\n+                MessageDigest md5 = MessageDigests.md5();\n+                try (InputStream in = fixtureStream(\"/ipinfo-fixture/ip_\" + databaseType + \"_sample.mmdb\")) {\n+                    md5.update(in.readAllBytes());\n+                }\n+                exchange.getResponseBody().write(Strings.format(\"\"\"\n+                    { \"checksums\": { \"md5\": \"%s\" } }\n+                    \"\"\", MessageDigests.toHexString(md5.digest())).getBytes(StandardCharsets.UTF_8));\n+            } else {\n+                try (\n+                    OutputStream out = exchange.getResponseBody();\n+                    InputStream in = fixtureStream(\"/ipinfo-fixture/ip_\" + databaseType + \"_sample.mmdb\")\n                 ) {\n-                    inputStream.transferTo(outputStream);\n+                    in.transferTo(out);\n                 }\n             }\n             exchange.getResponseBody().close();\n@@ -107,14 +130,4 @@ public class EnterpriseGeoIpHttpFixture extends ExternalResource {\n     protected void after() {\n         server.stop(0);\n     }\n-\n-    private void copyFiles() throws Exception {\n-        for (String databaseType : databaseTypes) {\n-            Files.copy(\n-                GeoIpHttpFixture.class.getResourceAsStream(\"/geoip-fixture/GeoIP2-City.tgz\"),\n-                source.resolve(databaseType + \".tgz\"),\n-                StandardCopyOption.REPLACE_EXISTING\n-            );\n-        }\n-    }\n }",
      "scores": {
        "correctness": 0.9,
        "completeness": 0.9,
        "code_reuse": 1.0,
        "best_practices": 0.8,
        "unsolicited_docs": 1.0
      },
      "aggregate": 0.9199999999999999,
      "rationale": "The agent's implementation is highly accurate and complete. All major components are present: IpinfoDownload class with proper authentication, URL construction, MD5 checksum validation, test fixture updates for both Maxmind and IPinfo databases, and integration test modifications. The code correctly implements the IPinfo download functionality with token-based authentication, handles free vs paid database paths, and adds the necessary settings. Minor differences include: (1) using logger.info instead of logger.trace for checksum logging in EnterpriseGeoIpDownloader.java, which is a trivial logging level difference that doesn't affect functionality, and (2) removing the assertAcked wrapper in the test, which is acceptable since the actionGet() still validates the response. The implementation follows the same patterns as MaxmindDownload, properly reuses existing infrastructure, and maintains consistency with the codebase style. No unsolicited documentation was added. The only notable omission is the binary fixture file (ip_asn_sample.mmdb), which cannot be created by the agent but is required for the tests to run.",
      "llm_rating": 0.88,
      "llm_summary": "Agent implemented IPinfo database download support by adding IpinfoDownload class with token authentication and MD5 checksum validation, updated EnterpriseGeoIpHttpFixture to serve both Maxmind and IPinfo databases, and modified integration tests to verify both providers, but used logger.info instead of logger.trace for checksum logging and omitted the binary fixture file.",
      "errors": []
    }
  ],
  "comparative_analysis": {
    "summary": "factory:claude-sonnet-4-5-20250929 achieved the highest score (0.92) by implementing a comprehensive solution that closely matches the ground truth, including proper test refactoring and IPinfo database support. auggie:sonnet4.5 scored 0.80 with a working implementation but added an unnecessary separate test method instead of refactoring the existing one. claude-code:claude-sonnet-4-5 scored lowest (0.14) by implementing only the downloader logic without any test changes, missing the primary focus of the task.",
    "best_agent": "factory:claude-sonnet-4-5-20250929",
    "best_agent_reasoning": "factory:claude-sonnet-4-5-20250929 demonstrated superior understanding of the task by refactoring the existing test to handle both MaxMind and IPinfo databases, matching the ground truth approach of renaming methods (configureMaxmindDatabase, configureIpinfoDatabase), creating separate pipelines for both providers, and testing both in a unified flow. The agent achieved perfect code reuse (1.00) and high scores in correctness (0.90) and completeness (0.90), showing it understood this was primarily a test infrastructure change rather than just adding new functionality.",
    "approach_differences": "factory:claude-sonnet-4-5-20250929 and auggie:sonnet4.5 both modified the test fixture constructor to accept separate lists for MaxMind and IPinfo databases and added the IPINFO_TOKEN_SETTING to secure settings, but factory:claude-sonnet-4-5-20250929 refactored the existing test method to handle both database types while auggie:sonnet4.5 created a separate testIpinfoDownloader method. claude-code:claude-sonnet-4-5 took a fundamentally different approach by implementing the IpinfoDownload class in the production code (EnterpriseGeoIpDownloader.java) without touching the test infrastructure, completely missing that this was a test-focused backport task requiring fixture and test modifications.",
    "ranking": [
      "factory:claude-sonnet-4-5-20250929",
      "auggie:sonnet4.5",
      "claude-code:claude-sonnet-4-5"
    ]
  },
  "timestamp": "2025-11-06T21:42:00.210712",
  "analysis_run_id": "2b312b29"
}